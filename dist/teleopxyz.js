/*! For license information please see teleopxyz.js.LICENSE.txt */
var teleopxyz;(()=>{var __webpack_modules__={"./node_modules/debug/src/browser.js":(module,exports,__webpack_require__)=>{"use strict";eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFelU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3AteHl6Ly4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzPzM0ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/debug/src/browser.js\n")},"./node_modules/debug/src/common.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsc0NBQUk7QUFDckM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWEsZUFBZTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEUsYUFBYTtBQUN2RjtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0NBQWtDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9wLXh5ei8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzP2RjOTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG4gIGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcbiAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG4gIC8qKlxuICAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcbiAgLyoqXG4gICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gICovXG5cbiAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgLyoqXG4gICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICAqXG4gICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcbiAgLyoqXG4gICogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcbiAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2VcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICB2YXIgaGFzaCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAvKipcbiAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgIHZhciBwcmV2VGltZTtcblxuICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgLy8gRGlzYWJsZWQ/XG4gICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSBkZWJ1ZzsgLy8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblxuICAgICAgdmFyIGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgc2VsZi5kaWZmID0gbXM7XG4gICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICBwcmV2VGltZSA9IGN1cnI7XG4gICAgICBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICAgIH0gLy8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblxuXG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uIChtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7IC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblxuICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7IC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcbiAgICAgIHZhciBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcbiAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICBkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgIGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICBkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7IC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcbiAgICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG4gICAgcmV0dXJuIGRlYnVnO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG4gIH1cbiAgLyoqXG4gICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICAgIGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG4gICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFzcGxpdFtpXSkge1xuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cbiAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcbiAgICAgIGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAqXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgY3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcbiAgfVxuICAvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICAgIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBDb2VyY2UgYHZhbGAuXG4gICpcbiAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuICByZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/debug/src/common.js\n")},"./node_modules/gamepad.js/gamepad.js":function(module){eval('!function(t,e){ true?module.exports=e():0}(this,(function(){return(()=>{var t={944:function(t){t.exports=(()=>{"use strict";var t={d:(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};function n(t){return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function r(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!n){if(Array.isArray(t)||(n=i(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var r=0,o=function(){};return{s:o,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,u=!0,s=!1;return{s:function(){n=n.call(t)},n:function(){var t=n.next();return u=t.done,t},e:function(t){s=!0,a=t},f:function(){try{u||null==n.return||n.return()}finally{if(s)throw a}}}}function o(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=t&&("undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"]);if(null!=n){var r,o,i=[],a=!0,u=!1;try{for(n=n.call(t);!(a=(r=n.next()).done)&&(i.push(r.value),!e||i.length!==e);a=!0);}catch(t){u=!0,o=t}finally{try{a||null==n.return||n.return()}finally{if(u)throw o}}return i}}(t,e)||i(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function i(t,e){if(t){if("string"==typeof t)return a(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?a(t,e):void 0}}function a(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function u(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}t.d(e,{default:()=>s});var s=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];u(this,t),this.allowExtra=e,this.defaults=new Map,this.types=new Map,this.optional=new Set,this.required=new Set}var e;return(e=[{key:"setDefaults",value:function(t){var e=this;return Object.entries(t).forEach((function(t){var n=o(t,2),r=n[0],i=n[1];return e.defaults.set(r,i)})),this}},{key:"setTypes",value:function(t){var e=this;return Object.entries(t).forEach((function(t){var n=o(t,2),r=n[0],i=n[1];return e.types.set(r,i)})),this}},{key:"setOptional",value:function(t){var e=this;return t.forEach((function(t){return e.optional.add(t)})),this}},{key:"setRequired",value:function(t){var e=this;return t.forEach((function(t){return e.required.add(t)})),this}},{key:"resolve",value:function(t){var e=Object.assign(this.getDefaults(),t);return this.validate(e),e}},{key:"getDefaults",value:function(){var t,e={},n=r(this.defaults);try{for(n.s();!(t=n.n()).done;){var i=o(t.value,2),a=i[0],u=i[1];e[a]=u}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"validate",value:function(t){for(var e in t){if(!this.optionExists(e))throw new Error(\'Unkown option "\'.concat(e,\'".\'));this.checkType(e,t[e])}var n,o=r(this.required.values());try{for(o.s();!(n=o.n()).done;){var i=n.value;if(void 0===t[i])throw new Error(\'Option "\'.concat(i,\'" is required.\'))}}catch(t){o.e(t)}finally{o.f()}}},{key:"checkType",value:function(t,e){if(this.types.has(t)){var r=this.types.get(t),o=n(e);if(o!==r)throw new Error(\'Wrong value for option "\'.concat(t,\'". Expected type "\').concat(r,\'" but got "\').concat(o,\'".\'))}}},{key:"optionExists",value:function(t){return!!this.allowExtra||this.defaults.has(t)||this.optional.has(t)||this.required.has(t)||this.types.has(t)}}])&&function(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}(t.prototype,e),t}();return e.default})()},162:function(t){t.exports=(()=>{"use strict";var t={d:(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{default:()=>n});var n=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this._events={},this.on=this.addEventListener,this.off=this.removeEventListener}var e;return(e=[{key:"emit",value:function(t,e){if(Object.prototype.hasOwnProperty.call(this._events,t))for(var n=this._events[t],r={type:t,detail:e},o=n.length,i=0;i<o;i++)this.handle(n[i],r)}},{key:"handle",value:function(t,e){t(e)}},{key:"addEventListener",value:function(t,e){Object.prototype.hasOwnProperty.call(this._events,t)||(this._events[t]=[]),this._events[t].indexOf(e)<0&&this._events[t].push(e)}},{key:"removeEventListener",value:function(t,e){if(Object.prototype.hasOwnProperty.call(this._events,t)){var n=this._events[t],r=n.indexOf(e);r>=0&&n.splice(r,1),0===n.length&&delete this._events[t]}}}])&&function(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}(t.prototype,e),t}();return e.default})()}},e={};function n(r){var o=e[r];if(void 0!==o)return o.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};return(()=>{"use strict";n.r(r),n.d(r,{GamepadHandler:()=>d,GamepadListener:()=>x});var t=n(162),e=n.n(t),o=n(944),i=n.n(o);function a(t){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function u(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function c(t,e){return(c=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function l(t,e){return!e||"object"!==a(e)&&"function"!=typeof e?f(t):e}function f(t){if(void 0===t)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return t}function p(t){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var d=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&c(t,e)}(d,t);var e,n,r,o,i,a=(o=d,i=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=p(o);if(i){var n=p(this).constructor;t=Reflect.construct(e,arguments,n)}else t=e.apply(this,arguments);return l(this,t)});function d(t,e){var n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return u(this,d),(n=a.call(this)).index=t,n.options=n.constructor.resolveOptions(r),n.sticks=new Array(e.axes.length/2).fill(null).map((function(){return[null,null]})),n.buttons=new Array(e.buttons.length).fill(null),n.updateStick=n.updateStick.bind(f(n)),n.updateButton=n.updateButton.bind(f(n)),n}return e=d,r=[{key:"resolveOptions",value:function(t){var e=void 0!==t.stick,n=void 0!==t.button,r={stick:this.optionResolver.resolve(e?t.stick:n?{}:t),button:this.optionResolver.resolve(n?t.button:e?{}:t)};return r.stick.deadZone=Math.max(Math.min(r.stick.deadZone,1),0),r.button.deadZone=Math.max(Math.min(r.button.deadZone,1),0),r.stick.precision=r.stick.precision?Math.pow(10,r.stick.precision):0,r.button.precision=r.button.precision?Math.pow(10,r.button.precision):0,r}}],(n=[{key:"update",value:function(t){for(var e=0,n=this.sticks.length,r=0;r<n;r++)for(var o=0;o<2;o++)this.updateStick(t,r,o,t.axes[e++]);var i=this.buttons.length;for(e=0;e<i;e++)this.updateButton(t,t.buttons[e],e)}},{key:"updateStick",value:function(t,e,n,r){var o=this.options.stick,i=o.deadZone,a=o.analog,u=o.precision;i&&r<i&&r>-i&&(r=0),a?u&&(r=Math.round(r*u)/u):r=r>0?1:r<0?-1:0,this.sticks[e][n]!==r&&(this.sticks[e][n]=r,this.emit("axis",{gamepad:t,stick:e,axis:n,value:r,index:this.index}))}},{key:"updateButton",value:function(t,e,n){var r=this.options.button,o=r.deadZone,i=r.analog,a=r.precision,u=e.value,s=e.pressed,c=u;o&&e.value<o&&e.value>-o&&(c=0),i?a&&(c=Math.round(c*a)/a):c=s?1:0,this.buttons[n]!==c&&(this.buttons[n]=c,this.emit("button",{gamepad:t,button:n,pressed:s,value:c,index:this.index}))}}])&&s(e.prototype,n),r&&s(e,r),d}(e());function h(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}d.optionResolver=(new(i())).setDefaults({analog:!0,deadZone:0,precision:0}).setTypes({analog:"boolean",deadZone:"number",precision:"number"});var y=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.callback=e,this.frame=null,this.update=this.update.bind(this)}var e,n;return e=t,(n=[{key:"setCallback",value:function(t){this.callback=t}},{key:"start",value:function(){this.frame||(this.frame=window.requestAnimationFrame(this.update))}},{key:"stop",value:function(){this.frame&&(window.cancelAnimationFrame(this.frame),this.frame=null)}},{key:"update",value:function(){this.frame=window.requestAnimationFrame(this.update),this.callback()}}])&&h(e.prototype,n),t}();function v(t){return(v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function b(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function m(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function g(t,e){return(g=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function w(t,e){return!e||"object"!==v(e)&&"function"!=typeof e?k(t):e}function k(t){if(void 0===t)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return t}function O(t){return(O=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var x=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&g(t,e)}(a,t);var e,n,r,o,i=(r=a,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=O(r);if(o){var n=O(this).constructor;t=Reflect.construct(e,arguments,n)}else t=e.apply(this,arguments);return w(this,t)});function a(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(b(this,a),t=i.call(this),"function"!=typeof navigator.getGamepads)throw new Error("This browser does not support gamepad API.");return t.options=e,t.onAxis=t.onAxis.bind(k(t)),t.update=t.update.bind(k(t)),t.start=t.start.bind(k(t)),t.stop=t.stop.bind(k(t)),t.discover=t.discover.bind(k(t)),t.onButton=t.onButton.bind(k(t)),t.handlers=new Array(4).fill(null),t.loop=new y(t.update),window.addEventListener("error",t.stop),t}return e=a,(n=[{key:"start",value:function(){this.loop.start()}},{key:"stop",value:function(){this.loop.stop()}},{key:"update",value:function(){var t=navigator.getGamepads();this.discover(t[0],0),this.discover(t[1],1),this.discover(t[2],2),this.discover(t[3],3)}},{key:"discover",value:function(t,e){t?(this.handlers[e]||this.registerHandler(e,t),this.handlers[e].update(t)):this.handlers[e]&&this.removeGamepad(e)}},{key:"registerHandler",value:function(t,e){if(this.handlers[t])throw new Error("Gamepad #".concat(t," is already registered."));var n=new d(t,e,this.options);this.handlers[t]=n,n.addEventListener("axis",this.onAxis),n.addEventListener("button",this.onButton),this.emit("gamepad:connected",{index:t,gamepad:e}),this.emit("gamepad:".concat(t,":connected"),{index:t,gamepad:e})}},{key:"removeGamepad",value:function(t){if(!this.handlers[t])throw new Error("Gamepad #".concat(t," is not registered."));this.handlers[t].removeEventListener("axis",this.onAxis),this.handlers[t].removeEventListener("button",this.onButton),this.handlers[t]=null,this.emit("gamepad:disconnected",{index:t}),this.emit("gamepad:".concat(t,":disconnected"),{index:t})}},{key:"onAxis",value:function(t){var e=t.detail.index;this.emit("gamepad:axis",t.detail),this.emit("gamepad:".concat(e,":axis"),t.detail),this.emit("gamepad:".concat(e,":axis:").concat(t.detail.axis),t.detail)}},{key:"onButton",value:function(t){var e=t.detail.index;this.emit("gamepad:button",t.detail),this.emit("gamepad:".concat(e,":button"),t.detail),this.emit("gamepad:".concat(e,":button:").concat(t.detail.button),t.detail)}}])&&m(e.prototype,n),a}(e())})(),r})()}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2FtZXBhZC5qcy9nYW1lcGFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsS0FBaUQsb0JBQW9CLENBQTZHLENBQUMsa0JBQWtCLFlBQVksT0FBTyxnQkFBZ0IsZ0JBQWdCLGFBQWEsT0FBTyxVQUFVLCtEQUErRCx1QkFBdUIsRUFBRSxvREFBb0QsTUFBTSxjQUFjLGlGQUFpRixnQkFBZ0IsYUFBYSxvR0FBb0csS0FBSyxnQkFBZ0Isc0VBQXNFLE9BQU8sZ0VBQWdFLFNBQVMsdUJBQXVCLE9BQU8saUJBQWlCLG9CQUFvQixRQUFRLEVBQUUsc0JBQXNCLGVBQWUsUUFBUSxNQUFNLDZKQUE2SixnQkFBZ0IsT0FBTyxhQUFhLFlBQVksY0FBYyxlQUFlLGtCQUFrQixlQUFlLFNBQVMsY0FBYyxJQUFJLDhCQUE4QixRQUFRLGdCQUFnQixnQkFBZ0IsbUJBQW1CLDZCQUE2QixtQkFBbUIsMkVBQTJFLFlBQVksdUJBQXVCLElBQUksZ0JBQWdCLDJEQUEyRCxPQUFPLFNBQVMsU0FBUyxRQUFRLElBQUksOEJBQThCLFFBQVEsY0FBYyxVQUFVLDBCQUEwQixpS0FBaUssR0FBRyxnQkFBZ0IsTUFBTSxvQ0FBb0Msb0RBQW9ELGdMQUFnTCxnQkFBZ0Isb0NBQW9DLDJCQUEyQixJQUFJLGNBQWMsU0FBUyxnQkFBZ0IsOEVBQThFLE9BQU8sY0FBYyxFQUFFLGlCQUFpQixhQUFhLDhEQUE4RCxpSEFBaUgsTUFBTSxXQUFXLG9DQUFvQyxXQUFXLDhDQUE4QywyQkFBMkIsMkJBQTJCLFNBQVMsRUFBRSxpQ0FBaUMsV0FBVyw4Q0FBOEMsMkJBQTJCLHdCQUF3QixTQUFTLEVBQUUsb0NBQW9DLFdBQVcsOEJBQThCLHlCQUF5QixTQUFTLEVBQUUsb0NBQW9DLFdBQVcsOEJBQThCLHlCQUF5QixTQUFTLEVBQUUsZ0NBQWdDLDBDQUEwQywyQkFBMkIsRUFBRSxtQ0FBbUMsVUFBVSxvQkFBb0IsSUFBSSxVQUFVLGdCQUFnQixFQUFFLGlDQUFpQyxRQUFRLFNB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QkFBa0IsRUFBRSw4QkFBOEIsOEJBQThCLHlGQUF5RixFQUFFLG1DQUFtQyxvSEFBb0gsRUFBRSwwQ0FBMEMscUZBQXFGLDhCQUE4QixvSUFBb0ksa0JBQWtCLCtDQUErQyxrQkFBa0IsR0FBRyxFQUFFLHNDQUFzQyxrRkFBa0YsOEtBQThLLFFBQVEsa0RBQWtELFFBQVEsR0FBRyxFQUFFLCtCQUErQixxQkFBcUIsNkpBQTZKLEVBQUUsaUNBQWlDLHFCQUFxQixxS0FBcUssdUJBQXVCLE1BQU0sTUFBTSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9wLXh5ei8uL25vZGVfbW9kdWxlcy9nYW1lcGFkLmpzL2dhbWVwYWQuanM/Y2NjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLmdhbWVwYWQ9ZSgpOnQuZ2FtZXBhZD1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7cmV0dXJuKCgpPT57dmFyIHQ9ezk0NDpmdW5jdGlvbih0KXt0LmV4cG9ydHM9KCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9e2Q6KGUsbik9Pntmb3IodmFyIHIgaW4gbil0Lm8obixyKSYmIXQubyhlLHIpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDpuW3JdfSl9LG86KHQsZSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpfSxlPXt9O2Z1bmN0aW9uIG4odCl7cmV0dXJuKG49XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWZ1bmN0aW9uIHIodCxlKXt2YXIgbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZ0W1N5bWJvbC5pdGVyYXRvcl18fHRbXCJAQGl0ZXJhdG9yXCJdO2lmKCFuKXtpZihBcnJheS5pc0FycmF5KHQpfHwobj1pKHQpKXx8ZSYmdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXtuJiYodD1uKTt2YXIgcj0wLG89ZnVuY3Rpb24oKXt9O3JldHVybntzOm8sbjpmdW5jdGlvbigpe3JldHVybiByPj10Lmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6dFtyKytdfX0sZTpmdW5jdGlvbih0KXt0aHJvdyB0fSxmOm99fXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX12YXIgYSx1PSEwLHM9ITE7cmV0dXJue3M6ZnVuY3Rpb24oKXtuPW4uY2FsbCh0KX0sbjpmdW5jdGlvbigpe3ZhciB0PW4ubmV4dCgpO3JldHVybiB1PXQuZG9uZSx0fSxlOmZ1bmN0aW9uKHQpe3M9ITAsYT10fSxmOmZ1bmN0aW9uKCl7dHJ5e3V8fG51bGw9PW4ucmV0dXJufHxuLnJldHVybigpfWZpbmFsbHl7aWYocyl0aHJvdyBhfX19fWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH0odCl8fGZ1bmN0aW9uKHQsZSl7dmFyIG49dCYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJnRbU3ltYm9sLml0ZXJhdG9yXXx8dFtcIkBAaXRlcmF0b3JcIl0pO2lmKG51bGwhPW4pe3ZhciByLG8saT1bXSxhPSEwLHU9ITE7dHJ5e2ZvcihuPW4uY2FsbCh0KTshKGE9KHI9bi5uZXh0KCkpLmRvbmUpJiYoaS5wdXNoKHIudmFsdWUpLCFlfHxpLmxlbmd0aCE9PWUpO2E9ITApO31jYXRjaCh0KXt1PSEwLG89dH1maW5hbGx5e3RyeXthfHxudWxsPT1uLnJldHVybnx8bi5yZXR1cm4oKX1maW5hbGx5e2lmKHUpdGhyb3cgb319cmV0dXJuIGl9fSh0LGUpfHxpKHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBpKHQsZSl7aWYodCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIGEodCxlKTt2YXIgbj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PW4mJnQuY29uc3RydWN0b3ImJihuPXQuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PW58fFwiU2V0XCI9PT1uP0FycmF5LmZyb20odCk6XCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pP2EodCxlKTp2b2lkIDB9fWZ1bmN0aW9uIGEodCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIG49MCxyPW5ldyBBcnJheShlKTtuPGU7bisrKXJbbl09dFtuXTtyZXR1cm4gcn1mdW5jdGlvbiB1KHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX10LmQoZSx7ZGVmYXVsdDooKT0+c30pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07dSh0aGlzLHQpLHRoaXMuYWxsb3dFeHRyYT1lLHRoaXMuZGVmYXVsdHM9bmV3IE1hcCx0aGlzLnR5cGVzPW5ldyBNYXAsdGhpcy5vcHRpb25hbD1uZXcgU2V0LHRoaXMucmVxdWlyZWQ9bmV3IFNldH12YXIgZTtyZXR1cm4oZT1be2tleTpcInNldERlZmF1bHRzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gT2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG49byh0LDIpLHI9blswXSxpPW5bMV07cmV0dXJuIGUuZGVmYXVsdHMuc2V0KHIsaSl9KSksdGhpc319LHtrZXk6XCJzZXRUeXBlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIE9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBuPW8odCwyKSxyPW5bMF0saT1uWzFdO3JldHVybiBlLnR5cGVzLnNldChyLGkpfSkpLHRoaXN9fSx7a2V5Olwic2V0T3B0aW9uYWxcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBlLm9wdGlvbmFsLmFkZCh0KX0pKSx0aGlzfX0se2tleTpcInNldFJlcXVpcmVkXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gZS5yZXF1aXJlZC5hZGQodCl9KSksdGhpc319LHtrZXk6XCJyZXNvbHZlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9T2JqZWN0LmFzc2lnbih0aGlzLmdldERlZmF1bHRzKCksdCk7cmV0dXJuIHRoaXMudmFsaWRhdGUoZSksZX19LHtrZXk6XCJnZXREZWZhdWx0c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZT17fSxuPXIodGhpcy5kZWZhdWx0cyk7dHJ5e2ZvcihuLnMoKTshKHQ9bi5uKCkpLmRvbmU7KXt2YXIgaT1vKHQudmFsdWUsMiksYT1pWzBdLHU9aVsxXTtlW2FdPXV9fWNhdGNoKHQpe24uZSh0KX1maW5hbGx5e24uZigpfXJldHVybiBlfX0se2tleTpcInZhbGlkYXRlXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHQpe2lmKCF0aGlzLm9wdGlvbkV4aXN0cyhlKSl0aHJvdyBuZXcgRXJyb3IoJ1Vua293biBvcHRpb24gXCInLmNvbmNhdChlLCdcIi4nKSk7dGhpcy5jaGVja1R5cGUoZSx0W2VdKX12YXIgbixvPXIodGhpcy5yZXF1aXJlZC52YWx1ZXMoKSk7dHJ5e2ZvcihvLnMoKTshKG49by5uKCkpLmRvbmU7KXt2YXIgaT1uLnZhbHVlO2lmKHZvaWQgMD09PXRbaV0pdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gXCInLmNvbmNhdChpLCdcIiBpcyByZXF1aXJlZC4nKSl9fWNhdGNoKHQpe28uZSh0KX1maW5hbGx5e28uZigpfX19LHtrZXk6XCJjaGVja1R5cGVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKHRoaXMudHlwZXMuaGFzKHQpKXt2YXIgcj10aGlzLnR5cGVzLmdldCh0KSxvPW4oZSk7aWYobyE9PXIpdGhyb3cgbmV3IEVycm9yKCdXcm9uZyB2YWx1ZSBmb3Igb3B0aW9uIFwiJy5jb25jYXQodCwnXCIuIEV4cGVjdGVkIHR5cGUgXCInKS5jb25jYXQociwnXCIgYnV0IGdvdCBcIicpLmNvbmNhdChvLCdcIi4nKSl9fX0se2tleTpcIm9wdGlvbkV4aXN0c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiEhdGhpcy5hbGxvd0V4dHJhfHx0aGlzLmRlZmF1bHRzLmhhcyh0KXx8dGhpcy5vcHRpb25hbC5oYXModCl8fHRoaXMucmVxdWlyZWQuaGFzKHQpfHx0aGlzLnR5cGVzLmhhcyh0KX19XSkmJmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX0odC5wcm90b3R5cGUsZSksdH0oKTtyZXR1cm4gZS5kZWZhdWx0fSkoKX0sMTYyOmZ1bmN0aW9uKHQpe3QuZXhwb3J0cz0oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17ZDooZSxuKT0+e2Zvcih2YXIgciBpbiBuKXQubyhuLHIpJiYhdC5vKGUscikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0Om5bcl19KX0sbzoodCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSl9LGU9e307dC5kKGUse2RlZmF1bHQ6KCk9Pm59KTt2YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLHQpLHRoaXMuX2V2ZW50cz17fSx0aGlzLm9uPXRoaXMuYWRkRXZlbnRMaXN0ZW5lcix0aGlzLm9mZj10aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJ9dmFyIGU7cmV0dXJuKGU9W3trZXk6XCJlbWl0XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fZXZlbnRzLHQpKWZvcih2YXIgbj10aGlzLl9ldmVudHNbdF0scj17dHlwZTp0LGRldGFpbDplfSxvPW4ubGVuZ3RoLGk9MDtpPG87aSsrKXRoaXMuaGFuZGxlKG5baV0scil9fSx7a2V5OlwiaGFuZGxlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0KGUpfX0se2tleTpcImFkZEV2ZW50TGlzdGVuZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9ldmVudHMsdCl8fCh0aGlzLl9ldmVudHNbdF09W10pLHRoaXMuX2V2ZW50c1t0XS5pbmRleE9mKGUpPDAmJnRoaXMuX2V2ZW50c1t0XS5wdXNoKGUpfX0se2tleTpcInJlbW92ZUV2ZW50TGlzdGVuZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9ldmVudHMsdCkpe3ZhciBuPXRoaXMuX2V2ZW50c1t0XSxyPW4uaW5kZXhPZihlKTtyPj0wJiZuLnNwbGljZShyLDEpLDA9PT1uLmxlbmd0aCYmZGVsZXRlIHRoaXMuX2V2ZW50c1t0XX19fV0pJiZmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19KHQucHJvdG90eXBlLGUpLHR9KCk7cmV0dXJuIGUuZGVmYXVsdH0pKCl9fSxlPXt9O2Z1bmN0aW9uIG4ocil7dmFyIG89ZVtyXTtpZih2b2lkIDAhPT1vKXJldHVybiBvLmV4cG9ydHM7dmFyIGk9ZVtyXT17ZXhwb3J0czp7fX07cmV0dXJuIHRbcl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsbiksaS5leHBvcnRzfW4ubj10PT57dmFyIGU9dCYmdC5fX2VzTW9kdWxlPygpPT50LmRlZmF1bHQ6KCk9PnQ7cmV0dXJuIG4uZChlLHthOmV9KSxlfSxuLmQ9KHQsZSk9Pntmb3IodmFyIHIgaW4gZSluLm8oZSxyKSYmIW4ubyh0LHIpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLHtlbnVtZXJhYmxlOiEwLGdldDplW3JdfSl9LG4ubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSksbi5yPXQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfTt2YXIgcj17fTtyZXR1cm4oKCk9PntcInVzZSBzdHJpY3RcIjtuLnIociksbi5kKHIse0dhbWVwYWRIYW5kbGVyOigpPT5kLEdhbWVwYWRMaXN0ZW5lcjooKT0+eH0pO3ZhciB0PW4oMTYyKSxlPW4ubih0KSxvPW4oOTQ0KSxpPW4ubihvKTtmdW5jdGlvbiBhKHQpe3JldHVybihhPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1mdW5jdGlvbiB1KHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBzKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBjKHQsZSl7cmV0dXJuKGM9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIGwodCxlKXtyZXR1cm4hZXx8XCJvYmplY3RcIiE9PWEoZSkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/Zih0KTplfWZ1bmN0aW9uIGYodCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9ZnVuY3Rpb24gcCh0KXtyZXR1cm4ocD1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSkodCl9dmFyIGQ9ZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiZjKHQsZSl9KGQsdCk7dmFyIGUsbixyLG8saSxhPShvPWQsaT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpLGZ1bmN0aW9uKCl7dmFyIHQsZT1wKG8pO2lmKGkpe3ZhciBuPXAodGhpcykuY29uc3RydWN0b3I7dD1SZWZsZWN0LmNvbnN0cnVjdChlLGFyZ3VtZW50cyxuKX1lbHNlIHQ9ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGwodGhpcyx0KX0pO2Z1bmN0aW9uIGQodCxlKXt2YXIgbixyPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fTtyZXR1cm4gdSh0aGlzLGQpLChuPWEuY2FsbCh0aGlzKSkuaW5kZXg9dCxuLm9wdGlvbnM9bi5jb25zdHJ1Y3Rvci5yZXNvbHZlT3B0aW9ucyhyKSxuLnN0aWNrcz1uZXcgQXJyYXkoZS5heGVzLmxlbmd0aC8yKS5maWxsKG51bGwpLm1hcCgoZnVuY3Rpb24oKXtyZXR1cm5bbnVsbCxudWxsXX0pKSxuLmJ1dHRvbnM9bmV3IEFycmF5KGUuYnV0dG9ucy5sZW5ndGgpLmZpbGwobnVsbCksbi51cGRhdGVTdGljaz1uLnVwZGF0ZVN0aWNrLmJpbmQoZihuKSksbi51cGRhdGVCdXR0b249bi51cGRhdGVCdXR0b24uYmluZChmKG4pKSxufXJldHVybiBlPWQscj1be2tleTpcInJlc29sdmVPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dm9pZCAwIT09dC5zdGljayxuPXZvaWQgMCE9PXQuYnV0dG9uLHI9e3N0aWNrOnRoaXMub3B0aW9uUmVzb2x2ZXIucmVzb2x2ZShlP3Quc3RpY2s6bj97fTp0KSxidXR0b246dGhpcy5vcHRpb25SZXNvbHZlci5yZXNvbHZlKG4/dC5idXR0b246ZT97fTp0KX07cmV0dXJuIHIuc3RpY2suZGVhZFpvbmU9TWF0aC5tYXgoTWF0aC5taW4oci5zdGljay5kZWFkWm9uZSwxKSwwKSxyLmJ1dHRvbi5kZWFkWm9uZT1NYXRoLm1heChNYXRoLm1pbihyLmJ1dHRvbi5kZWFkWm9uZSwxKSwwKSxyLnN0aWNrLnByZWNpc2lvbj1yLnN0aWNrLnByZWNpc2lvbj9NYXRoLnBvdygxMCxyLnN0aWNrLnByZWNpc2lvbik6MCxyLmJ1dHRvbi5wcmVjaXNpb249ci5idXR0b24ucHJlY2lzaW9uP01hdGgucG93KDEwLHIuYnV0dG9uLnByZWNpc2lvbik6MCxyfX1dLChuPVt7a2V5OlwidXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj10aGlzLnN0aWNrcy5sZW5ndGgscj0wO3I8bjtyKyspZm9yKHZhciBvPTA7bzwyO28rKyl0aGlzLnVwZGF0ZVN0aWNrKHQscixvLHQuYXhlc1tlKytdKTt2YXIgaT10aGlzLmJ1dHRvbnMubGVuZ3RoO2ZvcihlPTA7ZTxpO2UrKyl0aGlzLnVwZGF0ZUJ1dHRvbih0LHQuYnV0dG9uc1tlXSxlKX19LHtrZXk6XCJ1cGRhdGVTdGlja1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXRoaXMub3B0aW9ucy5zdGljayxpPW8uZGVhZFpvbmUsYT1vLmFuYWxvZyx1PW8ucHJlY2lzaW9uO2kmJnI8aSYmcj4taSYmKHI9MCksYT91JiYocj1NYXRoLnJvdW5kKHIqdSkvdSk6cj1yPjA/MTpyPDA/LTE6MCx0aGlzLnN0aWNrc1tlXVtuXSE9PXImJih0aGlzLnN0aWNrc1tlXVtuXT1yLHRoaXMuZW1pdChcImF4aXNcIix7Z2FtZXBhZDp0LHN0aWNrOmUsYXhpczpuLHZhbHVlOnIsaW5kZXg6dGhpcy5pbmRleH0pKX19LHtrZXk6XCJ1cGRhdGVCdXR0b25cIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy5vcHRpb25zLmJ1dHRvbixvPXIuZGVhZFpvbmUsaT1yLmFuYWxvZyxhPXIucHJlY2lzaW9uLHU9ZS52YWx1ZSxzPWUucHJlc3NlZCxjPXU7byYmZS52YWx1ZTxvJiZlLnZhbHVlPi1vJiYoYz0wKSxpP2EmJihjPU1hdGgucm91bmQoYyphKS9hKTpjPXM/MTowLHRoaXMuYnV0dG9uc1tuXSE9PWMmJih0aGlzLmJ1dHRvbnNbbl09Yyx0aGlzLmVtaXQoXCJidXR0b25cIix7Z2FtZXBhZDp0LGJ1dHRvbjpuLHByZXNzZWQ6cyx2YWx1ZTpjLGluZGV4OnRoaXMuaW5kZXh9KSl9fV0pJiZzKGUucHJvdG90eXBlLG4pLHImJnMoZSxyKSxkfShlKCkpO2Z1bmN0aW9uIGgodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWQub3B0aW9uUmVzb2x2ZXI9KG5ldyhpKCkpKS5zZXREZWZhdWx0cyh7YW5hbG9nOiEwLGRlYWRab25lOjAscHJlY2lzaW9uOjB9KS5zZXRUeXBlcyh7YW5hbG9nOlwiYm9vbGVhblwiLGRlYWRab25lOlwibnVtYmVyXCIscHJlY2lzaW9uOlwibnVtYmVyXCJ9KTt2YXIgeT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyx0KSx0aGlzLmNhbGxiYWNrPWUsdGhpcy5mcmFtZT1udWxsLHRoaXMudXBkYXRlPXRoaXMudXBkYXRlLmJpbmQodGhpcyl9dmFyIGUsbjtyZXR1cm4gZT10LChuPVt7a2V5Olwic2V0Q2FsbGJhY2tcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmNhbGxiYWNrPXR9fSx7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZnJhbWV8fCh0aGlzLmZyYW1lPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUpKX19LHtrZXk6XCJzdG9wXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZyYW1lJiYod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWUpLHRoaXMuZnJhbWU9bnVsbCl9fSx7a2V5OlwidXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZyYW1lPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUpLHRoaXMuY2FsbGJhY2soKX19XSkmJmgoZS5wcm90b3R5cGUsbiksdH0oKTtmdW5jdGlvbiB2KHQpe3JldHVybih2PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1mdW5jdGlvbiBiKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBtKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiBnKHQsZSl7cmV0dXJuKGc9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIHcodCxlKXtyZXR1cm4hZXx8XCJvYmplY3RcIiE9PXYoZSkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/ayh0KTplfWZ1bmN0aW9uIGsodCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9ZnVuY3Rpb24gTyh0KXtyZXR1cm4oTz1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSkodCl9dmFyIHg9ZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiZnKHQsZSl9KGEsdCk7dmFyIGUsbixyLG8saT0ocj1hLG89ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX0oKSxmdW5jdGlvbigpe3ZhciB0LGU9TyhyKTtpZihvKXt2YXIgbj1PKHRoaXMpLmNvbnN0cnVjdG9yO3Q9UmVmbGVjdC5jb25zdHJ1Y3QoZSxhcmd1bWVudHMsbil9ZWxzZSB0PWUuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB3KHRoaXMsdCl9KTtmdW5jdGlvbiBhKCl7dmFyIHQsZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307aWYoYih0aGlzLGEpLHQ9aS5jYWxsKHRoaXMpLFwiZnVuY3Rpb25cIiE9dHlwZW9mIG5hdmlnYXRvci5nZXRHYW1lcGFkcyl0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBnYW1lcGFkIEFQSS5cIik7cmV0dXJuIHQub3B0aW9ucz1lLHQub25BeGlzPXQub25BeGlzLmJpbmQoayh0KSksdC51cGRhdGU9dC51cGRhdGUuYmluZChrKHQpKSx0LnN0YXJ0PXQuc3RhcnQuYmluZChrKHQpKSx0LnN0b3A9dC5zdG9wLmJpbmQoayh0KSksdC5kaXNjb3Zlcj10LmRpc2NvdmVyLmJpbmQoayh0KSksdC5vbkJ1dHRvbj10Lm9uQnV0dG9uLmJpbmQoayh0KSksdC5oYW5kbGVycz1uZXcgQXJyYXkoNCkuZmlsbChudWxsKSx0Lmxvb3A9bmV3IHkodC51cGRhdGUpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIix0LnN0b3ApLHR9cmV0dXJuIGU9YSwobj1be2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmxvb3Auc3RhcnQoKX19LHtrZXk6XCJzdG9wXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmxvb3Auc3RvcCgpfX0se2tleTpcInVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9bmF2aWdhdG9yLmdldEdhbWVwYWRzKCk7dGhpcy5kaXNjb3Zlcih0WzBdLDApLHRoaXMuZGlzY292ZXIodFsxXSwxKSx0aGlzLmRpc2NvdmVyKHRbMl0sMiksdGhpcy5kaXNjb3Zlcih0WzNdLDMpfX0se2tleTpcImRpc2NvdmVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0Pyh0aGlzLmhhbmRsZXJzW2VdfHx0aGlzLnJlZ2lzdGVySGFuZGxlcihlLHQpLHRoaXMuaGFuZGxlcnNbZV0udXBkYXRlKHQpKTp0aGlzLmhhbmRsZXJzW2VdJiZ0aGlzLnJlbW92ZUdhbWVwYWQoZSl9fSx7a2V5OlwicmVnaXN0ZXJIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZih0aGlzLmhhbmRsZXJzW3RdKXRocm93IG5ldyBFcnJvcihcIkdhbWVwYWQgI1wiLmNvbmNhdCh0LFwiIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5cIikpO3ZhciBuPW5ldyBkKHQsZSx0aGlzLm9wdGlvbnMpO3RoaXMuaGFuZGxlcnNbdF09bixuLmFkZEV2ZW50TGlzdGVuZXIoXCJheGlzXCIsdGhpcy5vbkF4aXMpLG4uYWRkRXZlbnRMaXN0ZW5lcihcImJ1dHRvblwiLHRoaXMub25CdXR0b24pLHRoaXMuZW1pdChcImdhbWVwYWQ6Y29ubmVjdGVkXCIse2luZGV4OnQsZ2FtZXBhZDplfSksdGhpcy5lbWl0KFwiZ2FtZXBhZDpcIi5jb25jYXQodCxcIjpjb25uZWN0ZWRcIikse2luZGV4OnQsZ2FtZXBhZDplfSl9fSx7a2V5OlwicmVtb3ZlR2FtZXBhZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKCF0aGlzLmhhbmRsZXJzW3RdKXRocm93IG5ldyBFcnJvcihcIkdhbWVwYWQgI1wiLmNvbmNhdCh0LFwiIGlzIG5vdCByZWdpc3RlcmVkLlwiKSk7dGhpcy5oYW5kbGVyc1t0XS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYXhpc1wiLHRoaXMub25BeGlzKSx0aGlzLmhhbmRsZXJzW3RdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJidXR0b25cIix0aGlzLm9uQnV0dG9uKSx0aGlzLmhhbmRsZXJzW3RdPW51bGwsdGhpcy5lbWl0KFwiZ2FtZXBhZDpkaXNjb25uZWN0ZWRcIix7aW5kZXg6dH0pLHRoaXMuZW1pdChcImdhbWVwYWQ6XCIuY29uY2F0KHQsXCI6ZGlzY29ubmVjdGVkXCIpLHtpbmRleDp0fSl9fSx7a2V5Olwib25BeGlzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5kZXRhaWwuaW5kZXg7dGhpcy5lbWl0KFwiZ2FtZXBhZDpheGlzXCIsdC5kZXRhaWwpLHRoaXMuZW1pdChcImdhbWVwYWQ6XCIuY29uY2F0KGUsXCI6YXhpc1wiKSx0LmRldGFpbCksdGhpcy5lbWl0KFwiZ2FtZXBhZDpcIi5jb25jYXQoZSxcIjpheGlzOlwiKS5jb25jYXQodC5kZXRhaWwuYXhpcyksdC5kZXRhaWwpfX0se2tleTpcIm9uQnV0dG9uXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5kZXRhaWwuaW5kZXg7dGhpcy5lbWl0KFwiZ2FtZXBhZDpidXR0b25cIix0LmRldGFpbCksdGhpcy5lbWl0KFwiZ2FtZXBhZDpcIi5jb25jYXQoZSxcIjpidXR0b25cIiksdC5kZXRhaWwpLHRoaXMuZW1pdChcImdhbWVwYWQ6XCIuY29uY2F0KGUsXCI6YnV0dG9uOlwiKS5jb25jYXQodC5kZXRhaWwuYnV0dG9uKSx0LmRldGFpbCl9fV0pJiZtKGUucHJvdG90eXBlLG4pLGF9KGUoKSl9KSgpLHJ9KSgpfSkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gamepad.js/gamepad.js\n')},"./node_modules/ms/index.js":module=>{eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3AteHl6Ly4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzPzE0NjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ms/index.js\n")},"./node_modules/path-browserify/index.js":module=>{"use strict";eval("// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsWUFBWTtBQUNaO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQSxNQUFNO0FBQ04sZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlEO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9wLXh5ei8uL25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanM/ZGY3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAncGF0aCcgbW9kdWxlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSAob25seSB0aGUgcG9zaXggcGFydClcbi8vIHRyYW5zcGxpdGVkIHdpdGggQmFiZWxcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICcgKyBKU09OLnN0cmluZ2lmeShwYXRoKSk7XG4gIH1cbn1cblxuLy8gUmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIHdpdGggZGlyZWN0b3J5IG5hbWVzXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoLCBhbGxvd0Fib3ZlUm9vdCkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gIHZhciBsYXN0U2xhc2ggPSAtMTtcbiAgdmFyIGRvdHMgPSAwO1xuICB2YXIgY29kZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpIDwgcGF0aC5sZW5ndGgpXG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGVsc2UgaWYgKGNvZGUgPT09IDQ3IC8qLyovKVxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgY29kZSA9IDQ3IC8qLyovO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkge1xuICAgICAgICAvLyBOT09QXG4gICAgICB9IGVsc2UgaWYgKGxhc3RTbGFzaCAhPT0gaSAtIDEgJiYgZG90cyA9PT0gMikge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgbGFzdFNlZ21lbnRMZW5ndGggIT09IDIgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSA0NiAvKi4qLyB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFNsYXNoSW5kZXggPSByZXMubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCAhPT0gcmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuc2xpY2UoMCwgbGFzdFNsYXNoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID09PSAyIHx8IHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJlcyArPSAnLy4uJztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXMgPSAnLi4nO1xuICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgIHJlcyArPSAnLycgKyBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmVzID0gcGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcbiAgICAgIH1cbiAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICBkb3RzID0gMDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQ2IC8qLiovICYmIGRvdHMgIT09IC0xKSB7XG4gICAgICArK2RvdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvdHMgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gX2Zvcm1hdChzZXAsIHBhdGhPYmplY3QpIHtcbiAgdmFyIGRpciA9IHBhdGhPYmplY3QuZGlyIHx8IHBhdGhPYmplY3Qucm9vdDtcbiAgdmFyIGJhc2UgPSBwYXRoT2JqZWN0LmJhc2UgfHwgKHBhdGhPYmplY3QubmFtZSB8fCAnJykgKyAocGF0aE9iamVjdC5leHQgfHwgJycpO1xuICBpZiAoIWRpcikge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmIChkaXIgPT09IHBhdGhPYmplY3Qucm9vdCkge1xuICAgIHJldHVybiBkaXIgKyBiYXNlO1xuICB9XG4gIHJldHVybiBkaXIgKyBzZXAgKyBiYXNlO1xufVxuXG52YXIgcG9zaXggPSB7XG4gIC8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgcmVzb2x2ZWRQYXRoID0gJyc7XG4gICAgdmFyIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICB2YXIgY3dkO1xuXG4gICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgIHZhciBwYXRoO1xuICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgcGF0aCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY3dkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgY3dkID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgcGF0aCA9IGN3ZDtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgICAgLy8gU2tpcCBlbXB0eSBlbnRyaWVzXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gICAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVTdHJpbmdQb3NpeChyZXNvbHZlZFBhdGgsICFyZXNvbHZlZEFic29sdXRlKTtcblxuICAgIGlmIChyZXNvbHZlZEFic29sdXRlKSB7XG4gICAgICBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAnLyc7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcuJztcbiAgICB9XG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG5cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gICAgdmFyIHRyYWlsaW5nU2VwYXJhdG9yID0gcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IDQ3IC8qLyovO1xuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgcGF0aCA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsICFpc0Fic29sdXRlKTtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCAmJiAhaXNBYnNvbHV0ZSkgcGF0aCA9ICcuJztcbiAgICBpZiAocGF0aC5sZW5ndGggPiAwICYmIHRyYWlsaW5nU2VwYXJhdG9yKSBwYXRoICs9ICcvJztcblxuICAgIGlmIChpc0Fic29sdXRlKSByZXR1cm4gJy8nICsgcGF0aDtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICBpc0Fic29sdXRlOiBmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgfSxcblxuICBqb2luOiBmdW5jdGlvbiBqb2luKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuICcuJztcbiAgICB2YXIgam9pbmVkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgYXNzZXJ0UGF0aChhcmcpO1xuICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBqb2luZWQgPSBhcmc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBqb2luZWQgKz0gJy8nICsgYXJnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gJy4nO1xuICAgIHJldHVybiBwb3NpeC5ub3JtYWxpemUoam9pbmVkKTtcbiAgfSxcblxuICByZWxhdGl2ZTogZnVuY3Rpb24gcmVsYXRpdmUoZnJvbSwgdG8pIHtcbiAgICBhc3NlcnRQYXRoKGZyb20pO1xuICAgIGFzc2VydFBhdGgodG8pO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gJyc7XG5cbiAgICBmcm9tID0gcG9zaXgucmVzb2x2ZShmcm9tKTtcbiAgICB0byA9IHBvc2l4LnJlc29sdmUodG8pO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gJyc7XG5cbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgdmFyIGZyb21TdGFydCA9IDE7XG4gICAgZm9yICg7IGZyb21TdGFydCA8IGZyb20ubGVuZ3RoOyArK2Zyb21TdGFydCkge1xuICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQpICE9PSA0NyAvKi8qLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBmcm9tRW5kID0gZnJvbS5sZW5ndGg7XG4gICAgdmFyIGZyb21MZW4gPSBmcm9tRW5kIC0gZnJvbVN0YXJ0O1xuXG4gICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgIHZhciB0b1N0YXJ0ID0gMTtcbiAgICBmb3IgKDsgdG9TdGFydCA8IHRvLmxlbmd0aDsgKyt0b1N0YXJ0KSB7XG4gICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0KSAhPT0gNDcgLyovKi8pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgdG9FbmQgPSB0by5sZW5ndGg7XG4gICAgdmFyIHRvTGVuID0gdG9FbmQgLSB0b1N0YXJ0O1xuXG4gICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxuICAgIHZhciBsZW5ndGggPSBmcm9tTGVuIDwgdG9MZW4gPyBmcm9tTGVuIDogdG9MZW47XG4gICAgdmFyIGxhc3RDb21tb25TZXAgPSAtMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPD0gbGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpID09PSBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGB0b2AuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXInOyB0bz0nL2Zvby9iYXIvYmF6J1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpICsgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIHJvb3RcbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvJzsgdG89Jy9mb28nXG4gICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmcm9tTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYGZyb21gLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyL2Jheic7IHRvPScvZm9vL2JhcidcbiAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgcm9vdC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vJzsgdG89Jy8nXG4gICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgZnJvbUNvZGUgPSBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSk7XG4gICAgICB2YXIgdG9Db2RlID0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSk7XG4gICAgICBpZiAoZnJvbUNvZGUgIT09IHRvQ29kZSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gNDcgLyovKi8pXG4gICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYFxuICAgIC8vIGFuZCBgZnJvbWBcbiAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcbiAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgb3V0ICs9ICcuLic7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdXQgKz0gJy8uLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcbiAgICAvLyB0aGUgY29tbW9uIHBhdGggcGFydHNcbiAgICBpZiAob3V0Lmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gb3V0ICsgdG8uc2xpY2UodG9TdGFydCArIGxhc3RDb21tb25TZXApO1xuICAgIGVsc2Uge1xuICAgICAgdG9TdGFydCArPSBsYXN0Q29tbW9uU2VwO1xuICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IDQ3IC8qLyovKVxuICAgICAgICArK3RvU3RhcnQ7XG4gICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCk7XG4gICAgfVxuICB9LFxuXG4gIF9tYWtlTG9uZzogZnVuY3Rpb24gX21ha2VMb25nKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICBkaXJuYW1lOiBmdW5jdGlvbiBkaXJuYW1lKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gICAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSByZXR1cm4gJy8vJztcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xuICB9LFxuXG4gIGJhc2VuYW1lOiBmdW5jdGlvbiBiYXNlbmFtZShwYXRoLCBleHQpIHtcbiAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGV4dCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoZXh0Lmxlbmd0aCA9PT0gcGF0aC5sZW5ndGggJiYgZXh0ID09PSBwYXRoKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgZmlyc3ROb25TbGFzaEVuZCA9IC0xO1xuICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdE5vblNsYXNoRW5kID09PSAtMSkge1xuICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIHJlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZVxuICAgICAgICAgICAgLy8gd2UgbmVlZCBpdCBpZiB0aGUgZXh0ZW5zaW9uIGVuZHMgdXAgbm90IG1hdGNoaW5nXG4gICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZpcnN0Tm9uU2xhc2hFbmQgPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFeHRlbnNpb24gZG9lcyBub3QgbWF0Y2gsIHNvIG91ciByZXN1bHQgaXMgdGhlIGVudGlyZSBwYXRoXG4gICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICBleHRJZHggPSAtMTtcbiAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7ZWxzZSBpZiAoZW5kID09PSAtMSkgZW5kID0gcGF0aC5sZW5ndGg7XG4gICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfSxcblxuICBleHRuYW1lOiBmdW5jdGlvbiBleHRuYW1lKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIHZhciBzdGFydERvdCA9IC0xO1xuICAgIHZhciBzdGFydFBhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgfSxcblxuICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChwYXRoT2JqZWN0KSB7XG4gICAgaWYgKHBhdGhPYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIHBhdGhPYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHBhdGhPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gX2Zvcm1hdCgnLycsIHBhdGhPYmplY3QpO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIHZhciByZXQgPSB7IHJvb3Q6ICcnLCBkaXI6ICcnLCBiYXNlOiAnJywgZXh0OiAnJywgbmFtZTogJycgfTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiByZXQ7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGlzQWJzb2x1dGUgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgICB2YXIgc3RhcnQ7XG4gICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgIHJldC5yb290ID0gJy8nO1xuICAgICAgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHZhciBzdGFydERvdCA9IC0xO1xuICAgIHZhciBzdGFydFBhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcblxuICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG5cbiAgICAvLyBHZXQgbm9uLWRpciBpbmZvXG4gICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSBzdGFydERvdCA9IGk7ZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHByZURvdFN0YXRlID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICBpZiAoZW5kICE9PSAtMSkge1xuICAgICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKDEsIGVuZCk7ZWxzZSByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2UoMSwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2UoMSwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIHN0YXJ0RG90KTtcbiAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldC5leHQgPSBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH1cblxuICAgIGlmIChzdGFydFBhcnQgPiAwKSByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtlbHNlIGlmIChpc0Fic29sdXRlKSByZXQuZGlyID0gJy8nO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBzZXA6ICcvJyxcbiAgZGVsaW1pdGVyOiAnOicsXG4gIHdpbjMyOiBudWxsLFxuICBwb3NpeDogbnVsbFxufTtcblxucG9zaXgucG9zaXggPSBwb3NpeDtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3NpeDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/path-browserify/index.js\n")},"./src/TfTree.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('teleopxyz.TfTree')\nconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\n\nasync function getTopicType(ros, topic){\n  return new Promise((resolve, reject)=>{\n    ros.getTopicType(topic, resolve, reject)\n  })\n}\n\n\nfunction cleanPath(str){\n  return path.join('/', str)\n}\n\n\nclass TfTree extends THREE.Object3D {\n  constructor({ros, tfClient, rootObject, frames, scale, showArrows, showAxes, showNames}){\n    super()\n    this.ros = ros\n    this.tfClient = tfClient\n    this.rootObject = rootObject\n    this.axisScale = scale || 1.0\n    this.frames = {} //! Map of frameName to frameEnabled\n\n    for(const [frame, enabled] of Object.entries(frames)){\n      this.markFrame(frame, enabled)\n    }\n\n    this.sceneNodes = {}\n\n    this.tfSub = null\n\n    this.tfStaticSub = null\n\n  }\n\n\n  async setup(){\n    const [tfType, tfStaticType] = await Promise.all([\n      getTopicType(this.ros, '/tf'),\n      getTopicType(this.ros, '/tf_static')\n    ])\n\n    debug('types', tfType, tfStaticType)\n\n    this.tfSub = new ROSLIB.Topic({\n      ros: this.ros,\n      name: '/tf',\n      messageType: tfType\n    })\n\n    this.tfStaticSub = new ROSLIB.Topic({\n      ros: this.ros,\n      name: '/tf_static',\n      messageType: tfStaticType\n    })\n\n    this.listenForFrames()\n  }\n\n  listenForFrames(){\n    this.tfSub.subscribe(this.handleTfMessage.bind(this))\n    this.tfStaticSub.subscribe(this.handleTfMessage.bind(this))\n    setTimeout(this.stopListeningForFrames.bind(this), 3000)\n  }\n\n  frameExists(frame_id){\n    return this.frames[cleanPath(frame_id)] !== undefined\n  }\n\n  markFrame(frame, value){\n    const frame_id = cleanPath(frame)\n    if(!this.frameExists(frame_id)){\n      debug('discovered frame', frame_id)\n      this.frames[frame_id] = value\n    }\n  }\n  \n\n  handleTfMessage(msg){\n    for(let transform of msg.transforms){\n      this.markFrame(transform.child_frame_id, true)\n      this.markFrame(transform.header.frame_id, true)\n    }\n  }\n\n\n\n  stopListeningForFrames(){\n    debug('stopListeningForFrames done')\n    this.tfSub.unsubscribe()\n    this.tfStaticSub.unsubscribe()\n\n    this.subscribe()\n  }\n\n  //! Subscribe to needed Tf frames\n  subscribe(){\n\n    for(const [frame, enabled] of Object.entries(this.frames)){\n\n      if(enabled){\n        debug('subscribing to frame', frame)\n        let axis = new ROS3D.Axes({\n          lineType: 'full',\n          shaftRadius: 0.04,\n          scale: this.axisScale/5.0,\n        })\n\n        this.sceneNodes[frame] = new ROS3D.SceneNode({\n          frameID: frame,\n          tfClient: this.tfClient,\n          object: axis\n        })\n\n        this.rootObject.add(this.sceneNodes[frame])\n      }\n      else {\n        debug('ignoring frame', frame)\n      }\n    }\n  }\n\n}\n\nmodule.exports=TfTree;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVGZUcmVlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxrREFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMscURBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGVBQWUsMEVBQTBFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3AteHl6Ly4vc3JjL1RmVHJlZS5qcz9lNzFmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgndGVsZW9weHl6LlRmVHJlZScpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmFzeW5jIGZ1bmN0aW9uIGdldFRvcGljVHlwZShyb3MsIHRvcGljKXtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgcm9zLmdldFRvcGljVHlwZSh0b3BpYywgcmVzb2x2ZSwgcmVqZWN0KVxuICB9KVxufVxuXG5cbmZ1bmN0aW9uIGNsZWFuUGF0aChzdHIpe1xuICByZXR1cm4gcGF0aC5qb2luKCcvJywgc3RyKVxufVxuXG5cbmNsYXNzIFRmVHJlZSBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcbiAgY29uc3RydWN0b3Ioe3JvcywgdGZDbGllbnQsIHJvb3RPYmplY3QsIGZyYW1lcywgc2NhbGUsIHNob3dBcnJvd3MsIHNob3dBeGVzLCBzaG93TmFtZXN9KXtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5yb3MgPSByb3NcbiAgICB0aGlzLnRmQ2xpZW50ID0gdGZDbGllbnRcbiAgICB0aGlzLnJvb3RPYmplY3QgPSByb290T2JqZWN0XG4gICAgdGhpcy5heGlzU2NhbGUgPSBzY2FsZSB8fCAxLjBcbiAgICB0aGlzLmZyYW1lcyA9IHt9IC8vISBNYXAgb2YgZnJhbWVOYW1lIHRvIGZyYW1lRW5hYmxlZFxuXG4gICAgZm9yKGNvbnN0IFtmcmFtZSwgZW5hYmxlZF0gb2YgT2JqZWN0LmVudHJpZXMoZnJhbWVzKSl7XG4gICAgICB0aGlzLm1hcmtGcmFtZShmcmFtZSwgZW5hYmxlZClcbiAgICB9XG5cbiAgICB0aGlzLnNjZW5lTm9kZXMgPSB7fVxuXG4gICAgdGhpcy50ZlN1YiA9IG51bGxcblxuICAgIHRoaXMudGZTdGF0aWNTdWIgPSBudWxsXG5cbiAgfVxuXG5cbiAgYXN5bmMgc2V0dXAoKXtcbiAgICBjb25zdCBbdGZUeXBlLCB0ZlN0YXRpY1R5cGVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgZ2V0VG9waWNUeXBlKHRoaXMucm9zLCAnL3RmJyksXG4gICAgICBnZXRUb3BpY1R5cGUodGhpcy5yb3MsICcvdGZfc3RhdGljJylcbiAgICBdKVxuXG4gICAgZGVidWcoJ3R5cGVzJywgdGZUeXBlLCB0ZlN0YXRpY1R5cGUpXG5cbiAgICB0aGlzLnRmU3ViID0gbmV3IFJPU0xJQi5Ub3BpYyh7XG4gICAgICByb3M6IHRoaXMucm9zLFxuICAgICAgbmFtZTogJy90ZicsXG4gICAgICBtZXNzYWdlVHlwZTogdGZUeXBlXG4gICAgfSlcblxuICAgIHRoaXMudGZTdGF0aWNTdWIgPSBuZXcgUk9TTElCLlRvcGljKHtcbiAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICBuYW1lOiAnL3RmX3N0YXRpYycsXG4gICAgICBtZXNzYWdlVHlwZTogdGZTdGF0aWNUeXBlXG4gICAgfSlcblxuICAgIHRoaXMubGlzdGVuRm9yRnJhbWVzKClcbiAgfVxuXG4gIGxpc3RlbkZvckZyYW1lcygpe1xuICAgIHRoaXMudGZTdWIuc3Vic2NyaWJlKHRoaXMuaGFuZGxlVGZNZXNzYWdlLmJpbmQodGhpcykpXG4gICAgdGhpcy50ZlN0YXRpY1N1Yi5zdWJzY3JpYmUodGhpcy5oYW5kbGVUZk1lc3NhZ2UuYmluZCh0aGlzKSlcbiAgICBzZXRUaW1lb3V0KHRoaXMuc3RvcExpc3RlbmluZ0ZvckZyYW1lcy5iaW5kKHRoaXMpLCAzMDAwKVxuICB9XG5cbiAgZnJhbWVFeGlzdHMoZnJhbWVfaWQpe1xuICAgIHJldHVybiB0aGlzLmZyYW1lc1tjbGVhblBhdGgoZnJhbWVfaWQpXSAhPT0gdW5kZWZpbmVkXG4gIH1cblxuICBtYXJrRnJhbWUoZnJhbWUsIHZhbHVlKXtcbiAgICBjb25zdCBmcmFtZV9pZCA9IGNsZWFuUGF0aChmcmFtZSlcbiAgICBpZighdGhpcy5mcmFtZUV4aXN0cyhmcmFtZV9pZCkpe1xuICAgICAgZGVidWcoJ2Rpc2NvdmVyZWQgZnJhbWUnLCBmcmFtZV9pZClcbiAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lX2lkXSA9IHZhbHVlXG4gICAgfVxuICB9XG4gIFxuXG4gIGhhbmRsZVRmTWVzc2FnZShtc2cpe1xuICAgIGZvcihsZXQgdHJhbnNmb3JtIG9mIG1zZy50cmFuc2Zvcm1zKXtcbiAgICAgIHRoaXMubWFya0ZyYW1lKHRyYW5zZm9ybS5jaGlsZF9mcmFtZV9pZCwgdHJ1ZSlcbiAgICAgIHRoaXMubWFya0ZyYW1lKHRyYW5zZm9ybS5oZWFkZXIuZnJhbWVfaWQsIHRydWUpXG4gICAgfVxuICB9XG5cblxuXG4gIHN0b3BMaXN0ZW5pbmdGb3JGcmFtZXMoKXtcbiAgICBkZWJ1Zygnc3RvcExpc3RlbmluZ0ZvckZyYW1lcyBkb25lJylcbiAgICB0aGlzLnRmU3ViLnVuc3Vic2NyaWJlKClcbiAgICB0aGlzLnRmU3RhdGljU3ViLnVuc3Vic2NyaWJlKClcblxuICAgIHRoaXMuc3Vic2NyaWJlKClcbiAgfVxuXG4gIC8vISBTdWJzY3JpYmUgdG8gbmVlZGVkIFRmIGZyYW1lc1xuICBzdWJzY3JpYmUoKXtcblxuICAgIGZvcihjb25zdCBbZnJhbWUsIGVuYWJsZWRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZnJhbWVzKSl7XG5cbiAgICAgIGlmKGVuYWJsZWQpe1xuICAgICAgICBkZWJ1Zygnc3Vic2NyaWJpbmcgdG8gZnJhbWUnLCBmcmFtZSlcbiAgICAgICAgbGV0IGF4aXMgPSBuZXcgUk9TM0QuQXhlcyh7XG4gICAgICAgICAgbGluZVR5cGU6ICdmdWxsJyxcbiAgICAgICAgICBzaGFmdFJhZGl1czogMC4wNCxcbiAgICAgICAgICBzY2FsZTogdGhpcy5heGlzU2NhbGUvNS4wLFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuc2NlbmVOb2Rlc1tmcmFtZV0gPSBuZXcgUk9TM0QuU2NlbmVOb2RlKHtcbiAgICAgICAgICBmcmFtZUlEOiBmcmFtZSxcbiAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICBvYmplY3Q6IGF4aXNcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnJvb3RPYmplY3QuYWRkKHRoaXMuc2NlbmVOb2Rlc1tmcmFtZV0pXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVidWcoJ2lnbm9yaW5nIGZyYW1lJywgZnJhbWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHM9VGZUcmVlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/TfTree.js\n")},"./src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('teleopxyz.TeleOp')\nconst reach = __webpack_require__(/*! ./reach */ \"./src/reach.js\")\nconst yaml = __webpack_require__(/*! yaml */ \"./node_modules/yaml/browser/index.js\")\nconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\n\nconst Pkg = __webpack_require__(/*! ../package.json */ \"./package.json\")\n\nconst { GamepadListener } = __webpack_require__(/*! gamepad.js */ \"./node_modules/gamepad.js/gamepad.js\")\n\n\nconsole.log(Pkg.name, 'v'+Pkg.version, '')\nconsole.log('sense, plan, party ')\nconsole.log('\\n\\nWelcome fellow humans\\n\\nset localStorage.debug=\\'*\\' to activate debug output')\n\nfunction hasGamepadSupport(){\n  return navigator.getGamepads !== undefined\n}\n\nconst TfTree = __webpack_require__(/*! ./TfTree */ \"./src/TfTree.js\")\n\nclass TeleOp {\n  constructor(){\n    debug('new TeleOp')\n\n    this.ros = null\n    this.host = null\n    this.fileContent = null\n    this.divId = null\n    this.viewer = null\n    this.tfClient = null\n    this.baseLink = null\n    this.gamepadListener = null\n\n    this.joyMsg = null\n    this.joyIndex = null\n    this.joyPub = null\n    this.joyEnabled = false\n    this.joyUserOptIn = null\n    this.joyAutoRepeatRate = 4\n    this.joyRepeatTimer = null\n  }\n\n  static get version(){\n    return Pkg.version\n  }\n\n  async connectRos(){\n    return new Promise((resolve,reject)=>{\n\n      // Connect to ROS.\n      this.ros = new ROSLIB.Ros({\n        url : this.host\n      });\n\n      this.ros.once('error', (error) => {\n        debug('Connection error ' + this.host)\n        debug(error)\n        reject(error)\n      });\n      // Find out exactly when we made a connection.\n      this.ros.once('connection', () => {\n        debug('Connection open ' + this.host)\n        resolve()\n      })\n    })\n  }\n\n  onResize(event) {\n    debug('resize', event)\n    const width = this.div.clientWidth\n    const height = this.div.clientHeight\n    debug('size', width, height)\n    this.viewer.resize(width, height)\n  }\n\n  async start(host, rvizFile, divId=\"viewer\"){\n    debug('start')\n\n    this.host = host\n    this.divId = divId\n    this.fileContent = yaml.parse(rvizFile)\n\n    this.div = document.getElementById(this.divId)\n\n    debug('fileContent', this.fileContent)\n\n    await this.connectRos()\n\n    let globalOptions = {\n      background: TeleOp.rvizColor2hex(reach(this.fileContent, 'Visualization Manager.Global Options.Background Color'), null),\n      fixedFrame: reach(this.fileContent, 'Visualization Manager.Global Options.Fixed Frame', '/base_link'),\n      frameRate: reach(this.fileContent, 'Visualization Manager.Global Options.Frame Rate', 30)\n    }\n\n    this.viewer = new ROS3D.Viewer({\n      divID: this.divId,\n      width: this.div.clientWidth,\n      height: this.div.clientHeight,\n      antialias: true,\n      background: globalOptions.background\n    });\n\n    window.onresize = (e)=>{this.onResize(e)}\n\n    /*this.viewer.addObject(new ROS3D.Grid({\n      color:'#0181c4',\n      cellSize: 1.0,\n      num_cells: 20\n    }));*/\n\n\n    console.log('Globals', { globalOptions })\n\n\n\n    this.tfClient = new ROSLIB.TFClient({\n      ros: this.ros,\n      serverName: `/tf2_web_republisher`,   //! Need to make configurable and autodetect correct one on the fly\n      angularThres: 0.03,\n      transThres: 0.01,\n      //rate: globalOptions.frameRate,\n      fixedFrame: globalOptions.fixedFrame\n    })\n\n    if(hasGamepadSupport()){\n      debug('enabling gamepad support')\n      this.gamepadListener = new GamepadListener({analog: true/*, deadZone: 0.2*/})\n      this.gamepadListener.on('gamepad:connected', this.addGamepad.bind(this))\n      this.gamepadListener.on('gamepad:disconnected', this.removeGamepad.bind(this))\n      this.gamepadListener.on('gamepad:axis', this.onAxisChange.bind(this))\n      this.gamepadListener.on('gamepad:button', this.onAxisChange.bind(this))\n  \n      this.gamepadListener.start() \n    }\n\n    await this.renderFromFile()\n  }\n\n  addGamepad(event){\n    debug('addGamepad', event)\n    const gamepad = reach(event, 'detail.gamepad')\n\n    if(this.joyUserOptIn == null){\n      debug('prompting user for gamepad/joy support opt-in')\n      this.joyUserOptIn = window.confirm('Gamepad detected - would you like to use it as a /joy publisher?\\n\\n'+gamepad.id)\n      this.joyEnabled = this.joyUserOptIn\n\n      debug('joyUserOptIn =', this.joyUserOptIn)\n    }\n\n    if(this.joyUserOptIn == false){ return }\n\n    this.joyEnabled = true\n\n    if(this.joyPub == null){\n      this.joyIndex = reach(event, 'detail.index')\n      \n      debug('advertising /joy idx=',this.joyIndex)\n      this.joyPub = new ROSLIB.Topic({\n        ros : this.ros,\n        name : '/joy',\n        messageType : 'sensor_msgs/Joy'\n      })\n  \n      this.joyPub.advertise()\n\n      this.updateJoy(gamepad)\n\n    }\n  }\n\n  removeGamepad(event){\n    debug('removeGamepad', event)\n\n    //! cleanup timer\n    if(this.joyRepeatTimer != null){\n      clearTimeout(this.joyRepeatTimer)\n      this.joyRepeatTimer = null\n    }\n\n    //! cleanup publisher\n    if(this.joyPub != null && event.detail.index == this.joyIndex){\n      this.joyPub.unadvertise()\n    }\n\n\n    this.joyPub = null\n    this.joyIndex = null\n    //this.joyUserOptIn = null\n    this.joyEnabled = false\n  }\n\n  getJoyMsgFromGamepad(gamepad){\n    return new ROSLIB.Message({\n      axes: [...gamepad.axes],\n      buttons: gamepad.buttons.map( btn => parseInt(btn.value) )\n    })\n  }\n\n  autoUpdateJoy(){\n    if(this.joyMsg!=null && this.joyEnabled == true){\n      this.joyPub.publish(this.joyMsg)\n\n      this.joyRepeatTimer = null\n      this.debounceJoyAutoUpdate()\n    }\n  }\n\n  debounceJoyAutoUpdate(){\n    if(this.joyAutoRepeatRate > 0.0){\n      let repeatMs = 1000.0 / this.joyAutoRepeatRate\n      if(this.joyRepeatTimer != null){\n        clearTimeout(this.joyRepeatTimer)\n      }\n\n      //! set timer further into the future\n      this.joyRepeatTimer = setTimeout(this.autoUpdateJoy.bind(this), repeatMs)\n\n    }\n  }\n\n  updateJoy(gamepad){\n\n    if(!this.joyEnabled){return}\n\n    this.joyMsg = this.getJoyMsgFromGamepad(gamepad)\n\n    this.joyPub.publish(this.joyMsg)\n    this.debounceJoyAutoUpdate()\n  }\n\n  onAxisChange(event){\n    if(this.joyIndex != reach(event,'detail.index')){ return }\n\n    const gamepad = reach(event, 'detail.gamepad')\n    this.updateJoy(gamepad)\n  }\n\n  onButtonChange(event){\n    if(this.joyIndex != reach(event,'detail.index')){ return }\n\n    const gamepad = reach(event, 'detail.gamepad')\n    this.updateJoy(gamepad)\n  }\n\n  async renderFromFile(){\n\n    let displays = reach(this.fileContent, 'Visualization Manager.Displays', [])\n\n    for(let display of displays){\n      //debug(`parsing display '${display.Class}'`, { display })\n\n      if(!display.Enabled){\n        debug(`skipping ${display.Class}`)\n        continue\n      }\n\n      let obj = undefined;\n      switch (display.Class) {\n        case 'rviz/Grid':\n          debug('display.color', display.Color)\n          obj=new ROS3D.Grid({\n            color: TeleOp.rvizColor2hex(display.Color, '#ff1010'),\n            cellSize: display['Cell Size'],\n            num_cells: display['Plane Cell Count']\n          })\n          this.viewer.addObject(obj)\n          break\n        case 'rviz/TF':\n          debug(display.Class, display.Name)\n          const allEnabled = display.Frames['All Enabled'] || false\n\n          const frames = Object.fromEntries(\n            Object.entries(display.Frames)\n            .map(([key,value])=> {\n              return [key, allEnabled || value.Value && true]\n            })\n            .filter(([key, value]) => key != 'All Enabled')\n          )\n          \n          debug('\\t','frames', frames)\n          obj = new TfTree({\n            frames,\n            ros: this.ros,\n            tfClient: this.tfClient,\n            rootObject: this.viewer.scene,\n            scale: parseFloat(display['Marker Scale']),\n            showAxes: display['Show Axes'],\n            showNames: display['Show Names'],\n            showArrows: display['Show Arrows']\n          })\n\n          await obj.setup()\n          break;\n        case 'rviz/LaserScan':\n          debug(display.Class, display.Topic)\n\n          obj = new ROS3D.LaserScan({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            tfClient: this.tfClient,\n            color: display.color, // need to check if this is in the right format\n            // texture: , // (optional) Image url for a texture to use for the points. Defaults to a single white pixel.\n            rootObject: this.viewer.scene,\n            material: {\n              size: display['Size (Pixels)'], // (optional) defaults to 0.05\n            },\n            max_pts: 50000 // (optional) defaults to 100\n          })\n          break\n        case 'rviz/PointCloud2':\n          debug(display.Class, display.Topic)\n          obj = new ROS3D.PointCloud2({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            max_pts: 50000,\n            //colorsrc: display[\"Color Transformer\"],\n            material: { \n              size: 0.02\n            }\n          })\n\n          //debug('\\t','pt', display[\"Color Transformer\"])\n          break\n        case 'rviz/Marker':\n          debug(display.Class, display['Marker Topic'])\n          obj = new ROS3D.MarkerClient({\n            ros: this.ros,\n            topic: `${display['Marker Topic']}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient\n          })\n          break\n        case 'rviz/MarkerArray':\n          debug(display.Class, display['Marker Topic'])\n          obj = new ROS3D.MarkerArrayClient({\n            ros: this.ros,\n            topic: `${display['Marker Topic']}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient\n          })\n          break\n        case 'rviz/Map':\n          debug(display.Class, display.Topic)\n          obj = new ROS3D.OccupancyGridClient({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            continuous: true\n          })\n          break\n        case 'rviz/Odometry':\n          debug(display.Class, display.Topic)\n          obj = new ROS3D.Odometry({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            keep: display.Keep,\n            length: reach(display, 'Shape.Axes Length'),\n            headlength: reach(display, 'Shape.Head Length'),\n            shaftLength: reach(display, 'Shape.Shaft Length'),\n            headDiameter: reach(display, 'Shape.Head Radius')*2.0,\n            shaftDiameter: reach(display, 'Shape.Shaft Radius')*2.0,\n            color: TeleOp.rvizColor2hex(reach(display,'Shape.Color'), '#cc00ff')\n          })\n          break\n        case 'rviz/Path':\n          debug(display.Class)\n          obj = new ROS3D.Path({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            color: TeleOp.rvizColor2hex(display.Color, '#cc00ff')\n          })\n          break\n        case 'rviz/RobotModel':\n          debug(display.Class)\n          //console.log(display)\n\n          let paramPath = path.join('/', display['Robot Description'])\n\n          //console.log(paramPath)\n\n          const urdfText = await new Promise((resolve,reject)=>{\n            let descParam = new ROSLIB.Param({\n              ros: this.ros, name: paramPath\n            })\n\n            descParam.get(val=>{ resolve(val) })\n          })\n\n          debug('\\t','urdf', urdfText)\n\n          let publicModelPath = ''\n          if(urdfText != null && urdfText.length > 0){\n            /*let parser = new DOMParser()\n            let xmlDoc = parser.parseFromString(urdfText, 'text/xml')\n\n            const robotTag = xmlDoc.getElementsByTagName('robot')[0]\n            const robotName = robotTag.getAttribute('name')\n            debug('\\t','urdf robot name', robotName, robotName.indexOf('magni'))\n            if(robotName.indexOf('magni') != -1){\n              publicModelPath = 'https://raw.githubusercontent.com/UbiquityRobotics/magni_robot/noetic-devel'\n            }*/\n\n            try{\n              obj = new ROS3D.UrdfClient({\n                path: '/packages/',\n                ros: this.ros,\n                param: paramPath,\n                rootObject: this.viewer.scene,\n                tfClient: this.tfClient,\n                tfPrefix: display['TF Prefix']\n              })\n            }\n            catch(err){\n              debug('\\t','urdf error', err)\n              //delete obj\n              obj = null\n            }\n            \n  \n            debug('\\t',obj)\n          }\n          \n          break\n        case 'rviz/InteractiveMarkers':\n          debug(display.Class, display['Update Topic'])\n\n          const topic = display['Update Topic'].replace('/update','')\n\n          debug('\\t', 'topic', topic)\n\n          obj = new ROS3D.InteractiveMarkerClient({\n            topic,\n            ros: this.ros,\n            tfClient: this.tfClient,\n            camera: this.viewer.camera,\n            rootObject: this.viewer.selectableObjects,\n          })\n\n          break;\n        case 'rviz/PointStamped':\n          debug(display.Class, display['Topic'])\n\n          obj = new ROS3D.Point({\n            ros: this.ros,\n            tfClient: this.tfClient,\n            topic: display['Topic'],\n            color: TeleOp.rvizColor2hex(display['Color']),\n            radius: display['Radius']\n          })\n          break;\n        case 'rviz/Polygon':\n          debug(display.Class, display['Topic'])\n\n          obj = new ROS3D.Polygon({\n            ros: this.ros,\n            tfClient: this.tfClient,\n            topic: display['Topic'],\n            color: TeleOp.rvizColor2hex(display['Color'])\n          })\n\n          break;\n        case 'rviz/Pose':\n        case 'rviz/PoseArray':\n        case 'rviz/PoseWithCovariance':\n          debug(display.Class, display['Topic'])\n          const type = display.Class.replace('rviz/', '')\n          const Class = ROS3D[type]\n\n          obj = new Class({\n            ros: this.ros,\n            tfClient: this.tfClient,\n            topic: display['Topic'],\n            color: TeleOp.rvizColor2hex(display['Color']),\n            length: reach(display, 'Axes Length'),\n            headlength: reach(display, 'Head Length'),\n            shaftLength: reach(display, 'Shaft Length'),\n            headDiameter: reach(display, 'Head Radius')*2.0,\n            shaftDiameter: reach(display, 'Shaft Radius')*2.0\n          })\n\n          break;\n        default:\n          console.warn(`display class '${display.Class}' not supported`)\n          console.warn(display)\n          break\n      }\n\n      if (obj) {\n        debug(obj)\n      }\n    }\n\n  }\n\n\n\n  disableViz() {\n    /** @todo */\n    debug('disable viz - not implemented')\n  }\n\n\n  static rvizColor2hex(color, defaultHex) {\n    if (!color) { return defaultHex }\n    return TeleOp.rgb2hex(color.replace(/;/g, ','))\n  }\n  \n  static rgb2hex(rgb) {\n    rgb = rgb.match(/[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n    return (rgb && rgb.length === 4) ? \"#\" +\n      (\"0\" + parseInt(rgb[1], 10).toString(16)).slice(-2) +\n      (\"0\" + parseInt(rgb[2], 10).toString(16)).slice(-2) +\n      (\"0\" + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';\n  }\n}\n\nmodule.exports=TeleOp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esa0JBQWtCO0FBQ2xCLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcC14eXovLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3RlbGVvcHh5ei5UZWxlT3AnKVxuY29uc3QgcmVhY2ggPSByZXF1aXJlKCcuL3JlYWNoJylcbmNvbnN0IHlhbWwgPSByZXF1aXJlKCd5YW1sJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuY29uc3QgUGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJylcblxuY29uc3QgeyBHYW1lcGFkTGlzdGVuZXIgfSA9IHJlcXVpcmUoJ2dhbWVwYWQuanMnKVxuXG5cbmNvbnNvbGUubG9nKFBrZy5uYW1lLCAndicrUGtnLnZlcnNpb24sICfwn6SWJylcbmNvbnNvbGUubG9nKCdzZW5zZSwgcGxhbiwgcGFydHkg8J+kmCcpXG5jb25zb2xlLmxvZygnXFxuXFxuV2VsY29tZSBmZWxsb3cgaHVtYW5zXFxuXFxuc2V0IGxvY2FsU3RvcmFnZS5kZWJ1Zz1cXCcqXFwnIHRvIGFjdGl2YXRlIGRlYnVnIG91dHB1dCcpXG5cbmZ1bmN0aW9uIGhhc0dhbWVwYWRTdXBwb3J0KCl7XG4gIHJldHVybiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMgIT09IHVuZGVmaW5lZFxufVxuXG5jb25zdCBUZlRyZWUgPSByZXF1aXJlKCcuL1RmVHJlZScpXG5cbmNsYXNzIFRlbGVPcCB7XG4gIGNvbnN0cnVjdG9yKCl7XG4gICAgZGVidWcoJ25ldyBUZWxlT3AnKVxuXG4gICAgdGhpcy5yb3MgPSBudWxsXG4gICAgdGhpcy5ob3N0ID0gbnVsbFxuICAgIHRoaXMuZmlsZUNvbnRlbnQgPSBudWxsXG4gICAgdGhpcy5kaXZJZCA9IG51bGxcbiAgICB0aGlzLnZpZXdlciA9IG51bGxcbiAgICB0aGlzLnRmQ2xpZW50ID0gbnVsbFxuICAgIHRoaXMuYmFzZUxpbmsgPSBudWxsXG4gICAgdGhpcy5nYW1lcGFkTGlzdGVuZXIgPSBudWxsXG5cbiAgICB0aGlzLmpveU1zZyA9IG51bGxcbiAgICB0aGlzLmpveUluZGV4ID0gbnVsbFxuICAgIHRoaXMuam95UHViID0gbnVsbFxuICAgIHRoaXMuam95RW5hYmxlZCA9IGZhbHNlXG4gICAgdGhpcy5qb3lVc2VyT3B0SW4gPSBudWxsXG4gICAgdGhpcy5qb3lBdXRvUmVwZWF0UmF0ZSA9IDRcbiAgICB0aGlzLmpveVJlcGVhdFRpbWVyID0gbnVsbFxuICB9XG5cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCl7XG4gICAgcmV0dXJuIFBrZy52ZXJzaW9uXG4gIH1cblxuICBhc3luYyBjb25uZWN0Um9zKCl7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntcblxuICAgICAgLy8gQ29ubmVjdCB0byBST1MuXG4gICAgICB0aGlzLnJvcyA9IG5ldyBST1NMSUIuUm9zKHtcbiAgICAgICAgdXJsIDogdGhpcy5ob3N0XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5yb3Mub25jZSgnZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgZGVidWcoJ0Nvbm5lY3Rpb24gZXJyb3IgJyArIHRoaXMuaG9zdClcbiAgICAgICAgZGVidWcoZXJyb3IpXG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0pO1xuICAgICAgLy8gRmluZCBvdXQgZXhhY3RseSB3aGVuIHdlIG1hZGUgYSBjb25uZWN0aW9uLlxuICAgICAgdGhpcy5yb3Mub25jZSgnY29ubmVjdGlvbicsICgpID0+IHtcbiAgICAgICAgZGVidWcoJ0Nvbm5lY3Rpb24gb3BlbiAnICsgdGhpcy5ob3N0KVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIG9uUmVzaXplKGV2ZW50KSB7XG4gICAgZGVidWcoJ3Jlc2l6ZScsIGV2ZW50KVxuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5kaXYuY2xpZW50V2lkdGhcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmRpdi5jbGllbnRIZWlnaHRcbiAgICBkZWJ1Zygnc2l6ZScsIHdpZHRoLCBoZWlnaHQpXG4gICAgdGhpcy52aWV3ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gIH1cblxuICBhc3luYyBzdGFydChob3N0LCBydml6RmlsZSwgZGl2SWQ9XCJ2aWV3ZXJcIil7XG4gICAgZGVidWcoJ3N0YXJ0JylcblxuICAgIHRoaXMuaG9zdCA9IGhvc3RcbiAgICB0aGlzLmRpdklkID0gZGl2SWRcbiAgICB0aGlzLmZpbGVDb250ZW50ID0geWFtbC5wYXJzZShydml6RmlsZSlcblxuICAgIHRoaXMuZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5kaXZJZClcblxuICAgIGRlYnVnKCdmaWxlQ29udGVudCcsIHRoaXMuZmlsZUNvbnRlbnQpXG5cbiAgICBhd2FpdCB0aGlzLmNvbm5lY3RSb3MoKVxuXG4gICAgbGV0IGdsb2JhbE9wdGlvbnMgPSB7XG4gICAgICBiYWNrZ3JvdW5kOiBUZWxlT3AucnZpekNvbG9yMmhleChyZWFjaCh0aGlzLmZpbGVDb250ZW50LCAnVmlzdWFsaXphdGlvbiBNYW5hZ2VyLkdsb2JhbCBPcHRpb25zLkJhY2tncm91bmQgQ29sb3InKSwgbnVsbCksXG4gICAgICBmaXhlZEZyYW1lOiByZWFjaCh0aGlzLmZpbGVDb250ZW50LCAnVmlzdWFsaXphdGlvbiBNYW5hZ2VyLkdsb2JhbCBPcHRpb25zLkZpeGVkIEZyYW1lJywgJy9iYXNlX2xpbmsnKSxcbiAgICAgIGZyYW1lUmF0ZTogcmVhY2godGhpcy5maWxlQ29udGVudCwgJ1Zpc3VhbGl6YXRpb24gTWFuYWdlci5HbG9iYWwgT3B0aW9ucy5GcmFtZSBSYXRlJywgMzApXG4gICAgfVxuXG4gICAgdGhpcy52aWV3ZXIgPSBuZXcgUk9TM0QuVmlld2VyKHtcbiAgICAgIGRpdklEOiB0aGlzLmRpdklkLFxuICAgICAgd2lkdGg6IHRoaXMuZGl2LmNsaWVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmRpdi5jbGllbnRIZWlnaHQsXG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICBiYWNrZ3JvdW5kOiBnbG9iYWxPcHRpb25zLmJhY2tncm91bmRcbiAgICB9KTtcblxuICAgIHdpbmRvdy5vbnJlc2l6ZSA9IChlKT0+e3RoaXMub25SZXNpemUoZSl9XG5cbiAgICAvKnRoaXMudmlld2VyLmFkZE9iamVjdChuZXcgUk9TM0QuR3JpZCh7XG4gICAgICBjb2xvcjonIzAxODFjNCcsXG4gICAgICBjZWxsU2l6ZTogMS4wLFxuICAgICAgbnVtX2NlbGxzOiAyMFxuICAgIH0pKTsqL1xuXG5cbiAgICBjb25zb2xlLmxvZygnR2xvYmFscycsIHsgZ2xvYmFsT3B0aW9ucyB9KVxuXG5cblxuICAgIHRoaXMudGZDbGllbnQgPSBuZXcgUk9TTElCLlRGQ2xpZW50KHtcbiAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICBzZXJ2ZXJOYW1lOiBgL3RmMl93ZWJfcmVwdWJsaXNoZXJgLCAgIC8vISBOZWVkIHRvIG1ha2UgY29uZmlndXJhYmxlIGFuZCBhdXRvZGV0ZWN0IGNvcnJlY3Qgb25lIG9uIHRoZSBmbHlcbiAgICAgIGFuZ3VsYXJUaHJlczogMC4wMyxcbiAgICAgIHRyYW5zVGhyZXM6IDAuMDEsXG4gICAgICAvL3JhdGU6IGdsb2JhbE9wdGlvbnMuZnJhbWVSYXRlLFxuICAgICAgZml4ZWRGcmFtZTogZ2xvYmFsT3B0aW9ucy5maXhlZEZyYW1lXG4gICAgfSlcblxuICAgIGlmKGhhc0dhbWVwYWRTdXBwb3J0KCkpe1xuICAgICAgZGVidWcoJ2VuYWJsaW5nIGdhbWVwYWQgc3VwcG9ydCcpXG4gICAgICB0aGlzLmdhbWVwYWRMaXN0ZW5lciA9IG5ldyBHYW1lcGFkTGlzdGVuZXIoe2FuYWxvZzogdHJ1ZS8qLCBkZWFkWm9uZTogMC4yKi99KVxuICAgICAgdGhpcy5nYW1lcGFkTGlzdGVuZXIub24oJ2dhbWVwYWQ6Y29ubmVjdGVkJywgdGhpcy5hZGRHYW1lcGFkLmJpbmQodGhpcykpXG4gICAgICB0aGlzLmdhbWVwYWRMaXN0ZW5lci5vbignZ2FtZXBhZDpkaXNjb25uZWN0ZWQnLCB0aGlzLnJlbW92ZUdhbWVwYWQuYmluZCh0aGlzKSlcbiAgICAgIHRoaXMuZ2FtZXBhZExpc3RlbmVyLm9uKCdnYW1lcGFkOmF4aXMnLCB0aGlzLm9uQXhpc0NoYW5nZS5iaW5kKHRoaXMpKVxuICAgICAgdGhpcy5nYW1lcGFkTGlzdGVuZXIub24oJ2dhbWVwYWQ6YnV0dG9uJywgdGhpcy5vbkF4aXNDaGFuZ2UuYmluZCh0aGlzKSlcbiAgXG4gICAgICB0aGlzLmdhbWVwYWRMaXN0ZW5lci5zdGFydCgpIFxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucmVuZGVyRnJvbUZpbGUoKVxuICB9XG5cbiAgYWRkR2FtZXBhZChldmVudCl7XG4gICAgZGVidWcoJ2FkZEdhbWVwYWQnLCBldmVudClcbiAgICBjb25zdCBnYW1lcGFkID0gcmVhY2goZXZlbnQsICdkZXRhaWwuZ2FtZXBhZCcpXG5cbiAgICBpZih0aGlzLmpveVVzZXJPcHRJbiA9PSBudWxsKXtcbiAgICAgIGRlYnVnKCdwcm9tcHRpbmcgdXNlciBmb3IgZ2FtZXBhZC9qb3kgc3VwcG9ydCBvcHQtaW4nKVxuICAgICAgdGhpcy5qb3lVc2VyT3B0SW4gPSB3aW5kb3cuY29uZmlybSgnR2FtZXBhZCBkZXRlY3RlZCAtIHdvdWxkIHlvdSBsaWtlIHRvIHVzZSBpdCBhcyBhIC9qb3kgcHVibGlzaGVyP1xcblxcbicrZ2FtZXBhZC5pZClcbiAgICAgIHRoaXMuam95RW5hYmxlZCA9IHRoaXMuam95VXNlck9wdEluXG5cbiAgICAgIGRlYnVnKCdqb3lVc2VyT3B0SW4gPScsIHRoaXMuam95VXNlck9wdEluKVxuICAgIH1cblxuICAgIGlmKHRoaXMuam95VXNlck9wdEluID09IGZhbHNlKXsgcmV0dXJuIH1cblxuICAgIHRoaXMuam95RW5hYmxlZCA9IHRydWVcblxuICAgIGlmKHRoaXMuam95UHViID09IG51bGwpe1xuICAgICAgdGhpcy5qb3lJbmRleCA9IHJlYWNoKGV2ZW50LCAnZGV0YWlsLmluZGV4JylcbiAgICAgIFxuICAgICAgZGVidWcoJ2FkdmVydGlzaW5nIC9qb3kgaWR4PScsdGhpcy5qb3lJbmRleClcbiAgICAgIHRoaXMuam95UHViID0gbmV3IFJPU0xJQi5Ub3BpYyh7XG4gICAgICAgIHJvcyA6IHRoaXMucm9zLFxuICAgICAgICBuYW1lIDogJy9qb3knLFxuICAgICAgICBtZXNzYWdlVHlwZSA6ICdzZW5zb3JfbXNncy9Kb3knXG4gICAgICB9KVxuICBcbiAgICAgIHRoaXMuam95UHViLmFkdmVydGlzZSgpXG5cbiAgICAgIHRoaXMudXBkYXRlSm95KGdhbWVwYWQpXG5cbiAgICB9XG4gIH1cblxuICByZW1vdmVHYW1lcGFkKGV2ZW50KXtcbiAgICBkZWJ1ZygncmVtb3ZlR2FtZXBhZCcsIGV2ZW50KVxuXG4gICAgLy8hIGNsZWFudXAgdGltZXJcbiAgICBpZih0aGlzLmpveVJlcGVhdFRpbWVyICE9IG51bGwpe1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuam95UmVwZWF0VGltZXIpXG4gICAgICB0aGlzLmpveVJlcGVhdFRpbWVyID0gbnVsbFxuICAgIH1cblxuICAgIC8vISBjbGVhbnVwIHB1Ymxpc2hlclxuICAgIGlmKHRoaXMuam95UHViICE9IG51bGwgJiYgZXZlbnQuZGV0YWlsLmluZGV4ID09IHRoaXMuam95SW5kZXgpe1xuICAgICAgdGhpcy5qb3lQdWIudW5hZHZlcnRpc2UoKVxuICAgIH1cblxuXG4gICAgdGhpcy5qb3lQdWIgPSBudWxsXG4gICAgdGhpcy5qb3lJbmRleCA9IG51bGxcbiAgICAvL3RoaXMuam95VXNlck9wdEluID0gbnVsbFxuICAgIHRoaXMuam95RW5hYmxlZCA9IGZhbHNlXG4gIH1cblxuICBnZXRKb3lNc2dGcm9tR2FtZXBhZChnYW1lcGFkKXtcbiAgICByZXR1cm4gbmV3IFJPU0xJQi5NZXNzYWdlKHtcbiAgICAgIGF4ZXM6IFsuLi5nYW1lcGFkLmF4ZXNdLFxuICAgICAgYnV0dG9uczogZ2FtZXBhZC5idXR0b25zLm1hcCggYnRuID0+IHBhcnNlSW50KGJ0bi52YWx1ZSkgKVxuICAgIH0pXG4gIH1cblxuICBhdXRvVXBkYXRlSm95KCl7XG4gICAgaWYodGhpcy5qb3lNc2chPW51bGwgJiYgdGhpcy5qb3lFbmFibGVkID09IHRydWUpe1xuICAgICAgdGhpcy5qb3lQdWIucHVibGlzaCh0aGlzLmpveU1zZylcblxuICAgICAgdGhpcy5qb3lSZXBlYXRUaW1lciA9IG51bGxcbiAgICAgIHRoaXMuZGVib3VuY2VKb3lBdXRvVXBkYXRlKClcbiAgICB9XG4gIH1cblxuICBkZWJvdW5jZUpveUF1dG9VcGRhdGUoKXtcbiAgICBpZih0aGlzLmpveUF1dG9SZXBlYXRSYXRlID4gMC4wKXtcbiAgICAgIGxldCByZXBlYXRNcyA9IDEwMDAuMCAvIHRoaXMuam95QXV0b1JlcGVhdFJhdGVcbiAgICAgIGlmKHRoaXMuam95UmVwZWF0VGltZXIgIT0gbnVsbCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmpveVJlcGVhdFRpbWVyKVxuICAgICAgfVxuXG4gICAgICAvLyEgc2V0IHRpbWVyIGZ1cnRoZXIgaW50byB0aGUgZnV0dXJlXG4gICAgICB0aGlzLmpveVJlcGVhdFRpbWVyID0gc2V0VGltZW91dCh0aGlzLmF1dG9VcGRhdGVKb3kuYmluZCh0aGlzKSwgcmVwZWF0TXMpXG5cbiAgICB9XG4gIH1cblxuICB1cGRhdGVKb3koZ2FtZXBhZCl7XG5cbiAgICBpZighdGhpcy5qb3lFbmFibGVkKXtyZXR1cm59XG5cbiAgICB0aGlzLmpveU1zZyA9IHRoaXMuZ2V0Sm95TXNnRnJvbUdhbWVwYWQoZ2FtZXBhZClcblxuICAgIHRoaXMuam95UHViLnB1Ymxpc2godGhpcy5qb3lNc2cpXG4gICAgdGhpcy5kZWJvdW5jZUpveUF1dG9VcGRhdGUoKVxuICB9XG5cbiAgb25BeGlzQ2hhbmdlKGV2ZW50KXtcbiAgICBpZih0aGlzLmpveUluZGV4ICE9IHJlYWNoKGV2ZW50LCdkZXRhaWwuaW5kZXgnKSl7IHJldHVybiB9XG5cbiAgICBjb25zdCBnYW1lcGFkID0gcmVhY2goZXZlbnQsICdkZXRhaWwuZ2FtZXBhZCcpXG4gICAgdGhpcy51cGRhdGVKb3koZ2FtZXBhZClcbiAgfVxuXG4gIG9uQnV0dG9uQ2hhbmdlKGV2ZW50KXtcbiAgICBpZih0aGlzLmpveUluZGV4ICE9IHJlYWNoKGV2ZW50LCdkZXRhaWwuaW5kZXgnKSl7IHJldHVybiB9XG5cbiAgICBjb25zdCBnYW1lcGFkID0gcmVhY2goZXZlbnQsICdkZXRhaWwuZ2FtZXBhZCcpXG4gICAgdGhpcy51cGRhdGVKb3koZ2FtZXBhZClcbiAgfVxuXG4gIGFzeW5jIHJlbmRlckZyb21GaWxlKCl7XG5cbiAgICBsZXQgZGlzcGxheXMgPSByZWFjaCh0aGlzLmZpbGVDb250ZW50LCAnVmlzdWFsaXphdGlvbiBNYW5hZ2VyLkRpc3BsYXlzJywgW10pXG5cbiAgICBmb3IobGV0IGRpc3BsYXkgb2YgZGlzcGxheXMpe1xuICAgICAgLy9kZWJ1ZyhgcGFyc2luZyBkaXNwbGF5ICcke2Rpc3BsYXkuQ2xhc3N9J2AsIHsgZGlzcGxheSB9KVxuXG4gICAgICBpZighZGlzcGxheS5FbmFibGVkKXtcbiAgICAgICAgZGVidWcoYHNraXBwaW5nICR7ZGlzcGxheS5DbGFzc31gKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBsZXQgb2JqID0gdW5kZWZpbmVkO1xuICAgICAgc3dpdGNoIChkaXNwbGF5LkNsYXNzKSB7XG4gICAgICAgIGNhc2UgJ3J2aXovR3JpZCc6XG4gICAgICAgICAgZGVidWcoJ2Rpc3BsYXkuY29sb3InLCBkaXNwbGF5LkNvbG9yKVxuICAgICAgICAgIG9iaj1uZXcgUk9TM0QuR3JpZCh7XG4gICAgICAgICAgICBjb2xvcjogVGVsZU9wLnJ2aXpDb2xvcjJoZXgoZGlzcGxheS5Db2xvciwgJyNmZjEwMTAnKSxcbiAgICAgICAgICAgIGNlbGxTaXplOiBkaXNwbGF5WydDZWxsIFNpemUnXSxcbiAgICAgICAgICAgIG51bV9jZWxsczogZGlzcGxheVsnUGxhbmUgQ2VsbCBDb3VudCddXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLnZpZXdlci5hZGRPYmplY3Qob2JqKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3J2aXovVEYnOlxuICAgICAgICAgIGRlYnVnKGRpc3BsYXkuQ2xhc3MsIGRpc3BsYXkuTmFtZSlcbiAgICAgICAgICBjb25zdCBhbGxFbmFibGVkID0gZGlzcGxheS5GcmFtZXNbJ0FsbCBFbmFibGVkJ10gfHwgZmFsc2VcblxuICAgICAgICAgIGNvbnN0IGZyYW1lcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRpc3BsYXkuRnJhbWVzKVxuICAgICAgICAgICAgLm1hcCgoW2tleSx2YWx1ZV0pPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gW2tleSwgYWxsRW5hYmxlZCB8fCB2YWx1ZS5WYWx1ZSAmJiB0cnVlXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ga2V5ICE9ICdBbGwgRW5hYmxlZCcpXG4gICAgICAgICAgKVxuICAgICAgICAgIFxuICAgICAgICAgIGRlYnVnKCdcXHQnLCdmcmFtZXMnLCBmcmFtZXMpXG4gICAgICAgICAgb2JqID0gbmV3IFRmVHJlZSh7XG4gICAgICAgICAgICBmcmFtZXMsXG4gICAgICAgICAgICByb3M6IHRoaXMucm9zLFxuICAgICAgICAgICAgdGZDbGllbnQ6IHRoaXMudGZDbGllbnQsXG4gICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zY2VuZSxcbiAgICAgICAgICAgIHNjYWxlOiBwYXJzZUZsb2F0KGRpc3BsYXlbJ01hcmtlciBTY2FsZSddKSxcbiAgICAgICAgICAgIHNob3dBeGVzOiBkaXNwbGF5WydTaG93IEF4ZXMnXSxcbiAgICAgICAgICAgIHNob3dOYW1lczogZGlzcGxheVsnU2hvdyBOYW1lcyddLFxuICAgICAgICAgICAgc2hvd0Fycm93czogZGlzcGxheVsnU2hvdyBBcnJvd3MnXVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBhd2FpdCBvYmouc2V0dXAoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdydml6L0xhc2VyU2Nhbic6XG4gICAgICAgICAgZGVidWcoZGlzcGxheS5DbGFzcywgZGlzcGxheS5Ub3BpYylcblxuICAgICAgICAgIG9iaiA9IG5ldyBST1MzRC5MYXNlclNjYW4oe1xuICAgICAgICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgICAgICAgIHRvcGljOiBgJHtkaXNwbGF5LlRvcGljfWAsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgIGNvbG9yOiBkaXNwbGF5LmNvbG9yLCAvLyBuZWVkIHRvIGNoZWNrIGlmIHRoaXMgaXMgaW4gdGhlIHJpZ2h0IGZvcm1hdFxuICAgICAgICAgICAgLy8gdGV4dHVyZTogLCAvLyAob3B0aW9uYWwpIEltYWdlIHVybCBmb3IgYSB0ZXh0dXJlIHRvIHVzZSBmb3IgdGhlIHBvaW50cy4gRGVmYXVsdHMgdG8gYSBzaW5nbGUgd2hpdGUgcGl4ZWwuXG4gICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zY2VuZSxcbiAgICAgICAgICAgIG1hdGVyaWFsOiB7XG4gICAgICAgICAgICAgIHNpemU6IGRpc3BsYXlbJ1NpemUgKFBpeGVscyknXSwgLy8gKG9wdGlvbmFsKSBkZWZhdWx0cyB0byAwLjA1XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4X3B0czogNTAwMDAgLy8gKG9wdGlvbmFsKSBkZWZhdWx0cyB0byAxMDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3J2aXovUG9pbnRDbG91ZDInOlxuICAgICAgICAgIGRlYnVnKGRpc3BsYXkuQ2xhc3MsIGRpc3BsYXkuVG9waWMpXG4gICAgICAgICAgb2JqID0gbmV3IFJPUzNELlBvaW50Q2xvdWQyKHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0b3BpYzogYCR7ZGlzcGxheS5Ub3BpY31gLFxuICAgICAgICAgICAgcm9vdE9iamVjdDogdGhpcy52aWV3ZXIuc2NlbmUsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgIG1heF9wdHM6IDUwMDAwLFxuICAgICAgICAgICAgLy9jb2xvcnNyYzogZGlzcGxheVtcIkNvbG9yIFRyYW5zZm9ybWVyXCJdLFxuICAgICAgICAgICAgbWF0ZXJpYWw6IHsgXG4gICAgICAgICAgICAgIHNpemU6IDAuMDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgLy9kZWJ1ZygnXFx0JywncHQnLCBkaXNwbGF5W1wiQ29sb3IgVHJhbnNmb3JtZXJcIl0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncnZpei9NYXJrZXInOlxuICAgICAgICAgIGRlYnVnKGRpc3BsYXkuQ2xhc3MsIGRpc3BsYXlbJ01hcmtlciBUb3BpYyddKVxuICAgICAgICAgIG9iaiA9IG5ldyBST1MzRC5NYXJrZXJDbGllbnQoe1xuICAgICAgICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgICAgICAgIHRvcGljOiBgJHtkaXNwbGF5WydNYXJrZXIgVG9waWMnXX1gLFxuICAgICAgICAgICAgcm9vdE9iamVjdDogdGhpcy52aWV3ZXIuc2NlbmUsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudFxuICAgICAgICAgIH0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncnZpei9NYXJrZXJBcnJheSc6XG4gICAgICAgICAgZGVidWcoZGlzcGxheS5DbGFzcywgZGlzcGxheVsnTWFya2VyIFRvcGljJ10pXG4gICAgICAgICAgb2JqID0gbmV3IFJPUzNELk1hcmtlckFycmF5Q2xpZW50KHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0b3BpYzogYCR7ZGlzcGxheVsnTWFya2VyIFRvcGljJ119YCxcbiAgICAgICAgICAgIHJvb3RPYmplY3Q6IHRoaXMudmlld2VyLnNjZW5lLFxuICAgICAgICAgICAgdGZDbGllbnQ6IHRoaXMudGZDbGllbnRcbiAgICAgICAgICB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3J2aXovTWFwJzpcbiAgICAgICAgICBkZWJ1ZyhkaXNwbGF5LkNsYXNzLCBkaXNwbGF5LlRvcGljKVxuICAgICAgICAgIG9iaiA9IG5ldyBST1MzRC5PY2N1cGFuY3lHcmlkQ2xpZW50KHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0b3BpYzogYCR7ZGlzcGxheS5Ub3BpY31gLFxuICAgICAgICAgICAgcm9vdE9iamVjdDogdGhpcy52aWV3ZXIuc2NlbmUsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgIGNvbnRpbnVvdXM6IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3J2aXovT2RvbWV0cnknOlxuICAgICAgICAgIGRlYnVnKGRpc3BsYXkuQ2xhc3MsIGRpc3BsYXkuVG9waWMpXG4gICAgICAgICAgb2JqID0gbmV3IFJPUzNELk9kb21ldHJ5KHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0b3BpYzogYCR7ZGlzcGxheS5Ub3BpY31gLFxuICAgICAgICAgICAgcm9vdE9iamVjdDogdGhpcy52aWV3ZXIuc2NlbmUsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgIGtlZXA6IGRpc3BsYXkuS2VlcCxcbiAgICAgICAgICAgIGxlbmd0aDogcmVhY2goZGlzcGxheSwgJ1NoYXBlLkF4ZXMgTGVuZ3RoJyksXG4gICAgICAgICAgICBoZWFkbGVuZ3RoOiByZWFjaChkaXNwbGF5LCAnU2hhcGUuSGVhZCBMZW5ndGgnKSxcbiAgICAgICAgICAgIHNoYWZ0TGVuZ3RoOiByZWFjaChkaXNwbGF5LCAnU2hhcGUuU2hhZnQgTGVuZ3RoJyksXG4gICAgICAgICAgICBoZWFkRGlhbWV0ZXI6IHJlYWNoKGRpc3BsYXksICdTaGFwZS5IZWFkIFJhZGl1cycpKjIuMCxcbiAgICAgICAgICAgIHNoYWZ0RGlhbWV0ZXI6IHJlYWNoKGRpc3BsYXksICdTaGFwZS5TaGFmdCBSYWRpdXMnKSoyLjAsXG4gICAgICAgICAgICBjb2xvcjogVGVsZU9wLnJ2aXpDb2xvcjJoZXgocmVhY2goZGlzcGxheSwnU2hhcGUuQ29sb3InKSwgJyNjYzAwZmYnKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncnZpei9QYXRoJzpcbiAgICAgICAgICBkZWJ1ZyhkaXNwbGF5LkNsYXNzKVxuICAgICAgICAgIG9iaiA9IG5ldyBST1MzRC5QYXRoKHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0b3BpYzogYCR7ZGlzcGxheS5Ub3BpY31gLFxuICAgICAgICAgICAgcm9vdE9iamVjdDogdGhpcy52aWV3ZXIuc2NlbmUsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgIGNvbG9yOiBUZWxlT3AucnZpekNvbG9yMmhleChkaXNwbGF5LkNvbG9yLCAnI2NjMDBmZicpXG4gICAgICAgICAgfSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdydml6L1JvYm90TW9kZWwnOlxuICAgICAgICAgIGRlYnVnKGRpc3BsYXkuQ2xhc3MpXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhkaXNwbGF5KVxuXG4gICAgICAgICAgbGV0IHBhcmFtUGF0aCA9IHBhdGguam9pbignLycsIGRpc3BsYXlbJ1JvYm90IERlc2NyaXB0aW9uJ10pXG5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKHBhcmFtUGF0aClcblxuICAgICAgICAgIGNvbnN0IHVyZGZUZXh0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e1xuICAgICAgICAgICAgbGV0IGRlc2NQYXJhbSA9IG5ldyBST1NMSUIuUGFyYW0oe1xuICAgICAgICAgICAgICByb3M6IHRoaXMucm9zLCBuYW1lOiBwYXJhbVBhdGhcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGRlc2NQYXJhbS5nZXQodmFsPT57IHJlc29sdmUodmFsKSB9KVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBkZWJ1ZygnXFx0JywndXJkZicsIHVyZGZUZXh0KVxuXG4gICAgICAgICAgbGV0IHB1YmxpY01vZGVsUGF0aCA9ICcnXG4gICAgICAgICAgaWYodXJkZlRleHQgIT0gbnVsbCAmJiB1cmRmVGV4dC5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIC8qbGV0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKVxuICAgICAgICAgICAgbGV0IHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodXJkZlRleHQsICd0ZXh0L3htbCcpXG5cbiAgICAgICAgICAgIGNvbnN0IHJvYm90VGFnID0geG1sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdyb2JvdCcpWzBdXG4gICAgICAgICAgICBjb25zdCByb2JvdE5hbWUgPSByb2JvdFRhZy5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuICAgICAgICAgICAgZGVidWcoJ1xcdCcsJ3VyZGYgcm9ib3QgbmFtZScsIHJvYm90TmFtZSwgcm9ib3ROYW1lLmluZGV4T2YoJ21hZ25pJykpXG4gICAgICAgICAgICBpZihyb2JvdE5hbWUuaW5kZXhPZignbWFnbmknKSAhPSAtMSl7XG4gICAgICAgICAgICAgIHB1YmxpY01vZGVsUGF0aCA9ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vVWJpcXVpdHlSb2JvdGljcy9tYWduaV9yb2JvdC9ub2V0aWMtZGV2ZWwnXG4gICAgICAgICAgICB9Ki9cblxuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBvYmogPSBuZXcgUk9TM0QuVXJkZkNsaWVudCh7XG4gICAgICAgICAgICAgICAgcGF0aDogJy9wYWNrYWdlcy8nLFxuICAgICAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICAgICAgcGFyYW06IHBhcmFtUGF0aCxcbiAgICAgICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zY2VuZSxcbiAgICAgICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgICAgICB0ZlByZWZpeDogZGlzcGxheVsnVEYgUHJlZml4J11cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGVycil7XG4gICAgICAgICAgICAgIGRlYnVnKCdcXHQnLCd1cmRmIGVycm9yJywgZXJyKVxuICAgICAgICAgICAgICAvL2RlbGV0ZSBvYmpcbiAgICAgICAgICAgICAgb2JqID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gIFxuICAgICAgICAgICAgZGVidWcoJ1xcdCcsb2JqKVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdydml6L0ludGVyYWN0aXZlTWFya2Vycyc6XG4gICAgICAgICAgZGVidWcoZGlzcGxheS5DbGFzcywgZGlzcGxheVsnVXBkYXRlIFRvcGljJ10pXG5cbiAgICAgICAgICBjb25zdCB0b3BpYyA9IGRpc3BsYXlbJ1VwZGF0ZSBUb3BpYyddLnJlcGxhY2UoJy91cGRhdGUnLCcnKVxuXG4gICAgICAgICAgZGVidWcoJ1xcdCcsICd0b3BpYycsIHRvcGljKVxuXG4gICAgICAgICAgb2JqID0gbmV3IFJPUzNELkludGVyYWN0aXZlTWFya2VyQ2xpZW50KHtcbiAgICAgICAgICAgIHRvcGljLFxuICAgICAgICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgICAgICAgIHRmQ2xpZW50OiB0aGlzLnRmQ2xpZW50LFxuICAgICAgICAgICAgY2FtZXJhOiB0aGlzLnZpZXdlci5jYW1lcmEsXG4gICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zZWxlY3RhYmxlT2JqZWN0cyxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3J2aXovUG9pbnRTdGFtcGVkJzpcbiAgICAgICAgICBkZWJ1ZyhkaXNwbGF5LkNsYXNzLCBkaXNwbGF5WydUb3BpYyddKVxuXG4gICAgICAgICAgb2JqID0gbmV3IFJPUzNELlBvaW50KHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgIHRvcGljOiBkaXNwbGF5WydUb3BpYyddLFxuICAgICAgICAgICAgY29sb3I6IFRlbGVPcC5ydml6Q29sb3IyaGV4KGRpc3BsYXlbJ0NvbG9yJ10pLFxuICAgICAgICAgICAgcmFkaXVzOiBkaXNwbGF5WydSYWRpdXMnXVxuICAgICAgICAgIH0pXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3J2aXovUG9seWdvbic6XG4gICAgICAgICAgZGVidWcoZGlzcGxheS5DbGFzcywgZGlzcGxheVsnVG9waWMnXSlcblxuICAgICAgICAgIG9iaiA9IG5ldyBST1MzRC5Qb2x5Z29uKHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgIHRvcGljOiBkaXNwbGF5WydUb3BpYyddLFxuICAgICAgICAgICAgY29sb3I6IFRlbGVPcC5ydml6Q29sb3IyaGV4KGRpc3BsYXlbJ0NvbG9yJ10pXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdydml6L1Bvc2UnOlxuICAgICAgICBjYXNlICdydml6L1Bvc2VBcnJheSc6XG4gICAgICAgIGNhc2UgJ3J2aXovUG9zZVdpdGhDb3ZhcmlhbmNlJzpcbiAgICAgICAgICBkZWJ1ZyhkaXNwbGF5LkNsYXNzLCBkaXNwbGF5WydUb3BpYyddKVxuICAgICAgICAgIGNvbnN0IHR5cGUgPSBkaXNwbGF5LkNsYXNzLnJlcGxhY2UoJ3J2aXovJywgJycpXG4gICAgICAgICAgY29uc3QgQ2xhc3MgPSBST1MzRFt0eXBlXVxuXG4gICAgICAgICAgb2JqID0gbmV3IENsYXNzKHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgIHRvcGljOiBkaXNwbGF5WydUb3BpYyddLFxuICAgICAgICAgICAgY29sb3I6IFRlbGVPcC5ydml6Q29sb3IyaGV4KGRpc3BsYXlbJ0NvbG9yJ10pLFxuICAgICAgICAgICAgbGVuZ3RoOiByZWFjaChkaXNwbGF5LCAnQXhlcyBMZW5ndGgnKSxcbiAgICAgICAgICAgIGhlYWRsZW5ndGg6IHJlYWNoKGRpc3BsYXksICdIZWFkIExlbmd0aCcpLFxuICAgICAgICAgICAgc2hhZnRMZW5ndGg6IHJlYWNoKGRpc3BsYXksICdTaGFmdCBMZW5ndGgnKSxcbiAgICAgICAgICAgIGhlYWREaWFtZXRlcjogcmVhY2goZGlzcGxheSwgJ0hlYWQgUmFkaXVzJykqMi4wLFxuICAgICAgICAgICAgc2hhZnREaWFtZXRlcjogcmVhY2goZGlzcGxheSwgJ1NoYWZ0IFJhZGl1cycpKjIuMFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLndhcm4oYGRpc3BsYXkgY2xhc3MgJyR7ZGlzcGxheS5DbGFzc30nIG5vdCBzdXBwb3J0ZWRgKVxuICAgICAgICAgIGNvbnNvbGUud2FybihkaXNwbGF5KVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGlmIChvYmopIHtcbiAgICAgICAgZGVidWcob2JqKVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cblxuXG4gIGRpc2FibGVWaXooKSB7XG4gICAgLyoqIEB0b2RvICovXG4gICAgZGVidWcoJ2Rpc2FibGUgdml6IC0gbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG5cbiAgc3RhdGljIHJ2aXpDb2xvcjJoZXgoY29sb3IsIGRlZmF1bHRIZXgpIHtcbiAgICBpZiAoIWNvbG9yKSB7IHJldHVybiBkZWZhdWx0SGV4IH1cbiAgICByZXR1cm4gVGVsZU9wLnJnYjJoZXgoY29sb3IucmVwbGFjZSgvOy9nLCAnLCcpKVxuICB9XG4gIFxuICBzdGF0aWMgcmdiMmhleChyZ2IpIHtcbiAgICByZ2IgPSByZ2IubWF0Y2goL1tcXHMrXT8oXFxkKylbXFxzK10/LFtcXHMrXT8oXFxkKylbXFxzK10/LFtcXHMrXT8oXFxkKylbXFxzK10/L2kpO1xuICAgIHJldHVybiAocmdiICYmIHJnYi5sZW5ndGggPT09IDQpID8gXCIjXCIgK1xuICAgICAgKFwiMFwiICsgcGFyc2VJbnQocmdiWzFdLCAxMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMikgK1xuICAgICAgKFwiMFwiICsgcGFyc2VJbnQocmdiWzJdLCAxMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMikgK1xuICAgICAgKFwiMFwiICsgcGFyc2VJbnQocmdiWzNdLCAxMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMikgOiAnJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cz1UZWxlT3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n")},"./src/reach.js":module=>{eval("module.exports = function(obj, path, defaultVal){\n  var tokens = path.split('.')\n  var val = obj;\n\n  try{\n    for(var i=0; i<tokens.length; i++){\n      val = val[tokens[i]]\n    }\n\n    if(val == undefined){ val = defaultVal }\n  }\n  catch(excp){\n    val = (defaultVal != undefined) ? defaultVal : null\n  }\n\n  return val;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVhY2guanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9wLXh5ei8uL3NyYy9yZWFjaC5qcz83ZjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBwYXRoLCBkZWZhdWx0VmFsKXtcbiAgdmFyIHRva2VucyA9IHBhdGguc3BsaXQoJy4nKVxuICB2YXIgdmFsID0gb2JqO1xuXG4gIHRyeXtcbiAgICBmb3IodmFyIGk9MDsgaTx0b2tlbnMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFsID0gdmFsW3Rva2Vuc1tpXV1cbiAgICB9XG5cbiAgICBpZih2YWwgPT0gdW5kZWZpbmVkKXsgdmFsID0gZGVmYXVsdFZhbCB9XG4gIH1cbiAgY2F0Y2goZXhjcCl7XG4gICAgdmFsID0gKGRlZmF1bHRWYWwgIT0gdW5kZWZpbmVkKSA/IGRlZmF1bHRWYWwgOiBudWxsXG4gIH1cblxuICByZXR1cm4gdmFsO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/reach.js\n")},"./node_modules/yaml/browser/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('module.exports = __webpack_require__(/*! ./dist */ "./node_modules/yaml/browser/dist/index.js").YAML\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9HQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcC14eXovLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2luZGV4LmpzPzg5ZjgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QnKS5ZQU1MXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/index.js\n')},"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"C\": () => (/* binding */ Char),\n/* harmony export */   \"N\": () => (/* binding */ Node),\n/* harmony export */   \"P\": () => (/* binding */ PlainValue),\n/* harmony export */   \"R\": () => (/* binding */ Range),\n/* harmony export */   \"T\": () => (/* binding */ Type),\n/* harmony export */   \"Y\": () => (/* binding */ YAMLSyntaxError),\n/* harmony export */   \"_\": () => (/* binding */ _createForOfIteratorHelper),\n/* harmony export */   \"a\": () => (/* binding */ _typeof),\n/* harmony export */   \"b\": () => (/* binding */ _createClass),\n/* harmony export */   \"c\": () => (/* binding */ _classCallCheck),\n/* harmony export */   \"d\": () => (/* binding */ defaultTagPrefix),\n/* harmony export */   \"e\": () => (/* binding */ _defineProperty),\n/* harmony export */   \"f\": () => (/* binding */ YAMLWarning),\n/* harmony export */   \"g\": () => (/* binding */ YAMLSemanticError),\n/* harmony export */   \"h\": () => (/* binding */ _slicedToArray),\n/* harmony export */   \"i\": () => (/* binding */ YAMLError),\n/* harmony export */   \"j\": () => (/* binding */ _inherits),\n/* harmony export */   \"k\": () => (/* binding */ _createSuper),\n/* harmony export */   \"l\": () => (/* binding */ _get),\n/* harmony export */   \"m\": () => (/* binding */ _getPrototypeOf),\n/* harmony export */   \"n\": () => (/* binding */ defaultTags),\n/* harmony export */   \"o\": () => (/* binding */ YAMLReferenceError),\n/* harmony export */   \"p\": () => (/* binding */ _assertThisInitialized),\n/* harmony export */   \"q\": () => (/* binding */ _toArray),\n/* harmony export */   \"r\": () => (/* binding */ _possibleConstructorReturn)\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '';\n      col -= src.length - maxWidth;\n      src = '' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }], [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  return Range;\n}();\n\n/** Root class of all nodes */\n\nvar Node = /*#__PURE__*/function () {\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3);\n                _tag$match2[0];\n                var handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvUGxhaW5WYWx1ZS1iODAzNmI3NS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsK0JBQStCO0FBQzdFOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LEtBQUs7O0FBRTNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLFNBQVM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRTZlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9wLXh5ei8uL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9QbGFpblZhbHVlLWI4MDM2Yjc1LmpzPzRkZmQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF90b0FycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdDtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICAgIGRpZEVyciA9IGZhbHNlLFxuICAgICAgZXJyO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gZTtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgQ2hhciA9IHtcbiAgQU5DSE9SOiAnJicsXG4gIENPTU1FTlQ6ICcjJyxcbiAgVEFHOiAnIScsXG4gIERJUkVDVElWRVNfRU5EOiAnLScsXG4gIERPQ1VNRU5UX0VORDogJy4nXG59O1xudmFyIFR5cGUgPSB7XG4gIEFMSUFTOiAnQUxJQVMnLFxuICBCTEFOS19MSU5FOiAnQkxBTktfTElORScsXG4gIEJMT0NLX0ZPTERFRDogJ0JMT0NLX0ZPTERFRCcsXG4gIEJMT0NLX0xJVEVSQUw6ICdCTE9DS19MSVRFUkFMJyxcbiAgQ09NTUVOVDogJ0NPTU1FTlQnLFxuICBESVJFQ1RJVkU6ICdESVJFQ1RJVkUnLFxuICBET0NVTUVOVDogJ0RPQ1VNRU5UJyxcbiAgRkxPV19NQVA6ICdGTE9XX01BUCcsXG4gIEZMT1dfU0VROiAnRkxPV19TRVEnLFxuICBNQVA6ICdNQVAnLFxuICBNQVBfS0VZOiAnTUFQX0tFWScsXG4gIE1BUF9WQUxVRTogJ01BUF9WQUxVRScsXG4gIFBMQUlOOiAnUExBSU4nLFxuICBRVU9URV9ET1VCTEU6ICdRVU9URV9ET1VCTEUnLFxuICBRVU9URV9TSU5HTEU6ICdRVU9URV9TSU5HTEUnLFxuICBTRVE6ICdTRVEnLFxuICBTRVFfSVRFTTogJ1NFUV9JVEVNJ1xufTtcbnZhciBkZWZhdWx0VGFnUHJlZml4ID0gJ3RhZzp5YW1sLm9yZywyMDAyOic7XG52YXIgZGVmYXVsdFRhZ3MgPSB7XG4gIE1BUDogJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsXG4gIFNFUTogJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsXG4gIFNUUjogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cidcbn07XG5cbmZ1bmN0aW9uIGZpbmRMaW5lU3RhcnRzKHNyYykge1xuICB2YXIgbHMgPSBbMF07XG4gIHZhciBvZmZzZXQgPSBzcmMuaW5kZXhPZignXFxuJyk7XG5cbiAgd2hpbGUgKG9mZnNldCAhPT0gLTEpIHtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICBscy5wdXNoKG9mZnNldCk7XG4gICAgb2Zmc2V0ID0gc3JjLmluZGV4T2YoJ1xcbicsIG9mZnNldCk7XG4gIH1cblxuICByZXR1cm4gbHM7XG59XG5cbmZ1bmN0aW9uIGdldFNyY0luZm8oY3N0KSB7XG4gIHZhciBsaW5lU3RhcnRzLCBzcmM7XG5cbiAgaWYgKHR5cGVvZiBjc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgbGluZVN0YXJ0cyA9IGZpbmRMaW5lU3RhcnRzKGNzdCk7XG4gICAgc3JjID0gY3N0O1xuICB9IGVsc2Uge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNzdCkpIGNzdCA9IGNzdFswXTtcblxuICAgIGlmIChjc3QgJiYgY3N0LmNvbnRleHQpIHtcbiAgICAgIGlmICghY3N0LmxpbmVTdGFydHMpIGNzdC5saW5lU3RhcnRzID0gZmluZExpbmVTdGFydHMoY3N0LmNvbnRleHQuc3JjKTtcbiAgICAgIGxpbmVTdGFydHMgPSBjc3QubGluZVN0YXJ0cztcbiAgICAgIHNyYyA9IGNzdC5jb250ZXh0LnNyYztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmVTdGFydHM6IGxpbmVTdGFydHMsXG4gICAgc3JjOiBzcmNcbiAgfTtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTGluZVBvcyAtIE9uZS1pbmRleGVkIHBvc2l0aW9uIGluIHRoZSBzb3VyY2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29sXG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGxpbmUvY29sIHBvc2l0aW9uIG1hdGNoaW5nIGEgY2hhcmFjdGVyIG9mZnNldC5cbiAqXG4gKiBBY2NlcHRzIGEgc291cmNlIHN0cmluZyBvciBhIENTVCBkb2N1bWVudCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci4gV2l0aFxuICogdGhlIGxhdHRlciwgc3RhcnRpbmcgaW5kaWNlcyBmb3IgbGluZXMgYXJlIGNhY2hlZCBpbiB0aGUgZG9jdW1lbnQgYXNcbiAqIGBsaW5lU3RhcnRzOiBudW1iZXJbXWAuXG4gKlxuICogUmV0dXJucyBhIG9uZS1pbmRleGVkIGB7IGxpbmUsIGNvbCB9YCBsb2NhdGlvbiBpZiBmb3VuZCwgb3JcbiAqIGB1bmRlZmluZWRgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ3xEb2N1bWVudHxEb2N1bWVudFtdfSBjc3RcbiAqIEByZXR1cm5zIHs/TGluZVBvc31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpbmVQb3Mob2Zmc2V0LCBjc3QpIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCA8IDApIHJldHVybiBudWxsO1xuXG4gIHZhciBfZ2V0U3JjSW5mbyA9IGdldFNyY0luZm8oY3N0KSxcbiAgICAgIGxpbmVTdGFydHMgPSBfZ2V0U3JjSW5mby5saW5lU3RhcnRzLFxuICAgICAgc3JjID0gX2dldFNyY0luZm8uc3JjO1xuXG4gIGlmICghbGluZVN0YXJ0cyB8fCAhc3JjIHx8IG9mZnNldCA+IHNyYy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVN0YXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBzdGFydCA9IGxpbmVTdGFydHNbaV07XG5cbiAgICBpZiAob2Zmc2V0IDwgc3RhcnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IGksXG4gICAgICAgIGNvbDogb2Zmc2V0IC0gbGluZVN0YXJ0c1tpIC0gMV0gKyAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0KSByZXR1cm4ge1xuICAgICAgbGluZTogaSArIDEsXG4gICAgICBjb2w6IDFcbiAgICB9O1xuICB9XG5cbiAgdmFyIGxpbmUgPSBsaW5lU3RhcnRzLmxlbmd0aDtcbiAgcmV0dXJuIHtcbiAgICBsaW5lOiBsaW5lLFxuICAgIGNvbDogb2Zmc2V0IC0gbGluZVN0YXJ0c1tsaW5lIC0gMV0gKyAxXG4gIH07XG59XG4vKipcbiAqIEdldCBhIHNwZWNpZmllZCBsaW5lIGZyb20gdGhlIHNvdXJjZS5cbiAqXG4gKiBBY2NlcHRzIGEgc291cmNlIHN0cmluZyBvciBhIENTVCBkb2N1bWVudCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci4gV2l0aFxuICogdGhlIGxhdHRlciwgc3RhcnRpbmcgaW5kaWNlcyBmb3IgbGluZXMgYXJlIGNhY2hlZCBpbiB0aGUgZG9jdW1lbnQgYXNcbiAqIGBsaW5lU3RhcnRzOiBudW1iZXJbXWAuXG4gKlxuICogUmV0dXJucyB0aGUgbGluZSBhcyBhIHN0cmluZyBpZiBmb3VuZCwgb3IgYG51bGxgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGluZSBPbmUtaW5kZXhlZCBsaW5lIG51bWJlclxuICogQHBhcmFtIHtzdHJpbmd8RG9jdW1lbnR8RG9jdW1lbnRbXX0gY3N0XG4gKiBAcmV0dXJucyB7P3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRMaW5lKGxpbmUsIGNzdCkge1xuICB2YXIgX2dldFNyY0luZm8yID0gZ2V0U3JjSW5mbyhjc3QpLFxuICAgICAgbGluZVN0YXJ0cyA9IF9nZXRTcmNJbmZvMi5saW5lU3RhcnRzLFxuICAgICAgc3JjID0gX2dldFNyY0luZm8yLnNyYztcblxuICBpZiAoIWxpbmVTdGFydHMgfHwgIShsaW5lID49IDEpIHx8IGxpbmUgPiBsaW5lU3RhcnRzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gIHZhciBzdGFydCA9IGxpbmVTdGFydHNbbGluZSAtIDFdO1xuICB2YXIgZW5kID0gbGluZVN0YXJ0c1tsaW5lXTsgLy8gdW5kZWZpbmVkIGZvciBsYXN0IGxpbmU7IHRoYXQncyBvayBmb3Igc2xpY2UoKVxuXG4gIHdoaWxlIChlbmQgJiYgZW5kID4gc3RhcnQgJiYgc3JjW2VuZCAtIDFdID09PSAnXFxuJykge1xuICAgIC0tZW5kO1xuICB9XG5cbiAgcmV0dXJuIHNyYy5zbGljZShzdGFydCwgZW5kKTtcbn1cbi8qKlxuICogUHJldHR5LXByaW50IHRoZSBzdGFydGluZyBsaW5lIGZyb20gdGhlIHNvdXJjZSBpbmRpY2F0ZWQgYnkgdGhlIHJhbmdlIGBwb3NgXG4gKlxuICogVHJpbXMgb3V0cHV0IHRvIGBtYXhXaWR0aGAgY2hhcnMgd2hpbGUga2VlcGluZyB0aGUgc3RhcnRpbmcgY29sdW1uIHZpc2libGUsXG4gKiB1c2luZyBg4oCmYCBhdCBlaXRoZXIgZW5kIHRvIGluZGljYXRlIGRyb3BwZWQgY2hhcmFjdGVycy5cbiAqXG4gKiBSZXR1cm5zIGEgdHdvLWxpbmUgc3RyaW5nIChvciBgbnVsbGApIHdpdGggYFxcbmAgYXMgc2VwYXJhdG9yOyB0aGUgc2Vjb25kIGxpbmVcbiAqIHdpbGwgaG9sZCBhcHByb3ByaWF0ZWx5IGluZGVudGVkIGBeYCBtYXJrcyBpbmRpY2F0aW5nIHRoZSBjb2x1bW4gcmFuZ2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICogQHBhcmFtIHtMaW5lUG9zfSBwb3Muc3RhcnRcbiAqIEBwYXJhbSB7TGluZVBvc30gW3Bvcy5lbmRdXG4gKiBAcGFyYW0ge3N0cmluZ3xEb2N1bWVudHxEb2N1bWVudFtdKn0gY3N0XG4gKiBAcGFyYW0ge251bWJlcn0gW21heFdpZHRoPTgwXVxuICogQHJldHVybnMgez9zdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0UHJldHR5Q29udGV4dChfcmVmLCBjc3QpIHtcbiAgdmFyIHN0YXJ0ID0gX3JlZi5zdGFydCxcbiAgICAgIGVuZCA9IF9yZWYuZW5kO1xuICB2YXIgbWF4V2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDgwO1xuICB2YXIgc3JjID0gZ2V0TGluZShzdGFydC5saW5lLCBjc3QpO1xuICBpZiAoIXNyYykgcmV0dXJuIG51bGw7XG4gIHZhciBjb2wgPSBzdGFydC5jb2w7XG5cbiAgaWYgKHNyYy5sZW5ndGggPiBtYXhXaWR0aCkge1xuICAgIGlmIChjb2wgPD0gbWF4V2lkdGggLSAxMCkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cigwLCBtYXhXaWR0aCAtIDEpICsgJ+KApic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKG1heFdpZHRoIC8gMik7XG4gICAgICBpZiAoc3JjLmxlbmd0aCA+IGNvbCArIGhhbGZXaWR0aCkgc3JjID0gc3JjLnN1YnN0cigwLCBjb2wgKyBoYWxmV2lkdGggLSAxKSArICfigKYnO1xuICAgICAgY29sIC09IHNyYy5sZW5ndGggLSBtYXhXaWR0aDtcbiAgICAgIHNyYyA9ICfigKYnICsgc3JjLnN1YnN0cigxIC0gbWF4V2lkdGgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlcnJMZW4gPSAxO1xuICB2YXIgZXJyRW5kID0gJyc7XG5cbiAgaWYgKGVuZCkge1xuICAgIGlmIChlbmQubGluZSA9PT0gc3RhcnQubGluZSAmJiBjb2wgKyAoZW5kLmNvbCAtIHN0YXJ0LmNvbCkgPD0gbWF4V2lkdGggKyAxKSB7XG4gICAgICBlcnJMZW4gPSBlbmQuY29sIC0gc3RhcnQuY29sO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJMZW4gPSBNYXRoLm1pbihzcmMubGVuZ3RoICsgMSwgbWF4V2lkdGgpIC0gY29sO1xuICAgICAgZXJyRW5kID0gJ+KApic7XG4gICAgfVxuICB9XG5cbiAgdmFyIG9mZnNldCA9IGNvbCA+IDEgPyAnICcucmVwZWF0KGNvbCAtIDEpIDogJyc7XG4gIHZhciBlcnIgPSAnXicucmVwZWF0KGVyckxlbik7XG4gIHJldHVybiBcIlwiLmNvbmNhdChzcmMsIFwiXFxuXCIpLmNvbmNhdChvZmZzZXQpLmNvbmNhdChlcnIpLmNvbmNhdChlcnJFbmQpO1xufVxuXG52YXIgUmFuZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlKTtcblxuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZCB8fCBzdGFydDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYW5nZSwgW3tcbiAgICBrZXk6IFwiaXNFbXB0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnN0YXJ0ICE9PSAnbnVtYmVyJyB8fCAhdGhpcy5lbmQgfHwgdGhpcy5lbmQgPD0gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGBvcmlnU3RhcnRgIGFuZCBgb3JpZ0VuZGAgdG8gcG9pbnQgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSByYW5nZSBmb3JcbiAgICAgKiB0aGlzIG5vZGUsIHdoaWNoIG1heSBkaWZmZXIgZHVlIHRvIGRyb3BwZWQgQ1IgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGNyIC0gUG9zaXRpb25zIG9mIGRyb3BwZWQgQ1IgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBTdGFydGluZyBpbmRleCBvZiBgY3JgIGZyb20gdGhlIGxhc3QgY2FsbFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIG5leHQgb2Zmc2V0LCBtYXRjaGluZyB0aGUgb25lIGZvdW5kIGZvciBgb3JpZ1N0YXJ0YFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3JpZ1JhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWdSYW5nZShjciwgb2Zmc2V0KSB7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICBpZiAoY3IubGVuZ3RoID09PSAwIHx8IGVuZCA8PSBjclswXSkge1xuICAgICAgICB0aGlzLm9yaWdTdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLm9yaWdFbmQgPSBlbmQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBpID0gb2Zmc2V0O1xuXG4gICAgICB3aGlsZSAoaSA8IGNyLmxlbmd0aCkge1xuICAgICAgICBpZiAoY3JbaV0gPiBzdGFydCkgYnJlYWs7ZWxzZSArK2k7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3JpZ1N0YXJ0ID0gc3RhcnQgKyBpO1xuICAgICAgdmFyIG5leHRPZmZzZXQgPSBpO1xuXG4gICAgICB3aGlsZSAoaSA8IGNyLmxlbmd0aCkge1xuICAgICAgICAvLyBpZiBlbmQgd2FzIGF0IFxcbiwgaXQgc2hvdWxkIG5vdyBiZSBhdCBcXHJcbiAgICAgICAgaWYgKGNyW2ldID49IGVuZCkgYnJlYWs7ZWxzZSArK2k7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3JpZ0VuZCA9IGVuZCArIGk7XG4gICAgICByZXR1cm4gbmV4dE9mZnNldDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkob3JpZykge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShvcmlnLnN0YXJ0LCBvcmlnLmVuZCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhbmdlO1xufSgpO1xuXG4vKiogUm9vdCBjbGFzcyBvZiBhbGwgbm9kZXMgKi9cblxudmFyIE5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlKHR5cGUsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGUpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb250ZXh0Jywge1xuICAgICAgdmFsdWU6IGNvbnRleHQgfHwgbnVsbCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgdGhpcy5yYW5nZSA9IG51bGw7XG4gICAgdGhpcy52YWx1ZVJhbmdlID0gbnVsbDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHMgfHwgW107XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlLCBbe1xuICAgIGtleTogXCJnZXRQcm9wVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvcFZhbHVlKGlkeCwga2V5LCBza2lwS2V5KSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc3JjID0gdGhpcy5jb250ZXh0LnNyYztcbiAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wc1tpZHhdO1xuICAgICAgcmV0dXJuIHByb3AgJiYgc3JjW3Byb3Auc3RhcnRdID09PSBrZXkgPyBzcmMuc2xpY2UocHJvcC5zdGFydCArIChza2lwS2V5ID8gMSA6IDApLCBwcm9wLmVuZCkgOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbmNob3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5nZXRQcm9wVmFsdWUoaSwgQ2hhci5BTkNIT1IsIHRydWUpO1xuICAgICAgICBpZiAoYW5jaG9yICE9IG51bGwpIHJldHVybiBhbmNob3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21tZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgY29tbWVudHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5nZXRQcm9wVmFsdWUoaSwgQ2hhci5DT01NRU5ULCB0cnVlKTtcbiAgICAgICAgaWYgKGNvbW1lbnQgIT0gbnVsbCkgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbW1lbnRzLmxlbmd0aCA+IDAgPyBjb21tZW50cy5qb2luKCdcXG4nKSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbW1lbnRIYXNSZXF1aXJlZFdoaXRlc3BhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWVudEhhc1JlcXVpcmVkV2hpdGVzcGFjZShzdGFydCkge1xuICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmM7XG4gICAgICBpZiAodGhpcy5oZWFkZXIgJiYgc3RhcnQgPT09IHRoaXMuaGVhZGVyLmVuZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCF0aGlzLnZhbHVlUmFuZ2UpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBlbmQgPSB0aGlzLnZhbHVlUmFuZ2UuZW5kO1xuICAgICAgcmV0dXJuIHN0YXJ0ICE9PSBlbmQgfHwgTm9kZS5hdEJsYW5rKHNyYywgZW5kIC0gMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0NvbW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHNyY1t0aGlzLnByb3BzW2ldLnN0YXJ0XSA9PT0gQ2hhci5DT01NRU5UKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1Byb3BzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChzcmNbdGhpcy5wcm9wc1tpXS5zdGFydF0gIT09IENoYXIuQ09NTUVOVCkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmNsdWRlc1RyYWlsaW5nTGluZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwianNvbkxpa2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBqc29uTGlrZVR5cGVzID0gW1R5cGUuRkxPV19NQVAsIFR5cGUuRkxPV19TRVEsIFR5cGUuUVVPVEVfRE9VQkxFLCBUeXBlLlFVT1RFX1NJTkdMRV07XG4gICAgICByZXR1cm4ganNvbkxpa2VUeXBlcy5pbmRleE9mKHRoaXMudHlwZSkgIT09IC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYW5nZUFzTGluZVBvc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLnJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc3RhcnQgPSBnZXRMaW5lUG9zKHRoaXMucmFuZ2Uuc3RhcnQsIHRoaXMuY29udGV4dC5yb290KTtcbiAgICAgIGlmICghc3RhcnQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgZW5kID0gZ2V0TGluZVBvcyh0aGlzLnJhbmdlLmVuZCwgdGhpcy5jb250ZXh0LnJvb3QpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmF3VmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy52YWx1ZVJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiBudWxsO1xuICAgICAgdmFyIF90aGlzJHZhbHVlUmFuZ2UgPSB0aGlzLnZhbHVlUmFuZ2UsXG4gICAgICAgICAgc3RhcnQgPSBfdGhpcyR2YWx1ZVJhbmdlLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IF90aGlzJHZhbHVlUmFuZ2UuZW5kO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zcmMuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRhZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB0YWcgPSB0aGlzLmdldFByb3BWYWx1ZShpLCBDaGFyLlRBRywgZmFsc2UpO1xuXG4gICAgICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0YWdbMV0gPT09ICc8Jykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmVyYmF0aW06IHRhZy5zbGljZSgyLCAtMSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgdmFyIF90YWckbWF0Y2ggPSB0YWcubWF0Y2goL14oLiohKShbXiFdKikkLyksXG4gICAgICAgICAgICAgICAgX3RhZyRtYXRjaDIgPSBfc2xpY2VkVG9BcnJheShfdGFnJG1hdGNoLCAzKTtcbiAgICAgICAgICAgICAgICBfdGFnJG1hdGNoMlswXTtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gX3RhZyRtYXRjaDJbMV0sXG4gICAgICAgICAgICAgICAgc3VmZml4ID0gX3RhZyRtYXRjaDJbMl07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxuICAgICAgICAgICAgICBzdWZmaXg6IHN1ZmZpeFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlUmFuZ2VDb250YWluc05ld2xpbmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy52YWx1ZVJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBfdGhpcyR2YWx1ZVJhbmdlMiA9IHRoaXMudmFsdWVSYW5nZSxcbiAgICAgICAgICBzdGFydCA9IF90aGlzJHZhbHVlUmFuZ2UyLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IF90aGlzJHZhbHVlUmFuZ2UyLmVuZDtcbiAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICBpZiAoc3JjW2ldID09PSAnXFxuJykgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VDb21tZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQ29tbWVudChzdGFydCkge1xuICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmM7XG5cbiAgICAgIGlmIChzcmNbc3RhcnRdID09PSBDaGFyLkNPTU1FTlQpIHtcbiAgICAgICAgdmFyIGVuZCA9IE5vZGUuZW5kT2ZMaW5lKHNyYywgc3RhcnQgKyAxKTtcbiAgICAgICAgdmFyIGNvbW1lbnRSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy5wcm9wcy5wdXNoKGNvbW1lbnRSYW5nZSk7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9wdWxhdGVzIHRoZSBgb3JpZ1N0YXJ0YCBhbmQgYG9yaWdFbmRgIHZhbHVlcyBvZiBhbGwgcmFuZ2VzIGZvciB0aGlzXG4gICAgICogbm9kZS4gRXh0ZW5kZWQgYnkgY2hpbGQgY2xhc3NlcyB0byBoYW5kbGUgZGVzY2VuZGFudCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGNyIC0gUG9zaXRpb25zIG9mIGRyb3BwZWQgQ1IgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBTdGFydGluZyBpbmRleCBvZiBgY3JgIGZyb20gdGhlIGxhc3QgY2FsbFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIG5leHQgb2Zmc2V0LCBtYXRjaGluZyB0aGUgb25lIGZvdW5kIGZvciBgb3JpZ1N0YXJ0YFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3JpZ1Jhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpIHtcbiAgICAgIGlmICh0aGlzLnJhbmdlKSBvZmZzZXQgPSB0aGlzLnJhbmdlLnNldE9yaWdSYW5nZShjciwgb2Zmc2V0KTtcbiAgICAgIGlmICh0aGlzLnZhbHVlUmFuZ2UpIHRoaXMudmFsdWVSYW5nZS5zZXRPcmlnUmFuZ2UoY3IsIG9mZnNldCk7XG4gICAgICB0aGlzLnByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3Auc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjLFxuICAgICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZSxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFyIHN0ciA9IHNyYy5zbGljZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcbiAgICAgIHJldHVybiBOb2RlLmFkZFN0cmluZ1Rlcm1pbmF0b3Ioc3JjLCByYW5nZS5lbmQsIHN0cik7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiYWRkU3RyaW5nVGVybWluYXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTdHJpbmdUZXJtaW5hdG9yKHNyYywgb2Zmc2V0LCBzdHIpIHtcbiAgICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnXFxuJykgcmV0dXJuIHN0cjtcbiAgICAgIHZhciBuZXh0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG5leHQgPj0gc3JjLmxlbmd0aCB8fCBzcmNbbmV4dF0gPT09ICdcXG4nID8gc3RyICsgJ1xcbicgOiBzdHI7XG4gICAgfSAvLyBeKC0tLXwuLi4pXG5cbiAgfSwge1xuICAgIGtleTogXCJhdERvY3VtZW50Qm91bmRhcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXREb2N1bWVudEJvdW5kYXJ5KHNyYywgb2Zmc2V0LCBzZXApIHtcbiAgICAgIHZhciBjaDAgPSBzcmNbb2Zmc2V0XTtcbiAgICAgIGlmICghY2gwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHZhciBwcmV2ID0gc3JjW29mZnNldCAtIDFdO1xuICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gJ1xcbicpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKHNlcCkge1xuICAgICAgICBpZiAoY2gwICE9PSBzZXApIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaDAgIT09IENoYXIuRElSRUNUSVZFU19FTkQgJiYgY2gwICE9PSBDaGFyLkRPQ1VNRU5UX0VORCkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2gxID0gc3JjW29mZnNldCArIDFdO1xuICAgICAgdmFyIGNoMiA9IHNyY1tvZmZzZXQgKyAyXTtcbiAgICAgIGlmIChjaDEgIT09IGNoMCB8fCBjaDIgIT09IGNoMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGNoMyA9IHNyY1tvZmZzZXQgKyAzXTtcbiAgICAgIHJldHVybiAhY2gzIHx8IGNoMyA9PT0gJ1xcbicgfHwgY2gzID09PSAnXFx0JyB8fCBjaDMgPT09ICcgJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kT2ZJZGVudGlmaWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE9mSWRlbnRpZmllcihzcmMsIG9mZnNldCkge1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldF07XG4gICAgICB2YXIgaXNWZXJiYXRpbSA9IGNoID09PSAnPCc7XG4gICAgICB2YXIgbm90T2sgPSBpc1ZlcmJhdGltID8gWydcXG4nLCAnXFx0JywgJyAnLCAnPiddIDogWydcXG4nLCAnXFx0JywgJyAnLCAnWycsICddJywgJ3snLCAnfScsICcsJ107XG5cbiAgICAgIHdoaWxlIChjaCAmJiBub3RPay5pbmRleE9mKGNoKSA9PT0gLTEpIHtcbiAgICAgICAgY2ggPSBzcmNbb2Zmc2V0ICs9IDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNWZXJiYXRpbSAmJiBjaCA9PT0gJz4nKSBvZmZzZXQgKz0gMTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZE9mSW5kZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE9mSW5kZW50KHNyYywgb2Zmc2V0KSB7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgd2hpbGUgKGNoID09PSAnICcpIHtcbiAgICAgICAgY2ggPSBzcmNbb2Zmc2V0ICs9IDFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRPZkxpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2ZMaW5lKHNyYywgb2Zmc2V0KSB7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJykge1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXQgKz0gMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZE9mV2hpdGVTcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpIHtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgICB3aGlsZSAoY2ggPT09ICdcXHQnIHx8IGNoID09PSAnICcpIHtcbiAgICAgICAgY2ggPSBzcmNbb2Zmc2V0ICs9IDFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydE9mTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydE9mTGluZShzcmMsIG9mZnNldCkge1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldCAtIDFdO1xuICAgICAgaWYgKGNoID09PSAnXFxuJykgcmV0dXJuIG9mZnNldDtcblxuICAgICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJykge1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXQgLT0gMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmQgb2YgaW5kZW50YXRpb24sIG9yIG51bGwgaWYgdGhlIGxpbmUncyBpbmRlbnQgbGV2ZWwgaXMgbm90IG1vcmVcbiAgICAgKiB0aGFuIGBpbmRlbnRgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lU3RhcnRcbiAgICAgKiBAcmV0dXJucyB7P251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuZE9mQmxvY2tJbmRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2ZCbG9ja0luZGVudChzcmMsIGluZGVudCwgbGluZVN0YXJ0KSB7XG4gICAgICB2YXIgaW5FbmQgPSBOb2RlLmVuZE9mSW5kZW50KHNyYywgbGluZVN0YXJ0KTtcblxuICAgICAgaWYgKGluRW5kID4gbGluZVN0YXJ0ICsgaW5kZW50KSB7XG4gICAgICAgIHJldHVybiBpbkVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB3c0VuZCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgaW5FbmQpO1xuICAgICAgICB2YXIgY2ggPSBzcmNbd3NFbmRdO1xuICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxuJykgcmV0dXJuIHdzRW5kO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXRCbGFua1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdEJsYW5rKHNyYywgb2Zmc2V0LCBlbmRBc0JsYW5rKSB7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICAgIHJldHVybiBjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnICcgfHwgZW5kQXNCbGFuayAmJiAhY2g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHROb2RlSXNJbmRlbnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0Tm9kZUlzSW5kZW50ZWQoY2gsIGluZGVudERpZmYsIGluZGljYXRvckFzSW5kZW50KSB7XG4gICAgICBpZiAoIWNoIHx8IGluZGVudERpZmYgPCAwKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoaW5kZW50RGlmZiA+IDApIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGluZGljYXRvckFzSW5kZW50ICYmIGNoID09PSAnLSc7XG4gICAgfSAvLyBzaG91bGQgYmUgYXQgbGluZSBvciBzdHJpbmcgZW5kLCBvciBhdCBuZXh0IG5vbi13aGl0ZXNwYWNlIGNoYXJcblxuICB9LCB7XG4gICAga2V5OiBcIm5vcm1hbGl6ZU9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemVPZmZzZXQoc3JjLCBvZmZzZXQpIHtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuICAgICAgcmV0dXJuICFjaCA/IG9mZnNldCA6IGNoICE9PSAnXFxuJyAmJiBzcmNbb2Zmc2V0IC0gMV0gPT09ICdcXG4nID8gb2Zmc2V0IC0gMSA6IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICB9IC8vIGZvbGQgc2luZ2xlIG5ld2xpbmUgaW50byBzcGFjZSwgbXVsdGlwbGUgbmV3bGluZXMgdG8gTiAtIDEgbmV3bGluZXNcbiAgICAvLyBwcmVzdW1lcyBzcmNbb2Zmc2V0XSA9PT0gJ1xcbidcblxuICB9LCB7XG4gICAga2V5OiBcImZvbGROZXdsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbGROZXdsaW5lKHNyYywgb2Zmc2V0LCBpbmRlbnQpIHtcbiAgICAgIHZhciBpbkNvdW50ID0gMDtcbiAgICAgIHZhciBlcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGZvbGQgPSAnJztcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXQgKyAxXTtcblxuICAgICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnXFxuJykge1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgIGluQ291bnQgPSAwO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICBmb2xkICs9ICdcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgaWYgKGluQ291bnQgPD0gaW5kZW50KSBlcnJvciA9IHRydWU7XG4gICAgICAgICAgICBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCArIDIpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICBpbkNvdW50ICs9IDE7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2ggPSBzcmNbb2Zmc2V0ICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmICghZm9sZCkgZm9sZCA9ICcgJztcbiAgICAgIGlmIChjaCAmJiBpbkNvdW50IDw9IGluZGVudCkgZXJyb3IgPSB0cnVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9sZDogZm9sZCxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZTtcbn0oKTtcblxudmFyIFlBTUxFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhZQU1MRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihZQU1MRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFlBTUxFcnJvcihuYW1lLCBzb3VyY2UsIG1lc3NhZ2UpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWUFNTEVycm9yKTtcblxuICAgIGlmICghbWVzc2FnZSB8fCAhKHNvdXJjZSBpbnN0YW5jZW9mIE5vZGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgbmV3IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFlBTUxFcnJvciwgW3tcbiAgICBrZXk6IFwibWFrZVByZXR0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlUHJldHR5KCkge1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZSkgcmV0dXJuO1xuICAgICAgdGhpcy5ub2RlVHlwZSA9IHRoaXMuc291cmNlLnR5cGU7XG4gICAgICB2YXIgY3N0ID0gdGhpcy5zb3VyY2UuY29udGV4dCAmJiB0aGlzLnNvdXJjZS5jb250ZXh0LnJvb3Q7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSBuZXcgUmFuZ2UodGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgIHZhciBzdGFydCA9IGNzdCAmJiBnZXRMaW5lUG9zKHRoaXMub2Zmc2V0LCBjc3QpO1xuXG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgIHZhciBlbmQgPSB7XG4gICAgICAgICAgICBsaW5lOiBzdGFydC5saW5lLFxuICAgICAgICAgICAgY29sOiBzdGFydC5jb2wgKyAxXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmxpbmVQb3MgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5vZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5zb3VyY2UucmFuZ2U7XG4gICAgICAgIHRoaXMubGluZVBvcyA9IHRoaXMuc291cmNlLnJhbmdlQXNMaW5lUG9zO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5saW5lUG9zKSB7XG4gICAgICAgIHZhciBfdGhpcyRsaW5lUG9zJHN0YXJ0ID0gdGhpcy5saW5lUG9zLnN0YXJ0LFxuICAgICAgICAgICAgbGluZSA9IF90aGlzJGxpbmVQb3Mkc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNvbCA9IF90aGlzJGxpbmVQb3Mkc3RhcnQuY29sO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gXCIgYXQgbGluZSBcIi5jb25jYXQobGluZSwgXCIsIGNvbHVtbiBcIikuY29uY2F0KGNvbCk7XG4gICAgICAgIHZhciBjdHggPSBjc3QgJiYgZ2V0UHJldHR5Q29udGV4dCh0aGlzLmxpbmVQb3MsIGNzdCk7XG4gICAgICAgIGlmIChjdHgpIHRoaXMubWVzc2FnZSArPSBcIjpcXG5cXG5cIi5jb25jYXQoY3R4LCBcIlxcblwiKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRoaXMuc291cmNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBZQU1MRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xudmFyIFlBTUxSZWZlcmVuY2VFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1lBTUxFcnJvcikge1xuICBfaW5oZXJpdHMoWUFNTFJlZmVyZW5jZUVycm9yLCBfWUFNTEVycm9yKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihZQU1MUmVmZXJlbmNlRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFlBTUxSZWZlcmVuY2VFcnJvcihzb3VyY2UsIG1lc3NhZ2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWUFNTFJlZmVyZW5jZUVycm9yKTtcblxuICAgIHJldHVybiBfc3VwZXIyLmNhbGwodGhpcywgJ1lBTUxSZWZlcmVuY2VFcnJvcicsIHNvdXJjZSwgbWVzc2FnZSk7XG4gIH1cblxuICByZXR1cm4gWUFNTFJlZmVyZW5jZUVycm9yO1xufShZQU1MRXJyb3IpO1xudmFyIFlBTUxTZW1hbnRpY0Vycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfWUFNTEVycm9yMikge1xuICBfaW5oZXJpdHMoWUFNTFNlbWFudGljRXJyb3IsIF9ZQU1MRXJyb3IyKTtcblxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihZQU1MU2VtYW50aWNFcnJvcik7XG5cbiAgZnVuY3Rpb24gWUFNTFNlbWFudGljRXJyb3Ioc291cmNlLCBtZXNzYWdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBTUxTZW1hbnRpY0Vycm9yKTtcblxuICAgIHJldHVybiBfc3VwZXIzLmNhbGwodGhpcywgJ1lBTUxTZW1hbnRpY0Vycm9yJywgc291cmNlLCBtZXNzYWdlKTtcbiAgfVxuXG4gIHJldHVybiBZQU1MU2VtYW50aWNFcnJvcjtcbn0oWUFNTEVycm9yKTtcbnZhciBZQU1MU3ludGF4RXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9ZQU1MRXJyb3IzKSB7XG4gIF9pbmhlcml0cyhZQU1MU3ludGF4RXJyb3IsIF9ZQU1MRXJyb3IzKTtcblxuICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihZQU1MU3ludGF4RXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFlBTUxTeW50YXhFcnJvcihzb3VyY2UsIG1lc3NhZ2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWUFNTFN5bnRheEVycm9yKTtcblxuICAgIHJldHVybiBfc3VwZXI0LmNhbGwodGhpcywgJ1lBTUxTeW50YXhFcnJvcicsIHNvdXJjZSwgbWVzc2FnZSk7XG4gIH1cblxuICByZXR1cm4gWUFNTFN5bnRheEVycm9yO1xufShZQU1MRXJyb3IpO1xudmFyIFlBTUxXYXJuaW5nID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfWUFNTEVycm9yNCkge1xuICBfaW5oZXJpdHMoWUFNTFdhcm5pbmcsIF9ZQU1MRXJyb3I0KTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihZQU1MV2FybmluZyk7XG5cbiAgZnVuY3Rpb24gWUFNTFdhcm5pbmcoc291cmNlLCBtZXNzYWdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBTUxXYXJuaW5nKTtcblxuICAgIHJldHVybiBfc3VwZXI1LmNhbGwodGhpcywgJ1lBTUxXYXJuaW5nJywgc291cmNlLCBtZXNzYWdlKTtcbiAgfVxuXG4gIHJldHVybiBZQU1MV2FybmluZztcbn0oWUFNTEVycm9yKTtcblxudmFyIFBsYWluVmFsdWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhQbGFpblZhbHVlLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQbGFpblZhbHVlKTtcblxuICBmdW5jdGlvbiBQbGFpblZhbHVlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGFpblZhbHVlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQbGFpblZhbHVlLCBbe1xuICAgIGtleTogXCJzdHJWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLnZhbHVlUmFuZ2UgfHwgIXRoaXMuY29udGV4dCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgX3RoaXMkdmFsdWVSYW5nZSA9IHRoaXMudmFsdWVSYW5nZSxcbiAgICAgICAgICBzdGFydCA9IF90aGlzJHZhbHVlUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgZW5kID0gX3RoaXMkdmFsdWVSYW5nZS5lbmQ7XG4gICAgICB2YXIgc3JjID0gdGhpcy5jb250ZXh0LnNyYztcbiAgICAgIHZhciBjaCA9IHNyY1tlbmQgLSAxXTtcblxuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kICYmIChjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnICcpKSB7XG4gICAgICAgIGNoID0gc3JjWy0tZW5kIC0gMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIF9jaCA9IHNyY1tpXTtcblxuICAgICAgICBpZiAoX2NoID09PSAnXFxuJykge1xuICAgICAgICAgIHZhciBfTm9kZSRmb2xkTmV3bGluZSA9IE5vZGUuZm9sZE5ld2xpbmUoc3JjLCBpLCAtMSksXG4gICAgICAgICAgICAgIGZvbGQgPSBfTm9kZSRmb2xkTmV3bGluZS5mb2xkLFxuICAgICAgICAgICAgICBvZmZzZXQgPSBfTm9kZSRmb2xkTmV3bGluZS5vZmZzZXQ7XG5cbiAgICAgICAgICBzdHIgKz0gZm9sZDtcbiAgICAgICAgICBpID0gb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKF9jaCA9PT0gJyAnIHx8IF9jaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAvLyB0cmltIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICB2YXIgd3NTdGFydCA9IGk7XG4gICAgICAgICAgdmFyIG5leHQgPSBzcmNbaSArIDFdO1xuXG4gICAgICAgICAgd2hpbGUgKGkgPCBlbmQgJiYgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JykpIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIG5leHQgPSBzcmNbaSArIDFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0ICE9PSAnXFxuJykgc3RyICs9IGkgPiB3c1N0YXJ0ID8gc3JjLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IF9jaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gX2NoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjaDAgPSBzcmNbc3RhcnRdO1xuXG4gICAgICBzd2l0Y2ggKGNoMCkge1xuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnUGxhaW4gdmFsdWUgY2Fubm90IHN0YXJ0IHdpdGggYSB0YWIgY2hhcmFjdGVyJztcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbbmV3IFlBTUxTZW1hbnRpY0Vycm9yKHRoaXMsIG1zZyldO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICAgIHN0cjogc3RyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgY2FzZSAnYCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tc2cgPSBcIlBsYWluIHZhbHVlIGNhbm5vdCBzdGFydCB3aXRoIHJlc2VydmVkIGNoYXJhY3RlciBcIi5jb25jYXQoY2gwKTtcblxuICAgICAgICAgICAgdmFyIF9lcnJvcnMgPSBbbmV3IFlBTUxTZW1hbnRpY0Vycm9yKHRoaXMsIF9tc2cpXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVycm9yczogX2Vycm9ycyxcbiAgICAgICAgICAgICAgc3RyOiBzdHJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VCbG9ja1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQmxvY2tWYWx1ZShzdGFydCkge1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgaW5kZW50ID0gX3RoaXMkY29udGV4dC5pbmRlbnQsXG4gICAgICAgICAgaW5GbG93ID0gX3RoaXMkY29udGV4dC5pbkZsb3csXG4gICAgICAgICAgc3JjID0gX3RoaXMkY29udGV4dC5zcmM7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICB2YXIgdmFsdWVFbmQgPSBzdGFydDtcblxuICAgICAgZm9yICh2YXIgY2ggPSBzcmNbb2Zmc2V0XTsgY2ggPT09ICdcXG4nOyBjaCA9IHNyY1tvZmZzZXRdKSB7XG4gICAgICAgIGlmIChOb2RlLmF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIG9mZnNldCArIDEpKSBicmVhaztcbiAgICAgICAgdmFyIGVuZCA9IE5vZGUuZW5kT2ZCbG9ja0luZGVudChzcmMsIGluZGVudCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgIGlmIChlbmQgPT09IG51bGwgfHwgc3JjW2VuZF0gPT09ICcjJykgYnJlYWs7XG5cbiAgICAgICAgaWYgKHNyY1tlbmRdID09PSAnXFxuJykge1xuICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZUVuZCA9IFBsYWluVmFsdWUuZW5kT2ZMaW5lKHNyYywgZW5kLCBpbkZsb3cpO1xuICAgICAgICAgIG9mZnNldCA9IHZhbHVlRW5kO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZhbHVlUmFuZ2UuaXNFbXB0eSgpKSB0aGlzLnZhbHVlUmFuZ2Uuc3RhcnQgPSBzdGFydDtcbiAgICAgIHRoaXMudmFsdWVSYW5nZS5lbmQgPSB2YWx1ZUVuZDtcbiAgICAgIHJldHVybiB2YWx1ZUVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgcGxhaW4gdmFsdWUgZnJvbSB0aGUgc291cmNlXG4gICAgICpcbiAgICAgKiBBY2NlcHRlZCBmb3JtcyBhcmU6XG4gICAgICogYGBgXG4gICAgICogI2NvbW1lbnRcbiAgICAgKlxuICAgICAqIGZpcnN0IGxpbmVcbiAgICAgKlxuICAgICAqIGZpcnN0IGxpbmUgI2NvbW1lbnRcbiAgICAgKlxuICAgICAqIGZpcnN0IGxpbmVcbiAgICAgKiBibG9ja1xuICAgICAqIGxpbmVzXG4gICAgICpcbiAgICAgKiAjY29tbWVudFxuICAgICAqIGJsb2NrXG4gICAgICogbGluZXNcbiAgICAgKiBgYGBcbiAgICAgKiB3aGVyZSBibG9jayBsaW5lcyBhcmUgZW1wdHkgb3IgaGF2ZSBhbiBpbmRlbnQgbGV2ZWwgZ3JlYXRlciB0aGFuIGBpbmRlbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpcyBzY2FsYXIsIG1heSBiZSBgXFxuYFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB2YXIgaW5GbG93ID0gY29udGV4dC5pbkZsb3csXG4gICAgICAgICAgc3JjID0gY29udGV4dC5zcmM7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgaWYgKGNoICYmIGNoICE9PSAnIycgJiYgY2ggIT09ICdcXG4nKSB7XG4gICAgICAgIG9mZnNldCA9IFBsYWluVmFsdWUuZW5kT2ZMaW5lKHNyYywgc3RhcnQsIGluRmxvdyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCA9IHRoaXMucGFyc2VDb21tZW50KG9mZnNldCk7XG5cbiAgICAgIGlmICghdGhpcy5oYXNDb21tZW50IHx8IHRoaXMudmFsdWVSYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUJsb2NrVmFsdWUob2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJlbmRPZkxpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2ZMaW5lKHNyYywgc3RhcnQsIGluRmxvdykge1xuICAgICAgdmFyIGNoID0gc3JjW3N0YXJ0XTtcbiAgICAgIHZhciBvZmZzZXQgPSBzdGFydDtcblxuICAgICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJykge1xuICAgICAgICBpZiAoaW5GbG93ICYmIChjaCA9PT0gJ1snIHx8IGNoID09PSAnXScgfHwgY2ggPT09ICd7JyB8fCBjaCA9PT0gJ30nIHx8IGNoID09PSAnLCcpKSBicmVhaztcbiAgICAgICAgdmFyIG5leHQgPSBzcmNbb2Zmc2V0ICsgMV07XG4gICAgICAgIGlmIChjaCA9PT0gJzonICYmICghbmV4dCB8fCBuZXh0ID09PSAnXFxuJyB8fCBuZXh0ID09PSAnXFx0JyB8fCBuZXh0ID09PSAnICcgfHwgaW5GbG93ICYmIG5leHQgPT09ICcsJykpIGJyZWFrO1xuICAgICAgICBpZiAoKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSAmJiBuZXh0ID09PSAnIycpIGJyZWFrO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgY2ggPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQbGFpblZhbHVlO1xufShOb2RlKTtcblxuZXhwb3J0IHsgQ2hhciBhcyBDLCBOb2RlIGFzIE4sIFBsYWluVmFsdWUgYXMgUCwgUmFuZ2UgYXMgUiwgVHlwZSBhcyBULCBZQU1MU3ludGF4RXJyb3IgYXMgWSwgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIgYXMgXywgX3R5cGVvZiBhcyBhLCBfY3JlYXRlQ2xhc3MgYXMgYiwgX2NsYXNzQ2FsbENoZWNrIGFzIGMsIGRlZmF1bHRUYWdQcmVmaXggYXMgZCwgX2RlZmluZVByb3BlcnR5IGFzIGUsIFlBTUxXYXJuaW5nIGFzIGYsIFlBTUxTZW1hbnRpY0Vycm9yIGFzIGcsIF9zbGljZWRUb0FycmF5IGFzIGgsIFlBTUxFcnJvciBhcyBpLCBfaW5oZXJpdHMgYXMgaiwgX2NyZWF0ZVN1cGVyIGFzIGssIF9nZXQgYXMgbCwgX2dldFByb3RvdHlwZU9mIGFzIG0sIGRlZmF1bHRUYWdzIGFzIG4sIFlBTUxSZWZlcmVuY2VFcnJvciBhcyBvLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGFzIHAsIF90b0FycmF5IGFzIHEsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGFzIHIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\n")},"./node_modules/yaml/browser/dist/Schema-e94716c8.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"S\": () => (/* binding */ Schema)\n/* harmony export */ });\n/* harmony import */ var _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlainValue-b8036b75.js */ \"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\");\n/* harmony import */ var _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolveSeq-492ab440.js */ \"./node_modules/yaml/browser/dist/resolveSeq-492ab440.js\");\n/* harmony import */ var _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./warnings-df54cb69.js */ \"./node_modules/yaml/browser/dist/warnings-df54cb69.js\");\n\n\n\n\nfunction createMap(schema, obj, ctx) {\n  var map = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d(schema);\n\n  if (obj instanceof Map) {\n    var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(obj),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.h)(_step.value, 2),\n            key = _step$value[0],\n            value = _step$value[1];\n\n        map.items.push(schema.createPair(key, value, ctx));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (obj && (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(obj) === 'object') {\n    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n      var _key = _Object$keys[_i];\n      map.items.push(schema.createPair(_key, obj[_key], ctx));\n    }\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nvar map = {\n  createNode: createMap,\n  default: true,\n  nodeClass: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.g\n};\n\nfunction createSeq(schema, obj, ctx) {\n  var seq = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.Y(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(obj),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var it = _step.value;\n        var v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n        seq.items.push(v);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return seq;\n}\n\nvar seq = {\n  createNode: createSeq,\n  default: true,\n  nodeClass: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.Y,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.h\n};\n\nvar string = {\n  identify: function identify(value) {\n    return typeof value === 'string';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.j,\n  stringify: function stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.c)(item, ctx, onComment, onChompKeep);\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.s\n};\n\nvar failsafe = [map, seq, string];\n\n/* global BigInt */\n\nvar intIdentify$2 = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nvar intResolve$1 = function intResolve(src, part, radix) {\n  return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i.asBigInt ? BigInt(src) : parseInt(part, radix);\n};\n\nfunction intStringify$1(node, radix, prefix) {\n  var value = node.value;\n  if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);\n  return (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k)(node);\n}\n\nvar nullObj = {\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(null) : null;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: function resolve() {\n    return null;\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.n,\n  stringify: function stringify() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.n.nullStr;\n  }\n};\nvar boolObj = {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: function resolve(str) {\n    return str[0] === 't' || str[0] === 'T';\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a,\n  stringify: function stringify(_ref) {\n    var value = _ref.value;\n    return value ? _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a.trueStr : _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a.falseStr;\n  }\n};\nvar octObj = {\n  identify: function identify(value) {\n    return intIdentify$2(value) && value >= 0;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: function resolve(str, oct) {\n    return intResolve$1(str, oct, 8);\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i,\n  stringify: function stringify(node) {\n    return intStringify$1(node, 8, '0o');\n  }\n};\nvar intObj = {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return intResolve$1(str, str, 10);\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i,\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n};\nvar hexObj = {\n  identify: function identify(value) {\n    return intIdentify$2(value) && value >= 0;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: function resolve(str, hex) {\n    return intResolve$1(str, hex, 16);\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i,\n  stringify: function stringify(node) {\n    return intStringify$1(node, 16, '0x');\n  }\n};\nvar nanObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: function resolve(str, nan) {\n    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  },\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n};\nvar expObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return parseFloat(str);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return Number(value).toExponential();\n  }\n};\nvar floatObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n  resolve: function resolve(str, frac1, frac2) {\n    var frac = frac1 || frac2;\n    var node = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n};\nvar core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n\n/* global BigInt */\n\nvar intIdentify$1 = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nvar stringifyJSON = function stringifyJSON(_ref) {\n  var value = _ref.value;\n  return JSON.stringify(value);\n};\n\nvar json = [map, seq, {\n  identify: function identify(value) {\n    return typeof value === 'string';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.j,\n  stringify: stringifyJSON\n}, {\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(null) : null;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: function resolve() {\n    return null;\n  },\n  stringify: stringifyJSON\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: function resolve(str) {\n    return str === 'true';\n  },\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: function resolve(str) {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i.asBigInt ? BigInt(str) : parseInt(str, 10);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return intIdentify$1(value) ? value.toString() : JSON.stringify(value);\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: function resolve(str) {\n    return parseFloat(str);\n  },\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = function (str) {\n  throw new SyntaxError(\"Unresolved plain scalar \".concat(JSON.stringify(str)));\n};\n\n/* global BigInt */\n\nvar boolStringify = function boolStringify(_ref) {\n  var value = _ref.value;\n  return value ? _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a.trueStr : _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a.falseStr;\n};\n\nvar intIdentify = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nfunction intResolve(sign, src, radix) {\n  var str = src.replace(/_/g, '');\n\n  if (_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = \"0b\".concat(str);\n        break;\n\n      case 8:\n        str = \"0o\".concat(str);\n        break;\n\n      case 16:\n        str = \"0x\".concat(str);\n        break;\n    }\n\n    var _n = BigInt(str);\n\n    return sign === '-' ? BigInt(-1) * _n : _n;\n  }\n\n  var n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify(node, radix, prefix) {\n  var value = node.value;\n\n  if (intIdentify(value)) {\n    var str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k)(node);\n}\n\nvar yaml11 = failsafe.concat([{\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(null) : null;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: function resolve() {\n    return null;\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.n,\n  stringify: function stringify() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.n.nullStr;\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: function resolve() {\n    return true;\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a,\n  stringify: boolStringify\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: function resolve() {\n    return false;\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a,\n  stringify: boolStringify\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: function resolve(str, sign, bin) {\n    return intResolve(sign, bin, 2);\n  },\n  stringify: function stringify(node) {\n    return intStringify(node, 2, '0b');\n  }\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: function resolve(str, sign, oct) {\n    return intResolve(sign, oct, 8);\n  },\n  stringify: function stringify(node) {\n    return intStringify(node, 8, '0');\n  }\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: function resolve(str, sign, abs) {\n    return intResolve(sign, abs, 10);\n  },\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: function resolve(str, sign, hex) {\n    return intResolve(sign, hex, 16);\n  },\n  stringify: function stringify(node) {\n    return intStringify(node, 16, '0x');\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: function resolve(str, nan) {\n    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  },\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return parseFloat(str.replace(/_/g, ''));\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return Number(value).toExponential();\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n  resolve: function resolve(str, frac) {\n    var node = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      var f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n}], _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.b, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.o, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.p, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.s, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.i, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.f, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.t);\n\nvar schemas = {\n  core: core,\n  failsafe: failsafe,\n  json: json,\n  yaml11: yaml11\n};\nvar tags = {\n  binary: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.b,\n  bool: boolObj,\n  float: floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.f,\n  int: intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.i,\n  map: map,\n  null: nullObj,\n  omap: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.o,\n  pairs: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.p,\n  seq: seq,\n  set: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.s,\n  timestamp: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.t\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    var match = tags.filter(function (t) {\n      return t.tag === tagName;\n    });\n    var tagObj = match.find(function (t) {\n      return !t.format;\n    }) || match[0];\n    if (!tagObj) throw new Error(\"Tag \".concat(tagName, \" not found\"));\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(function (t) {\n    return (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format;\n  });\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.N) return value;\n  var defaultPrefix = ctx.defaultPrefix,\n      onTagObj = ctx.onTagObj,\n      prevObjects = ctx.prevObjects,\n      schema = ctx.schema,\n      wrapScalars = ctx.wrapScalars;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  var tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (!value || (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) !== 'object') return wrapScalars ? new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  var obj = {\n    value: undefined,\n    node: undefined\n  };\n\n  if (value && (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === 'object' && prevObjects) {\n    var prev = prevObjects.get(value);\n\n    if (prev) {\n      var alias = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.A(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(value) : value;\n  if (tagName && obj.node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.N) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  var tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    var keys = Object.keys(schemas).map(function (key) {\n      return JSON.stringify(key);\n    }).join(', ');\n    throw new Error(\"Unknown schema \\\"\".concat(schemaId, \"\\\"; use one of \").concat(keys));\n  }\n\n  if (Array.isArray(customTags)) {\n    var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(customTags),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var tag = _step.value;\n        tags = tags.concat(tag);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (var i = 0; i < tags.length; ++i) {\n    var _tag = tags[i];\n\n    if (typeof _tag === 'string') {\n      var tagObj = knownTags[_tag];\n\n      if (!tagObj) {\n        var _keys = Object.keys(knownTags).map(function (key) {\n          return JSON.stringify(key);\n        }).join(', ');\n\n        throw new Error(\"Unknown custom tag \\\"\".concat(_tag, \"\\\"; use one of \").concat(_keys));\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nvar sortMapEntriesByKey = function sortMapEntriesByKey(a, b) {\n  return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n};\n\nvar Schema = /*#__PURE__*/function () {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  function Schema(_ref) {\n    var customTags = _ref.customTags,\n        merge = _ref.merge,\n        schema = _ref.schema,\n        sortMapEntries = _ref.sortMapEntries,\n        deprecatedCustomTags = _ref.tags;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Schema);\n\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) (0,_warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.a)('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Schema, [{\n    key: \"createNode\",\n    value: function createNode$1(value, wrapScalars, tagName, ctx) {\n      var baseCtx = {\n        defaultPrefix: Schema.defaultPrefix,\n        schema: this,\n        wrapScalars: wrapScalars\n      };\n      var createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n      return createNode(value, tagName, createCtx);\n    }\n  }, {\n    key: \"createPair\",\n    value: function createPair(key, value, ctx) {\n      if (!ctx) ctx = {\n        wrapScalars: true\n      };\n      var k = this.createNode(key, ctx.wrapScalars, null, ctx);\n      var v = this.createNode(value, ctx.wrapScalars, null, ctx);\n      return new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P(k, v);\n    }\n  }]);\n\n  return Schema;\n}();\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Schema, \"defaultPrefix\", _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.d);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Schema, \"defaultTags\", _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvU2NoZW1hLWU5NDcxNmM4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc047QUFDdUU7QUFDN0g7O0FBRWhLO0FBQ0EsZ0JBQWdCLHNEQUFPOztBQUV2QjtBQUNBLG9CQUFvQiwwREFBMEI7QUFDOUM7O0FBRUE7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hELDBCQUEwQiwwREFBYztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUksZ0JBQWdCLDBEQUFPO0FBQzNCLHNEQUFzRCwwQkFBMEI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBTztBQUNwQjtBQUNBLFdBQVcsc0RBQVU7QUFDckI7O0FBRUE7QUFDQSxnQkFBZ0Isc0RBQU87O0FBRXZCO0FBQ0Esb0JBQW9CLDBEQUEwQjtBQUM5Qzs7QUFFQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBTztBQUNwQjtBQUNBLFdBQVcsc0RBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLHNEQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLDBEQUFlO0FBQzFCLEdBQUc7QUFDSCxXQUFXLHNEQUFVO0FBQ3JCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsK0RBQW1CO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQWU7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUNBQWlD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QUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQUk7QUFDckI7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCwwREFBZSwwQkFBMEIsc0RBQWdCOztBQUV6RCwwREFBZSx3QkFBd0Isc0RBQVc7O0FBRTNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9wLXh5ei8uL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9TY2hlbWEtZTk0NzE2YzguanM/NDNkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfIGFzIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyLCBoIGFzIF9zbGljZWRUb0FycmF5LCBhIGFzIF90eXBlb2YsIGIgYXMgX2NyZWF0ZUNsYXNzLCBlIGFzIF9kZWZpbmVQcm9wZXJ0eSwgYyBhcyBfY2xhc3NDYWxsQ2hlY2ssIGQgYXMgZGVmYXVsdFRhZ1ByZWZpeCwgbiBhcyBkZWZhdWx0VGFncyB9IGZyb20gJy4vUGxhaW5WYWx1ZS1iODAzNmI3NS5qcyc7XG5pbXBvcnQgeyBkIGFzIFlBTUxNYXAsIGcgYXMgcmVzb2x2ZU1hcCwgWSBhcyBZQU1MU2VxLCBoIGFzIHJlc29sdmVTZXEsIGogYXMgcmVzb2x2ZVN0cmluZywgYyBhcyBzdHJpbmdpZnlTdHJpbmcsIHMgYXMgc3RyT3B0aW9ucywgUyBhcyBTY2FsYXIsIG4gYXMgbnVsbE9wdGlvbnMsIGEgYXMgYm9vbE9wdGlvbnMsIGkgYXMgaW50T3B0aW9ucywgayBhcyBzdHJpbmdpZnlOdW1iZXIsIE4gYXMgTm9kZSwgQSBhcyBBbGlhcywgUCBhcyBQYWlyIH0gZnJvbSAnLi9yZXNvbHZlU2VxLTQ5MmFiNDQwLmpzJztcbmltcG9ydCB7IGIgYXMgYmluYXJ5LCBvIGFzIG9tYXAsIHAgYXMgcGFpcnMsIHMgYXMgc2V0LCBpIGFzIGludFRpbWUsIGYgYXMgZmxvYXRUaW1lLCB0IGFzIHRpbWVzdGFtcCwgYSBhcyB3YXJuT3B0aW9uRGVwcmVjYXRpb24gfSBmcm9tICcuL3dhcm5pbmdzLWRmNTRjYjY5LmpzJztcblxuZnVuY3Rpb24gY3JlYXRlTWFwKHNjaGVtYSwgb2JqLCBjdHgpIHtcbiAgdmFyIG1hcCA9IG5ldyBZQU1MTWFwKHNjaGVtYSk7XG5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvYmopLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICBrZXkgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgICAgbWFwLml0ZW1zLnB1c2goc2NoZW1hLmNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgY3R4KSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvYmogJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMob2JqKTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IF9PYmplY3Qka2V5c1tfaV07XG4gICAgICBtYXAuaXRlbXMucHVzaChzY2hlbWEuY3JlYXRlUGFpcihfa2V5LCBvYmpbX2tleV0sIGN0eCkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2NoZW1hLnNvcnRNYXBFbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWFwLml0ZW1zLnNvcnQoc2NoZW1hLnNvcnRNYXBFbnRyaWVzKTtcbiAgfVxuXG4gIHJldHVybiBtYXA7XG59XG5cbnZhciBtYXAgPSB7XG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZU1hcCxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgbm9kZUNsYXNzOiBZQU1MTWFwLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLFxuICByZXNvbHZlOiByZXNvbHZlTWFwXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTZXEoc2NoZW1hLCBvYmosIGN0eCkge1xuICB2YXIgc2VxID0gbmV3IFlBTUxTZXEoc2NoZW1hKTtcblxuICBpZiAob2JqICYmIG9ialtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG9iaiksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBpdCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgdiA9IHNjaGVtYS5jcmVhdGVOb2RlKGl0LCBjdHgud3JhcFNjYWxhcnMsIG51bGwsIGN0eCk7XG4gICAgICAgIHNlcS5pdGVtcy5wdXNoKHYpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VxO1xufVxuXG52YXIgc2VxID0ge1xuICBjcmVhdGVOb2RlOiBjcmVhdGVTZXEsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIG5vZGVDbGFzczogWUFNTFNlcSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVNlcVxufTtcblxudmFyIHN0cmluZyA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gIHJlc29sdmU6IHJlc29sdmVTdHJpbmcsXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYWN0dWFsU3RyaW5nOiB0cnVlXG4gICAgfSwgY3R4KTtcbiAgICByZXR1cm4gc3RyaW5naWZ5U3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIH0sXG4gIG9wdGlvbnM6IHN0ck9wdGlvbnNcbn07XG5cbnZhciBmYWlsc2FmZSA9IFttYXAsIHNlcSwgc3RyaW5nXTtcblxuLyogZ2xvYmFsIEJpZ0ludCAqL1xuXG52YXIgaW50SWRlbnRpZnkkMiA9IGZ1bmN0aW9uIGludElkZW50aWZ5KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufTtcblxudmFyIGludFJlc29sdmUkMSA9IGZ1bmN0aW9uIGludFJlc29sdmUoc3JjLCBwYXJ0LCByYWRpeCkge1xuICByZXR1cm4gaW50T3B0aW9ucy5hc0JpZ0ludCA/IEJpZ0ludChzcmMpIDogcGFyc2VJbnQocGFydCwgcmFkaXgpO1xufTtcblxuZnVuY3Rpb24gaW50U3RyaW5naWZ5JDEobm9kZSwgcmFkaXgsIHByZWZpeCkge1xuICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlO1xuICBpZiAoaW50SWRlbnRpZnkkMih2YWx1ZSkgJiYgdmFsdWUgPj0gMCkgcmV0dXJuIHByZWZpeCArIHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgcmV0dXJuIHN0cmluZ2lmeU51bWJlcihub2RlKTtcbn1cblxudmFyIG51bGxPYmogPSB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICB9LFxuICBjcmVhdGVOb2RlOiBmdW5jdGlvbiBjcmVhdGVOb2RlKHNjaGVtYSwgdmFsdWUsIGN0eCkge1xuICAgIHJldHVybiBjdHgud3JhcFNjYWxhcnMgPyBuZXcgU2NhbGFyKG51bGwpIDogbnVsbDtcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsXG4gIHRlc3Q6IC9eKD86fnxbTm5ddWxsfE5VTEwpPyQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBvcHRpb25zOiBudWxsT3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgcmV0dXJuIG51bGxPcHRpb25zLm51bGxTdHI7XG4gIH1cbn07XG52YXIgYm9vbE9iaiA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgdGVzdDogL14oPzpbVHRdcnVlfFRSVUV8W0ZmXWFsc2V8RkFMU0UpJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyKSB7XG4gICAgcmV0dXJuIHN0clswXSA9PT0gJ3QnIHx8IHN0clswXSA9PT0gJ1QnO1xuICB9LFxuICBvcHRpb25zOiBib29sT3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoX3JlZikge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlID8gYm9vbE9wdGlvbnMudHJ1ZVN0ciA6IGJvb2xPcHRpb25zLmZhbHNlU3RyO1xuICB9XG59O1xudmFyIG9jdE9iaiA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludElkZW50aWZ5JDIodmFsdWUpICYmIHZhbHVlID49IDA7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ09DVCcsXG4gIHRlc3Q6IC9eMG8oWzAtN10rKSQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0ciwgb2N0KSB7XG4gICAgcmV0dXJuIGludFJlc29sdmUkMShzdHIsIG9jdCwgOCk7XG4gIH0sXG4gIG9wdGlvbnM6IGludE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUpIHtcbiAgICByZXR1cm4gaW50U3RyaW5naWZ5JDEobm9kZSwgOCwgJzBvJyk7XG4gIH1cbn07XG52YXIgaW50T2JqID0ge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnkkMixcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgdGVzdDogL15bLStdP1swLTldKyQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0cikge1xuICAgIHJldHVybiBpbnRSZXNvbHZlJDEoc3RyLCBzdHIsIDEwKTtcbiAgfSxcbiAgb3B0aW9uczogaW50T3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG52YXIgaGV4T2JqID0ge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gaW50SWRlbnRpZnkkMih2YWx1ZSkgJiYgdmFsdWUgPj0gMDtcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgZm9ybWF0OiAnSEVYJyxcbiAgdGVzdDogL14weChbMC05YS1mQS1GXSspJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyLCBoZXgpIHtcbiAgICByZXR1cm4gaW50UmVzb2x2ZSQxKHN0ciwgaGV4LCAxNik7XG4gIH0sXG4gIG9wdGlvbnM6IGludE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUpIHtcbiAgICByZXR1cm4gaW50U3RyaW5naWZ5JDEobm9kZSwgMTYsICcweCcpO1xuICB9XG59O1xudmFyIG5hbk9iaiA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgdGVzdDogL14oPzpbLStdP1xcLmluZnwoXFwubmFuKSkkL2ksXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyLCBuYW4pIHtcbiAgICByZXR1cm4gbmFuID8gTmFOIDogc3RyWzBdID09PSAnLScgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIH0sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xudmFyIGV4cE9iaiA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgZm9ybWF0OiAnRVhQJyxcbiAgdGVzdDogL15bLStdPyg/OlxcLlswLTldK3xbMC05XSsoPzpcXC5bMC05XSopPylbZUVdWy0rXT9bMC05XSskLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICB9LFxuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShfcmVmMikge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpLnRvRXhwb25lbnRpYWwoKTtcbiAgfVxufTtcbnZhciBmbG9hdE9iaiA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgdGVzdDogL15bLStdPyg/OlxcLihbMC05XSspfFswLTldK1xcLihbMC05XSopKSQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0ciwgZnJhYzEsIGZyYWMyKSB7XG4gICAgdmFyIGZyYWMgPSBmcmFjMSB8fCBmcmFjMjtcbiAgICB2YXIgbm9kZSA9IG5ldyBTY2FsYXIocGFyc2VGbG9hdChzdHIpKTtcbiAgICBpZiAoZnJhYyAmJiBmcmFjW2ZyYWMubGVuZ3RoIC0gMV0gPT09ICcwJykgbm9kZS5taW5GcmFjdGlvbkRpZ2l0cyA9IGZyYWMubGVuZ3RoO1xuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbnZhciBjb3JlID0gZmFpbHNhZmUuY29uY2F0KFtudWxsT2JqLCBib29sT2JqLCBvY3RPYmosIGludE9iaiwgaGV4T2JqLCBuYW5PYmosIGV4cE9iaiwgZmxvYXRPYmpdKTtcblxuLyogZ2xvYmFsIEJpZ0ludCAqL1xuXG52YXIgaW50SWRlbnRpZnkkMSA9IGZ1bmN0aW9uIGludElkZW50aWZ5KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufTtcblxudmFyIHN0cmluZ2lmeUpTT04gPSBmdW5jdGlvbiBzdHJpbmdpZnlKU09OKF9yZWYpIHtcbiAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbn07XG5cbnZhciBqc29uID0gW21hcCwgc2VxLCB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLFxuICByZXNvbHZlOiByZXNvbHZlU3RyaW5nLFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbn0sIHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gIH0sXG4gIGNyZWF0ZU5vZGU6IGZ1bmN0aW9uIGNyZWF0ZU5vZGUoc2NoZW1hLCB2YWx1ZSwgY3R4KSB7XG4gICAgcmV0dXJuIGN0eC53cmFwU2NhbGFycyA/IG5ldyBTY2FsYXIobnVsbCkgOiBudWxsO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgdGVzdDogL15udWxsJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxufSwge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICB0ZXN0OiAvXnRydWV8ZmFsc2UkLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyID09PSAndHJ1ZSc7XG4gIH0sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxufSwge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnkkMSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgdGVzdDogL14tPyg/OjB8WzEtOV1bMC05XSopJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyKSB7XG4gICAgcmV0dXJuIGludE9wdGlvbnMuYXNCaWdJbnQgPyBCaWdJbnQoc3RyKSA6IHBhcnNlSW50KHN0ciwgMTApO1xuICB9LFxuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShfcmVmMikge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICAgIHJldHVybiBpbnRJZGVudGlmeSQxKHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH1cbn0sIHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgdGVzdDogL14tPyg/OjB8WzEtOV1bMC05XSopKD86XFwuWzAtOV0qKT8oPzpbZUVdWy0rXT9bMC05XSspPyQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0cikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gIH0sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxufV07XG5cbmpzb24uc2NhbGFyRmFsbGJhY2sgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVucmVzb2x2ZWQgcGxhaW4gc2NhbGFyIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShzdHIpKSk7XG59O1xuXG4vKiBnbG9iYWwgQmlnSW50ICovXG5cbnZhciBib29sU3RyaW5naWZ5ID0gZnVuY3Rpb24gYm9vbFN0cmluZ2lmeShfcmVmKSB7XG4gIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gIHJldHVybiB2YWx1ZSA/IGJvb2xPcHRpb25zLnRydWVTdHIgOiBib29sT3B0aW9ucy5mYWxzZVN0cjtcbn07XG5cbnZhciBpbnRJZGVudGlmeSA9IGZ1bmN0aW9uIGludElkZW50aWZ5KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufTtcblxuZnVuY3Rpb24gaW50UmVzb2x2ZShzaWduLCBzcmMsIHJhZGl4KSB7XG4gIHZhciBzdHIgPSBzcmMucmVwbGFjZSgvXy9nLCAnJyk7XG5cbiAgaWYgKGludE9wdGlvbnMuYXNCaWdJbnQpIHtcbiAgICBzd2l0Y2ggKHJhZGl4KSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHN0ciA9IFwiMGJcIi5jb25jYXQoc3RyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgODpcbiAgICAgICAgc3RyID0gXCIwb1wiLmNvbmNhdChzdHIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxNjpcbiAgICAgICAgc3RyID0gXCIweFwiLmNvbmNhdChzdHIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgX24gPSBCaWdJbnQoc3RyKTtcblxuICAgIHJldHVybiBzaWduID09PSAnLScgPyBCaWdJbnQoLTEpICogX24gOiBfbjtcbiAgfVxuXG4gIHZhciBuID0gcGFyc2VJbnQoc3RyLCByYWRpeCk7XG4gIHJldHVybiBzaWduID09PSAnLScgPyAtMSAqIG4gOiBuO1xufVxuXG5mdW5jdGlvbiBpbnRTdHJpbmdpZnkobm9kZSwgcmFkaXgsIHByZWZpeCkge1xuICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlO1xuXG4gIGlmIChpbnRJZGVudGlmeSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyID0gdmFsdWUudG9TdHJpbmcocmFkaXgpO1xuICAgIHJldHVybiB2YWx1ZSA8IDAgPyAnLScgKyBwcmVmaXggKyBzdHIuc3Vic3RyKDEpIDogcHJlZml4ICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeU51bWJlcihub2RlKTtcbn1cblxudmFyIHlhbWwxMSA9IGZhaWxzYWZlLmNvbmNhdChbe1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgfSxcbiAgY3JlYXRlTm9kZTogZnVuY3Rpb24gY3JlYXRlTm9kZShzY2hlbWEsIHZhbHVlLCBjdHgpIHtcbiAgICByZXR1cm4gY3R4LndyYXBTY2FsYXJzID8gbmV3IFNjYWxhcihudWxsKSA6IG51bGw7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICB0ZXN0OiAvXig/On58W05uXXVsbHxOVUxMKT8kLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgb3B0aW9uczogbnVsbE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KCkge1xuICAgIHJldHVybiBudWxsT3B0aW9ucy5udWxsU3RyO1xuICB9XG59LCB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gIHRlc3Q6IC9eKD86WXx5fFtZeV1lc3xZRVN8W1R0XXJ1ZXxUUlVFfFtPb11ufE9OKSQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBvcHRpb25zOiBib29sT3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59LCB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gIHRlc3Q6IC9eKD86TnxufFtObl1vfE5PfFtGZl1hbHNlfEZBTFNFfFtPb11mZnxPRkYpJC9pLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgb3B0aW9uczogYm9vbE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogYm9vbFN0cmluZ2lmeVxufSwge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ0JJTicsXG4gIHRlc3Q6IC9eKFstK10/KTBiKFswLTFfXSspJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyLCBzaWduLCBiaW4pIHtcbiAgICByZXR1cm4gaW50UmVzb2x2ZShzaWduLCBiaW4sIDIpO1xuICB9LFxuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlKSB7XG4gICAgcmV0dXJuIGludFN0cmluZ2lmeShub2RlLCAyLCAnMGInKTtcbiAgfVxufSwge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ09DVCcsXG4gIHRlc3Q6IC9eKFstK10/KTAoWzAtN19dKykkLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIsIHNpZ24sIG9jdCkge1xuICAgIHJldHVybiBpbnRSZXNvbHZlKHNpZ24sIG9jdCwgOCk7XG4gIH0sXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUpIHtcbiAgICByZXR1cm4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwJyk7XG4gIH1cbn0sIHtcbiAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICB0ZXN0OiAvXihbLStdPykoWzAtOV1bMC05X10qKSQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0ciwgc2lnbiwgYWJzKSB7XG4gICAgcmV0dXJuIGludFJlc29sdmUoc2lnbiwgYWJzLCAxMCk7XG4gIH0sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59LCB7XG4gIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgZm9ybWF0OiAnSEVYJyxcbiAgdGVzdDogL14oWy0rXT8pMHgoWzAtOWEtZkEtRl9dKykkLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIsIHNpZ24sIGhleCkge1xuICAgIHJldHVybiBpbnRSZXNvbHZlKHNpZ24sIGhleCwgMTYpO1xuICB9LFxuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlKSB7XG4gICAgcmV0dXJuIGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jyk7XG4gIH1cbn0sIHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgdGVzdDogL14oPzpbLStdP1xcLmluZnwoXFwubmFuKSkkL2ksXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyLCBuYW4pIHtcbiAgICByZXR1cm4gbmFuID8gTmFOIDogc3RyWzBdID09PSAnLScgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIH0sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59LCB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIGZvcm1hdDogJ0VYUCcsXG4gIHRlc3Q6IC9eWy0rXT8oWzAtOV1bMC05X10qKT8oXFwuWzAtOV9dKik/W2VFXVstK10/WzAtOV0rJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoL18vZywgJycpKTtcbiAgfSxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoX3JlZjIpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKS50b0V4cG9uZW50aWFsKCk7XG4gIH1cbn0sIHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/XFwuKFswLTlfXSopJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyLCBmcmFjKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgU2NhbGFyKHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoL18vZywgJycpKSk7XG5cbiAgICBpZiAoZnJhYykge1xuICAgICAgdmFyIGYgPSBmcmFjLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgaWYgKGZbZi5sZW5ndGggLSAxXSA9PT0gJzAnKSBub2RlLm1pbkZyYWN0aW9uRGlnaXRzID0gZi5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59XSwgYmluYXJ5LCBvbWFwLCBwYWlycywgc2V0LCBpbnRUaW1lLCBmbG9hdFRpbWUsIHRpbWVzdGFtcCk7XG5cbnZhciBzY2hlbWFzID0ge1xuICBjb3JlOiBjb3JlLFxuICBmYWlsc2FmZTogZmFpbHNhZmUsXG4gIGpzb246IGpzb24sXG4gIHlhbWwxMTogeWFtbDExXG59O1xudmFyIHRhZ3MgPSB7XG4gIGJpbmFyeTogYmluYXJ5LFxuICBib29sOiBib29sT2JqLFxuICBmbG9hdDogZmxvYXRPYmosXG4gIGZsb2F0RXhwOiBleHBPYmosXG4gIGZsb2F0TmFOOiBuYW5PYmosXG4gIGZsb2F0VGltZTogZmxvYXRUaW1lLFxuICBpbnQ6IGludE9iaixcbiAgaW50SGV4OiBoZXhPYmosXG4gIGludE9jdDogb2N0T2JqLFxuICBpbnRUaW1lOiBpbnRUaW1lLFxuICBtYXA6IG1hcCxcbiAgbnVsbDogbnVsbE9iaixcbiAgb21hcDogb21hcCxcbiAgcGFpcnM6IHBhaXJzLFxuICBzZXE6IHNlcSxcbiAgc2V0OiBzZXQsXG4gIHRpbWVzdGFtcDogdGltZXN0YW1wXG59O1xuXG5mdW5jdGlvbiBmaW5kVGFnT2JqZWN0KHZhbHVlLCB0YWdOYW1lLCB0YWdzKSB7XG4gIGlmICh0YWdOYW1lKSB7XG4gICAgdmFyIG1hdGNoID0gdGFncy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0LnRhZyA9PT0gdGFnTmFtZTtcbiAgICB9KTtcbiAgICB2YXIgdGFnT2JqID0gbWF0Y2guZmluZChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICF0LmZvcm1hdDtcbiAgICB9KSB8fCBtYXRjaFswXTtcbiAgICBpZiAoIXRhZ09iaikgdGhyb3cgbmV3IEVycm9yKFwiVGFnIFwiLmNvbmNhdCh0YWdOYW1lLCBcIiBub3QgZm91bmRcIikpO1xuICAgIHJldHVybiB0YWdPYmo7XG4gIH0gLy8gVE9ETzogZGVwcmVjYXRlL3JlbW92ZSBjbGFzcyBjaGVja1xuXG5cbiAgcmV0dXJuIHRhZ3MuZmluZChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAodC5pZGVudGlmeSAmJiB0LmlkZW50aWZ5KHZhbHVlKSB8fCB0LmNsYXNzICYmIHZhbHVlIGluc3RhbmNlb2YgdC5jbGFzcykgJiYgIXQuZm9ybWF0O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZSh2YWx1ZSwgdGFnTmFtZSwgY3R4KSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHJldHVybiB2YWx1ZTtcbiAgdmFyIGRlZmF1bHRQcmVmaXggPSBjdHguZGVmYXVsdFByZWZpeCxcbiAgICAgIG9uVGFnT2JqID0gY3R4Lm9uVGFnT2JqLFxuICAgICAgcHJldk9iamVjdHMgPSBjdHgucHJldk9iamVjdHMsXG4gICAgICBzY2hlbWEgPSBjdHguc2NoZW1hLFxuICAgICAgd3JhcFNjYWxhcnMgPSBjdHgud3JhcFNjYWxhcnM7XG4gIGlmICh0YWdOYW1lICYmIHRhZ05hbWUuc3RhcnRzV2l0aCgnISEnKSkgdGFnTmFtZSA9IGRlZmF1bHRQcmVmaXggKyB0YWdOYW1lLnNsaWNlKDIpO1xuICB2YXIgdGFnT2JqID0gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgc2NoZW1hLnRhZ3MpO1xuXG4gIGlmICghdGFnT2JqKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHZhbHVlID0gdmFsdWUudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSB8fCBfdHlwZW9mKHZhbHVlKSAhPT0gJ29iamVjdCcpIHJldHVybiB3cmFwU2NhbGFycyA/IG5ldyBTY2FsYXIodmFsdWUpIDogdmFsdWU7XG4gICAgdGFnT2JqID0gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBtYXAgOiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdID8gc2VxIDogbWFwO1xuICB9XG5cbiAgaWYgKG9uVGFnT2JqKSB7XG4gICAgb25UYWdPYmoodGFnT2JqKTtcbiAgICBkZWxldGUgY3R4Lm9uVGFnT2JqO1xuICB9IC8vIERldGVjdCBkdXBsaWNhdGUgcmVmZXJlbmNlcyB0byB0aGUgc2FtZSBvYmplY3QgJiB1c2UgQWxpYXMgbm9kZXMgZm9yIGFsbFxuICAvLyBhZnRlciBmaXJzdC4gVGhlIGBvYmpgIHdyYXBwZXIgYWxsb3dzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHJlc29sdmUuXG5cblxuICB2YXIgb2JqID0ge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgbm9kZTogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKHZhbHVlICYmIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiBwcmV2T2JqZWN0cykge1xuICAgIHZhciBwcmV2ID0gcHJldk9iamVjdHMuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChwcmV2KSB7XG4gICAgICB2YXIgYWxpYXMgPSBuZXcgQWxpYXMocHJldik7IC8vIGxlYXZlcyBzb3VyY2UgZGlydHk7IG11c3QgYmUgY2xlYW5lZCBieSBjYWxsZXJcblxuICAgICAgY3R4LmFsaWFzTm9kZXMucHVzaChhbGlhcyk7IC8vIGRlZmluZWQgYWxvbmcgd2l0aCBwcmV2T2JqZWN0c1xuXG4gICAgICByZXR1cm4gYWxpYXM7XG4gICAgfVxuXG4gICAgb2JqLnZhbHVlID0gdmFsdWU7XG4gICAgcHJldk9iamVjdHMuc2V0KHZhbHVlLCBvYmopO1xuICB9XG5cbiAgb2JqLm5vZGUgPSB0YWdPYmouY3JlYXRlTm9kZSA/IHRhZ09iai5jcmVhdGVOb2RlKGN0eC5zY2hlbWEsIHZhbHVlLCBjdHgpIDogd3JhcFNjYWxhcnMgPyBuZXcgU2NhbGFyKHZhbHVlKSA6IHZhbHVlO1xuICBpZiAodGFnTmFtZSAmJiBvYmoubm9kZSBpbnN0YW5jZW9mIE5vZGUpIG9iai5ub2RlLnRhZyA9IHRhZ05hbWU7XG4gIHJldHVybiBvYmoubm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0U2NoZW1hVGFncyhzY2hlbWFzLCBrbm93blRhZ3MsIGN1c3RvbVRhZ3MsIHNjaGVtYUlkKSB7XG4gIHZhciB0YWdzID0gc2NoZW1hc1tzY2hlbWFJZC5yZXBsYWNlKC9cXFcvZywgJycpXTsgLy8gJ3lhbWwtMS4xJyAtPiAneWFtbDExJ1xuXG4gIGlmICghdGFncykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgIH0pLmpvaW4oJywgJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzY2hlbWEgXFxcIlwiLmNvbmNhdChzY2hlbWFJZCwgXCJcXFwiOyB1c2Ugb25lIG9mIFwiKS5jb25jYXQoa2V5cykpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VzdG9tVGFncykpIHtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY3VzdG9tVGFncyksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciB0YWcgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgdGFncyA9IHRhZ3MuY29uY2F0KHRhZyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgY3VzdG9tVGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRhZ3MgPSBjdXN0b21UYWdzKHRhZ3Muc2xpY2UoKSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgX3RhZyA9IHRhZ3NbaV07XG5cbiAgICBpZiAodHlwZW9mIF90YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgdGFnT2JqID0ga25vd25UYWdzW190YWddO1xuXG4gICAgICBpZiAoIXRhZ09iaikge1xuICAgICAgICB2YXIgX2tleXMgPSBPYmplY3Qua2V5cyhrbm93blRhZ3MpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjdXN0b20gdGFnIFxcXCJcIi5jb25jYXQoX3RhZywgXCJcXFwiOyB1c2Ugb25lIG9mIFwiKS5jb25jYXQoX2tleXMpKTtcbiAgICAgIH1cblxuICAgICAgdGFnc1tpXSA9IHRhZ09iajtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFncztcbn1cblxudmFyIHNvcnRNYXBFbnRyaWVzQnlLZXkgPSBmdW5jdGlvbiBzb3J0TWFwRW50cmllc0J5S2V5KGEsIGIpIHtcbiAgcmV0dXJuIGEua2V5IDwgYi5rZXkgPyAtMSA6IGEua2V5ID4gYi5rZXkgPyAxIDogMDtcbn07XG5cbnZhciBTY2hlbWEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBUT0RPOiByZW1vdmUgaW4gdjJcbiAgLy8gVE9ETzogcmVtb3ZlIGluIHYyXG4gIGZ1bmN0aW9uIFNjaGVtYShfcmVmKSB7XG4gICAgdmFyIGN1c3RvbVRhZ3MgPSBfcmVmLmN1c3RvbVRhZ3MsXG4gICAgICAgIG1lcmdlID0gX3JlZi5tZXJnZSxcbiAgICAgICAgc2NoZW1hID0gX3JlZi5zY2hlbWEsXG4gICAgICAgIHNvcnRNYXBFbnRyaWVzID0gX3JlZi5zb3J0TWFwRW50cmllcyxcbiAgICAgICAgZGVwcmVjYXRlZEN1c3RvbVRhZ3MgPSBfcmVmLnRhZ3M7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NoZW1hKTtcblxuICAgIHRoaXMubWVyZ2UgPSAhIW1lcmdlO1xuICAgIHRoaXMubmFtZSA9IHNjaGVtYTtcbiAgICB0aGlzLnNvcnRNYXBFbnRyaWVzID0gc29ydE1hcEVudHJpZXMgPT09IHRydWUgPyBzb3J0TWFwRW50cmllc0J5S2V5IDogc29ydE1hcEVudHJpZXMgfHwgbnVsbDtcbiAgICBpZiAoIWN1c3RvbVRhZ3MgJiYgZGVwcmVjYXRlZEN1c3RvbVRhZ3MpIHdhcm5PcHRpb25EZXByZWNhdGlvbigndGFncycsICdjdXN0b21UYWdzJyk7XG4gICAgdGhpcy50YWdzID0gZ2V0U2NoZW1hVGFncyhzY2hlbWFzLCB0YWdzLCBjdXN0b21UYWdzIHx8IGRlcHJlY2F0ZWRDdXN0b21UYWdzLCBzY2hlbWEpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNjaGVtYSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVOb2RlJDEodmFsdWUsIHdyYXBTY2FsYXJzLCB0YWdOYW1lLCBjdHgpIHtcbiAgICAgIHZhciBiYXNlQ3R4ID0ge1xuICAgICAgICBkZWZhdWx0UHJlZml4OiBTY2hlbWEuZGVmYXVsdFByZWZpeCxcbiAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICB3cmFwU2NhbGFyczogd3JhcFNjYWxhcnNcbiAgICAgIH07XG4gICAgICB2YXIgY3JlYXRlQ3R4ID0gY3R4ID8gT2JqZWN0LmFzc2lnbihjdHgsIGJhc2VDdHgpIDogYmFzZUN0eDtcbiAgICAgIHJldHVybiBjcmVhdGVOb2RlKHZhbHVlLCB0YWdOYW1lLCBjcmVhdGVDdHgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVQYWlyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgY3R4KSB7XG4gICAgICBpZiAoIWN0eCkgY3R4ID0ge1xuICAgICAgICB3cmFwU2NhbGFyczogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHZhciBrID0gdGhpcy5jcmVhdGVOb2RlKGtleSwgY3R4LndyYXBTY2FsYXJzLCBudWxsLCBjdHgpO1xuICAgICAgdmFyIHYgPSB0aGlzLmNyZWF0ZU5vZGUodmFsdWUsIGN0eC53cmFwU2NhbGFycywgbnVsbCwgY3R4KTtcbiAgICAgIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2NoZW1hO1xufSgpO1xuXG5fZGVmaW5lUHJvcGVydHkoU2NoZW1hLCBcImRlZmF1bHRQcmVmaXhcIiwgZGVmYXVsdFRhZ1ByZWZpeCk7XG5cbl9kZWZpbmVQcm9wZXJ0eShTY2hlbWEsIFwiZGVmYXVsdFRhZ3NcIiwgZGVmYXVsdFRhZ3MpO1xuXG5leHBvcnQgeyBTY2hlbWEgYXMgUyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/Schema-e94716c8.js\n")},"./node_modules/yaml/browser/dist/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"YAML\": () => (/* binding */ YAML)\n/* harmony export */ });\n/* harmony import */ var _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlainValue-b8036b75.js */ \"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\");\n/* harmony import */ var _parse_cst_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse-cst.js */ \"./node_modules/yaml/browser/dist/parse-cst.js\");\n/* harmony import */ var _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resolveSeq-492ab440.js */ \"./node_modules/yaml/browser/dist/resolveSeq-492ab440.js\");\n/* harmony import */ var _Schema_e94716c8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Schema-e94716c8.js */ \"./node_modules/yaml/browser/dist/Schema-e94716c8.js\");\n/* harmony import */ var _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./warnings-df54cb69.js */ \"./node_modules/yaml/browser/dist/warnings-df54cb69.js\");\n\n\n\n\n\n\nvar defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nvar scalarOptions = {\n  get binary() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.b;\n  },\n\n  set binary(opt) {\n    Object.assign(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.b, opt);\n  },\n\n  get bool() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.a;\n  },\n\n  set bool(opt) {\n    Object.assign(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.a, opt);\n  },\n\n  get int() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.i;\n  },\n\n  set int(opt) {\n    Object.assign(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.i, opt);\n  },\n\n  get null() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.n;\n  },\n\n  set null(opt) {\n    Object.assign(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.n, opt);\n  },\n\n  get str() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.s;\n  },\n\n  set str(opt) {\n    Object.assign(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.s, opt);\n  }\n\n};\nvar documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.d\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.d\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.d\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    var priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? \"!\".concat(vocab[1], \"/\").concat(vocab[2]) : \"!\".concat(tag.replace(/^tag:/, ''));\n  }\n\n  var p = doc.tagPrefixes.find(function (p) {\n    return tag.indexOf(p.prefix) === 0;\n  });\n\n  if (!p) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(function (p) {\n      return tag.indexOf(p.prefix) === 0;\n    });\n  }\n\n  if (!p) return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  var suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, function (ch) {\n    return {\n      '!': '%21',\n      ',': '%2C',\n      '[': '%5B',\n      ']': '%5D',\n      '{': '%7B',\n      '}': '%7D'\n    }[ch];\n  });\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.A) return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.A;\n\n  if (item.tag) {\n    var match = tags.filter(function (t) {\n      return t.tag === item.tag;\n    });\n    if (match.length > 0) return match.find(function (t) {\n      return t.format === item.format;\n    }) || match[0];\n  }\n\n  var tagObj, obj;\n\n  if (item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    var _match = tags.filter(function (t) {\n      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;\n    });\n\n    tagObj = _match.find(function (t) {\n      return t.format === item.format;\n    }) || _match.find(function (t) {\n      return !t.format;\n    });\n  } else {\n    obj = item;\n    tagObj = tags.find(function (t) {\n      return t.nodeClass && obj instanceof t.nodeClass;\n    });\n  }\n\n  if (!tagObj) {\n    var name = obj && obj.constructor ? obj.constructor.name : (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(obj);\n    throw new Error(\"Tag not resolved for \".concat(name, \" value\"));\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, _ref) {\n  var anchors = _ref.anchors,\n      doc = _ref.doc;\n  var props = [];\n  var anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(\"&\".concat(anchor));\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify$1(item, ctx, onComment, onChompKeep) {\n  var _ctx$doc = ctx.doc,\n      anchors = _ctx$doc.anchors,\n      schema = _ctx$doc.schema;\n  var tagObj;\n\n  if (!(item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.N)) {\n    var createCtx = {\n      aliasNodes: [],\n      onTagObj: function onTagObj(o) {\n        return tagObj = o;\n      },\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(createCtx.aliasNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var alias = _step.value;\n        alias.source = alias.source.node;\n        var name = anchors.getName(alias.source);\n\n        if (!name) {\n          name = anchors.newName();\n          anchors.map[name] = alias.source;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.P) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  var props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S ? (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.c)(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S || str[0] === '{' || str[0] === '[' ? \"\".concat(props, \" \").concat(str) : \"\".concat(props, \"\\n\").concat(ctx.indent).concat(str);\n}\n\nvar Anchors = /*#__PURE__*/function () {\n  function Anchors(prefix) {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Anchors);\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Anchors, [{\n    key: \"createAlias\",\n    value: function createAlias(node, name) {\n      this.setAnchor(node, name);\n      return new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.A(node);\n    }\n  }, {\n    key: \"createMergePair\",\n    value: function createMergePair() {\n      var _this = this;\n\n      var merge = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.M();\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      merge.value.items = sources.map(function (s) {\n        if (s instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.A) {\n          if (s.source instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.d) return s;\n        } else if (s instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.d) {\n          return _this.createAlias(s);\n        }\n\n        throw new Error('Merge sources must be Map nodes or their Aliases');\n      });\n      return merge;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(node) {\n      var map = this.map;\n      return Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      return Object.keys(this.map);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(name) {\n      return this.map[name];\n    }\n  }, {\n    key: \"newName\",\n    value: function newName(prefix) {\n      if (!prefix) prefix = this.prefix;\n      var names = Object.keys(this.map);\n\n      for (var i = 1; true; ++i) {\n        var name = \"\".concat(prefix).concat(i);\n        if (!names.includes(name)) return name;\n      }\n    } // During parsing, map & aliases contain CST nodes\n\n  }, {\n    key: \"resolveNodes\",\n    value: function resolveNodes() {\n      var map = this.map,\n          _cstAliases = this._cstAliases;\n      Object.keys(map).forEach(function (a) {\n        map[a] = map[a].resolved;\n      });\n\n      _cstAliases.forEach(function (a) {\n        a.source = a.source.resolved;\n      });\n\n      delete this._cstAliases;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(node, name) {\n      if (node != null && !Anchors.validAnchorNode(node)) {\n        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n      }\n\n      if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n        throw new Error('Anchor names must not contain whitespace or control characters');\n      }\n\n      var map = this.map;\n      var prev = node && Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n\n      if (prev) {\n        if (!name) {\n          return prev;\n        } else if (prev !== name) {\n          delete map[prev];\n          map[name] = node;\n        }\n      } else {\n        if (!name) {\n          if (!node) return null;\n          name = this.newName();\n        }\n\n        map[name] = node;\n      }\n\n      return name;\n    }\n  }], [{\n    key: \"validAnchorNode\",\n    value: function validAnchorNode(node) {\n      return node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S || node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.Y || node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.d;\n    }\n  }]);\n\n  return Anchors;\n}();\n\nvar visit = function visit(node, tags) {\n  if (node && (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(node) === 'object') {\n    var tag = node.tag;\n\n    if (node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(function (n) {\n        return visit(n, tags);\n      });\n    } else if (node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.P) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nvar listTagNames = function listTagNames(node) {\n  return Object.keys(visit(node, {}));\n};\n\nfunction parseContents(doc, contents) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var body = undefined;\n  var spaceBefore = false;\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(contents),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.valueRange) {\n        if (body !== undefined) {\n          var msg = 'Document contains trailing content not separated by a ... or --- line';\n          doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(node, msg));\n          break;\n        }\n\n        var res = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.r)(doc, node);\n\n        if (spaceBefore) {\n          res.spaceBefore = true;\n          spaceBefore = false;\n        }\n\n        body = res;\n      } else if (node.comment !== null) {\n        var cc = body === undefined ? comments.before : comments.after;\n        cc.push(node.comment);\n      } else if (node.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE) {\n        spaceBefore = true;\n\n        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n          // space-separated comments at start are parsed as document comments\n          doc.commentBefore = comments.before.join('\\n');\n          comments.before = [];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      var cbNode = body instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? \"\".concat(cb, \"\\n\").concat(cbNode.commentBefore) : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective(_ref, directive) {\n  var tagPrefixes = _ref.tagPrefixes;\n\n  var _directive$parameters = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.h)(directive.parameters, 2),\n      handle = _directive$parameters[0],\n      prefix = _directive$parameters[1];\n\n  if (!handle || !prefix) {\n    var msg = 'Insufficient parameters given for %TAG directive';\n    throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(directive, msg);\n  }\n\n  if (tagPrefixes.some(function (p) {\n    return p.handle === handle;\n  })) {\n    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(directive, _msg);\n  }\n\n  return {\n    handle: handle,\n    prefix: prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  var _directive$parameters2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.h)(directive.parameters, 1),\n      version = _directive$parameters2[0];\n\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    var msg = 'Insufficient parameters given for %YAML directive';\n    throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    var v0 = doc.version || doc.options.version;\n\n    var _msg2 = \"Document will be parsed as YAML \".concat(v0, \" rather than YAML \").concat(version);\n\n    doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(directive, _msg2));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  var directiveComments = [];\n  var hasDirectives = false;\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(directives),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      var comment = directive.comment,\n          name = directive.name;\n\n      switch (name) {\n        case 'TAG':\n          try {\n            doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        case 'YAML':\n        case 'YAML:1.0':\n          if (doc.version) {\n            var msg = 'The %YAML directive must only be given at most once per document.';\n            doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(directive, msg));\n          }\n\n          try {\n            doc.version = resolveYamlDirective(doc, directive);\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        default:\n          if (name) {\n            var _msg3 = \"YAML only supports %TAG and %YAML directives, and not %\".concat(name);\n\n            doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(directive, _msg3));\n          }\n\n      }\n\n      if (comment) directiveComments.push(comment);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    var copyTagPrefix = function copyTagPrefix(_ref2) {\n      var handle = _ref2.handle,\n          prefix = _ref2.prefix;\n      return {\n        handle: handle,\n        prefix: prefix\n      };\n    };\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nvar Document$1 = /*#__PURE__*/function () {\n  function Document(options) {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Document);\n\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Document, [{\n    key: \"add\",\n    value: function add(value) {\n      assertCollection(this.contents);\n      return this.contents.add(value);\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      assertCollection(this.contents);\n      this.contents.addIn(path, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      assertCollection(this.contents);\n      return this.contents.delete(key);\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      if ((0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.e)(path)) {\n        if (this.contents == null) return false;\n        this.contents = null;\n        return true;\n      }\n\n      assertCollection(this.contents);\n      return this.contents.deleteIn(path);\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      return this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C ? this.contents.get(key, keepScalar) : undefined;\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      if ((0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.e)(path)) return !keepScalar && this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S ? this.contents.value : this.contents;\n      return this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C ? this.contents.has(key) : false;\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      if ((0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.e)(path)) return this.contents !== undefined;\n      return this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C ? this.contents.hasIn(path) : false;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assertCollection(this.contents);\n      this.contents.set(key, value);\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      if ((0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.e)(path)) this.contents = value;else {\n        assertCollection(this.contents);\n        this.contents.setIn(path, value);\n      }\n    }\n  }, {\n    key: \"setSchema\",\n    value: function setSchema(id, customTags) {\n      if (!id && !customTags && this.schema) return;\n      if (typeof id === 'number') id = id.toFixed(1);\n\n      if (id === '1.0' || id === '1.1' || id === '1.2') {\n        if (this.version) this.version = id;else this.options.version = id;\n        delete this.options.schema;\n      } else if (id && typeof id === 'string') {\n        this.options.schema = id;\n      }\n\n      if (Array.isArray(customTags)) this.options.customTags = customTags;\n      var opt = Object.assign({}, this.getDefaults(), this.options);\n      this.schema = new _Schema_e94716c8_js__WEBPACK_IMPORTED_MODULE_3__.S(opt);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(node, prevDoc) {\n      if (this.options.keepCstNodes) this.cstNode = node;\n      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n      var _node$directives = node.directives,\n          directives = _node$directives === void 0 ? [] : _node$directives,\n          _node$contents = node.contents,\n          contents = _node$contents === void 0 ? [] : _node$contents,\n          directivesEndMarker = node.directivesEndMarker,\n          error = node.error,\n          valueRange = node.valueRange;\n\n      if (error) {\n        if (!error.source) error.source = this;\n        this.errors.push(error);\n      }\n\n      parseDirectives(this, directives, prevDoc);\n      if (directivesEndMarker) this.directivesEndMarker = true;\n      this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n      this.setSchema();\n      this.anchors._cstAliases = [];\n      parseContents(this, contents);\n      this.anchors.resolveNodes();\n\n      if (this.options.prettyErrors) {\n        var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.errors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _error = _step.value;\n            if (_error instanceof _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.i) _error.makePretty();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.warnings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var warn = _step2.value;\n            if (warn instanceof _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.i) warn.makePretty();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"listNonDefaultTags\",\n    value: function listNonDefaultTags() {\n      return listTagNames(this.contents).filter(function (t) {\n        return t.indexOf(_Schema_e94716c8_js__WEBPACK_IMPORTED_MODULE_3__.S.defaultPrefix) !== 0;\n      });\n    }\n  }, {\n    key: \"setTagPrefix\",\n    value: function setTagPrefix(handle, prefix) {\n      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n      if (prefix) {\n        var prev = this.tagPrefixes.find(function (p) {\n          return p.handle === handle;\n        });\n        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n          handle: handle,\n          prefix: prefix\n        });\n      } else {\n        this.tagPrefixes = this.tagPrefixes.filter(function (p) {\n          return p.handle !== handle;\n        });\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, onAnchor) {\n      var _this = this;\n\n      var _this$options = this.options,\n          keepBlobsInJSON = _this$options.keepBlobsInJSON,\n          mapAsMap = _this$options.mapAsMap,\n          maxAliasCount = _this$options.maxAliasCount;\n      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S));\n      var ctx = {\n        doc: this,\n        indentStep: '  ',\n        keep: keep,\n        mapAsMap: keep && !!mapAsMap,\n        maxAliasCount: maxAliasCount,\n        stringify: stringify$1 // Requiring directly in Pair would create circular dependencies\n\n      };\n      var anchorNames = Object.keys(this.anchors.map);\n      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {\n        return [_this.anchors.map[name], {\n          alias: [],\n          aliasCount: 0,\n          count: 1\n        }];\n      }));\n\n      var res = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.t)(this.contents, arg, ctx);\n\n      if (typeof onAnchor === 'function' && ctx.anchors) {\n        var _iterator3 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(ctx.anchors.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _step3.value,\n                count = _step3$value.count,\n                _res = _step3$value.res;\n            onAnchor(_res, count);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n      var indentSize = this.options.indent;\n\n      if (!Number.isInteger(indentSize) || indentSize <= 0) {\n        var s = JSON.stringify(indentSize);\n        throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n      }\n\n      this.setSchema();\n      var lines = [];\n      var hasDirectives = false;\n\n      if (this.version) {\n        var vd = '%YAML 1.2';\n\n        if (this.schema.name === 'yaml-1.1') {\n          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n        }\n\n        lines.push(vd);\n        hasDirectives = true;\n      }\n\n      var tagNames = this.listNonDefaultTags();\n      this.tagPrefixes.forEach(function (_ref) {\n        var handle = _ref.handle,\n            prefix = _ref.prefix;\n\n        if (tagNames.some(function (t) {\n          return t.indexOf(prefix) === 0;\n        })) {\n          lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n          hasDirectives = true;\n        }\n      });\n      if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n      if (this.commentBefore) {\n        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n        lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n      }\n\n      var ctx = {\n        anchors: Object.create(null),\n        doc: this,\n        indent: '',\n        indentStep: ' '.repeat(indentSize),\n        stringify: stringify$1 // Requiring directly in nodes would create circular dependencies\n\n      };\n      var chompKeep = false;\n      var contentComment = null;\n\n      if (this.contents) {\n        if (this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.N) {\n          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n          ctx.forceBlockIndent = !!this.comment;\n          contentComment = this.contents.comment;\n        }\n\n        var onChompKeep = contentComment ? null : function () {\n          return chompKeep = true;\n        };\n        var body = stringify$1(this.contents, ctx, function () {\n          return contentComment = null;\n        }, onChompKeep);\n        lines.push((0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.f)(body, '', contentComment));\n      } else if (this.contents !== undefined) {\n        lines.push(stringify$1(this.contents, ctx));\n      }\n\n      if (this.comment) {\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n        lines.push(this.comment.replace(/^/gm, '#'));\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n  }]);\n\n  return Document;\n}();\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Document$1, \"defaults\", documentOptions);\n\nfunction createNode(value) {\n  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var tag = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);\n  var schema = new _Schema_e94716c8_js__WEBPACK_IMPORTED_MODULE_3__.S(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nvar Document = /*#__PURE__*/function (_YAMLDocument) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Document, _YAMLDocument);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Document);\n\n  function Document(options) {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Document);\n\n    return _super.call(this, Object.assign({}, defaultOptions, options));\n  }\n\n  return Document;\n}(Document$1);\n\nfunction parseAllDocuments(src, options) {\n  var stream = [];\n  var prev;\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_parse_cst_js__WEBPACK_IMPORTED_MODULE_1__.parse)(src)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var cstDoc = _step.value;\n      var doc = new Document(options);\n      doc.parse(cstDoc, prev);\n      stream.push(doc);\n      prev = doc;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  var cst = (0,_parse_cst_js__WEBPACK_IMPORTED_MODULE_1__.parse)(src);\n  var doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  var doc = parseDocument(src, options);\n  doc.warnings.forEach(function (warning) {\n    return (0,_warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_4__.w)(warning);\n  });\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  var doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nvar YAML = {\n  createNode: createNode,\n  defaultOptions: defaultOptions,\n  Document: Document,\n  parse: parse,\n  parseAllDocuments: parseAllDocuments,\n  parseCST: _parse_cst_js__WEBPACK_IMPORTED_MODULE_1__.parse,\n  parseDocument: parseDocument,\n  scalarOptions: scalarOptions,\n  stringify: stringify\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtVO0FBQ2hSO0FBQ2tSO0FBQ2pSO0FBQ0E7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNEQUFhO0FBQ3hCLEdBQUc7O0FBRUg7QUFDQSxrQkFBa0Isc0RBQWE7QUFDL0IsR0FBRzs7QUFFSDtBQUNBLFdBQVcsc0RBQVc7QUFDdEIsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQixzREFBVztBQUM3QixHQUFHOztBQUVIO0FBQ0EsV0FBVyxzREFBVTtBQUNyQixHQUFHOztBQUVIO0FBQ0Esa0JBQWtCLHNEQUFVO0FBQzVCLEdBQUc7O0FBRUg7QUFDQSxXQUFXLHNEQUFXO0FBQ3RCLEdBQUc7O0FBRUg7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0IsR0FBRzs7QUFFSDtBQUNBLFdBQVcsc0RBQVU7QUFDckIsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQixzREFBVTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQWdCO0FBQzlCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLHNEQUFnQjtBQUM5QixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsc0RBQWdCO0FBQzlCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsNERB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Q0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3AteHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2luZGV4LmpzP2RlYjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZCBhcyBkZWZhdWx0VGFnUHJlZml4LCBfIGFzIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyLCBhIGFzIF90eXBlb2YsIGIgYXMgX2NyZWF0ZUNsYXNzLCBjIGFzIF9jbGFzc0NhbGxDaGVjaywgZSBhcyBfZGVmaW5lUHJvcGVydHksIFkgYXMgWUFNTFN5bnRheEVycm9yLCBUIGFzIFR5cGUsIGYgYXMgWUFNTFdhcm5pbmcsIGcgYXMgWUFNTFNlbWFudGljRXJyb3IsIGggYXMgX3NsaWNlZFRvQXJyYXksIGkgYXMgWUFNTEVycm9yLCBqIGFzIF9pbmhlcml0cywgayBhcyBfY3JlYXRlU3VwZXIgfSBmcm9tICcuL1BsYWluVmFsdWUtYjgwMzZiNzUuanMnO1xuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2UkMSB9IGZyb20gJy4vcGFyc2UtY3N0LmpzJztcbmltcG9ydCB7IGIgYXMgYmluYXJ5T3B0aW9ucywgYSBhcyBib29sT3B0aW9ucywgaSBhcyBpbnRPcHRpb25zLCBuIGFzIG51bGxPcHRpb25zLCBzIGFzIHN0ck9wdGlvbnMsIE4gYXMgTm9kZSwgUCBhcyBQYWlyLCBTIGFzIFNjYWxhciwgYyBhcyBzdHJpbmdpZnlTdHJpbmcsIEEgYXMgQWxpYXMsIFkgYXMgWUFNTFNlcSwgZCBhcyBZQU1MTWFwLCBNIGFzIE1lcmdlLCBDIGFzIENvbGxlY3Rpb24sIHIgYXMgcmVzb2x2ZU5vZGUsIGUgYXMgaXNFbXB0eVBhdGgsIHQgYXMgdG9KU09OLCBmIGFzIGFkZENvbW1lbnQgfSBmcm9tICcuL3Jlc29sdmVTZXEtNDkyYWI0NDAuanMnO1xuaW1wb3J0IHsgUyBhcyBTY2hlbWEgfSBmcm9tICcuL1NjaGVtYS1lOTQ3MTZjOC5qcyc7XG5pbXBvcnQgeyB3IGFzIHdhcm4gfSBmcm9tICcuL3dhcm5pbmdzLWRmNTRjYjY5LmpzJztcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBhbmNob3JQcmVmaXg6ICdhJyxcbiAgY3VzdG9tVGFnczogbnVsbCxcbiAgaW5kZW50OiAyLFxuICBpbmRlbnRTZXE6IHRydWUsXG4gIGtlZXBDc3ROb2RlczogZmFsc2UsXG4gIGtlZXBOb2RlVHlwZXM6IHRydWUsXG4gIGtlZXBCbG9ic0luSlNPTjogdHJ1ZSxcbiAgbWFwQXNNYXA6IGZhbHNlLFxuICBtYXhBbGlhc0NvdW50OiAxMDAsXG4gIHByZXR0eUVycm9yczogZmFsc2UsXG4gIC8vIFRPRE8gU2V0IHRydWUgaW4gdjJcbiAgc2ltcGxlS2V5czogZmFsc2UsXG4gIHZlcnNpb246ICcxLjInXG59O1xudmFyIHNjYWxhck9wdGlvbnMgPSB7XG4gIGdldCBiaW5hcnkoKSB7XG4gICAgcmV0dXJuIGJpbmFyeU9wdGlvbnM7XG4gIH0sXG5cbiAgc2V0IGJpbmFyeShvcHQpIHtcbiAgICBPYmplY3QuYXNzaWduKGJpbmFyeU9wdGlvbnMsIG9wdCk7XG4gIH0sXG5cbiAgZ2V0IGJvb2woKSB7XG4gICAgcmV0dXJuIGJvb2xPcHRpb25zO1xuICB9LFxuXG4gIHNldCBib29sKG9wdCkge1xuICAgIE9iamVjdC5hc3NpZ24oYm9vbE9wdGlvbnMsIG9wdCk7XG4gIH0sXG5cbiAgZ2V0IGludCgpIHtcbiAgICByZXR1cm4gaW50T3B0aW9ucztcbiAgfSxcblxuICBzZXQgaW50KG9wdCkge1xuICAgIE9iamVjdC5hc3NpZ24oaW50T3B0aW9ucywgb3B0KTtcbiAgfSxcblxuICBnZXQgbnVsbCgpIHtcbiAgICByZXR1cm4gbnVsbE9wdGlvbnM7XG4gIH0sXG5cbiAgc2V0IG51bGwob3B0KSB7XG4gICAgT2JqZWN0LmFzc2lnbihudWxsT3B0aW9ucywgb3B0KTtcbiAgfSxcblxuICBnZXQgc3RyKCkge1xuICAgIHJldHVybiBzdHJPcHRpb25zO1xuICB9LFxuXG4gIHNldCBzdHIob3B0KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdHJPcHRpb25zLCBvcHQpO1xuICB9XG5cbn07XG52YXIgZG9jdW1lbnRPcHRpb25zID0ge1xuICAnMS4wJzoge1xuICAgIHNjaGVtYTogJ3lhbWwtMS4xJyxcbiAgICBtZXJnZTogdHJ1ZSxcbiAgICB0YWdQcmVmaXhlczogW3tcbiAgICAgIGhhbmRsZTogJyEnLFxuICAgICAgcHJlZml4OiBkZWZhdWx0VGFnUHJlZml4XG4gICAgfSwge1xuICAgICAgaGFuZGxlOiAnISEnLFxuICAgICAgcHJlZml4OiAndGFnOnByaXZhdGUueWFtbC5vcmcsMjAwMjonXG4gICAgfV1cbiAgfSxcbiAgMS4xOiB7XG4gICAgc2NoZW1hOiAneWFtbC0xLjEnLFxuICAgIG1lcmdlOiB0cnVlLFxuICAgIHRhZ1ByZWZpeGVzOiBbe1xuICAgICAgaGFuZGxlOiAnIScsXG4gICAgICBwcmVmaXg6ICchJ1xuICAgIH0sIHtcbiAgICAgIGhhbmRsZTogJyEhJyxcbiAgICAgIHByZWZpeDogZGVmYXVsdFRhZ1ByZWZpeFxuICAgIH1dXG4gIH0sXG4gIDEuMjoge1xuICAgIHNjaGVtYTogJ2NvcmUnLFxuICAgIG1lcmdlOiBmYWxzZSxcbiAgICB0YWdQcmVmaXhlczogW3tcbiAgICAgIGhhbmRsZTogJyEnLFxuICAgICAgcHJlZml4OiAnISdcbiAgICB9LCB7XG4gICAgICBoYW5kbGU6ICchIScsXG4gICAgICBwcmVmaXg6IGRlZmF1bHRUYWdQcmVmaXhcbiAgICB9XVxuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlUYWcoZG9jLCB0YWcpIHtcbiAgaWYgKChkb2MudmVyc2lvbiB8fCBkb2Mub3B0aW9ucy52ZXJzaW9uKSA9PT0gJzEuMCcpIHtcbiAgICB2YXIgcHJpdiA9IHRhZy5tYXRjaCgvXnRhZzpwcml2YXRlXFwueWFtbFxcLm9yZywyMDAyOihbXjovXSspJC8pO1xuICAgIGlmIChwcml2KSByZXR1cm4gJyEnICsgcHJpdlsxXTtcbiAgICB2YXIgdm9jYWIgPSB0YWcubWF0Y2goL150YWc6KFthLXpBLVowLTktXSspXFwueWFtbFxcLm9yZywyMDAyOiguKikvKTtcbiAgICByZXR1cm4gdm9jYWIgPyBcIiFcIi5jb25jYXQodm9jYWJbMV0sIFwiL1wiKS5jb25jYXQodm9jYWJbMl0pIDogXCIhXCIuY29uY2F0KHRhZy5yZXBsYWNlKC9edGFnOi8sICcnKSk7XG4gIH1cblxuICB2YXIgcCA9IGRvYy50YWdQcmVmaXhlcy5maW5kKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHRhZy5pbmRleE9mKHAucHJlZml4KSA9PT0gMDtcbiAgfSk7XG5cbiAgaWYgKCFwKSB7XG4gICAgdmFyIGR0cCA9IGRvYy5nZXREZWZhdWx0cygpLnRhZ1ByZWZpeGVzO1xuICAgIHAgPSBkdHAgJiYgZHRwLmZpbmQoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiB0YWcuaW5kZXhPZihwLnByZWZpeCkgPT09IDA7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIXApIHJldHVybiB0YWdbMF0gPT09ICchJyA/IHRhZyA6IFwiITxcIi5jb25jYXQodGFnLCBcIj5cIik7XG4gIHZhciBzdWZmaXggPSB0YWcuc3Vic3RyKHAucHJlZml4Lmxlbmd0aCkucmVwbGFjZSgvWyEsW1xcXXt9XS9nLCBmdW5jdGlvbiAoY2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJyEnOiAnJTIxJyxcbiAgICAgICcsJzogJyUyQycsXG4gICAgICAnWyc6ICclNUInLFxuICAgICAgJ10nOiAnJTVEJyxcbiAgICAgICd7JzogJyU3QicsXG4gICAgICAnfSc6ICclN0QnXG4gICAgfVtjaF07XG4gIH0pO1xuICByZXR1cm4gcC5oYW5kbGUgKyBzdWZmaXg7XG59XG5cbmZ1bmN0aW9uIGdldFRhZ09iamVjdCh0YWdzLCBpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgQWxpYXMpIHJldHVybiBBbGlhcztcblxuICBpZiAoaXRlbS50YWcpIHtcbiAgICB2YXIgbWF0Y2ggPSB0YWdzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQudGFnID09PSBpdGVtLnRhZztcbiAgICB9KTtcbiAgICBpZiAobWF0Y2gubGVuZ3RoID4gMCkgcmV0dXJuIG1hdGNoLmZpbmQoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0LmZvcm1hdCA9PT0gaXRlbS5mb3JtYXQ7XG4gICAgfSkgfHwgbWF0Y2hbMF07XG4gIH1cblxuICB2YXIgdGFnT2JqLCBvYmo7XG5cbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTY2FsYXIpIHtcbiAgICBvYmogPSBpdGVtLnZhbHVlOyAvLyBUT0RPOiBkZXByZWNhdGUvcmVtb3ZlIGNsYXNzIGNoZWNrXG5cbiAgICB2YXIgX21hdGNoID0gdGFncy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0LmlkZW50aWZ5ICYmIHQuaWRlbnRpZnkob2JqKSB8fCB0LmNsYXNzICYmIG9iaiBpbnN0YW5jZW9mIHQuY2xhc3M7XG4gICAgfSk7XG5cbiAgICB0YWdPYmogPSBfbWF0Y2guZmluZChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQuZm9ybWF0ID09PSBpdGVtLmZvcm1hdDtcbiAgICB9KSB8fCBfbWF0Y2guZmluZChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICF0LmZvcm1hdDtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmogPSBpdGVtO1xuICAgIHRhZ09iaiA9IHRhZ3MuZmluZChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQubm9kZUNsYXNzICYmIG9iaiBpbnN0YW5jZW9mIHQubm9kZUNsYXNzO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCF0YWdPYmopIHtcbiAgICB2YXIgbmFtZSA9IG9iaiAmJiBvYmouY29uc3RydWN0b3IgPyBvYmouY29uc3RydWN0b3IubmFtZSA6IF90eXBlb2Yob2JqKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYWcgbm90IHJlc29sdmVkIGZvciBcIi5jb25jYXQobmFtZSwgXCIgdmFsdWVcIikpO1xuICB9XG5cbiAgcmV0dXJuIHRhZ09iajtcbn0gLy8gbmVlZHMgdG8gYmUgY2FsbGVkIGJlZm9yZSB2YWx1ZSBzdHJpbmdpZmllciB0byBhbGxvdyBmb3IgY2lyY3VsYXIgYW5jaG9yIHJlZnNcblxuXG5mdW5jdGlvbiBzdHJpbmdpZnlQcm9wcyhub2RlLCB0YWdPYmosIF9yZWYpIHtcbiAgdmFyIGFuY2hvcnMgPSBfcmVmLmFuY2hvcnMsXG4gICAgICBkb2MgPSBfcmVmLmRvYztcbiAgdmFyIHByb3BzID0gW107XG4gIHZhciBhbmNob3IgPSBkb2MuYW5jaG9ycy5nZXROYW1lKG5vZGUpO1xuXG4gIGlmIChhbmNob3IpIHtcbiAgICBhbmNob3JzW2FuY2hvcl0gPSBub2RlO1xuICAgIHByb3BzLnB1c2goXCImXCIuY29uY2F0KGFuY2hvcikpO1xuICB9XG5cbiAgaWYgKG5vZGUudGFnKSB7XG4gICAgcHJvcHMucHVzaChzdHJpbmdpZnlUYWcoZG9jLCBub2RlLnRhZykpO1xuICB9IGVsc2UgaWYgKCF0YWdPYmouZGVmYXVsdCkge1xuICAgIHByb3BzLnB1c2goc3RyaW5naWZ5VGFnKGRvYywgdGFnT2JqLnRhZykpO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5JDEoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gIHZhciBfY3R4JGRvYyA9IGN0eC5kb2MsXG4gICAgICBhbmNob3JzID0gX2N0eCRkb2MuYW5jaG9ycyxcbiAgICAgIHNjaGVtYSA9IF9jdHgkZG9jLnNjaGVtYTtcbiAgdmFyIHRhZ09iajtcblxuICBpZiAoIShpdGVtIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICB2YXIgY3JlYXRlQ3R4ID0ge1xuICAgICAgYWxpYXNOb2RlczogW10sXG4gICAgICBvblRhZ09iajogZnVuY3Rpb24gb25UYWdPYmoobykge1xuICAgICAgICByZXR1cm4gdGFnT2JqID0gbztcbiAgICAgIH0sXG4gICAgICBwcmV2T2JqZWN0czogbmV3IE1hcCgpXG4gICAgfTtcbiAgICBpdGVtID0gc2NoZW1hLmNyZWF0ZU5vZGUoaXRlbSwgdHJ1ZSwgbnVsbCwgY3JlYXRlQ3R4KTtcblxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjcmVhdGVDdHguYWxpYXNOb2RlcyksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBhbGlhcyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBhbGlhcy5zb3VyY2UgPSBhbGlhcy5zb3VyY2Uubm9kZTtcbiAgICAgICAgdmFyIG5hbWUgPSBhbmNob3JzLmdldE5hbWUoYWxpYXMuc291cmNlKTtcblxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICBuYW1lID0gYW5jaG9ycy5uZXdOYW1lKCk7XG4gICAgICAgICAgYW5jaG9ycy5tYXBbbmFtZV0gPSBhbGlhcy5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQYWlyKSByZXR1cm4gaXRlbS50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICBpZiAoIXRhZ09iaikgdGFnT2JqID0gZ2V0VGFnT2JqZWN0KHNjaGVtYS50YWdzLCBpdGVtKTtcbiAgdmFyIHByb3BzID0gc3RyaW5naWZ5UHJvcHMoaXRlbSwgdGFnT2JqLCBjdHgpO1xuICBpZiAocHJvcHMubGVuZ3RoID4gMCkgY3R4LmluZGVudEF0U3RhcnQgPSAoY3R4LmluZGVudEF0U3RhcnQgfHwgMCkgKyBwcm9wcy5sZW5ndGggKyAxO1xuICB2YXIgc3RyID0gdHlwZW9mIHRhZ09iai5zdHJpbmdpZnkgPT09ICdmdW5jdGlvbicgPyB0YWdPYmouc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkgOiBpdGVtIGluc3RhbmNlb2YgU2NhbGFyID8gc3RyaW5naWZ5U3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkgOiBpdGVtLnRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIGlmICghcHJvcHMpIHJldHVybiBzdHI7XG4gIHJldHVybiBpdGVtIGluc3RhbmNlb2YgU2NhbGFyIHx8IHN0clswXSA9PT0gJ3snIHx8IHN0clswXSA9PT0gJ1snID8gXCJcIi5jb25jYXQocHJvcHMsIFwiIFwiKS5jb25jYXQoc3RyKSA6IFwiXCIuY29uY2F0KHByb3BzLCBcIlxcblwiKS5jb25jYXQoY3R4LmluZGVudCkuY29uY2F0KHN0cik7XG59XG5cbnZhciBBbmNob3JzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5jaG9ycyhwcmVmaXgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5jaG9ycyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXBcIiwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbmNob3JzLCBbe1xuICAgIGtleTogXCJjcmVhdGVBbGlhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVBbGlhcyhub2RlLCBuYW1lKSB7XG4gICAgICB0aGlzLnNldEFuY2hvcihub2RlLCBuYW1lKTtcbiAgICAgIHJldHVybiBuZXcgQWxpYXMobm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZU1lcmdlUGFpclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVNZXJnZVBhaXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgbWVyZ2UgPSBuZXcgTWVyZ2UoKTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIG1lcmdlLnZhbHVlLml0ZW1zID0gc291cmNlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgaWYgKHMgaW5zdGFuY2VvZiBBbGlhcykge1xuICAgICAgICAgIGlmIChzLnNvdXJjZSBpbnN0YW5jZW9mIFlBTUxNYXApIHJldHVybiBzO1xuICAgICAgICB9IGVsc2UgaWYgKHMgaW5zdGFuY2VvZiBZQU1MTWFwKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZUFsaWFzKHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXJnZSBzb3VyY2VzIG11c3QgYmUgTWFwIG5vZGVzIG9yIHRoZWlyIEFsaWFzZXMnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1lcmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWUobm9kZSkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMubWFwO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkuZmluZChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gbWFwW2FdID09PSBub2RlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE5hbWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWVzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcFtuYW1lXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV3TmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdOYW1lKHByZWZpeCkge1xuICAgICAgaWYgKCFwcmVmaXgpIHByZWZpeCA9IHRoaXMucHJlZml4O1xuICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgdHJ1ZTsgKytpKSB7XG4gICAgICAgIHZhciBuYW1lID0gXCJcIi5jb25jYXQocHJlZml4KS5jb25jYXQoaSk7XG4gICAgICAgIGlmICghbmFtZXMuaW5jbHVkZXMobmFtZSkpIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgIH0gLy8gRHVyaW5nIHBhcnNpbmcsIG1hcCAmIGFsaWFzZXMgY29udGFpbiBDU1Qgbm9kZXNcblxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlTm9kZXMoKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5tYXAsXG4gICAgICAgICAgX2NzdEFsaWFzZXMgPSB0aGlzLl9jc3RBbGlhc2VzO1xuICAgICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIG1hcFthXSA9IG1hcFthXS5yZXNvbHZlZDtcbiAgICAgIH0pO1xuXG4gICAgICBfY3N0QWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGEuc291cmNlID0gYS5zb3VyY2UucmVzb2x2ZWQ7XG4gICAgICB9KTtcblxuICAgICAgZGVsZXRlIHRoaXMuX2NzdEFsaWFzZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEFuY2hvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBbmNob3Iobm9kZSwgbmFtZSkge1xuICAgICAgaWYgKG5vZGUgIT0gbnVsbCAmJiAhQW5jaG9ycy52YWxpZEFuY2hvck5vZGUobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbmNob3JzIG1heSBvbmx5IGJlIHNldCBmb3IgU2NhbGFyLCBTZXEgYW5kIE1hcCBub2RlcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSAmJiAvW1xceDAwLVxceDE5XFxzLFtcXF17fV0vLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbmNob3IgbmFtZXMgbXVzdCBub3QgY29udGFpbiB3aGl0ZXNwYWNlIG9yIGNvbnRyb2wgY2hhcmFjdGVycycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFwID0gdGhpcy5tYXA7XG4gICAgICB2YXIgcHJldiA9IG5vZGUgJiYgT2JqZWN0LmtleXMobWFwKS5maW5kKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBtYXBbYV0gPT09IG5vZGU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldiAhPT0gbmFtZSkge1xuICAgICAgICAgIGRlbGV0ZSBtYXBbcHJldl07XG4gICAgICAgICAgbWFwW25hbWVdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBuYW1lID0gdGhpcy5uZXdOYW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbbmFtZV0gPSBub2RlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ2YWxpZEFuY2hvck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRBbmNob3JOb2RlKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgU2NhbGFyIHx8IG5vZGUgaW5zdGFuY2VvZiBZQU1MU2VxIHx8IG5vZGUgaW5zdGFuY2VvZiBZQU1MTWFwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbmNob3JzO1xufSgpO1xuXG52YXIgdmlzaXQgPSBmdW5jdGlvbiB2aXNpdChub2RlLCB0YWdzKSB7XG4gIGlmIChub2RlICYmIF90eXBlb2Yobm9kZSkgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuXG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgICBpZiAodGFnKSB0YWdzW3RhZ10gPSB0cnVlO1xuICAgICAgbm9kZS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiB2aXNpdChuLCB0YWdzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFBhaXIpIHtcbiAgICAgIHZpc2l0KG5vZGUua2V5LCB0YWdzKTtcbiAgICAgIHZpc2l0KG5vZGUudmFsdWUsIHRhZ3MpO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNjYWxhcikge1xuICAgICAgaWYgKHRhZykgdGFnc1t0YWddID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFncztcbn07XG5cbnZhciBsaXN0VGFnTmFtZXMgPSBmdW5jdGlvbiBsaXN0VGFnTmFtZXMobm9kZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmlzaXQobm9kZSwge30pKTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlQ29udGVudHMoZG9jLCBjb250ZW50cykge1xuICB2YXIgY29tbWVudHMgPSB7XG4gICAgYmVmb3JlOiBbXSxcbiAgICBhZnRlcjogW11cbiAgfTtcbiAgdmFyIGJvZHkgPSB1bmRlZmluZWQ7XG4gIHZhciBzcGFjZUJlZm9yZSA9IGZhbHNlO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjb250ZW50cyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbm9kZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAobm9kZS52YWx1ZVJhbmdlKSB7XG4gICAgICAgIGlmIChib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbXNnID0gJ0RvY3VtZW50IGNvbnRhaW5zIHRyYWlsaW5nIGNvbnRlbnQgbm90IHNlcGFyYXRlZCBieSBhIC4uLiBvciAtLS0gbGluZSc7XG4gICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MU3ludGF4RXJyb3Iobm9kZSwgbXNnKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzID0gcmVzb2x2ZU5vZGUoZG9jLCBub2RlKTtcblxuICAgICAgICBpZiAoc3BhY2VCZWZvcmUpIHtcbiAgICAgICAgICByZXMuc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgICAgICAgIHNwYWNlQmVmb3JlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5ID0gcmVzO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNvbW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGNjID0gYm9keSA9PT0gdW5kZWZpbmVkID8gY29tbWVudHMuYmVmb3JlIDogY29tbWVudHMuYWZ0ZXI7XG4gICAgICAgIGNjLnB1c2gobm9kZS5jb21tZW50KTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBUeXBlLkJMQU5LX0xJTkUpIHtcbiAgICAgICAgc3BhY2VCZWZvcmUgPSB0cnVlO1xuXG4gICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQgJiYgY29tbWVudHMuYmVmb3JlLmxlbmd0aCA+IDAgJiYgIWRvYy5jb21tZW50QmVmb3JlKSB7XG4gICAgICAgICAgLy8gc3BhY2Utc2VwYXJhdGVkIGNvbW1lbnRzIGF0IHN0YXJ0IGFyZSBwYXJzZWQgYXMgZG9jdW1lbnQgY29tbWVudHNcbiAgICAgICAgICBkb2MuY29tbWVudEJlZm9yZSA9IGNvbW1lbnRzLmJlZm9yZS5qb2luKCdcXG4nKTtcbiAgICAgICAgICBjb21tZW50cy5iZWZvcmUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgZG9jLmNvbnRlbnRzID0gYm9keSB8fCBudWxsO1xuXG4gIGlmICghYm9keSkge1xuICAgIGRvYy5jb21tZW50ID0gY29tbWVudHMuYmVmb3JlLmNvbmNhdChjb21tZW50cy5hZnRlcikuam9pbignXFxuJykgfHwgbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2IgPSBjb21tZW50cy5iZWZvcmUuam9pbignXFxuJyk7XG5cbiAgICBpZiAoY2IpIHtcbiAgICAgIHZhciBjYk5vZGUgPSBib2R5IGluc3RhbmNlb2YgQ29sbGVjdGlvbiAmJiBib2R5Lml0ZW1zWzBdID8gYm9keS5pdGVtc1swXSA6IGJvZHk7XG4gICAgICBjYk5vZGUuY29tbWVudEJlZm9yZSA9IGNiTm9kZS5jb21tZW50QmVmb3JlID8gXCJcIi5jb25jYXQoY2IsIFwiXFxuXCIpLmNvbmNhdChjYk5vZGUuY29tbWVudEJlZm9yZSkgOiBjYjtcbiAgICB9XG5cbiAgICBkb2MuY29tbWVudCA9IGNvbW1lbnRzLmFmdGVyLmpvaW4oJ1xcbicpIHx8IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhZ0RpcmVjdGl2ZShfcmVmLCBkaXJlY3RpdmUpIHtcbiAgdmFyIHRhZ1ByZWZpeGVzID0gX3JlZi50YWdQcmVmaXhlcztcblxuICB2YXIgX2RpcmVjdGl2ZSRwYXJhbWV0ZXJzID0gX3NsaWNlZFRvQXJyYXkoZGlyZWN0aXZlLnBhcmFtZXRlcnMsIDIpLFxuICAgICAgaGFuZGxlID0gX2RpcmVjdGl2ZSRwYXJhbWV0ZXJzWzBdLFxuICAgICAgcHJlZml4ID0gX2RpcmVjdGl2ZSRwYXJhbWV0ZXJzWzFdO1xuXG4gIGlmICghaGFuZGxlIHx8ICFwcmVmaXgpIHtcbiAgICB2YXIgbXNnID0gJ0luc3VmZmljaWVudCBwYXJhbWV0ZXJzIGdpdmVuIGZvciAlVEFHIGRpcmVjdGl2ZSc7XG4gICAgdGhyb3cgbmV3IFlBTUxTZW1hbnRpY0Vycm9yKGRpcmVjdGl2ZSwgbXNnKTtcbiAgfVxuXG4gIGlmICh0YWdQcmVmaXhlcy5zb21lKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAuaGFuZGxlID09PSBoYW5kbGU7XG4gIH0pKSB7XG4gICAgdmFyIF9tc2cgPSAnVGhlICVUQUcgZGlyZWN0aXZlIG11c3Qgb25seSBiZSBnaXZlbiBhdCBtb3N0IG9uY2UgcGVyIGhhbmRsZSBpbiB0aGUgc2FtZSBkb2N1bWVudC4nO1xuICAgIHRocm93IG5ldyBZQU1MU2VtYW50aWNFcnJvcihkaXJlY3RpdmUsIF9tc2cpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICBwcmVmaXg6IHByZWZpeFxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbERpcmVjdGl2ZShkb2MsIGRpcmVjdGl2ZSkge1xuICB2YXIgX2RpcmVjdGl2ZSRwYXJhbWV0ZXJzMiA9IF9zbGljZWRUb0FycmF5KGRpcmVjdGl2ZS5wYXJhbWV0ZXJzLCAxKSxcbiAgICAgIHZlcnNpb24gPSBfZGlyZWN0aXZlJHBhcmFtZXRlcnMyWzBdO1xuXG4gIGlmIChkaXJlY3RpdmUubmFtZSA9PT0gJ1lBTUw6MS4wJykgdmVyc2lvbiA9ICcxLjAnO1xuXG4gIGlmICghdmVyc2lvbikge1xuICAgIHZhciBtc2cgPSAnSW5zdWZmaWNpZW50IHBhcmFtZXRlcnMgZ2l2ZW4gZm9yICVZQU1MIGRpcmVjdGl2ZSc7XG4gICAgdGhyb3cgbmV3IFlBTUxTZW1hbnRpY0Vycm9yKGRpcmVjdGl2ZSwgbXNnKTtcbiAgfVxuXG4gIGlmICghZG9jdW1lbnRPcHRpb25zW3ZlcnNpb25dKSB7XG4gICAgdmFyIHYwID0gZG9jLnZlcnNpb24gfHwgZG9jLm9wdGlvbnMudmVyc2lvbjtcblxuICAgIHZhciBfbXNnMiA9IFwiRG9jdW1lbnQgd2lsbCBiZSBwYXJzZWQgYXMgWUFNTCBcIi5jb25jYXQodjAsIFwiIHJhdGhlciB0aGFuIFlBTUwgXCIpLmNvbmNhdCh2ZXJzaW9uKTtcblxuICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBZQU1MV2FybmluZyhkaXJlY3RpdmUsIF9tc2cyKSk7XG4gIH1cblxuICByZXR1cm4gdmVyc2lvbjtcbn1cblxuZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmVzKGRvYywgZGlyZWN0aXZlcywgcHJldkRvYykge1xuICB2YXIgZGlyZWN0aXZlQ29tbWVudHMgPSBbXTtcbiAgdmFyIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZTtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGlyZWN0aXZlcyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgZGlyZWN0aXZlID0gX3N0ZXAudmFsdWU7XG4gICAgICB2YXIgY29tbWVudCA9IGRpcmVjdGl2ZS5jb21tZW50LFxuICAgICAgICAgIG5hbWUgPSBkaXJlY3RpdmUubmFtZTtcblxuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgJ1RBRyc6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRvYy50YWdQcmVmaXhlcy5wdXNoKHJlc29sdmVUYWdEaXJlY3RpdmUoZG9jLCBkaXJlY3RpdmUpKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdZQU1MJzpcbiAgICAgICAgY2FzZSAnWUFNTDoxLjAnOlxuICAgICAgICAgIGlmIChkb2MudmVyc2lvbikge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdUaGUgJVlBTUwgZGlyZWN0aXZlIG11c3Qgb25seSBiZSBnaXZlbiBhdCBtb3N0IG9uY2UgcGVyIGRvY3VtZW50Lic7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKGRpcmVjdGl2ZSwgbXNnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRvYy52ZXJzaW9uID0gcmVzb2x2ZVlhbWxEaXJlY3RpdmUoZG9jLCBkaXJlY3RpdmUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfbXNnMyA9IFwiWUFNTCBvbmx5IHN1cHBvcnRzICVUQUcgYW5kICVZQU1MIGRpcmVjdGl2ZXMsIGFuZCBub3QgJVwiLmNvbmNhdChuYW1lKTtcblxuICAgICAgICAgICAgZG9jLndhcm5pbmdzLnB1c2gobmV3IFlBTUxXYXJuaW5nKGRpcmVjdGl2ZSwgX21zZzMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbW1lbnQpIGRpcmVjdGl2ZUNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICBpZiAocHJldkRvYyAmJiAhaGFzRGlyZWN0aXZlcyAmJiAnMS4xJyA9PT0gKGRvYy52ZXJzaW9uIHx8IHByZXZEb2MudmVyc2lvbiB8fCBkb2Mub3B0aW9ucy52ZXJzaW9uKSkge1xuICAgIHZhciBjb3B5VGFnUHJlZml4ID0gZnVuY3Rpb24gY29weVRhZ1ByZWZpeChfcmVmMikge1xuICAgICAgdmFyIGhhbmRsZSA9IF9yZWYyLmhhbmRsZSxcbiAgICAgICAgICBwcmVmaXggPSBfcmVmMi5wcmVmaXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGRvYy50YWdQcmVmaXhlcyA9IHByZXZEb2MudGFnUHJlZml4ZXMubWFwKGNvcHlUYWdQcmVmaXgpO1xuICAgIGRvYy52ZXJzaW9uID0gcHJldkRvYy52ZXJzaW9uO1xuICB9XG5cbiAgZG9jLmNvbW1lbnRCZWZvcmUgPSBkaXJlY3RpdmVDb21tZW50cy5qb2luKCdcXG4nKSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDb2xsZWN0aW9uKGNvbnRlbnRzKSB7XG4gIGlmIChjb250ZW50cyBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHJldHVybiB0cnVlO1xuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgWUFNTCBjb2xsZWN0aW9uIGFzIGRvY3VtZW50IGNvbnRlbnRzJyk7XG59XG5cbnZhciBEb2N1bWVudCQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRG9jdW1lbnQob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb2N1bWVudCk7XG5cbiAgICB0aGlzLmFuY2hvcnMgPSBuZXcgQW5jaG9ycyhvcHRpb25zLmFuY2hvclByZWZpeCk7XG4gICAgdGhpcy5jb21tZW50QmVmb3JlID0gbnVsbDtcbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY29udGVudHMgPSBudWxsO1xuICAgIHRoaXMuZGlyZWN0aXZlc0VuZE1hcmtlciA9IG51bGw7XG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc2NoZW1hID0gbnVsbDtcbiAgICB0aGlzLnRhZ1ByZWZpeGVzID0gW107XG4gICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICB0aGlzLndhcm5pbmdzID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRG9jdW1lbnQsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5hZGQodmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKTtcbiAgICAgIHRoaXMuY29udGVudHMuYWRkSW4ocGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlSW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlSW4ocGF0aCkge1xuICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMuZGVsZXRlSW4ocGF0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlZmF1bHRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmF1bHRzKCkge1xuICAgICAgcmV0dXJuIERvY3VtZW50LmRlZmF1bHRzW3RoaXMudmVyc2lvbl0gfHwgRG9jdW1lbnQuZGVmYXVsdHNbdGhpcy5vcHRpb25zLnZlcnNpb25dIHx8IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uID8gdGhpcy5jb250ZW50cy5nZXQoa2V5LCBrZWVwU2NhbGFyKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKSByZXR1cm4gIWtlZXBTY2FsYXIgJiYgdGhpcy5jb250ZW50cyBpbnN0YW5jZW9mIFNjYWxhciA/IHRoaXMuY29udGVudHMudmFsdWUgOiB0aGlzLmNvbnRlbnRzO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uID8gdGhpcy5jb250ZW50cy5nZXRJbihwYXRoLCBrZWVwU2NhbGFyKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRzIGluc3RhbmNlb2YgQ29sbGVjdGlvbiA/IHRoaXMuY29udGVudHMuaGFzKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzSW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzSW4ocGF0aCkge1xuICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKSByZXR1cm4gdGhpcy5jb250ZW50cyAhPT0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uID8gdGhpcy5jb250ZW50cy5oYXNJbihwYXRoKSA6IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cyk7XG4gICAgICB0aGlzLmNvbnRlbnRzLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSkgdGhpcy5jb250ZW50cyA9IHZhbHVlO2Vsc2Uge1xuICAgICAgICBhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpO1xuICAgICAgICB0aGlzLmNvbnRlbnRzLnNldEluKHBhdGgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2NoZW1hXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNjaGVtYShpZCwgY3VzdG9tVGFncykge1xuICAgICAgaWYgKCFpZCAmJiAhY3VzdG9tVGFncyAmJiB0aGlzLnNjaGVtYSkgcmV0dXJuO1xuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ251bWJlcicpIGlkID0gaWQudG9GaXhlZCgxKTtcblxuICAgICAgaWYgKGlkID09PSAnMS4wJyB8fCBpZCA9PT0gJzEuMScgfHwgaWQgPT09ICcxLjInKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24pIHRoaXMudmVyc2lvbiA9IGlkO2Vsc2UgdGhpcy5vcHRpb25zLnZlcnNpb24gPSBpZDtcbiAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5zY2hlbWE7XG4gICAgICB9IGVsc2UgaWYgKGlkICYmIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNjaGVtYSA9IGlkO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSkgdGhpcy5vcHRpb25zLmN1c3RvbVRhZ3MgPSBjdXN0b21UYWdzO1xuICAgICAgdmFyIG9wdCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0RGVmYXVsdHMoKSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuc2NoZW1hID0gbmV3IFNjaGVtYShvcHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShub2RlLCBwcmV2RG9jKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBDc3ROb2RlcykgdGhpcy5jc3ROb2RlID0gbm9kZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE5vZGVUeXBlcykgdGhpcy50eXBlID0gJ0RPQ1VNRU5UJztcbiAgICAgIHZhciBfbm9kZSRkaXJlY3RpdmVzID0gbm9kZS5kaXJlY3RpdmVzLFxuICAgICAgICAgIGRpcmVjdGl2ZXMgPSBfbm9kZSRkaXJlY3RpdmVzID09PSB2b2lkIDAgPyBbXSA6IF9ub2RlJGRpcmVjdGl2ZXMsXG4gICAgICAgICAgX25vZGUkY29udGVudHMgPSBub2RlLmNvbnRlbnRzLFxuICAgICAgICAgIGNvbnRlbnRzID0gX25vZGUkY29udGVudHMgPT09IHZvaWQgMCA/IFtdIDogX25vZGUkY29udGVudHMsXG4gICAgICAgICAgZGlyZWN0aXZlc0VuZE1hcmtlciA9IG5vZGUuZGlyZWN0aXZlc0VuZE1hcmtlcixcbiAgICAgICAgICBlcnJvciA9IG5vZGUuZXJyb3IsXG4gICAgICAgICAgdmFsdWVSYW5nZSA9IG5vZGUudmFsdWVSYW5nZTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGlmICghZXJyb3Iuc291cmNlKSBlcnJvci5zb3VyY2UgPSB0aGlzO1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VEaXJlY3RpdmVzKHRoaXMsIGRpcmVjdGl2ZXMsIHByZXZEb2MpO1xuICAgICAgaWYgKGRpcmVjdGl2ZXNFbmRNYXJrZXIpIHRoaXMuZGlyZWN0aXZlc0VuZE1hcmtlciA9IHRydWU7XG4gICAgICB0aGlzLnJhbmdlID0gdmFsdWVSYW5nZSA/IFt2YWx1ZVJhbmdlLnN0YXJ0LCB2YWx1ZVJhbmdlLmVuZF0gOiBudWxsO1xuICAgICAgdGhpcy5zZXRTY2hlbWEoKTtcbiAgICAgIHRoaXMuYW5jaG9ycy5fY3N0QWxpYXNlcyA9IFtdO1xuICAgICAgcGFyc2VDb250ZW50cyh0aGlzLCBjb250ZW50cyk7XG4gICAgICB0aGlzLmFuY2hvcnMucmVzb2x2ZU5vZGVzKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldHR5RXJyb3JzKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmVycm9ycyksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX2Vycm9yID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoX2Vycm9yIGluc3RhbmNlb2YgWUFNTEVycm9yKSBfZXJyb3IubWFrZVByZXR0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLndhcm5pbmdzKSxcbiAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgd2FybiA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIGlmICh3YXJuIGluc3RhbmNlb2YgWUFNTEVycm9yKSB3YXJuLm1ha2VQcmV0dHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaXN0Tm9uRGVmYXVsdFRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdE5vbkRlZmF1bHRUYWdzKCkge1xuICAgICAgcmV0dXJuIGxpc3RUYWdOYW1lcyh0aGlzLmNvbnRlbnRzKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaW5kZXhPZihTY2hlbWEuZGVmYXVsdFByZWZpeCkgIT09IDA7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGFnUHJlZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRhZ1ByZWZpeChoYW5kbGUsIHByZWZpeCkge1xuICAgICAgaWYgKGhhbmRsZVswXSAhPT0gJyEnIHx8IGhhbmRsZVtoYW5kbGUubGVuZ3RoIC0gMV0gIT09ICchJykgdGhyb3cgbmV3IEVycm9yKCdIYW5kbGUgbXVzdCBzdGFydCBhbmQgZW5kIHdpdGggIScpO1xuXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy50YWdQcmVmaXhlcy5maW5kKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIHAuaGFuZGxlID09PSBoYW5kbGU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJldikgcHJldi5wcmVmaXggPSBwcmVmaXg7ZWxzZSB0aGlzLnRhZ1ByZWZpeGVzLnB1c2goe1xuICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxuICAgICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YWdQcmVmaXhlcyA9IHRoaXMudGFnUHJlZml4ZXMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIHAuaGFuZGxlICE9PSBoYW5kbGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OJDEoYXJnLCBvbkFuY2hvcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAga2VlcEJsb2JzSW5KU09OID0gX3RoaXMkb3B0aW9ucy5rZWVwQmxvYnNJbkpTT04sXG4gICAgICAgICAgbWFwQXNNYXAgPSBfdGhpcyRvcHRpb25zLm1hcEFzTWFwLFxuICAgICAgICAgIG1heEFsaWFzQ291bnQgPSBfdGhpcyRvcHRpb25zLm1heEFsaWFzQ291bnQ7XG4gICAgICB2YXIga2VlcCA9IGtlZXBCbG9ic0luSlNPTiAmJiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgfHwgISh0aGlzLmNvbnRlbnRzIGluc3RhbmNlb2YgU2NhbGFyKSk7XG4gICAgICB2YXIgY3R4ID0ge1xuICAgICAgICBkb2M6IHRoaXMsXG4gICAgICAgIGluZGVudFN0ZXA6ICcgICcsXG4gICAgICAgIGtlZXA6IGtlZXAsXG4gICAgICAgIG1hcEFzTWFwOiBrZWVwICYmICEhbWFwQXNNYXAsXG4gICAgICAgIG1heEFsaWFzQ291bnQ6IG1heEFsaWFzQ291bnQsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5JDEgLy8gUmVxdWlyaW5nIGRpcmVjdGx5IGluIFBhaXIgd291bGQgY3JlYXRlIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG4gICAgICB9O1xuICAgICAgdmFyIGFuY2hvck5hbWVzID0gT2JqZWN0LmtleXModGhpcy5hbmNob3JzLm1hcCk7XG4gICAgICBpZiAoYW5jaG9yTmFtZXMubGVuZ3RoID4gMCkgY3R4LmFuY2hvcnMgPSBuZXcgTWFwKGFuY2hvck5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gW190aGlzLmFuY2hvcnMubWFwW25hbWVdLCB7XG4gICAgICAgICAgYWxpYXM6IFtdLFxuICAgICAgICAgIGFsaWFzQ291bnQ6IDAsXG4gICAgICAgICAgY291bnQ6IDFcbiAgICAgICAgfV07XG4gICAgICB9KSk7XG5cbiAgICAgIHZhciByZXMgPSB0b0pTT04odGhpcy5jb250ZW50cywgYXJnLCBjdHgpO1xuXG4gICAgICBpZiAodHlwZW9mIG9uQW5jaG9yID09PSAnZnVuY3Rpb24nICYmIGN0eC5hbmNob3JzKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY3R4LmFuY2hvcnMudmFsdWVzKCkpLFxuICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc3RlcDMudmFsdWUsXG4gICAgICAgICAgICAgICAgY291bnQgPSBfc3RlcDMkdmFsdWUuY291bnQsXG4gICAgICAgICAgICAgICAgX3JlcyA9IF9zdGVwMyR2YWx1ZS5yZXM7XG4gICAgICAgICAgICBvbkFuY2hvcihfcmVzLCBjb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IHdpdGggZXJyb3JzIGNhbm5vdCBiZSBzdHJpbmdpZmllZCcpO1xuICAgICAgdmFyIGluZGVudFNpemUgPSB0aGlzLm9wdGlvbnMuaW5kZW50O1xuXG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5kZW50U2l6ZSkgfHwgaW5kZW50U2l6ZSA8PSAwKSB7XG4gICAgICAgIHZhciBzID0gSlNPTi5zdHJpbmdpZnkoaW5kZW50U2l6ZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJpbmRlbnRcXFwiIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgbm90IFwiLmNvbmNhdChzKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U2NoZW1hKCk7XG4gICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgIHZhciBoYXNEaXJlY3RpdmVzID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgdmFyIHZkID0gJyVZQU1MIDEuMic7XG5cbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hLm5hbWUgPT09ICd5YW1sLTEuMScpIHtcbiAgICAgICAgICBpZiAodGhpcy52ZXJzaW9uID09PSAnMS4wJykgdmQgPSAnJVlBTUw6MS4wJztlbHNlIGlmICh0aGlzLnZlcnNpb24gPT09ICcxLjEnKSB2ZCA9ICclWUFNTCAxLjEnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMucHVzaCh2ZCk7XG4gICAgICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFnTmFtZXMgPSB0aGlzLmxpc3ROb25EZWZhdWx0VGFncygpO1xuICAgICAgdGhpcy50YWdQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBoYW5kbGUgPSBfcmVmLmhhbmRsZSxcbiAgICAgICAgICAgIHByZWZpeCA9IF9yZWYucHJlZml4O1xuXG4gICAgICAgIGlmICh0YWdOYW1lcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuaW5kZXhPZihwcmVmaXgpID09PSAwO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGxpbmVzLnB1c2goXCIlVEFHIFwiLmNvbmNhdChoYW5kbGUsIFwiIFwiKS5jb25jYXQocHJlZml4KSk7XG4gICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc0RpcmVjdGl2ZXMgfHwgdGhpcy5kaXJlY3RpdmVzRW5kTWFya2VyKSBsaW5lcy5wdXNoKCctLS0nKTtcblxuICAgICAgaWYgKHRoaXMuY29tbWVudEJlZm9yZSkge1xuICAgICAgICBpZiAoaGFzRGlyZWN0aXZlcyB8fCAhdGhpcy5kaXJlY3RpdmVzRW5kTWFya2VyKSBsaW5lcy51bnNoaWZ0KCcnKTtcbiAgICAgICAgbGluZXMudW5zaGlmdCh0aGlzLmNvbW1lbnRCZWZvcmUucmVwbGFjZSgvXi9nbSwgJyMnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB7XG4gICAgICAgIGFuY2hvcnM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGRvYzogdGhpcyxcbiAgICAgICAgaW5kZW50OiAnJyxcbiAgICAgICAgaW5kZW50U3RlcDogJyAnLnJlcGVhdChpbmRlbnRTaXplKSxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnkkMSAvLyBSZXF1aXJpbmcgZGlyZWN0bHkgaW4gbm9kZXMgd291bGQgY3JlYXRlIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG4gICAgICB9O1xuICAgICAgdmFyIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgdmFyIGNvbnRlbnRDb21tZW50ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuY29udGVudHMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudHMgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29udGVudHMuc3BhY2VCZWZvcmUgJiYgKGhhc0RpcmVjdGl2ZXMgfHwgdGhpcy5kaXJlY3RpdmVzRW5kTWFya2VyKSkgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgaWYgKHRoaXMuY29udGVudHMuY29tbWVudEJlZm9yZSkgbGluZXMucHVzaCh0aGlzLmNvbnRlbnRzLmNvbW1lbnRCZWZvcmUucmVwbGFjZSgvXi9nbSwgJyMnKSk7IC8vIHRvcC1sZXZlbCBibG9jayBzY2FsYXJzIG5lZWQgdG8gYmUgaW5kZW50ZWQgaWYgZm9sbG93ZWQgYnkgYSBjb21tZW50XG5cbiAgICAgICAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9ICEhdGhpcy5jb21tZW50O1xuICAgICAgICAgIGNvbnRlbnRDb21tZW50ID0gdGhpcy5jb250ZW50cy5jb21tZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uQ2hvbXBLZWVwID0gY29udGVudENvbW1lbnQgPyBudWxsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjaG9tcEtlZXAgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYm9keSA9IHN0cmluZ2lmeSQxKHRoaXMuY29udGVudHMsIGN0eCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZW50Q29tbWVudCA9IG51bGw7XG4gICAgICAgIH0sIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgbGluZXMucHVzaChhZGRDb21tZW50KGJvZHksICcnLCBjb250ZW50Q29tbWVudCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnRlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGluZXMucHVzaChzdHJpbmdpZnkkMSh0aGlzLmNvbnRlbnRzLCBjdHgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29tbWVudCkge1xuICAgICAgICBpZiAoKCFjaG9tcEtlZXAgfHwgY29udGVudENvbW1lbnQpICYmIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdICE9PSAnJykgbGluZXMucHVzaCgnJyk7XG4gICAgICAgIGxpbmVzLnB1c2godGhpcy5jb21tZW50LnJlcGxhY2UoL14vZ20sICcjJykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJykgKyAnXFxuJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRG9jdW1lbnQ7XG59KCk7XG5cbl9kZWZpbmVQcm9wZXJ0eShEb2N1bWVudCQxLCBcImRlZmF1bHRzXCIsIGRvY3VtZW50T3B0aW9ucyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodmFsdWUpIHtcbiAgdmFyIHdyYXBTY2FsYXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICB2YXIgdGFnID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiB3cmFwU2NhbGFycyA9PT0gJ3N0cmluZycpIHtcbiAgICB0YWcgPSB3cmFwU2NhbGFycztcbiAgICB3cmFwU2NhbGFycyA9IHRydWU7XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERvY3VtZW50JDEuZGVmYXVsdHNbZGVmYXVsdE9wdGlvbnMudmVyc2lvbl0sIGRlZmF1bHRPcHRpb25zKTtcbiAgdmFyIHNjaGVtYSA9IG5ldyBTY2hlbWEob3B0aW9ucyk7XG4gIHJldHVybiBzY2hlbWEuY3JlYXRlTm9kZSh2YWx1ZSwgd3JhcFNjYWxhcnMsIHRhZyk7XG59XG5cbnZhciBEb2N1bWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1lBTUxEb2N1bWVudCkge1xuICBfaW5oZXJpdHMoRG9jdW1lbnQsIF9ZQU1MRG9jdW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRG9jdW1lbnQpO1xuXG4gIGZ1bmN0aW9uIERvY3VtZW50KG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9jdW1lbnQpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKSk7XG4gIH1cblxuICByZXR1cm4gRG9jdW1lbnQ7XG59KERvY3VtZW50JDEpO1xuXG5mdW5jdGlvbiBwYXJzZUFsbERvY3VtZW50cyhzcmMsIG9wdGlvbnMpIHtcbiAgdmFyIHN0cmVhbSA9IFtdO1xuICB2YXIgcHJldjtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGFyc2UkMShzcmMpKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBjc3REb2MgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHZhciBkb2MgPSBuZXcgRG9jdW1lbnQob3B0aW9ucyk7XG4gICAgICBkb2MucGFyc2UoY3N0RG9jLCBwcmV2KTtcbiAgICAgIHN0cmVhbS5wdXNoKGRvYyk7XG4gICAgICBwcmV2ID0gZG9jO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChzcmMsIG9wdGlvbnMpIHtcbiAgdmFyIGNzdCA9IHBhcnNlJDEoc3JjKTtcbiAgdmFyIGRvYyA9IG5ldyBEb2N1bWVudChvcHRpb25zKS5wYXJzZShjc3RbMF0pO1xuXG4gIGlmIChjc3QubGVuZ3RoID4gMSkge1xuICAgIHZhciBlcnJNc2cgPSAnU291cmNlIGNvbnRhaW5zIG11bHRpcGxlIGRvY3VtZW50czsgcGxlYXNlIHVzZSBZQU1MLnBhcnNlQWxsRG9jdW1lbnRzKCknO1xuICAgIGRvYy5lcnJvcnMudW5zaGlmdChuZXcgWUFNTFNlbWFudGljRXJyb3IoY3N0WzFdLCBlcnJNc2cpKTtcbiAgfVxuXG4gIHJldHVybiBkb2M7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHNyYywgb3B0aW9ucykge1xuICB2YXIgZG9jID0gcGFyc2VEb2N1bWVudChzcmMsIG9wdGlvbnMpO1xuICBkb2Mud2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAod2FybmluZykge1xuICAgIHJldHVybiB3YXJuKHdhcm5pbmcpO1xuICB9KTtcbiAgaWYgKGRvYy5lcnJvcnMubGVuZ3RoID4gMCkgdGhyb3cgZG9jLmVycm9yc1swXTtcbiAgcmV0dXJuIGRvYy50b0pTT04oKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBkb2MgPSBuZXcgRG9jdW1lbnQob3B0aW9ucyk7XG4gIGRvYy5jb250ZW50cyA9IHZhbHVlO1xuICByZXR1cm4gU3RyaW5nKGRvYyk7XG59XG5cbnZhciBZQU1MID0ge1xuICBjcmVhdGVOb2RlOiBjcmVhdGVOb2RlLFxuICBkZWZhdWx0T3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG4gIERvY3VtZW50OiBEb2N1bWVudCxcbiAgcGFyc2U6IHBhcnNlLFxuICBwYXJzZUFsbERvY3VtZW50czogcGFyc2VBbGxEb2N1bWVudHMsXG4gIHBhcnNlQ1NUOiBwYXJzZSQxLFxuICBwYXJzZURvY3VtZW50OiBwYXJzZURvY3VtZW50LFxuICBzY2FsYXJPcHRpb25zOiBzY2FsYXJPcHRpb25zLFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeVxufTtcblxuZXhwb3J0IHsgWUFNTCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/index.js\n")},"./node_modules/yaml/browser/dist/parse-cst.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlainValue-b8036b75.js */ \"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\");\n\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(BlankLine, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(BlankLine);\n\n  function BlankLine() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, BlankLine);\n\n    return _super.call(this, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(BlankLine, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, start + 1);\n      return start + 1;\n    }\n  }]);\n\n  return BlankLine;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(CollectionItem, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(CollectionItem, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM) this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, offset + 1);\n\n          comments.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return CollectionItem;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Comment, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Comment);\n\n  function Comment() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Comment);\n\n    return _super.call(this, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nvar Collection = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Collection, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Collection);\n\n  function Collection(firstItem) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Collection);\n\n    _this = _super.call(this, firstItem.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ : _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Collection, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, lineStart);\n\n          if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atBlank(src, offset)) {\n            var wsEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, msg);\n          }\n        }\n\n        if (firstItem.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, offset) + 1;\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  return Collection;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Directive, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Directive);\n\n  function Directive() {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Directive);\n\n    _this = _super.call(this, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Directive, [{\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }, {\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Directive;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Document, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Document);\n\n  function Document() {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Document);\n\n    _this = _super.call(this, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(src, offset, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset);\n\n      while (!_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(src, offset, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }], [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  return Document;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Alias, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Alias);\n\n  function Alias() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Alias, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIdentifier(src, start + 1);\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start + 1, offset);\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(BlockValue, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(BlockValue, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch === ' ' || _ch === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }, {\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(src, offset)) break;\n        var end = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch2 = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch2 && _ch2 !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }]);\n\n  return BlockValue;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(FlowCollection, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset + 1);\n\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(QuoteDouble, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(QuoteDouble);\n\n  function QuoteDouble() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(QuoteDouble, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(src, i + 1)) errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }, {\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(QuoteSingle, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(QuoteSingle);\n\n  function QuoteSingle() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(QuoteSingle, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(src, i + 1)) errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.ALIAS:\n      return new Alias(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_KEY:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_VALUE:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN:\n      return new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.P(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, ParseContext);\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, \"parseNode\", function (overlay, start) {\n      if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.DOCUMENT) {\n          node.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, offset) : _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.ANCHOR || ch === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.COMMENT || ch === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var inEnd = offset;\n          var lineStart = void 0;\n\n          do {\n            lineStart = inEnd + 1;\n            inEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, lineStart);\n          } while (src[inEnd] === '\\n');\n\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM && parent.context.atLineStart;\n          if (src[inEnd] !== '#' && !_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.COMMENT) {\n          var end = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, offset + 1);\n          props.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset, end));\n          offset = end;\n        } else {\n          var _end = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIdentifier(src, offset + 1);\n\n          if (ch === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset, _end));\n          lineHasProps = true;\n          offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }], [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.ALIAS;\n\n        case '>':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED;\n\n        case '|':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL;\n\n        case '{':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP;\n\n        case '[':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atBlank(src, offset + 1, true) ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_KEY : _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN;\n\n        case ':':\n          return !inFlow && _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atBlank(src, offset + 1, true) ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_VALUE : _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN;\n\n        case '-':\n          return !inFlow && _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atBlank(src, offset + 1, true) ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM : _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN;\n\n        case '\"':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE;\n\n        case \"'\":\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_SINGLE;\n\n        default:\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN;\n      }\n    }\n  }]);\n\n  return ParseContext;\n}();\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UtY3N0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlSOztBQUV6UjtBQUNBLEVBQUUsMERBQVM7O0FBRVgsZUFBZSwwREFBWTs7QUFFM0I7QUFDQSxJQUFJLDBEQUFlOztBQUVuQiw2QkFBNkIsaUVBQWU7QUFDNUM7QUFDQTs7O0FBR0EsRUFBRSwwREFBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBSztBQUM1QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsQ0FBQyxzREFBSTs7QUFFTjtBQUNBLEVBQUUsMERBQVM7O0FBRVgsZUFBZSwwREFBWTs7QUFFM0I7QUFDQTs7QUFFQSxJQUFJLDBEQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDBEQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtEQUFhLG1CQUFtQixzREFBaUI7QUFDekY7QUFDQSxtQkFBbUIsc0VBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWM7O0FBRW5DLDRCQUE0QixzREFBSztBQUNqQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esc0JBQXNCLHNFQUFvQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsbUJBQW1CLGtFQUFnQjtBQUNuQzs7QUFFQTtBQUNBOztBQUVBLFVBQVUseUVBQXVCLGtEQUFr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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9wLXh5ei8uL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS1jc3QuanM/ZTdkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqIGFzIF9pbmhlcml0cywgayBhcyBfY3JlYXRlU3VwZXIsIGMgYXMgX2NsYXNzQ2FsbENoZWNrLCBUIGFzIFR5cGUsIGIgYXMgX2NyZWF0ZUNsYXNzLCBSIGFzIFJhbmdlLCBOIGFzIE5vZGUsIGcgYXMgWUFNTFNlbWFudGljRXJyb3IsIGwgYXMgX2dldCwgbSBhcyBfZ2V0UHJvdG90eXBlT2YsIFkgYXMgWUFNTFN5bnRheEVycm9yLCBDIGFzIENoYXIsIGUgYXMgX2RlZmluZVByb3BlcnR5LCBQIGFzIFBsYWluVmFsdWUgfSBmcm9tICcuL1BsYWluVmFsdWUtYjgwMzZiNzUuanMnO1xuXG52YXIgQmxhbmtMaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoQmxhbmtMaW5lLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCbGFua0xpbmUpO1xuXG4gIGZ1bmN0aW9uIEJsYW5rTGluZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmxhbmtMaW5lKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBUeXBlLkJMQU5LX0xJTkUpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmxhbmtMaW5lLCBbe1xuICAgIGtleTogXCJpbmNsdWRlc1RyYWlsaW5nTGluZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIC8vIFRoaXMgaXMgbmV2ZXIgY2FsbGVkIGZyb20gYW55d2hlcmUsIGJ1dCBpZiBpdCB3ZXJlLFxuICAgICAgLy8gdGhpcyBpcyB0aGUgdmFsdWUgaXQgc2hvdWxkIHJldHVybi5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBibGFuayBsaW5lIGZyb20gdGhlIHNvdXJjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBcXG4gY2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQgKyAxKTtcbiAgICAgIHJldHVybiBzdGFydCArIDE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJsYW5rTGluZTtcbn0oTm9kZSk7XG5cbnZhciBDb2xsZWN0aW9uSXRlbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKENvbGxlY3Rpb25JdGVtLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDb2xsZWN0aW9uSXRlbSk7XG5cbiAgZnVuY3Rpb24gQ29sbGVjdGlvbkl0ZW0odHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sbGVjdGlvbkl0ZW0pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBwcm9wcyk7XG4gICAgX3RoaXMubm9kZSA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbGxlY3Rpb25JdGVtLCBbe1xuICAgIGtleTogXCJpbmNsdWRlc1RyYWlsaW5nTGluZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMubm9kZSAmJiB0aGlzLm5vZGUuaW5jbHVkZXNUcmFpbGluZ0xpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHZhciBwYXJzZU5vZGUgPSBjb250ZXh0LnBhcnNlTm9kZSxcbiAgICAgICAgICBzcmMgPSBjb250ZXh0LnNyYztcbiAgICAgIHZhciBhdExpbmVTdGFydCA9IGNvbnRleHQuYXRMaW5lU3RhcnQsXG4gICAgICAgICAgbGluZVN0YXJ0ID0gY29udGV4dC5saW5lU3RhcnQ7XG4gICAgICBpZiAoIWF0TGluZVN0YXJ0ICYmIHRoaXMudHlwZSA9PT0gVHlwZS5TRVFfSVRFTSkgdGhpcy5lcnJvciA9IG5ldyBZQU1MU2VtYW50aWNFcnJvcih0aGlzLCAnU2VxdWVuY2UgaXRlbXMgbXVzdCBub3QgaGF2ZSBwcmVjZWRpbmcgY29udGVudCBvbiB0aGUgc2FtZSBsaW5lJyk7XG4gICAgICB2YXIgaW5kZW50ID0gYXRMaW5lU3RhcnQgPyBzdGFydCAtIGxpbmVTdGFydCA6IGNvbnRleHQuaW5kZW50O1xuICAgICAgdmFyIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgc3RhcnQgKyAxKTtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuICAgICAgdmFyIGlubGluZUNvbW1lbnQgPSBjaCA9PT0gJyMnO1xuICAgICAgdmFyIGNvbW1lbnRzID0gW107XG4gICAgICB2YXIgYmxhbmtMaW5lID0gbnVsbDtcblxuICAgICAgd2hpbGUgKGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJyMnKSB7XG4gICAgICAgIGlmIChjaCA9PT0gJyMnKSB7XG4gICAgICAgICAgdmFyIF9lbmQgPSBOb2RlLmVuZE9mTGluZShzcmMsIG9mZnNldCArIDEpO1xuXG4gICAgICAgICAgY29tbWVudHMucHVzaChuZXcgUmFuZ2Uob2Zmc2V0LCBfZW5kKSk7XG4gICAgICAgICAgb2Zmc2V0ID0gX2VuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdExpbmVTdGFydCA9IHRydWU7XG4gICAgICAgICAgbGluZVN0YXJ0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICB2YXIgd3NFbmQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIGxpbmVTdGFydCk7XG5cbiAgICAgICAgICBpZiAoc3JjW3dzRW5kXSA9PT0gJ1xcbicgJiYgY29tbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBibGFua0xpbmUgPSBuZXcgQmxhbmtMaW5lKCk7XG4gICAgICAgICAgICBsaW5lU3RhcnQgPSBibGFua0xpbmUucGFyc2Uoe1xuICAgICAgICAgICAgICBzcmM6IHNyY1xuICAgICAgICAgICAgfSwgbGluZVN0YXJ0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvZmZzZXQgPSBOb2RlLmVuZE9mSW5kZW50KHNyYywgbGluZVN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoID0gc3JjW29mZnNldF07XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlLm5leHROb2RlSXNJbmRlbnRlZChjaCwgb2Zmc2V0IC0gKGxpbmVTdGFydCArIGluZGVudCksIHRoaXMudHlwZSAhPT0gVHlwZS5TRVFfSVRFTSkpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gcGFyc2VOb2RlKHtcbiAgICAgICAgICBhdExpbmVTdGFydDogYXRMaW5lU3RhcnQsXG4gICAgICAgICAgaW5Db2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICBpbmRlbnQ6IGluZGVudCxcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgICAgfSwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggJiYgbGluZVN0YXJ0ID4gc3RhcnQgKyAxKSB7XG4gICAgICAgIG9mZnNldCA9IGxpbmVTdGFydCAtIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgICAgaWYgKGJsYW5rTGluZSkge1xuICAgICAgICAgIC8vIE9ubHkgYmxhbmsgbGluZXMgcHJlY2VkaW5nIG5vbi1lbXB0eSBub2RlcyBhcmUgY2FwdHVyZWQuIE5vdGUgdGhhdFxuICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBjb2xsZWN0aW9uIGl0ZW0gcmFuZ2Ugc3RhcnQgaW5kaWNlcyBkbyBub3QgYWx3YXlzXG4gICAgICAgICAgLy8gaW5jcmVhc2UgbW9ub3RvbmljYWxseS4gLS0gZWVtZWxpL3lhbWwjMTI2XG4gICAgICAgICAgdmFyIGl0ZW1zID0gY29udGV4dC5wYXJlbnQuaXRlbXMgfHwgY29udGV4dC5wYXJlbnQuY29udGVudHM7XG4gICAgICAgICAgaWYgKGl0ZW1zKSBpdGVtcy5wdXNoKGJsYW5rTGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbWVudHMubGVuZ3RoKSBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnByb3BzLCBjb21tZW50cyk7XG4gICAgICAgIG9mZnNldCA9IHRoaXMubm9kZS5yYW5nZS5lbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5saW5lQ29tbWVudCkge1xuICAgICAgICAgIHZhciBjID0gY29tbWVudHNbMF07XG4gICAgICAgICAgdGhpcy5wcm9wcy5wdXNoKGMpO1xuICAgICAgICAgIG9mZnNldCA9IGMuZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZMaW5lKHNyYywgc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5kID0gdGhpcy5ub2RlID8gdGhpcy5ub2RlLnZhbHVlUmFuZ2UuZW5kIDogb2Zmc2V0O1xuICAgICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3JpZ1Jhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IF9nZXQoX2dldFByb3RvdHlwZU9mKENvbGxlY3Rpb25JdGVtLnByb3RvdHlwZSksIFwic2V0T3JpZ1Jhbmdlc1wiLCB0aGlzKS5jYWxsKHRoaXMsIGNyLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIHRoaXMubm9kZSA/IHRoaXMubm9kZS5zZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpIDogb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjLFxuICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGUsXG4gICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlLFxuICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YXIgc3RyID0gbm9kZSA/IHNyYy5zbGljZShyYW5nZS5zdGFydCwgbm9kZS5yYW5nZS5zdGFydCkgKyBTdHJpbmcobm9kZSkgOiBzcmMuc2xpY2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICByZXR1cm4gTm9kZS5hZGRTdHJpbmdUZXJtaW5hdG9yKHNyYywgcmFuZ2UuZW5kLCBzdHIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xsZWN0aW9uSXRlbTtcbn0oTm9kZSk7XG5cbnZhciBDb21tZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoQ29tbWVudCwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ29tbWVudCk7XG5cbiAgZnVuY3Rpb24gQ29tbWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tbWVudCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgVHlwZS5DT01NRU5UKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgY29tbWVudCBsaW5lIGZyb20gdGhlIHNvdXJjZVxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBjaGFyYWN0ZXJcbiAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXMgc2NhbGFyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENvbW1lbnQsIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMucGFyc2VDb21tZW50KHN0YXJ0KTtcbiAgICAgIHRoaXMucmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb21tZW50O1xufShOb2RlKTtcblxuZnVuY3Rpb24gZ3JhYkNvbGxlY3Rpb25FbmRDb21tZW50cyhub2RlKSB7XG4gIHZhciBjbm9kZSA9IG5vZGU7XG5cbiAgd2hpbGUgKGNub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbkl0ZW0pIHtcbiAgICBjbm9kZSA9IGNub2RlLm5vZGU7XG4gIH1cblxuICBpZiAoIShjbm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pKSByZXR1cm4gbnVsbDtcbiAgdmFyIGxlbiA9IGNub2RlLml0ZW1zLmxlbmd0aDtcbiAgdmFyIGNpID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIG4gPSBjbm9kZS5pdGVtc1tpXTtcblxuICAgIGlmIChuLnR5cGUgPT09IFR5cGUuQ09NTUVOVCkge1xuICAgICAgLy8gS2VlcCBzdWZmaWNpZW50bHkgaW5kZW50ZWQgY29tbWVudHMgd2l0aCBwcmVjZWRpbmcgbm9kZVxuICAgICAgdmFyIF9uJGNvbnRleHQgPSBuLmNvbnRleHQsXG4gICAgICAgICAgaW5kZW50ID0gX24kY29udGV4dC5pbmRlbnQsXG4gICAgICAgICAgbGluZVN0YXJ0ID0gX24kY29udGV4dC5saW5lU3RhcnQ7XG4gICAgICBpZiAoaW5kZW50ID4gMCAmJiBuLnJhbmdlLnN0YXJ0ID49IGxpbmVTdGFydCArIGluZGVudCkgYnJlYWs7XG4gICAgICBjaSA9IGk7XG4gICAgfSBlbHNlIGlmIChuLnR5cGUgPT09IFR5cGUuQkxBTktfTElORSkgY2kgPSBpO2Vsc2UgYnJlYWs7XG4gIH1cblxuICBpZiAoY2kgPT09IC0xKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNhID0gY25vZGUuaXRlbXMuc3BsaWNlKGNpLCBsZW4gLSBjaSk7XG4gIHZhciBwcmV2RW5kID0gY2FbMF0ucmFuZ2Uuc3RhcnQ7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjbm9kZS5yYW5nZS5lbmQgPSBwcmV2RW5kO1xuICAgIGlmIChjbm9kZS52YWx1ZVJhbmdlICYmIGNub2RlLnZhbHVlUmFuZ2UuZW5kID4gcHJldkVuZCkgY25vZGUudmFsdWVSYW5nZS5lbmQgPSBwcmV2RW5kO1xuICAgIGlmIChjbm9kZSA9PT0gbm9kZSkgYnJlYWs7XG4gICAgY25vZGUgPSBjbm9kZS5jb250ZXh0LnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBjYTtcbn1cbnZhciBDb2xsZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoQ29sbGVjdGlvbiwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ29sbGVjdGlvbik7XG5cbiAgZnVuY3Rpb24gQ29sbGVjdGlvbihmaXJzdEl0ZW0pIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sbGVjdGlvbik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZpcnN0SXRlbS50eXBlID09PSBUeXBlLlNFUV9JVEVNID8gVHlwZS5TRVEgOiBUeXBlLk1BUCk7XG5cbiAgICBmb3IgKHZhciBpID0gZmlyc3RJdGVtLnByb3BzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAoZmlyc3RJdGVtLnByb3BzW2ldLnN0YXJ0IDwgZmlyc3RJdGVtLmNvbnRleHQubGluZVN0YXJ0KSB7XG4gICAgICAgIC8vIHByb3BzIG9uIHByZXZpb3VzIGxpbmUgYXJlIGFzc3VtZWQgYnkgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgX3RoaXMucHJvcHMgPSBmaXJzdEl0ZW0ucHJvcHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICBmaXJzdEl0ZW0ucHJvcHMgPSBmaXJzdEl0ZW0ucHJvcHMuc2xpY2UoaSArIDEpO1xuICAgICAgICB2YXIgaXRlbVJhbmdlID0gZmlyc3RJdGVtLnByb3BzWzBdIHx8IGZpcnN0SXRlbS52YWx1ZVJhbmdlO1xuICAgICAgICBmaXJzdEl0ZW0ucmFuZ2Uuc3RhcnQgPSBpdGVtUmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLml0ZW1zID0gW2ZpcnN0SXRlbV07XG4gICAgdmFyIGVjID0gZ3JhYkNvbGxlY3Rpb25FbmRDb21tZW50cyhmaXJzdEl0ZW0pO1xuICAgIGlmIChlYykgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoX3RoaXMuaXRlbXMsIGVjKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29sbGVjdGlvbiwgW3tcbiAgICBrZXk6IFwiaW5jbHVkZXNUcmFpbGluZ0xpbmVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHZhciBwYXJzZU5vZGUgPSBjb250ZXh0LnBhcnNlTm9kZSxcbiAgICAgICAgICBzcmMgPSBjb250ZXh0LnNyYzsgLy8gSXQncyBlYXNpZXIgdG8gcmVjYWxjdWxhdGUgbGluZVN0YXJ0IGhlcmUgcmF0aGVyIHRoYW4gdHJhY2tpbmcgZG93biB0aGVcbiAgICAgIC8vIGxhc3QgY29udGV4dCBmcm9tIHdoaWNoIHRvIHJlYWQgaXQgLS0gZWVtZWxpL3lhbWwjMlxuXG4gICAgICB2YXIgbGluZVN0YXJ0ID0gTm9kZS5zdGFydE9mTGluZShzcmMsIHN0YXJ0KTtcbiAgICAgIHZhciBmaXJzdEl0ZW0gPSB0aGlzLml0ZW1zWzBdOyAvLyBGaXJzdC1pdGVtIGNvbnRleHQgbmVlZHMgdG8gYmUgY29ycmVjdCBmb3IgbGF0ZXIgY29tbWVudCBoYW5kbGluZ1xuICAgICAgLy8gLS0gZWVtZWxpL3lhbWwjMTdcblxuICAgICAgZmlyc3RJdGVtLmNvbnRleHQucGFyZW50ID0gdGhpcztcbiAgICAgIHRoaXMudmFsdWVSYW5nZSA9IFJhbmdlLmNvcHkoZmlyc3RJdGVtLnZhbHVlUmFuZ2UpO1xuICAgICAgdmFyIGluZGVudCA9IGZpcnN0SXRlbS5yYW5nZS5zdGFydCAtIGZpcnN0SXRlbS5jb250ZXh0LmxpbmVTdGFydDtcbiAgICAgIHZhciBvZmZzZXQgPSBzdGFydDtcbiAgICAgIG9mZnNldCA9IE5vZGUubm9ybWFsaXplT2Zmc2V0KHNyYywgb2Zmc2V0KTtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuICAgICAgdmFyIGF0TGluZVN0YXJ0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBsaW5lU3RhcnQpID09PSBvZmZzZXQ7XG4gICAgICB2YXIgcHJldkluY2x1ZGVzVHJhaWxpbmdMaW5lcyA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgd2hpbGUgKGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJyMnKSB7XG4gICAgICAgICAgaWYgKGF0TGluZVN0YXJ0ICYmIGNoID09PSAnXFxuJyAmJiAhcHJldkluY2x1ZGVzVHJhaWxpbmdMaW5lcykge1xuICAgICAgICAgICAgdmFyIGJsYW5rTGluZSA9IG5ldyBCbGFua0xpbmUoKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGJsYW5rTGluZS5wYXJzZSh7XG4gICAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZVJhbmdlLmVuZCA9IG9mZnNldDtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+PSBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNoID0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChibGFua0xpbmUpO1xuICAgICAgICAgICAgb2Zmc2V0IC09IDE7IC8vIGJsYW5rTGluZS5wYXJzZSgpIGNvbnN1bWVzIHRlcm1pbmFsIG5ld2xpbmVcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnIycpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCBsaW5lU3RhcnQgKyBpbmRlbnQgJiYgIUNvbGxlY3Rpb24ubmV4dENvbnRlbnRIYXNJbmRlbnQoc3JjLCBvZmZzZXQsIGluZGVudCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBuZXcgQ29tbWVudCgpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gY29tbWVudC5wYXJzZSh7XG4gICAgICAgICAgICAgIGluZGVudDogaW5kZW50LFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgICAgIH0sIG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlUmFuZ2UuZW5kID0gb2Zmc2V0O1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID49IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2ggPSBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lU3RhcnQgPSBvZmZzZXQgKyAxO1xuICAgICAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZJbmRlbnQoc3JjLCBsaW5lU3RhcnQpO1xuXG4gICAgICAgICAgaWYgKE5vZGUuYXRCbGFuayhzcmMsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIHZhciB3c0VuZCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gc3JjW3dzRW5kXTtcblxuICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQgPT09ICdcXG4nIHx8IG5leHQgPT09ICcjJykge1xuICAgICAgICAgICAgICBvZmZzZXQgPSB3c0VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaCA9IHNyY1tvZmZzZXRdO1xuICAgICAgICAgIGF0TGluZVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXQgIT09IGxpbmVTdGFydCArIGluZGVudCAmJiAoYXRMaW5lU3RhcnQgfHwgY2ggIT09ICc6JykpIHtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgbGluZVN0YXJ0ICsgaW5kZW50KSB7XG4gICAgICAgICAgICBpZiAobGluZVN0YXJ0ID4gc3RhcnQpIG9mZnNldCA9IGxpbmVTdGFydDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnQWxsIGNvbGxlY3Rpb24gaXRlbXMgbXVzdCBzdGFydCBhdCB0aGUgc2FtZSBjb2x1bW4nO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBZQU1MU3ludGF4RXJyb3IodGhpcywgbXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3RJdGVtLnR5cGUgPT09IFR5cGUuU0VRX0lURU0pIHtcbiAgICAgICAgICBpZiAoY2ggIT09ICctJykge1xuICAgICAgICAgICAgaWYgKGxpbmVTdGFydCA+IHN0YXJ0KSBvZmZzZXQgPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICctJyAmJiAhdGhpcy5lcnJvcikge1xuICAgICAgICAgIC8vIG1hcCBrZXkgbWF5IHN0YXJ0IHdpdGggLSwgYXMgbG9uZyBhcyBpdCdzIGZvbGxvd2VkIGJ5IGEgbm9uLXdoaXRlc3BhY2UgY2hhclxuICAgICAgICAgIHZhciBfbmV4dCA9IHNyY1tvZmZzZXQgKyAxXTtcblxuICAgICAgICAgIGlmICghX25leHQgfHwgX25leHQgPT09ICdcXG4nIHx8IF9uZXh0ID09PSAnXFx0JyB8fCBfbmV4dCA9PT0gJyAnKSB7XG4gICAgICAgICAgICB2YXIgX21zZyA9ICdBIGNvbGxlY3Rpb24gY2Fubm90IGJlIGJvdGggYSBtYXBwaW5nIGFuZCBhIHNlcXVlbmNlJztcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgWUFNTFN5bnRheEVycm9yKHRoaXMsIF9tc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gcGFyc2VOb2RlKHtcbiAgICAgICAgICBhdExpbmVTdGFydDogYXRMaW5lU3RhcnQsXG4gICAgICAgICAgaW5Db2xsZWN0aW9uOiB0cnVlLFxuICAgICAgICAgIGluZGVudDogaW5kZW50LFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybiBvZmZzZXQ7IC8vIGF0IG5leHQgZG9jdW1lbnQgc3RhcnRcblxuICAgICAgICB0aGlzLml0ZW1zLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMudmFsdWVSYW5nZS5lbmQgPSBub2RlLnZhbHVlUmFuZ2UuZW5kO1xuICAgICAgICBvZmZzZXQgPSBOb2RlLm5vcm1hbGl6ZU9mZnNldChzcmMsIG5vZGUucmFuZ2UuZW5kKTtcbiAgICAgICAgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICAgICAgYXRMaW5lU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgcHJldkluY2x1ZGVzVHJhaWxpbmdMaW5lcyA9IG5vZGUuaW5jbHVkZXNUcmFpbGluZ0xpbmVzOyAvLyBOZWVkIHRvIHJlc2V0IGxpbmVTdGFydCBhbmQgYXRMaW5lU3RhcnQgaGVyZSBpZiBwcmVjZWRpbmcgbm9kZSdzIHJhbmdlXG4gICAgICAgIC8vIGhhcyBhZHZhbmNlZCB0byBjaGVjayB0aGUgY3VycmVudCBsaW5lJ3MgaW5kZW50YXRpb24gbGV2ZWxcbiAgICAgICAgLy8gLS0gZWVtZWxpL3lhbWwjMTAgJiBlZW1lbGkveWFtbCMzOFxuXG4gICAgICAgIGlmIChjaCkge1xuICAgICAgICAgIHZhciBscyA9IG9mZnNldCAtIDE7XG4gICAgICAgICAgdmFyIHByZXYgPSBzcmNbbHNdO1xuXG4gICAgICAgICAgd2hpbGUgKHByZXYgPT09ICcgJyB8fCBwcmV2ID09PSAnXFx0Jykge1xuICAgICAgICAgICAgcHJldiA9IHNyY1stLWxzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJldiA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGxpbmVTdGFydCA9IGxzICsgMTtcbiAgICAgICAgICAgIGF0TGluZVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWMgPSBncmFiQ29sbGVjdGlvbkVuZENvbW1lbnRzKG5vZGUpO1xuICAgICAgICBpZiAoZWMpIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuaXRlbXMsIGVjKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3JpZ1Jhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IF9nZXQoX2dldFByb3RvdHlwZU9mKENvbGxlY3Rpb24ucHJvdG90eXBlKSwgXCJzZXRPcmlnUmFuZ2VzXCIsIHRoaXMpLmNhbGwodGhpcywgY3IsIG9mZnNldCk7XG4gICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5zZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjLFxuICAgICAgICAgIGl0ZW1zID0gdGhpcy5pdGVtcyxcbiAgICAgICAgICByYW5nZSA9IHRoaXMucmFuZ2UsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhciBzdHIgPSBzcmMuc2xpY2UocmFuZ2Uuc3RhcnQsIGl0ZW1zWzBdLnJhbmdlLnN0YXJ0KSArIFN0cmluZyhpdGVtc1swXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgdmFyIF9pdGVtJGNvbnRleHQgPSBpdGVtLmNvbnRleHQsXG4gICAgICAgICAgICBhdExpbmVTdGFydCA9IF9pdGVtJGNvbnRleHQuYXRMaW5lU3RhcnQsXG4gICAgICAgICAgICBpbmRlbnQgPSBfaXRlbSRjb250ZXh0LmluZGVudDtcbiAgICAgICAgaWYgKGF0TGluZVN0YXJ0KSBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW5kZW50OyArK19pKSB7XG4gICAgICAgICAgc3RyICs9ICcgJztcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gU3RyaW5nKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTm9kZS5hZGRTdHJpbmdUZXJtaW5hdG9yKHNyYywgcmFuZ2UuZW5kLCBzdHIpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5leHRDb250ZW50SGFzSW5kZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHRDb250ZW50SGFzSW5kZW50KHNyYywgb2Zmc2V0LCBpbmRlbnQpIHtcbiAgICAgIHZhciBsaW5lU3RhcnQgPSBOb2RlLmVuZE9mTGluZShzcmMsIG9mZnNldCkgKyAxO1xuICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBsaW5lU3RhcnQpO1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldF07XG4gICAgICBpZiAoIWNoKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAob2Zmc2V0ID49IGxpbmVTdGFydCArIGluZGVudCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoY2ggIT09ICcjJyAmJiBjaCAhPT0gJ1xcbicpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBDb2xsZWN0aW9uLm5leHRDb250ZW50SGFzSW5kZW50KHNyYywgb2Zmc2V0LCBpbmRlbnQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xsZWN0aW9uO1xufShOb2RlKTtcblxudmFyIERpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKERpcmVjdGl2ZSwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGlyZWN0aXZlKTtcblxuICBmdW5jdGlvbiBEaXJlY3RpdmUoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpcmVjdGl2ZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFR5cGUuRElSRUNUSVZFKTtcbiAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGlyZWN0aXZlLCBbe1xuICAgIGtleTogXCJwYXJhbWV0ZXJzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcmF3ID0gdGhpcy5yYXdWYWx1ZTtcbiAgICAgIHJldHVybiByYXcgPyByYXcudHJpbSgpLnNwbGl0KC9bIFxcdF0rLykgOiBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlTmFtZShzdGFydCkge1xuICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmM7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJyAmJiBjaCAhPT0gJ1xcdCcgJiYgY2ggIT09ICcgJykge1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXQgKz0gMV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmFtZSA9IHNyYy5zbGljZShzdGFydCwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlUGFyYW1ldGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnMoc3RhcnQpIHtcbiAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjO1xuICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0O1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldF07XG5cbiAgICAgIHdoaWxlIChjaCAmJiBjaCAhPT0gJ1xcbicgJiYgY2ggIT09ICcjJykge1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXQgKz0gMV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMucGFyc2VOYW1lKHN0YXJ0ICsgMSk7XG4gICAgICBvZmZzZXQgPSB0aGlzLnBhcnNlUGFyYW1ldGVycyhvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUNvbW1lbnQob2Zmc2V0KTtcbiAgICAgIHRoaXMucmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEaXJlY3RpdmU7XG59KE5vZGUpO1xuXG52YXIgRG9jdW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhEb2N1bWVudCwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRG9jdW1lbnQpO1xuXG4gIGZ1bmN0aW9uIERvY3VtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb2N1bWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFR5cGUuRE9DVU1FTlQpO1xuICAgIF90aGlzLmRpcmVjdGl2ZXMgPSBudWxsO1xuICAgIF90aGlzLmNvbnRlbnRzID0gbnVsbDtcbiAgICBfdGhpcy5kaXJlY3RpdmVzRW5kTWFya2VyID0gbnVsbDtcbiAgICBfdGhpcy5kb2N1bWVudEVuZE1hcmtlciA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERvY3VtZW50LCBbe1xuICAgIGtleTogXCJwYXJzZURpcmVjdGl2ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmVzKHN0YXJ0KSB7XG4gICAgICB2YXIgc3JjID0gdGhpcy5jb250ZXh0LnNyYztcbiAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdO1xuICAgICAgdmFyIGF0TGluZVN0YXJ0ID0gdHJ1ZTtcbiAgICAgIHZhciBoYXNEaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQ7XG5cbiAgICAgIHdoaWxlICghTm9kZS5hdERvY3VtZW50Qm91bmRhcnkoc3JjLCBvZmZzZXQsIENoYXIuRElSRUNUSVZFU19FTkQpKSB7XG4gICAgICAgIG9mZnNldCA9IERvY3VtZW50LnN0YXJ0Q29tbWVudE9yRW5kQmxhbmtMaW5lKHNyYywgb2Zmc2V0KTtcblxuICAgICAgICBzd2l0Y2ggKHNyY1tvZmZzZXRdKSB7XG4gICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgIGlmIChhdExpbmVTdGFydCkge1xuICAgICAgICAgICAgICB2YXIgYmxhbmtMaW5lID0gbmV3IEJsYW5rTGluZSgpO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBibGFua0xpbmUucGFyc2Uoe1xuICAgICAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgICAgICAgIH0sIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMucHVzaChibGFua0xpbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgYXRMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IG5ldyBDb21tZW50KCk7XG4gICAgICAgICAgICAgIG9mZnNldCA9IGNvbW1lbnQucGFyc2Uoe1xuICAgICAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgICAgICAgIH0sIG9mZnNldCk7XG4gICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICBhdExpbmVTdGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IG5ldyBEaXJlY3RpdmUoKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gZGlyZWN0aXZlLnBhcnNlKHtcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgICAgICAgfSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goZGlyZWN0aXZlKTtcbiAgICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGF0TGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgICAgICAgICAgICB0aGlzLmVycm9yID0gbmV3IFlBTUxTZW1hbnRpY0Vycm9yKHRoaXMsICdNaXNzaW5nIGRpcmVjdGl2ZXMtZW5kIGluZGljYXRvciBsaW5lJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSB0aGlzLmRpcmVjdGl2ZXM7XG4gICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmNbb2Zmc2V0XSkge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIgPSBuZXcgUmFuZ2Uob2Zmc2V0LCBvZmZzZXQgKyAzKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIDM7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgWUFNTFNlbWFudGljRXJyb3IodGhpcywgJ01pc3NpbmcgZGlyZWN0aXZlcy1lbmQgaW5kaWNhdG9yIGxpbmUnKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3RpdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IHRoaXMuZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlQ29udGVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VDb250ZW50cyhzdGFydCkge1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgcGFyc2VOb2RlID0gX3RoaXMkY29udGV4dC5wYXJzZU5vZGUsXG4gICAgICAgICAgc3JjID0gX3RoaXMkY29udGV4dC5zcmM7XG4gICAgICBpZiAoIXRoaXMuY29udGVudHMpIHRoaXMuY29udGVudHMgPSBbXTtcbiAgICAgIHZhciBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgICAgd2hpbGUgKHNyY1tsaW5lU3RhcnQgLSAxXSA9PT0gJy0nKSB7XG4gICAgICAgIGxpbmVTdGFydCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBzdGFydCk7XG4gICAgICB2YXIgYXRMaW5lU3RhcnQgPSBsaW5lU3RhcnQgPT09IHN0YXJ0O1xuICAgICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IFJhbmdlKG9mZnNldCk7XG5cbiAgICAgIHdoaWxlICghTm9kZS5hdERvY3VtZW50Qm91bmRhcnkoc3JjLCBvZmZzZXQsIENoYXIuRE9DVU1FTlRfRU5EKSkge1xuICAgICAgICBzd2l0Y2ggKHNyY1tvZmZzZXRdKSB7XG4gICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgIGlmIChhdExpbmVTdGFydCkge1xuICAgICAgICAgICAgICB2YXIgYmxhbmtMaW5lID0gbmV3IEJsYW5rTGluZSgpO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBibGFua0xpbmUucGFyc2Uoe1xuICAgICAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgICAgICAgIH0sIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRzLnB1c2goYmxhbmtMaW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgIGF0TGluZVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZVN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBuZXcgQ29tbWVudCgpO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBjb21tZW50LnBhcnNlKHtcbiAgICAgICAgICAgICAgICBzcmM6IHNyY1xuICAgICAgICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgIGF0TGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpRW5kID0gTm9kZS5lbmRPZkluZGVudChzcmMsIG9mZnNldCk7XG4gICAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGF0TGluZVN0YXJ0OiBhdExpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBpbmRlbnQ6IC0xLFxuICAgICAgICAgICAgICAgIGluRmxvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5Db2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBwYXJzZU5vZGUoY29udGV4dCwgaUVuZCk7XG4gICAgICAgICAgICAgIGlmICghbm9kZSkgcmV0dXJuIHRoaXMudmFsdWVSYW5nZS5lbmQgPSBpRW5kOyAvLyBhdCBuZXh0IGRvY3VtZW50IHN0YXJ0XG5cbiAgICAgICAgICAgICAgdGhpcy5jb250ZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlLnJhbmdlLmVuZDtcbiAgICAgICAgICAgICAgYXRMaW5lU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIGVjID0gZ3JhYkNvbGxlY3Rpb25FbmRDb21tZW50cyhub2RlKTtcbiAgICAgICAgICAgICAgaWYgKGVjKSBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLmNvbnRlbnRzLCBlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXQgPSBEb2N1bWVudC5zdGFydENvbW1lbnRPckVuZEJsYW5rTGluZShzcmMsIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmFsdWVSYW5nZS5lbmQgPSBvZmZzZXQ7XG5cbiAgICAgIGlmIChzcmNbb2Zmc2V0XSkge1xuICAgICAgICB0aGlzLmRvY3VtZW50RW5kTWFya2VyID0gbmV3IFJhbmdlKG9mZnNldCwgb2Zmc2V0ICsgMyk7XG4gICAgICAgIG9mZnNldCArPSAzO1xuXG4gICAgICAgIGlmIChzcmNbb2Zmc2V0XSkge1xuICAgICAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcblxuICAgICAgICAgIGlmIChzcmNbb2Zmc2V0XSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB2YXIgX2NvbW1lbnQgPSBuZXcgQ29tbWVudCgpO1xuXG4gICAgICAgICAgICBvZmZzZXQgPSBfY29tbWVudC5wYXJzZSh7XG4gICAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5wdXNoKF9jb21tZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKHNyY1tvZmZzZXRdKSB7XG4gICAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBZQU1MU3ludGF4RXJyb3IodGhpcywgJ0RvY3VtZW50IGVuZCBtYXJrZXIgbGluZSBjYW5ub3QgaGF2ZSBhIG5vbi1jb21tZW50IHN1ZmZpeCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgICAgY29udGV4dC5yb290ID0gdGhpcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB2YXIgc3JjID0gY29udGV4dC5zcmM7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3JjLmNoYXJDb2RlQXQoc3RhcnQpID09PSAweGZlZmYgPyBzdGFydCArIDEgOiBzdGFydDsgLy8gc2tpcCBCT01cblxuICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZURpcmVjdGl2ZXMob2Zmc2V0KTtcbiAgICAgIG9mZnNldCA9IHRoaXMucGFyc2VDb250ZW50cyhvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3JpZ1Jhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IF9nZXQoX2dldFByb3RvdHlwZU9mKERvY3VtZW50LnByb3RvdHlwZSksIFwic2V0T3JpZ1Jhbmdlc1wiLCB0aGlzKS5jYWxsKHRoaXMsIGNyLCBvZmZzZXQpO1xuICAgICAgdGhpcy5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5zZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5kaXJlY3RpdmVzRW5kTWFya2VyKSBvZmZzZXQgPSB0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIuc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpO1xuICAgICAgdGhpcy5jb250ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG9mZnNldCA9IG5vZGUuc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuZG9jdW1lbnRFbmRNYXJrZXIpIG9mZnNldCA9IHRoaXMuZG9jdW1lbnRFbmRNYXJrZXIuc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgY29udGVudHMgPSB0aGlzLmNvbnRlbnRzLFxuICAgICAgICAgIGRpcmVjdGl2ZXMgPSB0aGlzLmRpcmVjdGl2ZXMsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhciBzdHIgPSBkaXJlY3RpdmVzLmpvaW4oJycpO1xuXG4gICAgICBpZiAoY29udGVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPiAwIHx8IGNvbnRlbnRzWzBdLnR5cGUgPT09IFR5cGUuQ09NTUVOVCkgc3RyICs9ICctLS1cXG4nO1xuICAgICAgICBzdHIgKz0gY29udGVudHMuam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdICE9PSAnXFxuJykgc3RyICs9ICdcXG4nO1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJzdGFydENvbW1lbnRPckVuZEJsYW5rTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydENvbW1lbnRPckVuZEJsYW5rTGluZShzcmMsIHN0YXJ0KSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBzdGFydCk7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICAgIHJldHVybiBjaCA9PT0gJyMnIHx8IGNoID09PSAnXFxuJyA/IG9mZnNldCA6IHN0YXJ0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEb2N1bWVudDtcbn0oTm9kZSk7XG5cbnZhciBBbGlhcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKEFsaWFzLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihBbGlhcyk7XG5cbiAgZnVuY3Rpb24gQWxpYXMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFsaWFzKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbGlhcywgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gKmFsaWFzIGZyb20gdGhlIHNvdXJjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpcyBzY2FsYXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHZhciBzcmMgPSBjb250ZXh0LnNyYztcbiAgICAgIHZhciBvZmZzZXQgPSBOb2RlLmVuZE9mSWRlbnRpZmllcihzcmMsIHN0YXJ0ICsgMSk7XG4gICAgICB0aGlzLnZhbHVlUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQgKyAxLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUNvbW1lbnQob2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFsaWFzO1xufShOb2RlKTtcblxudmFyIENob21wID0ge1xuICBDTElQOiAnQ0xJUCcsXG4gIEtFRVA6ICdLRUVQJyxcbiAgU1RSSVA6ICdTVFJJUCdcbn07XG52YXIgQmxvY2tWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKEJsb2NrVmFsdWUsIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJsb2NrVmFsdWUpO1xuXG4gIGZ1bmN0aW9uIEJsb2NrVmFsdWUodHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmxvY2tWYWx1ZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHByb3BzKTtcbiAgICBfdGhpcy5ibG9ja0luZGVudCA9IG51bGw7XG4gICAgX3RoaXMuY2hvbXBpbmcgPSBDaG9tcC5DTElQO1xuICAgIF90aGlzLmhlYWRlciA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJsb2NrVmFsdWUsIFt7XG4gICAga2V5OiBcImluY2x1ZGVzVHJhaWxpbmdMaW5lc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hvbXBpbmcgPT09IENob21wLktFRVA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0clZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMudmFsdWVSYW5nZSB8fCAhdGhpcy5jb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBfdGhpcyR2YWx1ZVJhbmdlID0gdGhpcy52YWx1ZVJhbmdlLFxuICAgICAgICAgIHN0YXJ0ID0gX3RoaXMkdmFsdWVSYW5nZS5zdGFydCxcbiAgICAgICAgICBlbmQgPSBfdGhpcyR2YWx1ZVJhbmdlLmVuZDtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGluZGVudCA9IF90aGlzJGNvbnRleHQuaW5kZW50LFxuICAgICAgICAgIHNyYyA9IF90aGlzJGNvbnRleHQuc3JjO1xuICAgICAgaWYgKHRoaXMudmFsdWVSYW5nZS5pc0VtcHR5KCkpIHJldHVybiAnJztcbiAgICAgIHZhciBsYXN0TmV3TGluZSA9IG51bGw7XG4gICAgICB2YXIgY2ggPSBzcmNbZW5kIC0gMV07XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnICcpIHtcbiAgICAgICAgZW5kIC09IDE7XG5cbiAgICAgICAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgICAgICAgIGlmICh0aGlzLmNob21waW5nID09PSBDaG9tcC5LRUVQKSBicmVhaztlbHNlIHJldHVybiAnJzsgLy8gcHJvYmFibHkgbmV2ZXIgaGFwcGVuc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykgbGFzdE5ld0xpbmUgPSBlbmQ7XG4gICAgICAgIGNoID0gc3JjW2VuZCAtIDFdO1xuICAgICAgfVxuXG4gICAgICB2YXIga2VlcFN0YXJ0ID0gZW5kICsgMTtcblxuICAgICAgaWYgKGxhc3ROZXdMaW5lKSB7XG4gICAgICAgIGlmICh0aGlzLmNob21waW5nID09PSBDaG9tcC5LRUVQKSB7XG4gICAgICAgICAga2VlcFN0YXJ0ID0gbGFzdE5ld0xpbmU7XG4gICAgICAgICAgZW5kID0gdGhpcy52YWx1ZVJhbmdlLmVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSBsYXN0TmV3TGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmkgPSBpbmRlbnQgKyB0aGlzLmJsb2NrSW5kZW50O1xuICAgICAgdmFyIGZvbGRlZCA9IHRoaXMudHlwZSA9PT0gVHlwZS5CTE9DS19GT0xERUQ7XG4gICAgICB2YXIgYXRTdGFydCA9IHRydWU7XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICB2YXIgc2VwID0gJyc7XG4gICAgICB2YXIgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJpOyArK2opIHtcbiAgICAgICAgICBpZiAoc3JjW2ldICE9PSAnICcpIGJyZWFrO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfY2ggPSBzcmNbaV07XG5cbiAgICAgICAgaWYgKF9jaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBpZiAoc2VwID09PSAnXFxuJykgc3RyICs9ICdcXG4nO2Vsc2Ugc2VwID0gJ1xcbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGxpbmVFbmQgPSBOb2RlLmVuZE9mTGluZShzcmMsIGkpO1xuICAgICAgICAgIHZhciBsaW5lID0gc3JjLnNsaWNlKGksIGxpbmVFbmQpO1xuICAgICAgICAgIGkgPSBsaW5lRW5kO1xuXG4gICAgICAgICAgaWYgKGZvbGRlZCAmJiAoX2NoID09PSAnICcgfHwgX2NoID09PSAnXFx0JykgJiYgaSA8IGtlZXBTdGFydCkge1xuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJyAnKSBzZXAgPSAnXFxuJztlbHNlIGlmICghcHJldk1vcmVJbmRlbnRlZCAmJiAhYXRTdGFydCAmJiBzZXAgPT09ICdcXG4nKSBzZXAgPSAnXFxuXFxuJztcbiAgICAgICAgICAgIHN0ciArPSBzZXAgKyBsaW5lOyAvLysgKChsaW5lRW5kIDwgZW5kICYmIHNyY1tsaW5lRW5kXSkgfHwgJycpXG5cbiAgICAgICAgICAgIHNlcCA9IGxpbmVFbmQgPCBlbmQgJiYgc3JjW2xpbmVFbmRdIHx8ICcnO1xuICAgICAgICAgICAgcHJldk1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciArPSBzZXAgKyBsaW5lO1xuICAgICAgICAgICAgc2VwID0gZm9sZGVkICYmIGkgPCBrZWVwU3RhcnQgPyAnICcgOiAnXFxuJztcbiAgICAgICAgICAgIHByZXZNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXRTdGFydCAmJiBsaW5lICE9PSAnJykgYXRTdGFydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNob21waW5nID09PSBDaG9tcC5TVFJJUCA/IHN0ciA6IHN0ciArICdcXG4nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUJsb2NrSGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQmxvY2tIZWFkZXIoc3RhcnQpIHtcbiAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjO1xuICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0ICsgMTtcbiAgICAgIHZhciBiaSA9ICcnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICB0aGlzLmNob21waW5nID0gQ2hvbXAuU1RSSVA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgdGhpcy5jaG9tcGluZyA9IENob21wLktFRVA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgIGNhc2UgJzInOlxuICAgICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgIGNhc2UgJzQnOlxuICAgICAgICAgIGNhc2UgJzUnOlxuICAgICAgICAgIGNhc2UgJzYnOlxuICAgICAgICAgIGNhc2UgJzcnOlxuICAgICAgICAgIGNhc2UgJzgnOlxuICAgICAgICAgIGNhc2UgJzknOlxuICAgICAgICAgICAgYmkgKz0gY2g7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmJsb2NrSW5kZW50ID0gTnVtYmVyKGJpKSB8fCBudWxsO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgUmFuZ2Uoc3RhcnQsIG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlQmxvY2tWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUJsb2NrVmFsdWUoc3RhcnQpIHtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0MiA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBpbmRlbnQgPSBfdGhpcyRjb250ZXh0Mi5pbmRlbnQsXG4gICAgICAgICAgc3JjID0gX3RoaXMkY29udGV4dDIuc3JjO1xuICAgICAgdmFyIGV4cGxpY2l0ID0gISF0aGlzLmJsb2NrSW5kZW50O1xuICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0O1xuICAgICAgdmFyIHZhbHVlRW5kID0gc3RhcnQ7XG4gICAgICB2YXIgbWluQmxvY2tJbmRlbnQgPSAxO1xuXG4gICAgICBmb3IgKHZhciBjaCA9IHNyY1tvZmZzZXRdOyBjaCA9PT0gJ1xcbic7IGNoID0gc3JjW29mZnNldF0pIHtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIGlmIChOb2RlLmF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIG9mZnNldCkpIGJyZWFrO1xuICAgICAgICB2YXIgZW5kID0gTm9kZS5lbmRPZkJsb2NrSW5kZW50KHNyYywgaW5kZW50LCBvZmZzZXQpOyAvLyBzaG91bGQgbm90IGluY2x1ZGUgdGFiP1xuXG4gICAgICAgIGlmIChlbmQgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICB2YXIgX2NoMiA9IHNyY1tlbmRdO1xuICAgICAgICB2YXIgbGluZUluZGVudCA9IGVuZCAtIChvZmZzZXQgKyBpbmRlbnQpO1xuXG4gICAgICAgIGlmICghdGhpcy5ibG9ja0luZGVudCkge1xuICAgICAgICAgIC8vIG5vIGV4cGxpY2l0IGJsb2NrIGluZGVudCwgbm9uZSB5ZXQgZGV0ZWN0ZWRcbiAgICAgICAgICBpZiAoc3JjW2VuZF0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBsaW5lIHdpdGggbm9uLXdoaXRlc3BhY2UgY29udGVudFxuICAgICAgICAgICAgaWYgKGxpbmVJbmRlbnQgPCBtaW5CbG9ja0luZGVudCkge1xuICAgICAgICAgICAgICB2YXIgbXNnID0gJ0Jsb2NrIHNjYWxhcnMgd2l0aCBtb3JlLWluZGVudGVkIGxlYWRpbmcgZW1wdHkgbGluZXMgbXVzdCB1c2UgYW4gZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJztcbiAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBZQU1MU2VtYW50aWNFcnJvcih0aGlzLCBtc2cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJsb2NrSW5kZW50ID0gbGluZUluZGVudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVJbmRlbnQgPiBtaW5CbG9ja0luZGVudCkge1xuICAgICAgICAgICAgLy8gZW1wdHkgbGluZSB3aXRoIG1vcmUgd2hpdGVzcGFjZVxuICAgICAgICAgICAgbWluQmxvY2tJbmRlbnQgPSBsaW5lSW5kZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfY2gyICYmIF9jaDIgIT09ICdcXG4nICYmIGxpbmVJbmRlbnQgPCB0aGlzLmJsb2NrSW5kZW50KSB7XG4gICAgICAgICAgaWYgKHNyY1tlbmRdID09PSAnIycpIGJyZWFrO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICB2YXIgX3NyYyA9IGV4cGxpY2l0ID8gJ2V4cGxpY2l0IGluZGVudGF0aW9uIGluZGljYXRvcicgOiAnZmlyc3QgbGluZSc7XG5cbiAgICAgICAgICAgIHZhciBfbXNnID0gXCJCbG9jayBzY2FsYXJzIG11c3Qgbm90IGJlIGxlc3MgaW5kZW50ZWQgdGhhbiB0aGVpciBcIi5jb25jYXQoX3NyYyk7XG5cbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgWUFNTFNlbWFudGljRXJyb3IodGhpcywgX21zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNyY1tlbmRdID09PSAnXFxuJykge1xuICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSB2YWx1ZUVuZCA9IE5vZGUuZW5kT2ZMaW5lKHNyYywgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaG9tcGluZyAhPT0gQ2hvbXAuS0VFUCkge1xuICAgICAgICBvZmZzZXQgPSBzcmNbdmFsdWVFbmRdID8gdmFsdWVFbmQgKyAxIDogdmFsdWVFbmQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBSYW5nZShzdGFydCArIDEsIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBibG9jayB2YWx1ZSBmcm9tIHRoZSBzb3VyY2VcbiAgICAgKlxuICAgICAqIEFjY2VwdGVkIGZvcm1zIGFyZTpcbiAgICAgKiBgYGBcbiAgICAgKiBCU1xuICAgICAqIGJsb2NrXG4gICAgICogbGluZXNcbiAgICAgKlxuICAgICAqIEJTICNjb21tZW50XG4gICAgICogYmxvY2tcbiAgICAgKiBsaW5lc1xuICAgICAqIGBgYFxuICAgICAqIHdoZXJlIHRoZSBibG9jayBzdHlsZSBCUyBtYXRjaGVzIHRoZSByZWdleHAgYFt8Pl1bLSsxLTldKmAgYW5kIGJsb2NrIGxpbmVzXG4gICAgICogYXJlIGVtcHR5IG9yIGhhdmUgYW4gaW5kZW50IGxldmVsIGdyZWF0ZXIgdGhhbiBgaW5kZW50YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3QgY2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXMgYmxvY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdmFyIHNyYyA9IGNvbnRleHQuc3JjO1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMucGFyc2VCbG9ja0hlYWRlcihzdGFydCk7XG4gICAgICBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQ29tbWVudChvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUJsb2NrVmFsdWUob2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9yaWdSYW5nZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihCbG9ja1ZhbHVlLnByb3RvdHlwZSksIFwic2V0T3JpZ1Jhbmdlc1wiLCB0aGlzKS5jYWxsKHRoaXMsIGNyLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyID8gdGhpcy5oZWFkZXIuc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpIDogb2Zmc2V0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCbG9ja1ZhbHVlO1xufShOb2RlKTtcblxudmFyIEZsb3dDb2xsZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoRmxvd0NvbGxlY3Rpb24sIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEZsb3dDb2xsZWN0aW9uKTtcblxuICBmdW5jdGlvbiBGbG93Q29sbGVjdGlvbih0eXBlLCBwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGbG93Q29sbGVjdGlvbik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHByb3BzKTtcbiAgICBfdGhpcy5pdGVtcyA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZsb3dDb2xsZWN0aW9uLCBbe1xuICAgIGtleTogXCJwcmV2Tm9kZUlzSnNvbkxpa2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJldk5vZGVJc0pzb25MaWtlKCkge1xuICAgICAgdmFyIGlkeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaXRlbXNbaWR4IC0gMV07XG4gICAgICByZXR1cm4gISFub2RlICYmIChub2RlLmpzb25MaWtlIHx8IG5vZGUudHlwZSA9PT0gVHlwZS5DT01NRU5UICYmIHRoaXMucHJldk5vZGVJc0pzb25MaWtlKGlkeCAtIDEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB2YXIgcGFyc2VOb2RlID0gY29udGV4dC5wYXJzZU5vZGUsXG4gICAgICAgICAgc3JjID0gY29udGV4dC5zcmM7XG4gICAgICB2YXIgaW5kZW50ID0gY29udGV4dC5pbmRlbnQsXG4gICAgICAgICAgbGluZVN0YXJ0ID0gY29udGV4dC5saW5lU3RhcnQ7XG4gICAgICB2YXIgY2hhciA9IHNyY1tzdGFydF07IC8vIHsgb3IgW1xuXG4gICAgICB0aGlzLml0ZW1zID0gW3tcbiAgICAgICAgY2hhcjogY2hhcixcbiAgICAgICAgb2Zmc2V0OiBzdGFydFxuICAgICAgfV07XG4gICAgICB2YXIgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBzdGFydCArIDEpO1xuICAgICAgY2hhciA9IHNyY1tvZmZzZXRdO1xuXG4gICAgICB3aGlsZSAoY2hhciAmJiBjaGFyICE9PSAnXScgJiYgY2hhciAhPT0gJ30nKSB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxpbmVTdGFydCA9IG9mZnNldCArIDE7XG4gICAgICAgICAgICAgIHZhciB3c0VuZCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgbGluZVN0YXJ0KTtcblxuICAgICAgICAgICAgICBpZiAoc3JjW3dzRW5kXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxhbmtMaW5lID0gbmV3IEJsYW5rTGluZSgpO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGJsYW5rTGluZS5wYXJzZSh7XG4gICAgICAgICAgICAgICAgICBzcmM6IHNyY1xuICAgICAgICAgICAgICAgIH0sIGxpbmVTdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGJsYW5rTGluZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvZmZzZXQgPSBOb2RlLmVuZE9mSW5kZW50KHNyYywgbGluZVN0YXJ0KTtcblxuICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IGxpbmVTdGFydCArIGluZGVudCkge1xuICAgICAgICAgICAgICAgIGNoYXIgPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCBsaW5lU3RhcnQgKyBpbmRlbnQgfHwgY2hhciAhPT0gJ10nICYmIGNoYXIgIT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdJbnN1ZmZpY2llbnQgaW5kZW50YXRpb24gaW4gZmxvdyBjb2xsZWN0aW9uJztcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgWUFNTFNlbWFudGljRXJyb3IodGhpcywgbXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY2hhcjogY2hhcixcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IG5ldyBDb21tZW50KCk7XG4gICAgICAgICAgICAgIG9mZnNldCA9IGNvbW1lbnQucGFyc2Uoe1xuICAgICAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgICAgICAgIH0sIG9mZnNldCk7XG4gICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBuZXh0ID0gc3JjW29mZnNldCArIDFdO1xuXG4gICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJyB8fCBuZXh0ID09PSAnXFx0JyB8fCBuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJywnIHx8IC8vIGluLWZsb3cgOiBhZnRlciBKU09OLWxpa2Uga2V5IGRvZXMgbm90IG5lZWQgdG8gYmUgZm9sbG93ZWQgYnkgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICBjaGFyID09PSAnOicgJiYgdGhpcy5wcmV2Tm9kZUlzSnNvbkxpa2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBjaGFyOiBjaGFyLFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHBhcnNlTm9kZSh7XG4gICAgICAgICAgICAgICAgYXRMaW5lU3RhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGluQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5GbG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIGluZGVudDogLTEsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgICAgICAgICAgIH0sIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gYXQgbmV4dCBkb2N1bWVudCBzdGFydFxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBOb2RlLm5vcm1hbGl6ZU9mZnNldChzcmMsIG5vZGUucmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgY2hhciA9IHNyY1tvZmZzZXRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZhbHVlUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIG9mZnNldCArIDEpO1xuXG4gICAgICBpZiAoY2hhcikge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goe1xuICAgICAgICAgIGNoYXI6IGNoYXIsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0ICsgMSk7XG4gICAgICAgIG9mZnNldCA9IHRoaXMucGFyc2VDb21tZW50KG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9yaWdSYW5nZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihGbG93Q29sbGVjdGlvbi5wcm90b3R5cGUpLCBcInNldE9yaWdSYW5nZXNcIiwgdGhpcykuY2FsbCh0aGlzLCBjciwgb2Zmc2V0KTtcbiAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICBvZmZzZXQgPSBub2RlLnNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbm9kZS5vcmlnT2Zmc2V0ID0gbm9kZS5vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGkgPSBvZmZzZXQ7XG5cbiAgICAgICAgICB3aGlsZSAoaSA8IGNyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGNyW2ldID4gbm9kZS5vZmZzZXQpIGJyZWFrO2Vsc2UgKytpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUub3JpZ09mZnNldCA9IG5vZGUub2Zmc2V0ICsgaTtcbiAgICAgICAgICBvZmZzZXQgPSBpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmMsXG4gICAgICAgICAgaXRlbXMgPSB0aGlzLml0ZW1zLFxuICAgICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZSxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFyIG5vZGVzID0gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtIGluc3RhbmNlb2YgTm9kZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgdmFyIHByZXZFbmQgPSByYW5nZS5zdGFydDtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IHNyYy5zbGljZShwcmV2RW5kLCBub2RlLnJhbmdlLnN0YXJ0KTtcbiAgICAgICAgcHJldkVuZCA9IG5vZGUucmFuZ2UuZW5kO1xuICAgICAgICBzdHIgKz0gcHJlZml4ICsgU3RyaW5nKG5vZGUpO1xuXG4gICAgICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnXFxuJyAmJiBzcmNbcHJldkVuZCAtIDFdICE9PSAnXFxuJyAmJiBzcmNbcHJldkVuZF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgLy8gQ29tbWVudCByYW5nZSBkb2VzIG5vdCBpbmNsdWRlIHRoZSB0ZXJtaW5hbCBuZXdsaW5lLCBidXQgaXRzXG4gICAgICAgICAgLy8gc3RyaW5naWZpZWQgdmFsdWUgZG9lcy4gV2l0aG91dCB0aGlzIGZpeCwgbmV3bGluZXMgYXQgY29tbWVudCBlbmRzXG4gICAgICAgICAgLy8gZ2V0IGR1cGxpY2F0ZWQuXG4gICAgICAgICAgcHJldkVuZCArPSAxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN0ciArPSBzcmMuc2xpY2UocHJldkVuZCwgcmFuZ2UuZW5kKTtcbiAgICAgIHJldHVybiBOb2RlLmFkZFN0cmluZ1Rlcm1pbmF0b3Ioc3JjLCByYW5nZS5lbmQsIHN0cik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZsb3dDb2xsZWN0aW9uO1xufShOb2RlKTtcblxudmFyIFF1b3RlRG91YmxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoUXVvdGVEb3VibGUsIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFF1b3RlRG91YmxlKTtcblxuICBmdW5jdGlvbiBRdW90ZURvdWJsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVvdGVEb3VibGUpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFF1b3RlRG91YmxlLCBbe1xuICAgIGtleTogXCJzdHJWYWx1ZVwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgeyBzdHI6IHN0cmluZywgZXJyb3JzOiBZQU1MU3ludGF4RXJyb3JbXSB9fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy52YWx1ZVJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIF90aGlzJHZhbHVlUmFuZ2UgPSB0aGlzLnZhbHVlUmFuZ2UsXG4gICAgICAgICAgc3RhcnQgPSBfdGhpcyR2YWx1ZVJhbmdlLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IF90aGlzJHZhbHVlUmFuZ2UuZW5kO1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgaW5kZW50ID0gX3RoaXMkY29udGV4dC5pbmRlbnQsXG4gICAgICAgICAgc3JjID0gX3RoaXMkY29udGV4dC5zcmM7XG4gICAgICBpZiAoc3JjW2VuZCAtIDFdICE9PSAnXCInKSBlcnJvcnMucHVzaChuZXcgWUFNTFN5bnRheEVycm9yKHRoaXMsICdNaXNzaW5nIGNsb3NpbmcgXCJxdW90ZScpKTsgLy8gVXNpbmcgU3RyaW5nI3JlcGxhY2UgaXMgdG9vIHBhaW5mdWwgd2l0aCBlc2NhcGVkIG5ld2xpbmVzIHByZWNlZGVkIGJ5XG4gICAgICAvLyBlc2NhcGVkIGJhY2tzbGFzaGVzOyBhbHNvLCB0aGlzIHNob3VsZCBiZSBmYXN0ZXIuXG5cbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8IGVuZCAtIDE7ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzcmNbaV07XG5cbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgIGlmIChOb2RlLmF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIGkgKyAxKSkgZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKHRoaXMsICdEb2N1bWVudCBib3VuZGFyeSBpbmRpY2F0b3JzIGFyZSBub3QgYWxsb3dlZCB3aXRoaW4gc3RyaW5nIHZhbHVlcycpKTtcblxuICAgICAgICAgIHZhciBfTm9kZSRmb2xkTmV3bGluZSA9IE5vZGUuZm9sZE5ld2xpbmUoc3JjLCBpLCBpbmRlbnQpLFxuICAgICAgICAgICAgICBmb2xkID0gX05vZGUkZm9sZE5ld2xpbmUuZm9sZCxcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gX05vZGUkZm9sZE5ld2xpbmUub2Zmc2V0LFxuICAgICAgICAgICAgICBlcnJvciA9IF9Ob2RlJGZvbGROZXdsaW5lLmVycm9yO1xuXG4gICAgICAgICAgc3RyICs9IGZvbGQ7XG4gICAgICAgICAgaSA9IG9mZnNldDtcbiAgICAgICAgICBpZiAoZXJyb3IpIGVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcih0aGlzLCAnTXVsdGktbGluZSBkb3VibGUtcXVvdGVkIHN0cmluZyBuZWVkcyB0byBiZSBzdWZmaWNpZW50bHkgaW5kZW50ZWQnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgIGkgKz0gMTtcblxuICAgICAgICAgIHN3aXRjaCAoc3JjW2ldKSB7XG4gICAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXDAnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIG51bGwgY2hhcmFjdGVyXG5cbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xceDA3JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBiZWxsIGNoYXJhY3RlclxuXG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjZVxuXG4gICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXHgxYic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gZXNjYXBlIGNoYXJhY3RlclxuXG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGZvcm0gZmVlZFxuXG4gICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGxpbmUgZmVlZFxuXG4gICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGNhcnJpYWdlIHJldHVyblxuXG4gICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGhvcml6b250YWwgdGFiXG5cbiAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcdic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gdmVydGljYWwgdGFiXG5cbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICBzdHIgKz0gXCJcXHg4NVwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFVuaWNvZGUgbmV4dCBsaW5lXG5cbiAgICAgICAgICAgIGNhc2UgJ18nOlxuICAgICAgICAgICAgICBzdHIgKz0gXCJcXHhBMFwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFVuaWNvZGUgbm9uLWJyZWFraW5nIHNwYWNlXG5cbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICBzdHIgKz0gXCJcXHUyMDI4XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gVW5pY29kZSBsaW5lIHNlcGFyYXRvclxuXG4gICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgICAgc3RyICs9IFwiXFx1MjAyOVwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFVuaWNvZGUgcGFyYWdyYXBoIHNlcGFyYXRvclxuXG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgc3RyICs9ICcgJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcIic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgc3RyICs9ICcvJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgIHN0ciArPSB0aGlzLnBhcnNlQ2hhckNvZGUoaSArIDEsIDIsIGVycm9ycyk7XG4gICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5wYXJzZUNoYXJDb2RlKGkgKyAxLCA0LCBlcnJvcnMpO1xuICAgICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgICAgc3RyICs9IHRoaXMucGFyc2VDaGFyQ29kZShpICsgMSwgOCwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgaSArPSA4O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgICAgLy8gc2tpcCBlc2NhcGVkIG5ld2xpbmVzLCBidXQgc3RpbGwgdHJpbSB0aGUgZm9sbG93aW5nIGxpbmVcbiAgICAgICAgICAgICAgd2hpbGUgKHNyY1tpICsgMV0gPT09ICcgJyB8fCBzcmNbaSArIDFdID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgWUFNTFN5bnRheEVycm9yKHRoaXMsIFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgXCIuY29uY2F0KHNyYy5zdWJzdHIoaSAtIDEsIDIpKSkpO1xuICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnICsgc3JjW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0Jykge1xuICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgIHZhciB3c1N0YXJ0ID0gaTtcbiAgICAgICAgICB2YXIgbmV4dCA9IHNyY1tpICsgMV07XG5cbiAgICAgICAgICB3aGlsZSAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBuZXh0ID0gc3JjW2kgKyAxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV4dCAhPT0gJ1xcbicpIHN0ciArPSBpID4gd3NTdGFydCA/IHNyYy5zbGljZSh3c1N0YXJ0LCBpICsgMSkgOiBjaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8ge1xuICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgc3RyOiBzdHJcbiAgICAgIH0gOiBzdHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlQ2hhckNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VDaGFyQ29kZShvZmZzZXQsIGxlbmd0aCwgZXJyb3JzKSB7XG4gICAgICB2YXIgc3JjID0gdGhpcy5jb250ZXh0LnNyYztcbiAgICAgIHZhciBjYyA9IHNyYy5zdWJzdHIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgdmFyIG9rID0gY2MubGVuZ3RoID09PSBsZW5ndGggJiYgL15bMC05YS1mQS1GXSskLy50ZXN0KGNjKTtcbiAgICAgIHZhciBjb2RlID0gb2sgPyBwYXJzZUludChjYywgMTYpIDogTmFOO1xuXG4gICAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFlBTUxTeW50YXhFcnJvcih0aGlzLCBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIFwiLmNvbmNhdChzcmMuc3Vic3RyKG9mZnNldCAtIDIsIGxlbmd0aCArIDIpKSkpO1xuICAgICAgICByZXR1cm4gc3JjLnN1YnN0cihvZmZzZXQgLSAyLCBsZW5ndGggKyAyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBcImRvdWJsZSBxdW90ZWRcIiB2YWx1ZSBmcm9tIHRoZSBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3QgY2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXMgc2NhbGFyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHZhciBzcmMgPSBjb250ZXh0LnNyYztcbiAgICAgIHZhciBvZmZzZXQgPSBRdW90ZURvdWJsZS5lbmRPZlF1b3RlKHNyYywgc3RhcnQgKyAxKTtcbiAgICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCA9IHRoaXMucGFyc2VDb21tZW50KG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImVuZE9mUXVvdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2ZRdW90ZShzcmMsIG9mZnNldCkge1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldF07XG5cbiAgICAgIHdoaWxlIChjaCAmJiBjaCAhPT0gJ1wiJykge1xuICAgICAgICBvZmZzZXQgKz0gY2ggPT09ICdcXFxcJyA/IDIgOiAxO1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0ICsgMTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUXVvdGVEb3VibGU7XG59KE5vZGUpO1xuXG52YXIgUXVvdGVTaW5nbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhRdW90ZVNpbmdsZSwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUXVvdGVTaW5nbGUpO1xuXG4gIGZ1bmN0aW9uIFF1b3RlU2luZ2xlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdW90ZVNpbmdsZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUXVvdGVTaW5nbGUsIFt7XG4gICAga2V5OiBcInN0clZhbHVlXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB7IHN0cjogc3RyaW5nLCBlcnJvcnM6IFlBTUxTeW50YXhFcnJvcltdIH19XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLnZhbHVlUmFuZ2UgfHwgIXRoaXMuY29udGV4dCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgX3RoaXMkdmFsdWVSYW5nZSA9IHRoaXMudmFsdWVSYW5nZSxcbiAgICAgICAgICBzdGFydCA9IF90aGlzJHZhbHVlUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgZW5kID0gX3RoaXMkdmFsdWVSYW5nZS5lbmQ7XG4gICAgICB2YXIgX3RoaXMkY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBpbmRlbnQgPSBfdGhpcyRjb250ZXh0LmluZGVudCxcbiAgICAgICAgICBzcmMgPSBfdGhpcyRjb250ZXh0LnNyYztcbiAgICAgIGlmIChzcmNbZW5kIC0gMV0gIT09IFwiJ1wiKSBlcnJvcnMucHVzaChuZXcgWUFNTFN5bnRheEVycm9yKHRoaXMsIFwiTWlzc2luZyBjbG9zaW5nICdxdW90ZVwiKSk7XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIDE7IGkgPCBlbmQgLSAxOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3JjW2ldO1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBpZiAoTm9kZS5hdERvY3VtZW50Qm91bmRhcnkoc3JjLCBpICsgMSkpIGVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcih0aGlzLCAnRG9jdW1lbnQgYm91bmRhcnkgaW5kaWNhdG9ycyBhcmUgbm90IGFsbG93ZWQgd2l0aGluIHN0cmluZyB2YWx1ZXMnKSk7XG5cbiAgICAgICAgICB2YXIgX05vZGUkZm9sZE5ld2xpbmUgPSBOb2RlLmZvbGROZXdsaW5lKHNyYywgaSwgaW5kZW50KSxcbiAgICAgICAgICAgICAgZm9sZCA9IF9Ob2RlJGZvbGROZXdsaW5lLmZvbGQsXG4gICAgICAgICAgICAgIG9mZnNldCA9IF9Ob2RlJGZvbGROZXdsaW5lLm9mZnNldCxcbiAgICAgICAgICAgICAgZXJyb3IgPSBfTm9kZSRmb2xkTmV3bGluZS5lcnJvcjtcblxuICAgICAgICAgIHN0ciArPSBmb2xkO1xuICAgICAgICAgIGkgPSBvZmZzZXQ7XG4gICAgICAgICAgaWYgKGVycm9yKSBlcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IodGhpcywgJ011bHRpLWxpbmUgc2luZ2xlLXF1b3RlZCBzdHJpbmcgbmVlZHMgdG8gYmUgc3VmZmljaWVudGx5IGluZGVudGVkJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIidcIikge1xuICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgaWYgKHNyY1tpXSAhPT0gXCInXCIpIGVycm9ycy5wdXNoKG5ldyBZQU1MU3ludGF4RXJyb3IodGhpcywgJ1VuZXNjYXBlZCBzaW5nbGUgcXVvdGU/IFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4uJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgLy8gdHJpbSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgdmFyIHdzU3RhcnQgPSBpO1xuICAgICAgICAgIHZhciBuZXh0ID0gc3JjW2kgKyAxXTtcblxuICAgICAgICAgIHdoaWxlIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIG5leHQgPSBzcmNbaSArIDFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0ICE9PSAnXFxuJykgc3RyICs9IGkgPiB3c1N0YXJ0ID8gc3JjLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IGNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA+IDAgPyB7XG4gICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICBzdHI6IHN0clxuICAgICAgfSA6IHN0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgJ3NpbmdsZSBxdW90ZWQnIHZhbHVlIGZyb20gdGhlIHNvdXJjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpcyBzY2FsYXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdmFyIHNyYyA9IGNvbnRleHQuc3JjO1xuICAgICAgdmFyIG9mZnNldCA9IFF1b3RlU2luZ2xlLmVuZE9mUXVvdGUoc3JjLCBzdGFydCArIDEpO1xuICAgICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUNvbW1lbnQob2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZW5kT2ZRdW90ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZlF1b3RlKHNyYywgb2Zmc2V0KSB7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgIGlmIChjaCA9PT0gXCInXCIpIHtcbiAgICAgICAgICBpZiAoc3JjW29mZnNldCArIDFdICE9PSBcIidcIikgYnJlYWs7XG4gICAgICAgICAgY2ggPSBzcmNbb2Zmc2V0ICs9IDJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoID0gc3JjW29mZnNldCArPSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0ICsgMTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUXVvdGVTaW5nbGU7XG59KE5vZGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVOZXdOb2RlKHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgVHlwZS5BTElBUzpcbiAgICAgIHJldHVybiBuZXcgQWxpYXModHlwZSwgcHJvcHMpO1xuXG4gICAgY2FzZSBUeXBlLkJMT0NLX0ZPTERFRDpcbiAgICBjYXNlIFR5cGUuQkxPQ0tfTElURVJBTDpcbiAgICAgIHJldHVybiBuZXcgQmxvY2tWYWx1ZSh0eXBlLCBwcm9wcyk7XG5cbiAgICBjYXNlIFR5cGUuRkxPV19NQVA6XG4gICAgY2FzZSBUeXBlLkZMT1dfU0VROlxuICAgICAgcmV0dXJuIG5ldyBGbG93Q29sbGVjdGlvbih0eXBlLCBwcm9wcyk7XG5cbiAgICBjYXNlIFR5cGUuTUFQX0tFWTpcbiAgICBjYXNlIFR5cGUuTUFQX1ZBTFVFOlxuICAgIGNhc2UgVHlwZS5TRVFfSVRFTTpcbiAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbkl0ZW0odHlwZSwgcHJvcHMpO1xuXG4gICAgY2FzZSBUeXBlLkNPTU1FTlQ6XG4gICAgY2FzZSBUeXBlLlBMQUlOOlxuICAgICAgcmV0dXJuIG5ldyBQbGFpblZhbHVlKHR5cGUsIHByb3BzKTtcblxuICAgIGNhc2UgVHlwZS5RVU9URV9ET1VCTEU6XG4gICAgICByZXR1cm4gbmV3IFF1b3RlRG91YmxlKHR5cGUsIHByb3BzKTtcblxuICAgIGNhc2UgVHlwZS5RVU9URV9TSU5HTEU6XG4gICAgICByZXR1cm4gbmV3IFF1b3RlU2luZ2xlKHR5cGUsIHByb3BzKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXRMaW5lU3RhcnQgLSBOb2RlIHN0YXJ0cyBhdCBiZWdpbm5pbmcgb2YgbGluZVxuICogQHBhcmFtIHtib29sZWFufSBpbkZsb3cgLSB0cnVlIGlmIGN1cnJlbnRseSBpbiBhIGZsb3cgY29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpbkNvbGxlY3Rpb24gLSB0cnVlIGlmIGN1cnJlbnRseSBpbiBhIGNvbGxlY3Rpb24gY29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGVudCAtIEN1cnJlbnQgbGV2ZWwgb2YgaW5kZW50YXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lU3RhcnQgLSBTdGFydCBvZiB0aGUgY3VycmVudCBsaW5lXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudCAtIFRoZSBwYXJlbnQgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgLSBTb3VyY2Ugb2YgdGhlIFlBTUwgZG9jdW1lbnRcbiAqL1xuXG5cbnZhciBQYXJzZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJzZUNvbnRleHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgYXRMaW5lU3RhcnQgPSBfcmVmLmF0TGluZVN0YXJ0LFxuICAgICAgICBpbkNvbGxlY3Rpb24gPSBfcmVmLmluQ29sbGVjdGlvbixcbiAgICAgICAgaW5GbG93ID0gX3JlZi5pbkZsb3csXG4gICAgICAgIGluZGVudCA9IF9yZWYuaW5kZW50LFxuICAgICAgICBsaW5lU3RhcnQgPSBfcmVmLmxpbmVTdGFydCxcbiAgICAgICAgcGFyZW50ID0gX3JlZi5wYXJlbnQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2VDb250ZXh0KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcnNlTm9kZVwiLCBmdW5jdGlvbiAob3ZlcmxheSwgc3RhcnQpIHtcbiAgICAgIGlmIChOb2RlLmF0RG9jdW1lbnRCb3VuZGFyeShfdGhpcy5zcmMsIHN0YXJ0KSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQoX3RoaXMsIG92ZXJsYXkpO1xuXG4gICAgICB2YXIgX2NvbnRleHQkcGFyc2VQcm9wcyA9IGNvbnRleHQucGFyc2VQcm9wcyhzdGFydCksXG4gICAgICAgICAgcHJvcHMgPSBfY29udGV4dCRwYXJzZVByb3BzLnByb3BzLFxuICAgICAgICAgIHR5cGUgPSBfY29udGV4dCRwYXJzZVByb3BzLnR5cGUsXG4gICAgICAgICAgdmFsdWVTdGFydCA9IF9jb250ZXh0JHBhcnNlUHJvcHMudmFsdWVTdGFydDtcblxuICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOZXdOb2RlKHR5cGUsIHByb3BzKTtcbiAgICAgIHZhciBvZmZzZXQgPSBub2RlLnBhcnNlKGNvbnRleHQsIHZhbHVlU3RhcnQpO1xuICAgICAgbm9kZS5yYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IHN0YXJ0KSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMsIGxldCdzIG1ha2Ugc3VyZSB0byBhdCBsZWFzdFxuICAgICAgICAvLyBzdGVwIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZCB0byBhdm9pZCBhIGJ1c3kgbG9vcC5cbiAgICAgICAgbm9kZS5lcnJvciA9IG5ldyBFcnJvcihcIk5vZGUjcGFyc2UgY29uc3VtZWQgbm8gY2hhcmFjdGVyc1wiKTtcbiAgICAgICAgbm9kZS5lcnJvci5wYXJzZUVuZCA9IG9mZnNldDtcbiAgICAgICAgbm9kZS5lcnJvci5zb3VyY2UgPSBub2RlO1xuICAgICAgICBub2RlLnJhbmdlLmVuZCA9IHN0YXJ0ICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRleHQubm9kZVN0YXJ0c0NvbGxlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgaWYgKCFub2RlLmVycm9yICYmICFjb250ZXh0LmF0TGluZVN0YXJ0ICYmIGNvbnRleHQucGFyZW50LnR5cGUgPT09IFR5cGUuRE9DVU1FTlQpIHtcbiAgICAgICAgICBub2RlLmVycm9yID0gbmV3IFlBTUxTeW50YXhFcnJvcihub2RlLCAnQmxvY2sgY29sbGVjdGlvbiBtdXN0IG5vdCBoYXZlIHByZWNlZGluZyBjb250ZW50IGhlcmUgKGUuZy4gZGlyZWN0aXZlcy1lbmQgaW5kaWNhdG9yKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbihub2RlKTtcbiAgICAgICAgb2Zmc2V0ID0gY29sbGVjdGlvbi5wYXJzZShuZXcgUGFyc2VDb250ZXh0KGNvbnRleHQpLCBvZmZzZXQpO1xuICAgICAgICBjb2xsZWN0aW9uLnJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG5cbiAgICB0aGlzLmF0TGluZVN0YXJ0ID0gYXRMaW5lU3RhcnQgIT0gbnVsbCA/IGF0TGluZVN0YXJ0IDogb3JpZy5hdExpbmVTdGFydCB8fCBmYWxzZTtcbiAgICB0aGlzLmluQ29sbGVjdGlvbiA9IGluQ29sbGVjdGlvbiAhPSBudWxsID8gaW5Db2xsZWN0aW9uIDogb3JpZy5pbkNvbGxlY3Rpb24gfHwgZmFsc2U7XG4gICAgdGhpcy5pbkZsb3cgPSBpbkZsb3cgIT0gbnVsbCA/IGluRmxvdyA6IG9yaWcuaW5GbG93IHx8IGZhbHNlO1xuICAgIHRoaXMuaW5kZW50ID0gaW5kZW50ICE9IG51bGwgPyBpbmRlbnQgOiBvcmlnLmluZGVudDtcbiAgICB0aGlzLmxpbmVTdGFydCA9IGxpbmVTdGFydCAhPSBudWxsID8gbGluZVN0YXJ0IDogb3JpZy5saW5lU3RhcnQ7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgIT0gbnVsbCA/IHBhcmVudCA6IG9yaWcucGFyZW50IHx8IHt9O1xuICAgIHRoaXMucm9vdCA9IG9yaWcucm9vdDtcbiAgICB0aGlzLnNyYyA9IG9yaWcuc3JjO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhcnNlQ29udGV4dCwgW3tcbiAgICBrZXk6IFwibm9kZVN0YXJ0c0NvbGxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZVN0YXJ0c0NvbGxlY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGluQ29sbGVjdGlvbiA9IHRoaXMuaW5Db2xsZWN0aW9uLFxuICAgICAgICAgIGluRmxvdyA9IHRoaXMuaW5GbG93LFxuICAgICAgICAgIHNyYyA9IHRoaXMuc3JjO1xuICAgICAgaWYgKGluQ29sbGVjdGlvbiB8fCBpbkZsb3cpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbkl0ZW0pIHJldHVybiB0cnVlOyAvLyBjaGVjayBmb3IgaW1wbGljaXQga2V5XG5cbiAgICAgIHZhciBvZmZzZXQgPSBub2RlLnJhbmdlLmVuZDtcbiAgICAgIGlmIChzcmNbb2Zmc2V0XSA9PT0gJ1xcbicgfHwgc3JjW29mZnNldCAtIDFdID09PSAnXFxuJykgcmV0dXJuIGZhbHNlO1xuICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIHNyY1tvZmZzZXRdID09PSAnOic7XG4gICAgfSAvLyBBbmNob3IgYW5kIHRhZyBhcmUgYmVmb3JlIHR5cGUsIHdoaWNoIGRldGVybWluZXMgdGhlIG5vZGUgaW1wbGVtZW50YXRpb25cbiAgICAvLyBjbGFzczsgaGVuY2UgdGhpcyBpbnRlcm1lZGlhdGUgc3RlcC5cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VQcm9wcyhvZmZzZXQpIHtcbiAgICAgIHZhciBpbkZsb3cgPSB0aGlzLmluRmxvdyxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgICBzcmMgPSB0aGlzLnNyYztcbiAgICAgIHZhciBwcm9wcyA9IFtdO1xuICAgICAgdmFyIGxpbmVIYXNQcm9wcyA9IGZhbHNlO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5hdExpbmVTdGFydCA/IE5vZGUuZW5kT2ZJbmRlbnQoc3JjLCBvZmZzZXQpIDogTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldF07XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gQ2hhci5BTkNIT1IgfHwgY2ggPT09IENoYXIuQ09NTUVOVCB8fCBjaCA9PT0gQ2hhci5UQUcgfHwgY2ggPT09ICdcXG4nKSB7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICB2YXIgaW5FbmQgPSBvZmZzZXQ7XG4gICAgICAgICAgdmFyIGxpbmVTdGFydCA9IHZvaWQgMDtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxpbmVTdGFydCA9IGluRW5kICsgMTtcbiAgICAgICAgICAgIGluRW5kID0gTm9kZS5lbmRPZkluZGVudChzcmMsIGxpbmVTdGFydCk7XG4gICAgICAgICAgfSB3aGlsZSAoc3JjW2luRW5kXSA9PT0gJ1xcbicpO1xuXG4gICAgICAgICAgdmFyIGluZGVudERpZmYgPSBpbkVuZCAtIChsaW5lU3RhcnQgKyB0aGlzLmluZGVudCk7XG4gICAgICAgICAgdmFyIG5vSW5kaWNhdG9yQXNJbmRlbnQgPSBwYXJlbnQudHlwZSA9PT0gVHlwZS5TRVFfSVRFTSAmJiBwYXJlbnQuY29udGV4dC5hdExpbmVTdGFydDtcbiAgICAgICAgICBpZiAoc3JjW2luRW5kXSAhPT0gJyMnICYmICFOb2RlLm5leHROb2RlSXNJbmRlbnRlZChzcmNbaW5FbmRdLCBpbmRlbnREaWZmLCAhbm9JbmRpY2F0b3JBc0luZGVudCkpIGJyZWFrO1xuICAgICAgICAgIHRoaXMuYXRMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICAgIGxpbmVIYXNQcm9wcyA9IGZhbHNlO1xuICAgICAgICAgIG9mZnNldCA9IGluRW5kO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBDaGFyLkNPTU1FTlQpIHtcbiAgICAgICAgICB2YXIgZW5kID0gTm9kZS5lbmRPZkxpbmUoc3JjLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICBwcm9wcy5wdXNoKG5ldyBSYW5nZShvZmZzZXQsIGVuZCkpO1xuICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2VuZCA9IE5vZGUuZW5kT2ZJZGVudGlmaWVyKHNyYywgb2Zmc2V0ICsgMSk7XG5cbiAgICAgICAgICBpZiAoY2ggPT09IENoYXIuVEFHICYmIHNyY1tfZW5kXSA9PT0gJywnICYmIC9eW2EtekEtWjAtOS1dK1xcLlthLXpBLVowLTktXSssXFxkXFxkXFxkXFxkKC1cXGRcXGQpezAsMn1cXC9cXFMvLnRlc3Qoc3JjLnNsaWNlKG9mZnNldCArIDEsIF9lbmQgKyAxMykpKSB7XG4gICAgICAgICAgICAvLyBMZXQncyBwcmVzdW1lIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIFlBTUwgMS4wIGRvbWFpbiB0YWcgaGVyZSwgcmF0aGVyXG4gICAgICAgICAgICAvLyB0aGFuIGFuIGVtcHR5IGJ1dCAnZm9vLmJhcicgcHJpdmF0ZS10YWdnZWQgbm9kZSBpbiBhIGZsb3cgY29sbGVjdGlvblxuICAgICAgICAgICAgLy8gZm9sbG93ZWQgd2l0aG91dCB3aGl0ZXNwYWNlIGJ5IGEgcGxhaW4gc3RyaW5nIHN0YXJ0aW5nIHdpdGggYSB5ZWFyXG4gICAgICAgICAgICAvLyBvciBkYXRlIGRpdmlkZWQgYnkgc29tZXRoaW5nLlxuICAgICAgICAgICAgX2VuZCA9IE5vZGUuZW5kT2ZJZGVudGlmaWVyKHNyYywgX2VuZCArIDUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb3BzLnB1c2gobmV3IFJhbmdlKG9mZnNldCwgX2VuZCkpO1xuICAgICAgICAgIGxpbmVIYXNQcm9wcyA9IHRydWU7XG4gICAgICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBfZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoID0gc3JjW29mZnNldF07XG4gICAgICB9IC8vICctICZhIDogYicgaGFzIGFuIGFuY2hvciBvbiBhbiBlbXB0eSBub2RlXG5cblxuICAgICAgaWYgKGxpbmVIYXNQcm9wcyAmJiBjaCA9PT0gJzonICYmIE5vZGUuYXRCbGFuayhzcmMsIG9mZnNldCArIDEsIHRydWUpKSBvZmZzZXQgLT0gMTtcbiAgICAgIHZhciB0eXBlID0gUGFyc2VDb250ZXh0LnBhcnNlVHlwZShzcmMsIG9mZnNldCwgaW5GbG93KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdmFsdWVTdGFydDogb2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBub2RlIGZyb20gdGhlIHNvdXJjZVxuICAgICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBvdmVybGF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIGZvciB0aGUgbm9kZVxuICAgICAqIEByZXR1cm5zIHs/Tm9kZX0gLSBudWxsIGlmIGF0IGEgZG9jdW1lbnQgYm91bmRhcnlcbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlVHlwZShzcmMsIG9mZnNldCwgaW5GbG93KSB7XG4gICAgICBzd2l0Y2ggKHNyY1tvZmZzZXRdKSB7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgIHJldHVybiBUeXBlLkFMSUFTO1xuXG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIHJldHVybiBUeXBlLkJMT0NLX0ZPTERFRDtcblxuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICByZXR1cm4gVHlwZS5CTE9DS19MSVRFUkFMO1xuXG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgIHJldHVybiBUeXBlLkZMT1dfTUFQO1xuXG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgIHJldHVybiBUeXBlLkZMT1dfU0VRO1xuXG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIHJldHVybiAhaW5GbG93ICYmIE5vZGUuYXRCbGFuayhzcmMsIG9mZnNldCArIDEsIHRydWUpID8gVHlwZS5NQVBfS0VZIDogVHlwZS5QTEFJTjtcblxuICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICByZXR1cm4gIWluRmxvdyAmJiBOb2RlLmF0Qmxhbmsoc3JjLCBvZmZzZXQgKyAxLCB0cnVlKSA/IFR5cGUuTUFQX1ZBTFVFIDogVHlwZS5QTEFJTjtcblxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gIWluRmxvdyAmJiBOb2RlLmF0Qmxhbmsoc3JjLCBvZmZzZXQgKyAxLCB0cnVlKSA/IFR5cGUuU0VRX0lURU0gOiBUeXBlLlBMQUlOO1xuXG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICByZXR1cm4gVHlwZS5RVU9URV9ET1VCTEU7XG5cbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICByZXR1cm4gVHlwZS5RVU9URV9TSU5HTEU7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gVHlwZS5QTEFJTjtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFyc2VDb250ZXh0O1xufSgpO1xuXG4vLyBQdWJsaXNoZWQgYXMgJ3lhbWwvcGFyc2UtY3N0J1xuZnVuY3Rpb24gcGFyc2Uoc3JjKSB7XG4gIHZhciBjciA9IFtdO1xuXG4gIGlmIChzcmMuaW5kZXhPZignXFxyJykgIT09IC0xKSB7XG4gICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcclxcbj8vZywgZnVuY3Rpb24gKG1hdGNoLCBvZmZzZXQpIHtcbiAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxKSBjci5wdXNoKG9mZnNldCk7XG4gICAgICByZXR1cm4gJ1xcbic7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRzID0gW107XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIGRvIHtcbiAgICB2YXIgZG9jID0gbmV3IERvY3VtZW50KCk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHtcbiAgICAgIHNyYzogc3JjXG4gICAgfSk7XG4gICAgb2Zmc2V0ID0gZG9jLnBhcnNlKGNvbnRleHQsIG9mZnNldCk7XG4gICAgZG9jdW1lbnRzLnB1c2goZG9jKTtcbiAgfSB3aGlsZSAob2Zmc2V0IDwgc3JjLmxlbmd0aCk7XG5cbiAgZG9jdW1lbnRzLnNldE9yaWdSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjci5sZW5ndGg7ICsraSkge1xuICAgICAgY3JbaV0gLT0gaTtcbiAgICB9XG5cbiAgICB2YXIgY3JPZmZzZXQgPSAwO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRvY3VtZW50cy5sZW5ndGg7ICsrX2kpIHtcbiAgICAgIGNyT2Zmc2V0ID0gZG9jdW1lbnRzW19pXS5zZXRPcmlnUmFuZ2VzKGNyLCBjck9mZnNldCk7XG4gICAgfVxuXG4gICAgY3Iuc3BsaWNlKDAsIGNyLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgZG9jdW1lbnRzLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkb2N1bWVudHMuam9pbignLi4uXFxuJyk7XG4gIH07XG5cbiAgcmV0dXJuIGRvY3VtZW50cztcbn1cblxuZXhwb3J0IHsgcGFyc2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/parse-cst.js\n")},"./node_modules/yaml/browser/dist/resolveSeq-492ab440.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"A\": () => (/* binding */ Alias),\n/* harmony export */   \"C\": () => (/* binding */ Collection),\n/* harmony export */   \"M\": () => (/* binding */ Merge),\n/* harmony export */   \"N\": () => (/* binding */ Node),\n/* harmony export */   \"P\": () => (/* binding */ Pair),\n/* harmony export */   \"S\": () => (/* binding */ Scalar),\n/* harmony export */   \"Y\": () => (/* binding */ YAMLSeq),\n/* harmony export */   \"a\": () => (/* binding */ boolOptions),\n/* harmony export */   \"b\": () => (/* binding */ binaryOptions),\n/* harmony export */   \"c\": () => (/* binding */ stringifyString),\n/* harmony export */   \"d\": () => (/* binding */ YAMLMap),\n/* harmony export */   \"e\": () => (/* binding */ isEmptyPath),\n/* harmony export */   \"f\": () => (/* binding */ addComment),\n/* harmony export */   \"g\": () => (/* binding */ resolveMap),\n/* harmony export */   \"h\": () => (/* binding */ resolveSeq),\n/* harmony export */   \"i\": () => (/* binding */ intOptions),\n/* harmony export */   \"j\": () => (/* binding */ resolveString),\n/* harmony export */   \"k\": () => (/* binding */ stringifyNumber),\n/* harmony export */   \"l\": () => (/* binding */ findPair),\n/* harmony export */   \"n\": () => (/* binding */ nullOptions),\n/* harmony export */   \"r\": () => (/* binding */ resolveNode),\n/* harmony export */   \"s\": () => (/* binding */ strOptions),\n/* harmony export */   \"t\": () => (/* binding */ toJSON)\n/* harmony export */ });\n/* harmony import */ var _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlainValue-b8036b75.js */ \"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\");\n\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  var cc = comment.replace(/[\\s\\S]^/gm, \"$&\".concat(indent, \"#\"));\n  return \"#\".concat(cc, \"\\n\").concat(indent).concat(str);\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? \"\".concat(str, \" #\").concat(comment) : \"\".concat(str, \"\\n\") + comment.replace(/^/gm, \"\".concat(indent || '', \"#\"));\n}\n\nvar Node = function Node() {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Node);\n};\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map(function (v, i) {\n    return toJSON(v, String(i), ctx);\n  });\n\n  if (value && typeof value.toJSON === 'function') {\n    var anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = function (res) {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    var res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nvar Scalar = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Scalar, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Scalar);\n\n  function Scalar(value) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Scalar);\n\n    _this = _super.call(this);\n    _this.value = value;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Scalar, [{\n    key: \"toJSON\",\n    value: function toJSON$1(arg, ctx) {\n      return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return String(this.value);\n    }\n  }]);\n\n  return Scalar;\n}(Node);\n\nfunction collectionFromPath(schema, path, value) {\n  var v = value;\n\n  for (var i = path.length - 1; i >= 0; --i) {\n    var k = path[i];\n\n    if (Number.isInteger(k) && k >= 0) {\n      var a = [];\n      a[k] = v;\n      v = a;\n    } else {\n      var o = {};\n      Object.defineProperty(o, k, {\n        value: v,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n      v = o;\n    }\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nvar isEmptyPath = function isEmptyPath(path) {\n  return path == null || (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(path) === 'object' && path[Symbol.iterator]().next().done;\n};\nvar Collection = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Collection, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Collection);\n\n  function Collection(schema) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Collection);\n\n    _this = _super.call(this);\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"items\", []);\n\n    _this.schema = schema;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Collection, [{\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      if (isEmptyPath(path)) this.add(value);else {\n        var _path = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.q)(path),\n            key = _path[0],\n            rest = _path.slice(1);\n\n        var node = this.get(key, true);\n        if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n      }\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(_ref) {\n      var _ref2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.q)(_ref),\n          key = _ref2[0],\n          rest = _ref2.slice(1);\n\n      if (rest.length === 0) return this.delete(key);\n      var node = this.get(key, true);\n      if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(_ref3, keepScalar) {\n      var _ref4 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.q)(_ref3),\n          key = _ref4[0],\n          rest = _ref4.slice(1);\n\n      var node = this.get(key, true);\n      if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n    }\n  }, {\n    key: \"hasAllNullValues\",\n    value: function hasAllNullValues() {\n      return this.items.every(function (node) {\n        if (!node || node.type !== 'PAIR') return false;\n        var n = node.value;\n        return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n      });\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(_ref5) {\n      var _ref6 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.q)(_ref5),\n          key = _ref6[0],\n          rest = _ref6.slice(1);\n\n      if (rest.length === 0) return this.has(key);\n      var node = this.get(key, true);\n      return node instanceof Collection ? node.hasIn(rest) : false;\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(_ref7, value) {\n      var _ref8 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.q)(_ref7),\n          key = _ref8[0],\n          rest = _ref8.slice(1);\n\n      if (rest.length === 0) {\n        this.set(key, value);\n      } else {\n        var node = this.get(key, true);\n        if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n      }\n    } // overridden in implementations\n\n    /* istanbul ignore next */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return null;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, _ref9, onComment, onChompKeep) {\n      var _this2 = this;\n\n      var blockItem = _ref9.blockItem,\n          flowChars = _ref9.flowChars,\n          isMap = _ref9.isMap,\n          itemIndent = _ref9.itemIndent;\n      var _ctx = ctx,\n          indent = _ctx.indent,\n          indentStep = _ctx.indentStep,\n          stringify = _ctx.stringify;\n      var inFlow = this.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP || this.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ || ctx.inFlow;\n      if (inFlow) itemIndent += indentStep;\n      var allNullValues = isMap && this.hasAllNullValues();\n      ctx = Object.assign({}, ctx, {\n        allNullValues: allNullValues,\n        indent: itemIndent,\n        inFlow: inFlow,\n        type: null\n      });\n      var chompKeep = false;\n      var hasItemWithNewLine = false;\n      var nodes = this.items.reduce(function (nodes, item, i) {\n        var comment;\n\n        if (item) {\n          if (!chompKeep && item.spaceBefore) nodes.push({\n            type: 'comment',\n            str: ''\n          });\n          if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(function (line) {\n            nodes.push({\n              type: 'comment',\n              str: \"#\".concat(line)\n            });\n          });\n          if (item.comment) comment = item.comment;\n          if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n        }\n\n        chompKeep = false;\n        var str = stringify(item, ctx, function () {\n          return comment = null;\n        }, function () {\n          return chompKeep = true;\n        });\n        if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n        if (inFlow && i < _this2.items.length - 1) str += ',';\n        str = addComment(str, itemIndent, comment);\n        if (chompKeep && (comment || inFlow)) chompKeep = false;\n        nodes.push({\n          type: 'item',\n          str: str\n        });\n        return nodes;\n      }, []);\n      var str;\n\n      if (nodes.length === 0) {\n        str = flowChars.start + flowChars.end;\n      } else if (inFlow) {\n        var start = flowChars.start,\n            end = flowChars.end;\n        var strings = nodes.map(function (n) {\n          return n.str;\n        });\n\n        if (hasItemWithNewLine || strings.reduce(function (sum, str) {\n          return sum + str.length + 2;\n        }, 2) > Collection.maxFlowStringSingleLineLength) {\n          str = start;\n\n          var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(strings),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var s = _step.value;\n              str += s ? \"\\n\".concat(indentStep).concat(indent).concat(s) : '\\n';\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          str += \"\\n\".concat(indent).concat(end);\n        } else {\n          str = \"\".concat(start, \" \").concat(strings.join(' '), \" \").concat(end);\n        }\n      } else {\n        var _strings = nodes.map(blockItem);\n\n        str = _strings.shift();\n\n        var _iterator2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(_strings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _s = _step2.value;\n            str += _s ? \"\\n\".concat(indent).concat(_s) : '\\n';\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      if (this.comment) {\n        str += '\\n' + this.comment.replace(/^/gm, \"\".concat(indent, \"#\"));\n        if (onComment) onComment();\n      } else if (chompKeep && onChompKeep) onChompKeep();\n\n      return str;\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  var idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nvar YAMLSeq = /*#__PURE__*/function (_Collection) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(YAMLSeq, _Collection);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(YAMLSeq);\n\n  function YAMLSeq() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, YAMLSeq);\n\n    return _super.apply(this, arguments);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(YAMLSeq, [{\n    key: \"add\",\n    value: function add(value) {\n      this.items.push(value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') return false;\n      var del = this.items.splice(idx, 1);\n      return del.length > 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') return undefined;\n      var it = this.items[idx];\n      return !keepScalar && it instanceof Scalar ? it.value : it;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var idx = asItemIndex(key);\n      return typeof idx === 'number' && idx < this.items.length;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') throw new Error(\"Expected a valid index, not \".concat(key, \".\"));\n      this.items[idx] = value;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(_, ctx) {\n      var seq = [];\n      if (ctx && ctx.onCreate) ctx.onCreate(seq);\n      var i = 0;\n\n      var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          seq.push(toJSON(item, String(i++), ctx));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return seq;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n      return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(YAMLSeq.prototype), \"toString\", this).call(this, ctx, {\n        blockItem: function blockItem(n) {\n          return n.type === 'comment' ? n.str : \"- \".concat(n.str);\n        },\n        flowChars: {\n          start: '[',\n          end: ']'\n        },\n        isMap: false,\n        itemIndent: (ctx.indent || '') + '  '\n      }, onComment, onChompKeep);\n    }\n  }]);\n\n  return YAMLSeq;\n}(Collection);\n\nvar stringifyKey = function stringifyKey(key, jsKey, ctx) {\n  if (jsKey === null) return '';\n  if ((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(jsKey) !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: Object.create(null),\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nvar Pair = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Pair, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Pair);\n\n  function Pair(key) {\n    var _this;\n\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Pair);\n\n    _this = _super.call(this);\n    _this.key = key;\n    _this.value = value;\n    _this.type = Pair.Type.PAIR;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Pair, [{\n    key: \"commentBefore\",\n    get: function get() {\n      return this.key instanceof Node ? this.key.commentBefore : undefined;\n    },\n    set: function set(cb) {\n      if (this.key == null) this.key = new Scalar(null);\n      if (this.key instanceof Node) this.key.commentBefore = cb;else {\n        var msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n        throw new Error(msg);\n      }\n    }\n  }, {\n    key: \"addToJSMap\",\n    value: function addToJSMap(ctx, map) {\n      var key = toJSON(this.key, '', ctx);\n\n      if (map instanceof Map) {\n        var value = toJSON(this.value, key, ctx);\n        map.set(key, value);\n      } else if (map instanceof Set) {\n        map.add(key);\n      } else {\n        var stringKey = stringifyKey(this.key, key, ctx);\n\n        var _value = toJSON(this.value, stringKey, ctx);\n\n        if (stringKey in map) Object.defineProperty(map, stringKey, {\n          value: _value,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });else map[stringKey] = _value;\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx) {\n      var pair = ctx && ctx.mapAsMap ? new Map() : {};\n      return this.addToJSMap(ctx, pair);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx || !ctx.doc) return JSON.stringify(this);\n      var _ctx$doc$options = ctx.doc.options,\n          indentSize = _ctx$doc$options.indent,\n          indentSeq = _ctx$doc$options.indentSeq,\n          simpleKeys = _ctx$doc$options.simpleKeys;\n      var key = this.key,\n          value = this.value;\n      var keyComment = key instanceof Node && key.comment;\n\n      if (simpleKeys) {\n        if (keyComment) {\n          throw new Error('With simple keys, key nodes cannot have comments');\n        }\n\n        if (key instanceof Collection) {\n          var msg = 'With simple keys, collection cannot be used as a key value';\n          throw new Error(msg);\n        }\n      }\n\n      var explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED || key.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL : (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(key) === 'object'));\n      var _ctx = ctx,\n          doc = _ctx.doc,\n          indent = _ctx.indent,\n          indentStep = _ctx.indentStep,\n          stringify = _ctx.stringify;\n      ctx = Object.assign({}, ctx, {\n        implicitKey: !explicitKey,\n        indent: indent + indentStep\n      });\n      var chompKeep = false;\n      var str = stringify(key, ctx, function () {\n        return keyComment = null;\n      }, function () {\n        return chompKeep = true;\n      });\n      str = addComment(str, ctx.indent, keyComment);\n\n      if (!explicitKey && str.length > 1024) {\n        if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n      }\n\n      if (ctx.allNullValues && !simpleKeys) {\n        if (this.comment) {\n          str = addComment(str, ctx.indent, this.comment);\n          if (onComment) onComment();\n        } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n        return ctx.inFlow && !explicitKey ? str : \"? \".concat(str);\n      }\n\n      str = explicitKey ? \"? \".concat(str, \"\\n\").concat(indent, \":\") : \"\".concat(str, \":\");\n\n      if (this.comment) {\n        // expected (but not strictly required) to be a single-line comment\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      }\n\n      var vcb = '';\n      var valueComment = null;\n\n      if (value instanceof Node) {\n        if (value.spaceBefore) vcb = '\\n';\n\n        if (value.commentBefore) {\n          var cs = value.commentBefore.replace(/^/gm, \"\".concat(ctx.indent, \"#\"));\n          vcb += \"\\n\".concat(cs);\n        }\n\n        valueComment = value.comment;\n      } else if (value && (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === 'object') {\n        value = doc.schema.createNode(value, true);\n      }\n\n      ctx.implicitKey = false;\n      if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n      chompKeep = false;\n\n      if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substr(2);\n      }\n\n      var valueStr = stringify(value, ctx, function () {\n        return valueComment = null;\n      }, function () {\n        return chompKeep = true;\n      });\n      var ws = ' ';\n\n      if (vcb || this.comment) {\n        ws = \"\".concat(vcb, \"\\n\").concat(ctx.indent);\n      } else if (!explicitKey && value instanceof Collection) {\n        var flow = valueStr[0] === '[' || valueStr[0] === '{';\n        if (!flow || valueStr.includes('\\n')) ws = \"\\n\".concat(ctx.indent);\n      } else if (valueStr[0] === '\\n') ws = '';\n\n      if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n      return addComment(str + ws + valueStr, ctx.indent, valueComment);\n    }\n  }]);\n\n  return Pair;\n}(Node);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nvar getAliasCount = function getAliasCount(node, anchors) {\n  if (node instanceof Alias) {\n    var anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    var count = 0;\n\n    var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(node.items),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        var c = getAliasCount(item, anchors);\n        if (c > count) count = c;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    var kc = getAliasCount(node.key, anchors);\n    var vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Alias, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Alias);\n\n  function Alias(source) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Alias);\n\n    _this = _super.call(this);\n    _this.source = source;\n    _this.type = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.ALIAS;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Alias, [{\n    key: \"tag\",\n    set: function set(t) {\n      throw new Error('Alias nodes cannot have tags');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, ctx) {\n      if (!ctx) return toJSON(this.source, arg, ctx);\n      var anchors = ctx.anchors,\n          maxAliasCount = ctx.maxAliasCount;\n      var anchor = anchors.get(this.source);\n      /* istanbul ignore if */\n\n      if (!anchor || anchor.res === undefined) {\n        var msg = 'This should not happen: Alias anchor was not resolved?';\n        if (this.cstNode) throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.o(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n\n      if (maxAliasCount >= 0) {\n        anchor.count += 1;\n        if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n        if (anchor.count * anchor.aliasCount > maxAliasCount) {\n          var _msg = 'Excessive alias count indicates a resource exhaustion attack';\n          if (this.cstNode) throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.o(this.cstNode, _msg);else throw new ReferenceError(_msg);\n        }\n      }\n\n      return anchor.res;\n    } // Only called when stringifying an alias mapping key while constructing\n    // Object output.\n\n  }, {\n    key: \"toString\",\n    value: function toString(ctx) {\n      return Alias.stringify(this, ctx);\n    }\n  }], [{\n    key: \"stringify\",\n    value: function stringify(_ref, _ref2) {\n      var range = _ref.range,\n          source = _ref.source;\n      var anchors = _ref2.anchors,\n          doc = _ref2.doc,\n          implicitKey = _ref2.implicitKey,\n          inStringifyKey = _ref2.inStringifyKey;\n      var anchor = Object.keys(anchors).find(function (a) {\n        return anchors[a] === source;\n      });\n      if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n      if (anchor) return \"*\".concat(anchor).concat(implicitKey ? ' ' : '');\n      var msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n      throw new Error(\"\".concat(msg, \" [\").concat(range, \"]\"));\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  var k = key instanceof Scalar ? key.value : key;\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(items),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var it = _step.value;\n\n      if (it instanceof Pair) {\n        if (it.key === key || it.key === k) return it;\n        if (it.key && it.key.value === k) return it;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return undefined;\n}\nvar YAMLMap = /*#__PURE__*/function (_Collection) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(YAMLMap, _Collection);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(YAMLMap);\n\n  function YAMLMap() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, YAMLMap);\n\n    return _super.apply(this, arguments);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(YAMLMap, [{\n    key: \"add\",\n    value: function add(pair, overwrite) {\n      if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n      var prev = findPair(this.items, pair.key);\n      var sortEntries = this.schema && this.schema.sortMapEntries;\n\n      if (prev) {\n        if (overwrite) prev.value = pair.value;else throw new Error(\"Key \".concat(pair.key, \" already set\"));\n      } else if (sortEntries) {\n        var i = this.items.findIndex(function (item) {\n          return sortEntries(pair, item) < 0;\n        });\n        if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n      } else {\n        this.items.push(pair);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var it = findPair(this.items, key);\n      if (!it) return false;\n      var del = this.items.splice(this.items.indexOf(it), 1);\n      return del.length > 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      var it = findPair(this.items, key);\n      var node = it && it.value;\n      return !keepScalar && node instanceof Scalar ? node.value : node;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return !!findPair(this.items, key);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      this.add(new Pair(key, value), true);\n    }\n    /**\n     * @param {*} arg ignored\n     * @param {*} ctx Conversion context, originally set in Document#toJSON()\n     * @param {Class} Type If set, forces the returned collection type\n     * @returns {*} Instance of Type, Map, or Object\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx, Type) {\n      var map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n      if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n      var _iterator2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.items),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          item.addToJSMap(ctx, map);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n\n      var _iterator3 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.items),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          if (!(item instanceof Pair)) throw new Error(\"Map items must all be pairs; found \".concat(JSON.stringify(item), \" instead\"));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(YAMLMap.prototype), \"toString\", this).call(this, ctx, {\n        blockItem: function blockItem(n) {\n          return n.str;\n        },\n        flowChars: {\n          start: '{',\n          end: '}'\n        },\n        isMap: true,\n        itemIndent: ctx.indent || ''\n      }, onComment, onChompKeep);\n    }\n  }]);\n\n  return YAMLMap;\n}(Collection);\n\nvar MERGE_KEY = '<<';\nvar Merge = /*#__PURE__*/function (_Pair) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Merge, _Pair);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Merge);\n\n  function Merge(pair) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Merge);\n\n    if (pair instanceof Pair) {\n      var seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      _this = _super.call(this, pair.key, seq);\n      _this.range = pair.range;\n    } else {\n      _this = _super.call(this, new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    _this.type = Pair.Type.MERGE_PAIR;\n    return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.r)(_this);\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Merge, [{\n    key: \"addToJSMap\",\n    value: function addToJSMap(ctx, map) {\n      var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.value.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var source = _step.value.source;\n          if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n          var srcMap = source.toJSON(null, ctx, Map);\n\n          var _iterator2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(srcMap),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.h)(_step2.value, 2),\n                  key = _step2$value[0],\n                  value = _step2$value[1];\n\n              if (map instanceof Map) {\n                if (!map.has(key)) map.set(key, value);\n              } else if (map instanceof Set) {\n                map.add(key);\n              } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n                Object.defineProperty(map, key, {\n                  value: value,\n                  writable: true,\n                  enumerable: true,\n                  configurable: true\n                });\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment) {\n      var seq = this.value;\n      if (seq.items.length > 1) return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(Merge.prototype), \"toString\", this).call(this, ctx, onComment);\n      this.value = seq.items[0];\n\n      var str = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(Merge.prototype), \"toString\", this).call(this, ctx, onComment);\n\n      this.value = seq;\n      return str;\n    }\n  }]);\n\n  return Merge;\n}(Pair);\n\nvar binaryOptions = {\n  defaultType: _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL,\n  lineWidth: 76\n};\nvar boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nvar intOptions = {\n  asBigInt: false\n};\nvar nullOptions = {\n  nullStr: 'null'\n};\nvar strOptions = {\n  defaultType: _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          format = _step$value.format,\n          test = _step$value.test,\n          resolve = _step$value.resolve;\n\n      if (test) {\n        var match = str.match(test);\n\n        if (match) {\n          var res = resolve.apply(null, match);\n          if (!(res instanceof Scalar)) res = new Scalar(res);\n          if (format) res.format = format;\n          return res;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nvar FOLD_FLOW = 'flow';\nvar FOLD_BLOCK = 'block';\nvar FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nvar consumeMoreIndentedLines = function consumeMoreIndentedLines(text, i) {\n  var ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width or indent content from the start\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, _ref) {\n  var indentAtStart = _ref.indentAtStart,\n      _ref$lineWidth = _ref.lineWidth,\n      lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth,\n      _ref$minContentWidth = _ref.minContentWidth,\n      minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth,\n      onFold = _ref.onFold,\n      onOverflow = _ref.onOverflow;\n  if (!lineWidth || lineWidth < 0) return text;\n  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  var folds = [];\n  var escapedFolds = {};\n  var end = lineWidth - indent.length;\n\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n\n  var split = undefined;\n  var prev = undefined;\n  var overflow = false;\n  var i = -1;\n  var escStart = -1;\n  var escEnd = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (var ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n\n      escEnd = i;\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        var next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // Account for newline escape, but don't break preceding escape\n\n\n          var j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string\n\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  var res = text.slice(0, folds[0]);\n\n  for (var _i = 0; _i < folds.length; ++_i) {\n    var fold = folds[_i];\n\n    var _end = folds[_i + 1] || text.length;\n\n    if (fold === 0) res = \"\\n\".concat(indent).concat(text.slice(0, _end));else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += \"\".concat(text[fold], \"\\\\\");\n      res += \"\\n\".concat(indent).concat(text.slice(fold + 1, _end));\n    }\n  }\n\n  return res;\n}\n\nvar getFoldOptions = function getFoldOptions(_ref) {\n  var indentAtStart = _ref.indentAtStart;\n  return indentAtStart ? Object.assign({\n    indentAtStart: indentAtStart\n  }, strOptions.fold) : strOptions.fold;\n}; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nvar containsDocumentMarker = function containsDocumentMarker(str) {\n  return /^(%|---|\\.\\.\\.)/m.test(str);\n};\n\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n  if (!lineWidth || lineWidth < 0) return false;\n  var limit = lineWidth - indentLength;\n  var strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (var i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  var implicitKey = ctx.implicitKey;\n  var _strOptions$doubleQuo = strOptions.doubleQuoted,\n      jsonEncoding = _strOptions$doubleQuo.jsonEncoding,\n      minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;\n  var json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  var str = '';\n  var start = 0;\n\n  for (var i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          var code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  var res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, \"$&\\n\".concat(indent)) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString(_ref2, ctx, onComment, onChompKeep) {\n  var comment = _ref2.comment,\n      type = _ref2.type,\n      value = _ref2.value;\n\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  var indentSize = indent ? '2' : '1'; // root is at -1\n\n  var literal = type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED ? false : type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);\n  var header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  var wsStart = '';\n  var wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, function (ws) {\n    var n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, function (ws) {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    var m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, \"$&\".concat(indent));\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, \"$&\".concat(indent));\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return \"\".concat(header).concat(indentSize, \"\\n\").concat(indent).concat(wsEnd);\n\n  if (literal) {\n    value = value.replace(/\\n+/g, \"$&\".concat(indent));\n    return \"\".concat(header, \"\\n\").concat(indent).concat(wsStart).concat(value).concat(wsEnd);\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, \"$&\".concat(indent));\n  var body = foldFlowLines(\"\".concat(wsStart).concat(value).concat(wsEnd), indent, FOLD_BLOCK, strOptions.fold);\n  return \"\".concat(header, \"\\n\").concat(indent).concat(body);\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  var comment = item.comment,\n      type = item.type,\n      value = item.value;\n  var actualString = ctx.actualString,\n      implicitKey = ctx.implicitKey,\n      indent = ctx.indent,\n      inFlow = ctx.inFlow;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  var str = value.replace(/\\n+/g, \"$&\\n\".concat(indent)); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    var tags = ctx.doc.schema.tags;\n    var resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  var body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  var defaultType = strOptions.defaultType;\n  var implicitKey = ctx.implicitKey,\n      inFlow = ctx.inFlow;\n  var _item = item,\n      type = _item.type,\n      value = _item.value;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value: value\n    });\n  }\n\n  var _stringify = function _stringify(_type) {\n    switch (_type) {\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED:\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED || type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE;\n  }\n\n  var res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(\"Unsupported default string type \".concat(defaultType));\n  }\n\n  return res;\n}\n\nfunction stringifyNumber(_ref) {\n  var format = _ref.format,\n      minFractionDigits = _ref.minFractionDigits,\n      tag = _ref.tag,\n      value = _ref.value;\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  var n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    var i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    var d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) {\n      n += '0';\n    }\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  var char, name;\n\n  switch (cst.type) {\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  var lastItem;\n\n  for (var i = cst.items.length - 1; i >= 0; --i) {\n    var item = cst.items[i];\n\n    if (!item || item.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    var msg = \"Expected \".concat(name, \" to end with \").concat(char);\n    var err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  var prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    var msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  var sk = String(key);\n  var k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(source, \"The \\\"\".concat(k, \"\\\" key is too long\"));\n}\nfunction resolveComments(collection, comments) {\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(comments),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          afterKey = _step$value.afterKey,\n          before = _step$value.before,\n          comment = _step$value.comment;\n      var item = collection.items[before];\n\n      if (!item) {\n        if (comment !== undefined) {\n          if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n        }\n      } else {\n        if (afterKey && item.value) item = item.value;\n\n        if (comment === undefined) {\n          if (afterKey || !item.commentBefore) item.spaceBefore = true;\n        } else {\n          if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  var res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(function (error) {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  var _node$tag = node.tag,\n      handle = _node$tag.handle,\n      suffix = _node$tag.suffix;\n  var prefix = doc.tagPrefixes.find(function (p) {\n    return p.handle === handle;\n  });\n\n  if (!prefix) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(function (p) {\n      return p.handle === handle;\n    });\n    if (!prefix) throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, \"The \".concat(handle, \" tag handle is non-default and was not declared.\"));\n  }\n\n  if (!suffix) throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, \"The \".concat(handle, \" tag has no suffix.\"));\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      var vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? \"tag:\".concat(vocab[1], \".yaml.org,2002:\").concat(vocab[2]) : \"tag:\".concat(suffix);\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  var tag = node.tag,\n      type = node.type;\n  var nonSpecific = false;\n\n  if (tag) {\n    var handle = tag.handle,\n        suffix = tag.suffix,\n        verbatim = tag.verbatim;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      var msg = \"Verbatim tags aren't resolved, so \".concat(verbatim, \" is invalid.\");\n      doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_SINGLE:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.STR;\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.MAP;\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.SEQ;\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN:\n      return nonSpecific ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  var tags = doc.schema.tags;\n  var matchWithTest = [];\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var tag = _step.value;\n\n      if (tag.tag === tagName) {\n        if (tag.test) matchWithTest.push(tag);else {\n          var res = tag.resolve(doc, node);\n          return res instanceof Collection ? res : new Scalar(res);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName(_ref) {\n  var type = _ref.type;\n\n  switch (type) {\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.MAP;\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.SEQ;\n\n    default:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    var res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    var fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(\"The tag \".concat(tagName, \" is unavailable\"));\n    var msg = \"The tag \".concat(tagName, \" is unavailable, falling back to \").concat(fallback);\n    doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(node, msg));\n\n    var _res = resolveByTagName(doc, node, fallback);\n\n    _res.tag = tagName;\n    return _res;\n  } catch (error) {\n    var refError = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.o(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nvar isCollectionItem = function isCollectionItem(node) {\n  if (!node) return false;\n  var type = node.type;\n  return type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_KEY || type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_VALUE || type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var hasAnchor = false;\n  var hasTag = false;\n  var props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(props),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          start = _step$value.start,\n          end = _step$value.end;\n\n      switch (node.context.src[start]) {\n        case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.COMMENT:\n          {\n            if (!node.commentHasRequiredWhitespace(start)) {\n              var msg = 'Comments must be separated from other tokens by white space characters';\n              errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, msg));\n            }\n\n            var header = node.header,\n                valueRange = node.valueRange;\n            var cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n            cc.push(node.context.src.slice(start + 1, end));\n            break;\n          }\n        // Actual anchor & tag resolution is handled by schema, here we just complain\n\n        case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.ANCHOR:\n          if (hasAnchor) {\n            var _msg = 'A node can have at most one anchor';\n            errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, _msg));\n          }\n\n          hasAnchor = true;\n          break;\n\n        case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.TAG:\n          if (hasTag) {\n            var _msg2 = 'A node can have at most one tag';\n            errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, _msg2));\n          }\n\n          hasTag = true;\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    comments: comments,\n    hasAnchor: hasAnchor,\n    hasTag: hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  var anchors = doc.anchors,\n      errors = doc.errors,\n      schema = doc.schema;\n\n  if (node.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.ALIAS) {\n    var name = node.rawValue;\n    var src = anchors.getNode(name);\n\n    if (!src) {\n      var msg = \"Aliased anchor not found: \".concat(name);\n      errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.o(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    var res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  var tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN) {\n    var _msg3 = \"Failed to resolve \".concat(node.type, \" node here\");\n\n    errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(node, _msg3));\n    return null;\n  }\n\n  try {\n    var str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n\n  var _resolveNodeProps = resolveNodeProps(doc.errors, node),\n      comments = _resolveNodeProps.comments,\n      hasAnchor = _resolveNodeProps.hasAnchor,\n      hasTag = _resolveNodeProps.hasTag;\n\n  if (hasAnchor) {\n    var anchors = doc.anchors;\n    var name = node.anchor;\n    var prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.ALIAS && (hasAnchor || hasTag)) {\n    var msg = 'An alias node must not specify any properties';\n    doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, msg));\n  }\n\n  var res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? \"\".concat(res.commentBefore, \"\\n\").concat(cb) : cb;\n    }\n\n    var ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? \"\".concat(res.comment, \"\\n\").concat(ca) : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP && cst.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP) {\n    var msg = \"A \".concat(cst.type, \" node cannot be resolved as a mapping\");\n    doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(cst, msg));\n    return null;\n  }\n\n  var _ref = cst.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst),\n      comments = _ref.comments,\n      items = _ref.items;\n\n  var map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  var hasCollectionKey = false;\n\n  for (var i = 0; i < items.length; ++i) {\n    var iKey = items[i].key;\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      var sources = items[i].value.items;\n      var error = null;\n      sources.some(function (node) {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          var type = node.source.type;\n          if (type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP || type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, error));\n    } else {\n      for (var j = i + 1; j < items.length; ++j) {\n        var jKey = items[j].key;\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          var _msg = \"Map keys must be unique; \\\"\".concat(iKey, \"\\\" is repeated\");\n\n          doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, _msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nvar valueHasPairComment = function valueHasPairComment(_ref2) {\n  var _ref2$context = _ref2.context,\n      lineStart = _ref2$context.lineStart,\n      node = _ref2$context.node,\n      src = _ref2$context.src,\n      props = _ref2.props;\n  if (props.length === 0) return false;\n  var start = props[0].start;\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.COMMENT) return false;\n\n  for (var i = lineStart; i < start; ++i) {\n    if (src[i] === '\\n') return false;\n  }\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  var comment = item.getPropValue(0, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.COMMENT, true);\n  var found = false;\n  var cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    var cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var key = undefined;\n  var keyStart = null;\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    switch (item.type) {\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP && !item.node.context.atLineStart) {\n            var msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item.node, msg));\n          }\n\n          var valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.P(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            var pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              var origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          var pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (var j = i + 1;; ++j) {\n          var nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE:\n            case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT:\n              continue next;\n\n            case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                var _msg2 = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, _msg2));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          var _msg3 = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, _msg3));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var key = undefined;\n  var explicitKey = false;\n  var next = '{';\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      var char = item.char,\n          offset = item.offset;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      var msg = \"Flow map contains an unexpected \".concat(char);\n      var err = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ && cst.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ) {\n    var msg = \"A \".concat(cst.type, \" node cannot be resolved as a sequence\");\n    doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(cst, msg));\n    return null;\n  }\n\n  var _ref = cst.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst),\n      comments = _ref.comments,\n      items = _ref.items;\n\n  var seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(function (it) {\n    return it instanceof Pair && it.key instanceof Collection;\n  })) {\n    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  var comments = [];\n  var items = [];\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    switch (item.type) {\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          var msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(item, \"Unexpected \".concat(item.type, \" node in sequence\")));\n    }\n  }\n\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var explicitKey = false;\n  var key = undefined;\n  var keyStart = null;\n  var next = '[';\n  var prevItem = null;\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      var char = item.char,\n          offset = item.offset;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            var msg = 'Chaining flow sequence pairs is invalid';\n            var err = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            var keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            var src = prevItem.context.src;\n\n            for (var _i = keyStart; _i < keyEnd; ++_i) {\n              if (src[_i] === '\\n') {\n                var _msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n                doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(prevItem, _msg));\n                break;\n              }\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        var _msg2 = \"Flow sequence contains an unexpected \".concat(char);\n\n        var _err = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(cst, _msg2);\n\n        _err.offset = offset;\n        doc.errors.push(_err);\n      }\n    } else if (item.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        var _msg3 = \"Expected a \".concat(next, \" in flow sequence\");\n\n        doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, _msg3));\n      }\n\n      var value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcmVzb2x2ZVNlcS00OTJhYjQ0MC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ2Q7O0FBRWhkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDBEQUFlO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSwwREFBUzs7QUFFWCxlQUFlLDBEQUFZOztBQUUzQjtBQUNBOztBQUVBLElBQUksMERBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsMERBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsZ0NBQWdDLFFBQVE7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0EseUJBQXlCLDBEQUFPO0FBQ2hDO0FBQ0E7QUFDQSxFQUFFLDBEQUFTOztBQUVYLGVBQWUsMERBQVk7O0FBRTNCO0FBQ0E7O0FBRUEsSUFBSSwwREFBZTs7QUFFbkI7O0FBRUEsSUFBSSwwREFBZSxDQUFDLDBEQUFzQjs7QUFFMUM7QUFDQTtBQUNBOztBQUVBLEVBQUUsMERBQVk7QUFDZDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLG9CQUFvQiwwREFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLHdHQUF3RztBQUN4SztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQkFBa0IsMERB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QUNBOztBQUVBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQSxvQ0FBb0Msc0RBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLHVCQUF1QixzREFBZTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1QkFBdUIsaUVBQWU7QUFDNUM7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNLHVCQUF1Qiw4REFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQSw0QkFBNEIsc0RBQWlCO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9wLXh5ei8uL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9yZXNvbHZlU2VxLTQ5MmFiNDQwLmpzP2UwNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYyBhcyBfY2xhc3NDYWxsQ2hlY2ssIGogYXMgX2luaGVyaXRzLCBrIGFzIF9jcmVhdGVTdXBlciwgYiBhcyBfY3JlYXRlQ2xhc3MsIGUgYXMgX2RlZmluZVByb3BlcnR5LCBwIGFzIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQsIGEgYXMgX3R5cGVvZiwgcSBhcyBfdG9BcnJheSwgVCBhcyBUeXBlLCBfIGFzIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyLCBsIGFzIF9nZXQsIG0gYXMgX2dldFByb3RvdHlwZU9mLCBvIGFzIFlBTUxSZWZlcmVuY2VFcnJvciwgciBhcyBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgaCBhcyBfc2xpY2VkVG9BcnJheSwgZyBhcyBZQU1MU2VtYW50aWNFcnJvciwgbiBhcyBkZWZhdWx0VGFncywgZiBhcyBZQU1MV2FybmluZywgQyBhcyBDaGFyLCBZIGFzIFlBTUxTeW50YXhFcnJvciwgUCBhcyBQbGFpblZhbHVlIH0gZnJvbSAnLi9QbGFpblZhbHVlLWI4MDM2Yjc1LmpzJztcblxuZnVuY3Rpb24gYWRkQ29tbWVudEJlZm9yZShzdHIsIGluZGVudCwgY29tbWVudCkge1xuICBpZiAoIWNvbW1lbnQpIHJldHVybiBzdHI7XG4gIHZhciBjYyA9IGNvbW1lbnQucmVwbGFjZSgvW1xcc1xcU11eL2dtLCBcIiQmXCIuY29uY2F0KGluZGVudCwgXCIjXCIpKTtcbiAgcmV0dXJuIFwiI1wiLmNvbmNhdChjYywgXCJcXG5cIikuY29uY2F0KGluZGVudCkuY29uY2F0KHN0cik7XG59XG5mdW5jdGlvbiBhZGRDb21tZW50KHN0ciwgaW5kZW50LCBjb21tZW50KSB7XG4gIHJldHVybiAhY29tbWVudCA/IHN0ciA6IGNvbW1lbnQuaW5kZXhPZignXFxuJykgPT09IC0xID8gXCJcIi5jb25jYXQoc3RyLCBcIiAjXCIpLmNvbmNhdChjb21tZW50KSA6IFwiXCIuY29uY2F0KHN0ciwgXCJcXG5cIikgKyBjb21tZW50LnJlcGxhY2UoL14vZ20sIFwiXCIuY29uY2F0KGluZGVudCB8fCAnJywgXCIjXCIpKTtcbn1cblxudmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZSk7XG59O1xuXG5mdW5jdGlvbiB0b0pTT04odmFsdWUsIGFyZywgY3R4KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgIHJldHVybiB0b0pTT04odiwgU3RyaW5nKGkpLCBjdHgpO1xuICB9KTtcblxuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBhbmNob3IgPSBjdHggJiYgY3R4LmFuY2hvcnMgJiYgY3R4LmFuY2hvcnMuZ2V0KHZhbHVlKTtcbiAgICBpZiAoYW5jaG9yKSBjdHgub25DcmVhdGUgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICBhbmNob3IucmVzID0gcmVzO1xuICAgICAgZGVsZXRlIGN0eC5vbkNyZWF0ZTtcbiAgICB9O1xuICAgIHZhciByZXMgPSB2YWx1ZS50b0pTT04oYXJnLCBjdHgpO1xuICAgIGlmIChhbmNob3IgJiYgY3R4Lm9uQ3JlYXRlKSBjdHgub25DcmVhdGUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgaWYgKCghY3R4IHx8ICFjdHgua2VlcCkgJiYgdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JykgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIFNjYWxhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKFNjYWxhciwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2NhbGFyKTtcblxuICBmdW5jdGlvbiBTY2FsYXIodmFsdWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NhbGFyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2NhbGFyLCBbe1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OJDEoYXJnLCBjdHgpIHtcbiAgICAgIHJldHVybiBjdHggJiYgY3R4LmtlZXAgPyB0aGlzLnZhbHVlIDogdG9KU09OKHRoaXMudmFsdWUsIGFyZywgY3R4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY2FsYXI7XG59KE5vZGUpO1xuXG5mdW5jdGlvbiBjb2xsZWN0aW9uRnJvbVBhdGgoc2NoZW1hLCBwYXRoLCB2YWx1ZSkge1xuICB2YXIgdiA9IHZhbHVlO1xuXG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIGsgPSBwYXRoW2ldO1xuXG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaykgJiYgayA+PSAwKSB7XG4gICAgICB2YXIgYSA9IFtdO1xuICAgICAgYVtrXSA9IHY7XG4gICAgICB2ID0gYTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrLCB7XG4gICAgICAgIHZhbHVlOiB2LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHYgPSBvO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzY2hlbWEuY3JlYXRlTm9kZSh2LCBmYWxzZSk7XG59IC8vIG51bGwsIHVuZGVmaW5lZCwgb3IgYW4gZW1wdHkgbm9uLXN0cmluZyBpdGVyYWJsZSAoZS5nLiBbXSlcblxuXG52YXIgaXNFbXB0eVBhdGggPSBmdW5jdGlvbiBpc0VtcHR5UGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoID09IG51bGwgfHwgX3R5cGVvZihwYXRoKSA9PT0gJ29iamVjdCcgJiYgcGF0aFtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpLmRvbmU7XG59O1xudmFyIENvbGxlY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhDb2xsZWN0aW9uLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDb2xsZWN0aW9uKTtcblxuICBmdW5jdGlvbiBDb2xsZWN0aW9uKHNjaGVtYSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xsZWN0aW9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaXRlbXNcIiwgW10pO1xuXG4gICAgX3RoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2xsZWN0aW9uLCBbe1xuICAgIGtleTogXCJhZGRJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKSB0aGlzLmFkZCh2YWx1ZSk7ZWxzZSB7XG4gICAgICAgIHZhciBfcGF0aCA9IF90b0FycmF5KHBhdGgpLFxuICAgICAgICAgICAga2V5ID0gX3BhdGhbMF0sXG4gICAgICAgICAgICByZXN0ID0gX3BhdGguc2xpY2UoMSk7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIG5vZGUuYWRkSW4ocmVzdCwgdmFsdWUpO2Vsc2UgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNjaGVtYSkgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgXCIuY29uY2F0KGtleSwgXCIuIFJlbWFpbmluZyBwYXRoOiBcIikuY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlSW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlSW4oX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3RvQXJyYXkoX3JlZiksXG4gICAgICAgICAga2V5ID0gX3JlZjJbMF0sXG4gICAgICAgICAgcmVzdCA9IF9yZWYyLnNsaWNlKDEpO1xuXG4gICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSByZXR1cm4gbm9kZS5kZWxldGVJbihyZXN0KTtlbHNlIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCBcIi5jb25jYXQoa2V5LCBcIi4gUmVtYWluaW5nIHBhdGg6IFwiKS5jb25jYXQocmVzdCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbihfcmVmMywga2VlcFNjYWxhcikge1xuICAgICAgdmFyIF9yZWY0ID0gX3RvQXJyYXkoX3JlZjMpLFxuICAgICAgICAgIGtleSA9IF9yZWY0WzBdLFxuICAgICAgICAgIHJlc3QgPSBfcmVmNC5zbGljZSgxKTtcblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSByZXR1cm4gIWtlZXBTY2FsYXIgJiYgbm9kZSBpbnN0YW5jZW9mIFNjYWxhciA/IG5vZGUudmFsdWUgOiBub2RlO2Vsc2UgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uID8gbm9kZS5nZXRJbihyZXN0LCBrZWVwU2NhbGFyKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQWxsTnVsbFZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNBbGxOdWxsVmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZXZlcnkoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSAhPT0gJ1BBSVInKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBuID0gbm9kZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG4gPT0gbnVsbCB8fCBuIGluc3RhbmNlb2YgU2NhbGFyICYmIG4udmFsdWUgPT0gbnVsbCAmJiAhbi5jb21tZW50QmVmb3JlICYmICFuLmNvbW1lbnQgJiYgIW4udGFnO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0luKF9yZWY1KSB7XG4gICAgICB2YXIgX3JlZjYgPSBfdG9BcnJheShfcmVmNSksXG4gICAgICAgICAga2V5ID0gX3JlZjZbMF0sXG4gICAgICAgICAgcmVzdCA9IF9yZWY2LnNsaWNlKDEpO1xuXG4gICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmhhcyhrZXkpO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uID8gbm9kZS5oYXNJbihyZXN0KSA6IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbihfcmVmNywgdmFsdWUpIHtcbiAgICAgIHZhciBfcmVmOCA9IF90b0FycmF5KF9yZWY3KSxcbiAgICAgICAgICBrZXkgPSBfcmVmOFswXSxcbiAgICAgICAgICByZXN0ID0gX3JlZjguc2xpY2UoMSk7XG5cbiAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSBub2RlLnNldEluKHJlc3QsIHZhbHVlKTtlbHNlIGlmIChub2RlID09PSB1bmRlZmluZWQgJiYgdGhpcy5zY2hlbWEpIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0IFwiLmNvbmNhdChrZXksIFwiLiBSZW1haW5pbmcgcGF0aDogXCIpLmNvbmNhdChyZXN0KSk7XG4gICAgICB9XG4gICAgfSAvLyBvdmVycmlkZGVuIGluIGltcGxlbWVudGF0aW9uc1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoY3R4LCBfcmVmOSwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBibG9ja0l0ZW0gPSBfcmVmOS5ibG9ja0l0ZW0sXG4gICAgICAgICAgZmxvd0NoYXJzID0gX3JlZjkuZmxvd0NoYXJzLFxuICAgICAgICAgIGlzTWFwID0gX3JlZjkuaXNNYXAsXG4gICAgICAgICAgaXRlbUluZGVudCA9IF9yZWY5Lml0ZW1JbmRlbnQ7XG4gICAgICB2YXIgX2N0eCA9IGN0eCxcbiAgICAgICAgICBpbmRlbnQgPSBfY3R4LmluZGVudCxcbiAgICAgICAgICBpbmRlbnRTdGVwID0gX2N0eC5pbmRlbnRTdGVwLFxuICAgICAgICAgIHN0cmluZ2lmeSA9IF9jdHguc3RyaW5naWZ5O1xuICAgICAgdmFyIGluRmxvdyA9IHRoaXMudHlwZSA9PT0gVHlwZS5GTE9XX01BUCB8fCB0aGlzLnR5cGUgPT09IFR5cGUuRkxPV19TRVEgfHwgY3R4LmluRmxvdztcbiAgICAgIGlmIChpbkZsb3cpIGl0ZW1JbmRlbnQgKz0gaW5kZW50U3RlcDtcbiAgICAgIHZhciBhbGxOdWxsVmFsdWVzID0gaXNNYXAgJiYgdGhpcy5oYXNBbGxOdWxsVmFsdWVzKCk7XG4gICAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgYWxsTnVsbFZhbHVlczogYWxsTnVsbFZhbHVlcyxcbiAgICAgICAgaW5kZW50OiBpdGVtSW5kZW50LFxuICAgICAgICBpbkZsb3c6IGluRmxvdyxcbiAgICAgICAgdHlwZTogbnVsbFxuICAgICAgfSk7XG4gICAgICB2YXIgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICB2YXIgaGFzSXRlbVdpdGhOZXdMaW5lID0gZmFsc2U7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLml0ZW1zLnJlZHVjZShmdW5jdGlvbiAobm9kZXMsIGl0ZW0sIGkpIHtcbiAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICBpZiAoIWNob21wS2VlcCAmJiBpdGVtLnNwYWNlQmVmb3JlKSBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tZW50JyxcbiAgICAgICAgICAgIHN0cjogJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKSBpdGVtLmNvbW1lbnRCZWZvcmUubWF0Y2goL14uKiQvZ20pLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAnY29tbWVudCcsXG4gICAgICAgICAgICAgIHN0cjogXCIjXCIuY29uY2F0KGxpbmUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KSBjb21tZW50ID0gaXRlbS5jb21tZW50O1xuICAgICAgICAgIGlmIChpbkZsb3cgJiYgKCFjaG9tcEtlZXAgJiYgaXRlbS5zcGFjZUJlZm9yZSB8fCBpdGVtLmNvbW1lbnRCZWZvcmUgfHwgaXRlbS5jb21tZW50IHx8IGl0ZW0ua2V5ICYmIChpdGVtLmtleS5jb21tZW50QmVmb3JlIHx8IGl0ZW0ua2V5LmNvbW1lbnQpIHx8IGl0ZW0udmFsdWUgJiYgKGl0ZW0udmFsdWUuY29tbWVudEJlZm9yZSB8fCBpdGVtLnZhbHVlLmNvbW1lbnQpKSkgaGFzSXRlbVdpdGhOZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgICB2YXIgc3RyID0gc3RyaW5naWZ5KGl0ZW0sIGN0eCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb21tZW50ID0gbnVsbDtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjaG9tcEtlZXAgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluRmxvdyAmJiAhaGFzSXRlbVdpdGhOZXdMaW5lICYmIHN0ci5pbmNsdWRlcygnXFxuJykpIGhhc0l0ZW1XaXRoTmV3TGluZSA9IHRydWU7XG4gICAgICAgIGlmIChpbkZsb3cgJiYgaSA8IF90aGlzMi5pdGVtcy5sZW5ndGggLSAxKSBzdHIgKz0gJywnO1xuICAgICAgICBzdHIgPSBhZGRDb21tZW50KHN0ciwgaXRlbUluZGVudCwgY29tbWVudCk7XG4gICAgICAgIGlmIChjaG9tcEtlZXAgJiYgKGNvbW1lbnQgfHwgaW5GbG93KSkgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdpdGVtJyxcbiAgICAgICAgICBzdHI6IHN0clxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfSwgW10pO1xuICAgICAgdmFyIHN0cjtcblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdHIgPSBmbG93Q2hhcnMuc3RhcnQgKyBmbG93Q2hhcnMuZW5kO1xuICAgICAgfSBlbHNlIGlmIChpbkZsb3cpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZmxvd0NoYXJzLnN0YXJ0LFxuICAgICAgICAgICAgZW5kID0gZmxvd0NoYXJzLmVuZDtcbiAgICAgICAgdmFyIHN0cmluZ3MgPSBub2Rlcy5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5zdHI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChoYXNJdGVtV2l0aE5ld0xpbmUgfHwgc3RyaW5ncy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgc3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHN1bSArIHN0ci5sZW5ndGggKyAyO1xuICAgICAgICB9LCAyKSA+IENvbGxlY3Rpb24ubWF4Rmxvd1N0cmluZ1NpbmdsZUxpbmVMZW5ndGgpIHtcbiAgICAgICAgICBzdHIgPSBzdGFydDtcblxuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdHJpbmdzKSxcbiAgICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIHMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgc3RyICs9IHMgPyBcIlxcblwiLmNvbmNhdChpbmRlbnRTdGVwKS5jb25jYXQoaW5kZW50KS5jb25jYXQocykgOiAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyICs9IFwiXFxuXCIuY29uY2F0KGluZGVudCkuY29uY2F0KGVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gXCJcIi5jb25jYXQoc3RhcnQsIFwiIFwiKS5jb25jYXQoc3RyaW5ncy5qb2luKCcgJyksIFwiIFwiKS5jb25jYXQoZW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9zdHJpbmdzID0gbm9kZXMubWFwKGJsb2NrSXRlbSk7XG5cbiAgICAgICAgc3RyID0gX3N0cmluZ3Muc2hpZnQoKTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF9zdHJpbmdzKSxcbiAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX3MgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICBzdHIgKz0gX3MgPyBcIlxcblwiLmNvbmNhdChpbmRlbnQpLmNvbmNhdChfcykgOiAnXFxuJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbW1lbnQpIHtcbiAgICAgICAgc3RyICs9ICdcXG4nICsgdGhpcy5jb21tZW50LnJlcGxhY2UoL14vZ20sIFwiXCIuY29uY2F0KGluZGVudCwgXCIjXCIpKTtcbiAgICAgICAgaWYgKG9uQ29tbWVudCkgb25Db21tZW50KCk7XG4gICAgICB9IGVsc2UgaWYgKGNob21wS2VlcCAmJiBvbkNob21wS2VlcCkgb25DaG9tcEtlZXAoKTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29sbGVjdGlvbjtcbn0oTm9kZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShDb2xsZWN0aW9uLCBcIm1heEZsb3dTdHJpbmdTaW5nbGVMaW5lTGVuZ3RoXCIsIDYwKTtcblxuZnVuY3Rpb24gYXNJdGVtSW5kZXgoa2V5KSB7XG4gIHZhciBpZHggPSBrZXkgaW5zdGFuY2VvZiBTY2FsYXIgPyBrZXkudmFsdWUgOiBrZXk7XG4gIGlmIChpZHggJiYgdHlwZW9mIGlkeCA9PT0gJ3N0cmluZycpIGlkeCA9IE51bWJlcihpZHgpO1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihpZHgpICYmIGlkeCA+PSAwID8gaWR4IDogbnVsbDtcbn1cblxudmFyIFlBTUxTZXEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db2xsZWN0aW9uKSB7XG4gIF9pbmhlcml0cyhZQU1MU2VxLCBfQ29sbGVjdGlvbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihZQU1MU2VxKTtcblxuICBmdW5jdGlvbiBZQU1MU2VxKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBZQU1MU2VxKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhZQU1MU2VxLCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICB0aGlzLml0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgIHZhciBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIGl0ID0gdGhpcy5pdGVtc1tpZHhdO1xuICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGl0IGluc3RhbmNlb2YgU2NhbGFyID8gaXQudmFsdWUgOiBpdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgIHZhciBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIGlkeCA8IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIHZhbGlkIGluZGV4LCBub3QgXCIuY29uY2F0KGtleSwgXCIuXCIpKTtcbiAgICAgIHRoaXMuaXRlbXNbaWR4XSA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OJDEoXywgY3R4KSB7XG4gICAgICB2YXIgc2VxID0gW107XG4gICAgICBpZiAoY3R4ICYmIGN0eC5vbkNyZWF0ZSkgY3R4Lm9uQ3JlYXRlKHNlcSk7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLml0ZW1zKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHNlcS5wdXNoKHRvSlNPTihpdGVtLCBTdHJpbmcoaSsrKSwgY3R4KSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICBpZiAoIWN0eCkgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFlBTUxTZXEucHJvdG90eXBlKSwgXCJ0b1N0cmluZ1wiLCB0aGlzKS5jYWxsKHRoaXMsIGN0eCwge1xuICAgICAgICBibG9ja0l0ZW06IGZ1bmN0aW9uIGJsb2NrSXRlbShuKSB7XG4gICAgICAgICAgcmV0dXJuIG4udHlwZSA9PT0gJ2NvbW1lbnQnID8gbi5zdHIgOiBcIi0gXCIuY29uY2F0KG4uc3RyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvd0NoYXJzOiB7XG4gICAgICAgICAgc3RhcnQ6ICdbJyxcbiAgICAgICAgICBlbmQ6ICddJ1xuICAgICAgICB9LFxuICAgICAgICBpc01hcDogZmFsc2UsXG4gICAgICAgIGl0ZW1JbmRlbnQ6IChjdHguaW5kZW50IHx8ICcnKSArICcgICdcbiAgICAgIH0sIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBZQU1MU2VxO1xufShDb2xsZWN0aW9uKTtcblxudmFyIHN0cmluZ2lmeUtleSA9IGZ1bmN0aW9uIHN0cmluZ2lmeUtleShrZXksIGpzS2V5LCBjdHgpIHtcbiAgaWYgKGpzS2V5ID09PSBudWxsKSByZXR1cm4gJyc7XG4gIGlmIChfdHlwZW9mKGpzS2V5KSAhPT0gJ29iamVjdCcpIHJldHVybiBTdHJpbmcoanNLZXkpO1xuICBpZiAoa2V5IGluc3RhbmNlb2YgTm9kZSAmJiBjdHggJiYgY3R4LmRvYykgcmV0dXJuIGtleS50b1N0cmluZyh7XG4gICAgYW5jaG9yczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBkb2M6IGN0eC5kb2MsXG4gICAgaW5kZW50OiAnJyxcbiAgICBpbmRlbnRTdGVwOiBjdHguaW5kZW50U3RlcCxcbiAgICBpbkZsb3c6IHRydWUsXG4gICAgaW5TdHJpbmdpZnlLZXk6IHRydWUsXG4gICAgc3RyaW5naWZ5OiBjdHguc3RyaW5naWZ5XG4gIH0pO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNLZXkpO1xufTtcblxudmFyIFBhaXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhQYWlyLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQYWlyKTtcblxuICBmdW5jdGlvbiBQYWlyKGtleSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYWlyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMua2V5ID0ga2V5O1xuICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgX3RoaXMudHlwZSA9IFBhaXIuVHlwZS5QQUlSO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYWlyLCBbe1xuICAgIGtleTogXCJjb21tZW50QmVmb3JlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXkgaW5zdGFuY2VvZiBOb2RlID8gdGhpcy5rZXkuY29tbWVudEJlZm9yZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGNiKSB7XG4gICAgICBpZiAodGhpcy5rZXkgPT0gbnVsbCkgdGhpcy5rZXkgPSBuZXcgU2NhbGFyKG51bGwpO1xuICAgICAgaWYgKHRoaXMua2V5IGluc3RhbmNlb2YgTm9kZSkgdGhpcy5rZXkuY29tbWVudEJlZm9yZSA9IGNiO2Vsc2Uge1xuICAgICAgICB2YXIgbXNnID0gJ1BhaXIuY29tbWVudEJlZm9yZSBpcyBhbiBhbGlhcyBmb3IgUGFpci5rZXkuY29tbWVudEJlZm9yZS4gVG8gc2V0IGl0LCB0aGUga2V5IG11c3QgYmUgYSBOb2RlLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb0pTTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRvSlNNYXAoY3R4LCBtYXApIHtcbiAgICAgIHZhciBrZXkgPSB0b0pTT04odGhpcy5rZXksICcnLCBjdHgpO1xuXG4gICAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRvSlNPTih0aGlzLnZhbHVlLCBrZXksIGN0eCk7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG1hcCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBtYXAuYWRkKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RyaW5nS2V5ID0gc3RyaW5naWZ5S2V5KHRoaXMua2V5LCBrZXksIGN0eCk7XG5cbiAgICAgICAgdmFyIF92YWx1ZSA9IHRvSlNPTih0aGlzLnZhbHVlLCBzdHJpbmdLZXksIGN0eCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ0tleSBpbiBtYXApIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIHN0cmluZ0tleSwge1xuICAgICAgICAgIHZhbHVlOiBfdmFsdWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7ZWxzZSBtYXBbc3RyaW5nS2V5XSA9IF92YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgIHZhciBwYWlyID0gY3R4ICYmIGN0eC5tYXBBc01hcCA/IG5ldyBNYXAoKSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuYWRkVG9KU01hcChjdHgsIHBhaXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgIGlmICghY3R4IHx8ICFjdHguZG9jKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICB2YXIgX2N0eCRkb2Mkb3B0aW9ucyA9IGN0eC5kb2Mub3B0aW9ucyxcbiAgICAgICAgICBpbmRlbnRTaXplID0gX2N0eCRkb2Mkb3B0aW9ucy5pbmRlbnQsXG4gICAgICAgICAgaW5kZW50U2VxID0gX2N0eCRkb2Mkb3B0aW9ucy5pbmRlbnRTZXEsXG4gICAgICAgICAgc2ltcGxlS2V5cyA9IF9jdHgkZG9jJG9wdGlvbnMuc2ltcGxlS2V5cztcbiAgICAgIHZhciBrZXkgPSB0aGlzLmtleSxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB2YXIga2V5Q29tbWVudCA9IGtleSBpbnN0YW5jZW9mIE5vZGUgJiYga2V5LmNvbW1lbnQ7XG5cbiAgICAgIGlmIChzaW1wbGVLZXlzKSB7XG4gICAgICAgIGlmIChrZXlDb21tZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoIHNpbXBsZSBrZXlzLCBrZXkgbm9kZXMgY2Fubm90IGhhdmUgY29tbWVudHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIG1zZyA9ICdXaXRoIHNpbXBsZSBrZXlzLCBjb2xsZWN0aW9uIGNhbm5vdCBiZSB1c2VkIGFzIGEga2V5IHZhbHVlJztcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZXhwbGljaXRLZXkgPSAhc2ltcGxlS2V5cyAmJiAoIWtleSB8fCBrZXlDb21tZW50IHx8IChrZXkgaW5zdGFuY2VvZiBOb2RlID8ga2V5IGluc3RhbmNlb2YgQ29sbGVjdGlvbiB8fCBrZXkudHlwZSA9PT0gVHlwZS5CTE9DS19GT0xERUQgfHwga2V5LnR5cGUgPT09IFR5cGUuQkxPQ0tfTElURVJBTCA6IF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcpKTtcbiAgICAgIHZhciBfY3R4ID0gY3R4LFxuICAgICAgICAgIGRvYyA9IF9jdHguZG9jLFxuICAgICAgICAgIGluZGVudCA9IF9jdHguaW5kZW50LFxuICAgICAgICAgIGluZGVudFN0ZXAgPSBfY3R4LmluZGVudFN0ZXAsXG4gICAgICAgICAgc3RyaW5naWZ5ID0gX2N0eC5zdHJpbmdpZnk7XG4gICAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgaW1wbGljaXRLZXk6ICFleHBsaWNpdEtleSxcbiAgICAgICAgaW5kZW50OiBpbmRlbnQgKyBpbmRlbnRTdGVwXG4gICAgICB9KTtcbiAgICAgIHZhciBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICAgIHZhciBzdHIgPSBzdHJpbmdpZnkoa2V5LCBjdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGtleUNvbW1lbnQgPSBudWxsO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2hvbXBLZWVwID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgc3RyID0gYWRkQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGtleUNvbW1lbnQpO1xuXG4gICAgICBpZiAoIWV4cGxpY2l0S2V5ICYmIHN0ci5sZW5ndGggPiAxMDI0KSB7XG4gICAgICAgIGlmIChzaW1wbGVLZXlzKSB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIHNpbmdsZSBsaW5lIHNjYWxhciBtdXN0IG5vdCBzcGFuIG1vcmUgdGhhbiAxMDI0IGNoYXJhY3RlcnMnKTtcbiAgICAgICAgZXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3R4LmFsbE51bGxWYWx1ZXMgJiYgIXNpbXBsZUtleXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tbWVudCkge1xuICAgICAgICAgIHN0ciA9IGFkZENvbW1lbnQoc3RyLCBjdHguaW5kZW50LCB0aGlzLmNvbW1lbnQpO1xuICAgICAgICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGNob21wS2VlcCAmJiAha2V5Q29tbWVudCAmJiBvbkNob21wS2VlcCkgb25DaG9tcEtlZXAoKTtcblxuICAgICAgICByZXR1cm4gY3R4LmluRmxvdyAmJiAhZXhwbGljaXRLZXkgPyBzdHIgOiBcIj8gXCIuY29uY2F0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIHN0ciA9IGV4cGxpY2l0S2V5ID8gXCI/IFwiLmNvbmNhdChzdHIsIFwiXFxuXCIpLmNvbmNhdChpbmRlbnQsIFwiOlwiKSA6IFwiXCIuY29uY2F0KHN0ciwgXCI6XCIpO1xuXG4gICAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAgIC8vIGV4cGVjdGVkIChidXQgbm90IHN0cmljdGx5IHJlcXVpcmVkKSB0byBiZSBhIHNpbmdsZS1saW5lIGNvbW1lbnRcbiAgICAgICAgc3RyID0gYWRkQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIHRoaXMuY29tbWVudCk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmNiID0gJyc7XG4gICAgICB2YXIgdmFsdWVDb21tZW50ID0gbnVsbDtcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICBpZiAodmFsdWUuc3BhY2VCZWZvcmUpIHZjYiA9ICdcXG4nO1xuXG4gICAgICAgIGlmICh2YWx1ZS5jb21tZW50QmVmb3JlKSB7XG4gICAgICAgICAgdmFyIGNzID0gdmFsdWUuY29tbWVudEJlZm9yZS5yZXBsYWNlKC9eL2dtLCBcIlwiLmNvbmNhdChjdHguaW5kZW50LCBcIiNcIikpO1xuICAgICAgICAgIHZjYiArPSBcIlxcblwiLmNvbmNhdChjcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZUNvbW1lbnQgPSB2YWx1ZS5jb21tZW50O1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiBfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsdWUgPSBkb2Muc2NoZW1hLmNyZWF0ZU5vZGUodmFsdWUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjdHguaW1wbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgIGlmICghZXhwbGljaXRLZXkgJiYgIXRoaXMuY29tbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNjYWxhcikgY3R4LmluZGVudEF0U3RhcnQgPSBzdHIubGVuZ3RoICsgMTtcbiAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuXG4gICAgICBpZiAoIWluZGVudFNlcSAmJiBpbmRlbnRTaXplID49IDIgJiYgIWN0eC5pbkZsb3cgJiYgIWV4cGxpY2l0S2V5ICYmIHZhbHVlIGluc3RhbmNlb2YgWUFNTFNlcSAmJiB2YWx1ZS50eXBlICE9PSBUeXBlLkZMT1dfU0VRICYmICF2YWx1ZS50YWcgJiYgIWRvYy5hbmNob3JzLmdldE5hbWUodmFsdWUpKSB7XG4gICAgICAgIC8vIElmIGluZGVudFNlcSA9PT0gZmFsc2UsIGNvbnNpZGVyICctICcgYXMgcGFydCBvZiBpbmRlbnRhdGlvbiB3aGVyZSBwb3NzaWJsZVxuICAgICAgICBjdHguaW5kZW50ID0gY3R4LmluZGVudC5zdWJzdHIoMik7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZVN0ciA9IHN0cmluZ2lmeSh2YWx1ZSwgY3R4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUNvbW1lbnQgPSBudWxsO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2hvbXBLZWVwID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHdzID0gJyAnO1xuXG4gICAgICBpZiAodmNiIHx8IHRoaXMuY29tbWVudCkge1xuICAgICAgICB3cyA9IFwiXCIuY29uY2F0KHZjYiwgXCJcXG5cIikuY29uY2F0KGN0eC5pbmRlbnQpO1xuICAgICAgfSBlbHNlIGlmICghZXhwbGljaXRLZXkgJiYgdmFsdWUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBmbG93ID0gdmFsdWVTdHJbMF0gPT09ICdbJyB8fCB2YWx1ZVN0clswXSA9PT0gJ3snO1xuICAgICAgICBpZiAoIWZsb3cgfHwgdmFsdWVTdHIuaW5jbHVkZXMoJ1xcbicpKSB3cyA9IFwiXFxuXCIuY29uY2F0KGN0eC5pbmRlbnQpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZVN0clswXSA9PT0gJ1xcbicpIHdzID0gJyc7XG5cbiAgICAgIGlmIChjaG9tcEtlZXAgJiYgIXZhbHVlQ29tbWVudCAmJiBvbkNob21wS2VlcCkgb25DaG9tcEtlZXAoKTtcbiAgICAgIHJldHVybiBhZGRDb21tZW50KHN0ciArIHdzICsgdmFsdWVTdHIsIGN0eC5pbmRlbnQsIHZhbHVlQ29tbWVudCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhaXI7XG59KE5vZGUpO1xuXG5fZGVmaW5lUHJvcGVydHkoUGFpciwgXCJUeXBlXCIsIHtcbiAgUEFJUjogJ1BBSVInLFxuICBNRVJHRV9QQUlSOiAnTUVSR0VfUEFJUidcbn0pO1xuXG52YXIgZ2V0QWxpYXNDb3VudCA9IGZ1bmN0aW9uIGdldEFsaWFzQ291bnQobm9kZSwgYW5jaG9ycykge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIEFsaWFzKSB7XG4gICAgdmFyIGFuY2hvciA9IGFuY2hvcnMuZ2V0KG5vZGUuc291cmNlKTtcbiAgICByZXR1cm4gYW5jaG9yLmNvdW50ICogYW5jaG9yLmFsaWFzQ291bnQ7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG5vZGUuaXRlbXMpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgYyA9IGdldEFsaWFzQ291bnQoaXRlbSwgYW5jaG9ycyk7XG4gICAgICAgIGlmIChjID4gY291bnQpIGNvdW50ID0gYztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBQYWlyKSB7XG4gICAgdmFyIGtjID0gZ2V0QWxpYXNDb3VudChub2RlLmtleSwgYW5jaG9ycyk7XG4gICAgdmFyIHZjID0gZ2V0QWxpYXNDb3VudChub2RlLnZhbHVlLCBhbmNob3JzKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoa2MsIHZjKTtcbiAgfVxuXG4gIHJldHVybiAxO1xufTtcblxudmFyIEFsaWFzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoQWxpYXMsIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEFsaWFzKTtcblxuICBmdW5jdGlvbiBBbGlhcyhzb3VyY2UpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWxpYXMpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgX3RoaXMudHlwZSA9IFR5cGUuQUxJQVM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFsaWFzLCBbe1xuICAgIGtleTogXCJ0YWdcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsaWFzIG5vZGVzIGNhbm5vdCBoYXZlIHRhZ3MnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTiQxKGFyZywgY3R4KSB7XG4gICAgICBpZiAoIWN0eCkgcmV0dXJuIHRvSlNPTih0aGlzLnNvdXJjZSwgYXJnLCBjdHgpO1xuICAgICAgdmFyIGFuY2hvcnMgPSBjdHguYW5jaG9ycyxcbiAgICAgICAgICBtYXhBbGlhc0NvdW50ID0gY3R4Lm1heEFsaWFzQ291bnQ7XG4gICAgICB2YXIgYW5jaG9yID0gYW5jaG9ycy5nZXQodGhpcy5zb3VyY2UpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgICAgIGlmICghYW5jaG9yIHx8IGFuY2hvci5yZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbXNnID0gJ1RoaXMgc2hvdWxkIG5vdCBoYXBwZW46IEFsaWFzIGFuY2hvciB3YXMgbm90IHJlc29sdmVkPyc7XG4gICAgICAgIGlmICh0aGlzLmNzdE5vZGUpIHRocm93IG5ldyBZQU1MUmVmZXJlbmNlRXJyb3IodGhpcy5jc3ROb2RlLCBtc2cpO2Vsc2UgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhBbGlhc0NvdW50ID49IDApIHtcbiAgICAgICAgYW5jaG9yLmNvdW50ICs9IDE7XG4gICAgICAgIGlmIChhbmNob3IuYWxpYXNDb3VudCA9PT0gMCkgYW5jaG9yLmFsaWFzQ291bnQgPSBnZXRBbGlhc0NvdW50KHRoaXMuc291cmNlLCBhbmNob3JzKTtcblxuICAgICAgICBpZiAoYW5jaG9yLmNvdW50ICogYW5jaG9yLmFsaWFzQ291bnQgPiBtYXhBbGlhc0NvdW50KSB7XG4gICAgICAgICAgdmFyIF9tc2cgPSAnRXhjZXNzaXZlIGFsaWFzIGNvdW50IGluZGljYXRlcyBhIHJlc291cmNlIGV4aGF1c3Rpb24gYXR0YWNrJztcbiAgICAgICAgICBpZiAodGhpcy5jc3ROb2RlKSB0aHJvdyBuZXcgWUFNTFJlZmVyZW5jZUVycm9yKHRoaXMuY3N0Tm9kZSwgX21zZyk7ZWxzZSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoX21zZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuY2hvci5yZXM7XG4gICAgfSAvLyBPbmx5IGNhbGxlZCB3aGVuIHN0cmluZ2lmeWluZyBhbiBhbGlhcyBtYXBwaW5nIGtleSB3aGlsZSBjb25zdHJ1Y3RpbmdcbiAgICAvLyBPYmplY3Qgb3V0cHV0LlxuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoY3R4KSB7XG4gICAgICByZXR1cm4gQWxpYXMuc3RyaW5naWZ5KHRoaXMsIGN0eCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwic3RyaW5naWZ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmluZ2lmeShfcmVmLCBfcmVmMikge1xuICAgICAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgICAgICBzb3VyY2UgPSBfcmVmLnNvdXJjZTtcbiAgICAgIHZhciBhbmNob3JzID0gX3JlZjIuYW5jaG9ycyxcbiAgICAgICAgICBkb2MgPSBfcmVmMi5kb2MsXG4gICAgICAgICAgaW1wbGljaXRLZXkgPSBfcmVmMi5pbXBsaWNpdEtleSxcbiAgICAgICAgICBpblN0cmluZ2lmeUtleSA9IF9yZWYyLmluU3RyaW5naWZ5S2V5O1xuICAgICAgdmFyIGFuY2hvciA9IE9iamVjdC5rZXlzKGFuY2hvcnMpLmZpbmQoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGFuY2hvcnNbYV0gPT09IHNvdXJjZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhbmNob3IgJiYgaW5TdHJpbmdpZnlLZXkpIGFuY2hvciA9IGRvYy5hbmNob3JzLmdldE5hbWUoc291cmNlKSB8fCBkb2MuYW5jaG9ycy5uZXdOYW1lKCk7XG4gICAgICBpZiAoYW5jaG9yKSByZXR1cm4gXCIqXCIuY29uY2F0KGFuY2hvcikuY29uY2F0KGltcGxpY2l0S2V5ID8gJyAnIDogJycpO1xuICAgICAgdmFyIG1zZyA9IGRvYy5hbmNob3JzLmdldE5hbWUoc291cmNlKSA/ICdBbGlhcyBub2RlIG11c3QgYmUgYWZ0ZXIgc291cmNlIG5vZGUnIDogJ1NvdXJjZSBub2RlIG5vdCBmb3VuZCBmb3IgYWxpYXMgbm9kZSc7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQobXNnLCBcIiBbXCIpLmNvbmNhdChyYW5nZSwgXCJdXCIpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWxpYXM7XG59KE5vZGUpO1xuXG5fZGVmaW5lUHJvcGVydHkoQWxpYXMsIFwiZGVmYXVsdFwiLCB0cnVlKTtcblxuZnVuY3Rpb24gZmluZFBhaXIoaXRlbXMsIGtleSkge1xuICB2YXIgayA9IGtleSBpbnN0YW5jZW9mIFNjYWxhciA/IGtleS52YWx1ZSA6IGtleTtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaXRlbXMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGl0ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmIChpdCBpbnN0YW5jZW9mIFBhaXIpIHtcbiAgICAgICAgaWYgKGl0LmtleSA9PT0ga2V5IHx8IGl0LmtleSA9PT0gaykgcmV0dXJuIGl0O1xuICAgICAgICBpZiAoaXQua2V5ICYmIGl0LmtleS52YWx1ZSA9PT0gaykgcmV0dXJuIGl0O1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbnZhciBZQU1MTWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29sbGVjdGlvbikge1xuICBfaW5oZXJpdHMoWUFNTE1hcCwgX0NvbGxlY3Rpb24pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoWUFNTE1hcCk7XG5cbiAgZnVuY3Rpb24gWUFNTE1hcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWUFNTE1hcCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWUFNTE1hcCwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChwYWlyLCBvdmVyd3JpdGUpIHtcbiAgICAgIGlmICghcGFpcikgcGFpciA9IG5ldyBQYWlyKHBhaXIpO2Vsc2UgaWYgKCEocGFpciBpbnN0YW5jZW9mIFBhaXIpKSBwYWlyID0gbmV3IFBhaXIocGFpci5rZXkgfHwgcGFpciwgcGFpci52YWx1ZSk7XG4gICAgICB2YXIgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIHBhaXIua2V5KTtcbiAgICAgIHZhciBzb3J0RW50cmllcyA9IHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLnNvcnRNYXBFbnRyaWVzO1xuXG4gICAgICBpZiAocHJldikge1xuICAgICAgICBpZiAob3ZlcndyaXRlKSBwcmV2LnZhbHVlID0gcGFpci52YWx1ZTtlbHNlIHRocm93IG5ldyBFcnJvcihcIktleSBcIi5jb25jYXQocGFpci5rZXksIFwiIGFscmVhZHkgc2V0XCIpKTtcbiAgICAgIH0gZWxzZSBpZiAoc29ydEVudHJpZXMpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zLmZpbmRJbmRleChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBzb3J0RW50cmllcyhwYWlyLCBpdGVtKSA8IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHRoaXMuaXRlbXMucHVzaChwYWlyKTtlbHNlIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIHBhaXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICBpZiAoIWl0KSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKGl0KSwgMSk7XG4gICAgICByZXR1cm4gZGVsLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5LCBrZWVwU2NhbGFyKSB7XG4gICAgICB2YXIgaXQgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgdmFyIG5vZGUgPSBpdCAmJiBpdC52YWx1ZTtcbiAgICAgIHJldHVybiAha2VlcFNjYWxhciAmJiBub2RlIGluc3RhbmNlb2YgU2NhbGFyID8gbm9kZS52YWx1ZSA6IG5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gISFmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuYWRkKG5ldyBQYWlyKGtleSwgdmFsdWUpLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBhcmcgaWdub3JlZFxuICAgICAqIEBwYXJhbSB7Kn0gY3R4IENvbnZlcnNpb24gY29udGV4dCwgb3JpZ2luYWxseSBzZXQgaW4gRG9jdW1lbnQjdG9KU09OKClcbiAgICAgKiBAcGFyYW0ge0NsYXNzfSBUeXBlIElmIHNldCwgZm9yY2VzIHRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn0gSW5zdGFuY2Ugb2YgVHlwZSwgTWFwLCBvciBPYmplY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oXywgY3R4LCBUeXBlKSB7XG4gICAgICB2YXIgbWFwID0gVHlwZSA/IG5ldyBUeXBlKCkgOiBjdHggJiYgY3R4Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICBpZiAoY3R4ICYmIGN0eC5vbkNyZWF0ZSkgY3R4Lm9uQ3JlYXRlKG1hcCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5pdGVtcyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIGl0ZW0uYWRkVG9KU01hcChjdHgsIG1hcCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgIGlmICghY3R4KSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5pdGVtcyksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBQYWlyKSkgdGhyb3cgbmV3IEVycm9yKFwiTWFwIGl0ZW1zIG11c3QgYWxsIGJlIHBhaXJzOyBmb3VuZCBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoaXRlbSksIFwiIGluc3RlYWRcIikpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFlBTUxNYXAucHJvdG90eXBlKSwgXCJ0b1N0cmluZ1wiLCB0aGlzKS5jYWxsKHRoaXMsIGN0eCwge1xuICAgICAgICBibG9ja0l0ZW06IGZ1bmN0aW9uIGJsb2NrSXRlbShuKSB7XG4gICAgICAgICAgcmV0dXJuIG4uc3RyO1xuICAgICAgICB9LFxuICAgICAgICBmbG93Q2hhcnM6IHtcbiAgICAgICAgICBzdGFydDogJ3snLFxuICAgICAgICAgIGVuZDogJ30nXG4gICAgICAgIH0sXG4gICAgICAgIGlzTWFwOiB0cnVlLFxuICAgICAgICBpdGVtSW5kZW50OiBjdHguaW5kZW50IHx8ICcnXG4gICAgICB9LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gWUFNTE1hcDtcbn0oQ29sbGVjdGlvbik7XG5cbnZhciBNRVJHRV9LRVkgPSAnPDwnO1xudmFyIE1lcmdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFpcikge1xuICBfaW5oZXJpdHMoTWVyZ2UsIF9QYWlyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE1lcmdlKTtcblxuICBmdW5jdGlvbiBNZXJnZShwYWlyKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lcmdlKTtcblxuICAgIGlmIChwYWlyIGluc3RhbmNlb2YgUGFpcikge1xuICAgICAgdmFyIHNlcSA9IHBhaXIudmFsdWU7XG5cbiAgICAgIGlmICghKHNlcSBpbnN0YW5jZW9mIFlBTUxTZXEpKSB7XG4gICAgICAgIHNlcSA9IG5ldyBZQU1MU2VxKCk7XG4gICAgICAgIHNlcS5pdGVtcy5wdXNoKHBhaXIudmFsdWUpO1xuICAgICAgICBzZXEucmFuZ2UgPSBwYWlyLnZhbHVlLnJhbmdlO1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhaXIua2V5LCBzZXEpO1xuICAgICAgX3RoaXMucmFuZ2UgPSBwYWlyLnJhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldyBTY2FsYXIoTUVSR0VfS0VZKSwgbmV3IFlBTUxTZXEoKSk7XG4gICAgfVxuXG4gICAgX3RoaXMudHlwZSA9IFBhaXIuVHlwZS5NRVJHRV9QQUlSO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gIH0gLy8gSWYgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIG1lcmdlIGtleSBpcyBhIHNpbmdsZSBtYXBwaW5nIG5vZGUsIGVhY2ggb2ZcbiAgLy8gaXRzIGtleS92YWx1ZSBwYWlycyBpcyBpbnNlcnRlZCBpbnRvIHRoZSBjdXJyZW50IG1hcHBpbmcsIHVubGVzcyB0aGUga2V5XG4gIC8vIGFscmVhZHkgZXhpc3RzIGluIGl0LiBJZiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXJnZSBrZXkgaXMgYVxuICAvLyBzZXF1ZW5jZSwgdGhlbiB0aGlzIHNlcXVlbmNlIGlzIGV4cGVjdGVkIHRvIGNvbnRhaW4gbWFwcGluZyBub2RlcyBhbmQgZWFjaFxuICAvLyBvZiB0aGVzZSBub2RlcyBpcyBtZXJnZWQgaW4gdHVybiBhY2NvcmRpbmcgdG8gaXRzIG9yZGVyIGluIHRoZSBzZXF1ZW5jZS5cbiAgLy8gS2V5cyBpbiBtYXBwaW5nIG5vZGVzIGVhcmxpZXIgaW4gdGhlIHNlcXVlbmNlIG92ZXJyaWRlIGtleXMgc3BlY2lmaWVkIGluXG4gIC8vIGxhdGVyIG1hcHBpbmcgbm9kZXMuIC0tIGh0dHA6Ly95YW1sLm9yZy90eXBlL21lcmdlLmh0bWxcblxuXG4gIF9jcmVhdGVDbGFzcyhNZXJnZSwgW3tcbiAgICBrZXk6IFwiYWRkVG9KU01hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb0pTTWFwKGN0eCwgbWFwKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy52YWx1ZS5pdGVtcyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IF9zdGVwLnZhbHVlLnNvdXJjZTtcbiAgICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBZQU1MTWFwKSkgdGhyb3cgbmV3IEVycm9yKCdNZXJnZSBzb3VyY2VzIG11c3QgYmUgbWFwcycpO1xuICAgICAgICAgIHZhciBzcmNNYXAgPSBzb3VyY2UudG9KU09OKG51bGwsIGN0eCwgTWFwKTtcblxuICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3JjTWFwKSxcbiAgICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAga2V5ID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfc3RlcDIkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKSBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hcCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIG1hcC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwga2V5KSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIGtleSwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQpIHtcbiAgICAgIHZhciBzZXEgPSB0aGlzLnZhbHVlO1xuICAgICAgaWYgKHNlcS5pdGVtcy5sZW5ndGggPiAxKSByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTWVyZ2UucHJvdG90eXBlKSwgXCJ0b1N0cmluZ1wiLCB0aGlzKS5jYWxsKHRoaXMsIGN0eCwgb25Db21tZW50KTtcbiAgICAgIHRoaXMudmFsdWUgPSBzZXEuaXRlbXNbMF07XG5cbiAgICAgIHZhciBzdHIgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZXJnZS5wcm90b3R5cGUpLCBcInRvU3RyaW5nXCIsIHRoaXMpLmNhbGwodGhpcywgY3R4LCBvbkNvbW1lbnQpO1xuXG4gICAgICB0aGlzLnZhbHVlID0gc2VxO1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWVyZ2U7XG59KFBhaXIpO1xuXG52YXIgYmluYXJ5T3B0aW9ucyA9IHtcbiAgZGVmYXVsdFR5cGU6IFR5cGUuQkxPQ0tfTElURVJBTCxcbiAgbGluZVdpZHRoOiA3NlxufTtcbnZhciBib29sT3B0aW9ucyA9IHtcbiAgdHJ1ZVN0cjogJ3RydWUnLFxuICBmYWxzZVN0cjogJ2ZhbHNlJ1xufTtcbnZhciBpbnRPcHRpb25zID0ge1xuICBhc0JpZ0ludDogZmFsc2Vcbn07XG52YXIgbnVsbE9wdGlvbnMgPSB7XG4gIG51bGxTdHI6ICdudWxsJ1xufTtcbnZhciBzdHJPcHRpb25zID0ge1xuICBkZWZhdWx0VHlwZTogVHlwZS5QTEFJTixcbiAgZG91YmxlUXVvdGVkOiB7XG4gICAganNvbkVuY29kaW5nOiBmYWxzZSxcbiAgICBtaW5NdWx0aUxpbmVMZW5ndGg6IDQwXG4gIH0sXG4gIGZvbGQ6IHtcbiAgICBsaW5lV2lkdGg6IDgwLFxuICAgIG1pbkNvbnRlbnRXaWR0aDogMjBcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVNjYWxhcihzdHIsIHRhZ3MsIHNjYWxhckZhbGxiYWNrKSB7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0YWdzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgIGZvcm1hdCA9IF9zdGVwJHZhbHVlLmZvcm1hdCxcbiAgICAgICAgICB0ZXN0ID0gX3N0ZXAkdmFsdWUudGVzdCxcbiAgICAgICAgICByZXNvbHZlID0gX3N0ZXAkdmFsdWUucmVzb2x2ZTtcblxuICAgICAgaWYgKHRlc3QpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHRlc3QpO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhciByZXMgPSByZXNvbHZlLmFwcGx5KG51bGwsIG1hdGNoKTtcbiAgICAgICAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiBTY2FsYXIpKSByZXMgPSBuZXcgU2NhbGFyKHJlcyk7XG4gICAgICAgICAgaWYgKGZvcm1hdCkgcmVzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICBpZiAoc2NhbGFyRmFsbGJhY2spIHN0ciA9IHNjYWxhckZhbGxiYWNrKHN0cik7XG4gIHJldHVybiBuZXcgU2NhbGFyKHN0cik7XG59XG5cbnZhciBGT0xEX0ZMT1cgPSAnZmxvdyc7XG52YXIgRk9MRF9CTE9DSyA9ICdibG9jayc7XG52YXIgRk9MRF9RVU9URUQgPSAncXVvdGVkJzsgLy8gcHJlc3VtZXMgaSsxIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmVcbi8vIHJldHVybnMgaW5kZXggb2YgbGFzdCBuZXdsaW5lIGluIG1vcmUtaW5kZW50ZWQgYmxvY2tcblxudmFyIGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyA9IGZ1bmN0aW9uIGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpKSB7XG4gIHZhciBjaCA9IHRleHRbaSArIDFdO1xuXG4gIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0Jykge1xuICAgIGRvIHtcbiAgICAgIGNoID0gdGV4dFtpICs9IDFdO1xuICAgIH0gd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJyk7XG5cbiAgICBjaCA9IHRleHRbaSArIDFdO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59O1xuLyoqXG4gKiBUcmllcyB0byBrZWVwIGlucHV0IGF0IHVwIHRvIGBsaW5lV2lkdGhgIGNoYXJhY3RlcnMsIHNwbGl0dGluZyBvbmx5IG9uIHNwYWNlc1xuICogbm90IGZvbGxvd2VkIGJ5IG5ld2xpbmVzIG9yIHNwYWNlcyB1bmxlc3MgYG1vZGVgIGlzIGAncXVvdGVkJ2AuIExpbmVzIGFyZVxuICogdGVybWluYXRlZCB3aXRoIGBcXG5gIGFuZCBzdGFydGVkIHdpdGggYGluZGVudGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZT0nZmxvdyddIGAnYmxvY2snYCBwcmV2ZW50cyBtb3JlLWluZGVudGVkIGxpbmVzXG4gKiAgIGZyb20gYmVpbmcgZm9sZGVkOyBgJ3F1b3RlZCdgIGFsbG93cyBmb3IgYFxcYCBlc2NhcGVzLCBpbmNsdWRpbmcgZXNjYXBlZFxuICogICBuZXdsaW5lc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbmRlbnRBdFN0YXJ0XSBBY2NvdW50cyBmb3IgbGVhZGluZyBjb250ZW50cyBvblxuICogICB0aGUgZmlyc3QgbGluZSwgZGVmYXVsdGluZyB0byBgaW5kZW50Lmxlbmd0aGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5lV2lkdGg9ODBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluQ29udGVudFdpZHRoPTIwXSBBbGxvdyBoaWdobHkgaW5kZW50ZWQgbGluZXMgdG9cbiAqICAgc3RyZXRjaCB0aGUgbGluZSB3aWR0aCBvciBpbmRlbnQgY29udGVudCBmcm9tIHRoZSBzdGFydFxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5vbkZvbGQgQ2FsbGVkIG9uY2UgaWYgdGhlIHRleHQgaXMgZm9sZGVkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLm9uRm9sZCBDYWxsZWQgb25jZSBpZiBhbnkgbGluZSBvZiB0ZXh0IGV4Y2VlZHNcbiAqICAgbGluZVdpZHRoIGNoYXJhY3RlcnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvbGRGbG93TGluZXModGV4dCwgaW5kZW50LCBtb2RlLCBfcmVmKSB7XG4gIHZhciBpbmRlbnRBdFN0YXJ0ID0gX3JlZi5pbmRlbnRBdFN0YXJ0LFxuICAgICAgX3JlZiRsaW5lV2lkdGggPSBfcmVmLmxpbmVXaWR0aCxcbiAgICAgIGxpbmVXaWR0aCA9IF9yZWYkbGluZVdpZHRoID09PSB2b2lkIDAgPyA4MCA6IF9yZWYkbGluZVdpZHRoLFxuICAgICAgX3JlZiRtaW5Db250ZW50V2lkdGggPSBfcmVmLm1pbkNvbnRlbnRXaWR0aCxcbiAgICAgIG1pbkNvbnRlbnRXaWR0aCA9IF9yZWYkbWluQ29udGVudFdpZHRoID09PSB2b2lkIDAgPyAyMCA6IF9yZWYkbWluQ29udGVudFdpZHRoLFxuICAgICAgb25Gb2xkID0gX3JlZi5vbkZvbGQsXG4gICAgICBvbk92ZXJmbG93ID0gX3JlZi5vbk92ZXJmbG93O1xuICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKSByZXR1cm4gdGV4dDtcbiAgdmFyIGVuZFN0ZXAgPSBNYXRoLm1heCgxICsgbWluQ29udGVudFdpZHRoLCAxICsgbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aCk7XG4gIGlmICh0ZXh0Lmxlbmd0aCA8PSBlbmRTdGVwKSByZXR1cm4gdGV4dDtcbiAgdmFyIGZvbGRzID0gW107XG4gIHZhciBlc2NhcGVkRm9sZHMgPSB7fTtcbiAgdmFyIGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudC5sZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiBpbmRlbnRBdFN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgIGlmIChpbmRlbnRBdFN0YXJ0ID4gbGluZVdpZHRoIC0gTWF0aC5tYXgoMiwgbWluQ29udGVudFdpZHRoKSkgZm9sZHMucHVzaCgwKTtlbHNlIGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudEF0U3RhcnQ7XG4gIH1cblxuICB2YXIgc3BsaXQgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2ID0gdW5kZWZpbmVkO1xuICB2YXIgb3ZlcmZsb3cgPSBmYWxzZTtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGVzY1N0YXJ0ID0gLTE7XG4gIHZhciBlc2NFbmQgPSAtMTtcblxuICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSykge1xuICAgIGkgPSBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSk7XG4gICAgaWYgKGkgIT09IC0xKSBlbmQgPSBpICsgZW5kU3RlcDtcbiAgfVxuXG4gIGZvciAodmFyIGNoOyBjaCA9IHRleHRbaSArPSAxXTspIHtcbiAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgY2ggPT09ICdcXFxcJykge1xuICAgICAgZXNjU3RhcnQgPSBpO1xuXG4gICAgICBzd2l0Y2ggKHRleHRbaSArIDFdKSB7XG4gICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgaSArPSA5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICBlc2NFbmQgPSBpO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgIGlmIChtb2RlID09PSBGT0xEX0JMT0NLKSBpID0gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGkpO1xuICAgICAgZW5kID0gaSArIGVuZFN0ZXA7XG4gICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoID09PSAnICcgJiYgcHJldiAmJiBwcmV2ICE9PSAnICcgJiYgcHJldiAhPT0gJ1xcbicgJiYgcHJldiAhPT0gJ1xcdCcpIHtcbiAgICAgICAgLy8gc3BhY2Ugc3Vycm91bmRlZCBieSBub24tc3BhY2UgY2FuIGJlIHJlcGxhY2VkIHdpdGggbmV3bGluZSArIGluZGVudFxuICAgICAgICB2YXIgbmV4dCA9IHRleHRbaSArIDFdO1xuICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSAnICcgJiYgbmV4dCAhPT0gJ1xcbicgJiYgbmV4dCAhPT0gJ1xcdCcpIHNwbGl0ID0gaTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPj0gZW5kKSB7XG4gICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgIGZvbGRzLnB1c2goc3BsaXQpO1xuICAgICAgICAgIGVuZCA9IHNwbGl0ICsgZW5kU3RlcDtcbiAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCkge1xuICAgICAgICAgIC8vIHdoaXRlLXNwYWNlIGNvbGxlY3RlZCBhdCBlbmQgbWF5IHN0cmV0Y2ggcGFzdCBsaW5lV2lkdGhcbiAgICAgICAgICB3aGlsZSAocHJldiA9PT0gJyAnIHx8IHByZXYgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBwcmV2ID0gY2g7XG4gICAgICAgICAgICBjaCA9IHRleHRbaSArPSAxXTtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIEFjY291bnQgZm9yIG5ld2xpbmUgZXNjYXBlLCBidXQgZG9uJ3QgYnJlYWsgcHJlY2VkaW5nIGVzY2FwZVxuXG5cbiAgICAgICAgICB2YXIgaiA9IGkgPiBlc2NFbmQgKyAxID8gaSAtIDIgOiBlc2NTdGFydCAtIDE7IC8vIEJhaWwgb3V0IGlmIGxpbmVXaWR0aCAmIG1pbkNvbnRlbnRXaWR0aCBhcmUgc2hvcnRlciB0aGFuIGFuIGVzY2FwZSBzdHJpbmdcblxuICAgICAgICAgIGlmIChlc2NhcGVkRm9sZHNbal0pIHJldHVybiB0ZXh0O1xuICAgICAgICAgIGZvbGRzLnB1c2goaik7XG4gICAgICAgICAgZXNjYXBlZEZvbGRzW2pdID0gdHJ1ZTtcbiAgICAgICAgICBlbmQgPSBqICsgZW5kU3RlcDtcbiAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2ID0gY2g7XG4gIH1cblxuICBpZiAob3ZlcmZsb3cgJiYgb25PdmVyZmxvdykgb25PdmVyZmxvdygpO1xuICBpZiAoZm9sZHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGV4dDtcbiAgaWYgKG9uRm9sZCkgb25Gb2xkKCk7XG4gIHZhciByZXMgPSB0ZXh0LnNsaWNlKDAsIGZvbGRzWzBdKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZm9sZHMubGVuZ3RoOyArK19pKSB7XG4gICAgdmFyIGZvbGQgPSBmb2xkc1tfaV07XG5cbiAgICB2YXIgX2VuZCA9IGZvbGRzW19pICsgMV0gfHwgdGV4dC5sZW5ndGg7XG5cbiAgICBpZiAoZm9sZCA9PT0gMCkgcmVzID0gXCJcXG5cIi5jb25jYXQoaW5kZW50KS5jb25jYXQodGV4dC5zbGljZSgwLCBfZW5kKSk7ZWxzZSB7XG4gICAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgZXNjYXBlZEZvbGRzW2ZvbGRdKSByZXMgKz0gXCJcIi5jb25jYXQodGV4dFtmb2xkXSwgXCJcXFxcXCIpO1xuICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGluZGVudCkuY29uY2F0KHRleHQuc2xpY2UoZm9sZCArIDEsIF9lbmQpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgZ2V0Rm9sZE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRGb2xkT3B0aW9ucyhfcmVmKSB7XG4gIHZhciBpbmRlbnRBdFN0YXJ0ID0gX3JlZi5pbmRlbnRBdFN0YXJ0O1xuICByZXR1cm4gaW5kZW50QXRTdGFydCA/IE9iamVjdC5hc3NpZ24oe1xuICAgIGluZGVudEF0U3RhcnQ6IGluZGVudEF0U3RhcnRcbiAgfSwgc3RyT3B0aW9ucy5mb2xkKSA6IHN0ck9wdGlvbnMuZm9sZDtcbn07IC8vIEFsc28gY2hlY2tzIGZvciBsaW5lcyBzdGFydGluZyB3aXRoICUsIGFzIHBhcnNpbmcgdGhlIG91dHB1dCBhcyBZQU1MIDEuMSB3aWxsXG4vLyBwcmVzdW1lIHRoYXQncyBzdGFydGluZyBhIG5ldyBkb2N1bWVudC5cblxuXG52YXIgY29udGFpbnNEb2N1bWVudE1hcmtlciA9IGZ1bmN0aW9uIGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIoc3RyKSB7XG4gIHJldHVybiAvXiglfC0tLXxcXC5cXC5cXC4pL20udGVzdChzdHIpO1xufTtcblxuZnVuY3Rpb24gbGluZUxlbmd0aE92ZXJMaW1pdChzdHIsIGxpbmVXaWR0aCwgaW5kZW50TGVuZ3RoKSB7XG4gIGlmICghbGluZVdpZHRoIHx8IGxpbmVXaWR0aCA8IDApIHJldHVybiBmYWxzZTtcbiAgdmFyIGxpbWl0ID0gbGluZVdpZHRoIC0gaW5kZW50TGVuZ3RoO1xuICB2YXIgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiA8PSBsaW1pdCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwLCBzdGFydCA9IDA7IGkgPCBzdHJMZW47ICsraSkge1xuICAgIGlmIChzdHJbaV0gPT09ICdcXG4nKSB7XG4gICAgICBpZiAoaSAtIHN0YXJ0ID4gbGltaXQpIHJldHVybiB0cnVlO1xuICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgIGlmIChzdHJMZW4gLSBzdGFydCA8PSBsaW1pdCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICB2YXIgaW1wbGljaXRLZXkgPSBjdHguaW1wbGljaXRLZXk7XG4gIHZhciBfc3RyT3B0aW9ucyRkb3VibGVRdW8gPSBzdHJPcHRpb25zLmRvdWJsZVF1b3RlZCxcbiAgICAgIGpzb25FbmNvZGluZyA9IF9zdHJPcHRpb25zJGRvdWJsZVF1by5qc29uRW5jb2RpbmcsXG4gICAgICBtaW5NdWx0aUxpbmVMZW5ndGggPSBfc3RyT3B0aW9ucyRkb3VibGVRdW8ubWluTXVsdGlMaW5lTGVuZ3RoO1xuICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgaWYgKGpzb25FbmNvZGluZykgcmV0dXJuIGpzb247XG4gIHZhciBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIHN0YXJ0ID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgY2ggPSBqc29uW2ldOyBjaDsgY2ggPSBqc29uWysraV0pIHtcbiAgICBpZiAoY2ggPT09ICcgJyAmJiBqc29uW2kgKyAxXSA9PT0gJ1xcXFwnICYmIGpzb25baSArIDJdID09PSAnbicpIHtcbiAgICAgIC8vIHNwYWNlIGJlZm9yZSBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcXFwgJztcbiAgICAgIGkgKz0gMTtcbiAgICAgIHN0YXJ0ID0gaTtcbiAgICAgIGNoID0gJ1xcXFwnO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJ1xcXFwnKSBzd2l0Y2ggKGpzb25baSArIDFdKSB7XG4gICAgICBjYXNlICd1JzpcbiAgICAgICAge1xuICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICB2YXIgY29kZSA9IGpzb24uc3Vic3RyKGkgKyAyLCA0KTtcblxuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSAnMDAwMCc6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFxcXDAnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnMDAwNyc6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFxcXGEnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnMDAwYic6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFxcXHYnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnMDAxYic6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFxcXGUnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnMDA4NSc6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFxcXE4nO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnMDBhMCc6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFxcXF8nO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnMjAyOCc6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFxcXEwnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnMjAyOSc6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFxcXFAnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKGNvZGUuc3Vic3RyKDAsIDIpID09PSAnMDAnKSBzdHIgKz0gJ1xcXFx4JyArIGNvZGUuc3Vic3RyKDIpO2Vsc2Ugc3RyICs9IGpzb24uc3Vic3RyKGksIDYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICduJzpcbiAgICAgICAgaWYgKGltcGxpY2l0S2V5IHx8IGpzb25baSArIDJdID09PSAnXCInIHx8IGpzb24ubGVuZ3RoIDwgbWluTXVsdGlMaW5lTGVuZ3RoKSB7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZvbGRpbmcgd2lsbCBlYXQgZmlyc3QgbmV3bGluZVxuICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKSArICdcXG5cXG4nO1xuXG4gICAgICAgICAgd2hpbGUgKGpzb25baSArIDJdID09PSAnXFxcXCcgJiYganNvbltpICsgM10gPT09ICduJyAmJiBqc29uW2kgKyA0XSAhPT0gJ1wiJykge1xuICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0ciArPSBpbmRlbnQ7IC8vIHNwYWNlIGFmdGVyIG5ld2xpbmUgbmVlZHMgdG8gYmUgZXNjYXBlZCB0byBub3QgYmUgZm9sZGVkXG5cbiAgICAgICAgICBpZiAoanNvbltpICsgMl0gPT09ICcgJykgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpICs9IDE7XG4gICAgfVxuICB9XG5cbiAgc3RyID0gc3RhcnQgPyBzdHIgKyBqc29uLnNsaWNlKHN0YXJ0KSA6IGpzb247XG4gIHJldHVybiBpbXBsaWNpdEtleSA/IHN0ciA6IGZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIEZPTERfUVVPVEVELCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcbn1cblxuZnVuY3Rpb24gc2luZ2xlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgaWYgKGN0eC5pbXBsaWNpdEtleSkge1xuICAgIGlmICgvXFxuLy50ZXN0KHZhbHVlKSkgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzaW5nbGUgcXVvdGVkIHN0cmluZyBjYW4ndCBoYXZlIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBhcm91bmQgbmV3bGluZVxuICAgIGlmICgvWyBcXHRdXFxufFxcblsgXFx0XS8udGVzdCh2YWx1ZSkpIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gIH1cblxuICB2YXIgaW5kZW50ID0gY3R4LmluZGVudCB8fCAoY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkgPyAnICAnIDogJycpO1xuICB2YXIgcmVzID0gXCInXCIgKyB2YWx1ZS5yZXBsYWNlKC8nL2csIFwiJydcIikucmVwbGFjZSgvXFxuKy9nLCBcIiQmXFxuXCIuY29uY2F0KGluZGVudCkpICsgXCInXCI7XG4gIHJldHVybiBjdHguaW1wbGljaXRLZXkgPyByZXMgOiBmb2xkRmxvd0xpbmVzKHJlcywgaW5kZW50LCBGT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuXG5mdW5jdGlvbiBibG9ja1N0cmluZyhfcmVmMiwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gIHZhciBjb21tZW50ID0gX3JlZjIuY29tbWVudCxcbiAgICAgIHR5cGUgPSBfcmVmMi50eXBlLFxuICAgICAgdmFsdWUgPSBfcmVmMi52YWx1ZTtcblxuICAvLyAxLiBCbG9jayBjYW4ndCBlbmQgaW4gd2hpdGVzcGFjZSB1bmxlc3MgdGhlIGxhc3QgbGluZSBpcyBub24tZW1wdHkuXG4gIC8vIDIuIFN0cmluZ3MgY29uc2lzdGluZyBvZiBvbmx5IHdoaXRlc3BhY2UgYXJlIGJlc3QgcmVuZGVyZWQgZXhwbGljaXRseS5cbiAgaWYgKC9cXG5bXFx0IF0rJC8udGVzdCh2YWx1ZSkgfHwgL15cXHMqJC8udGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICB9XG5cbiAgdmFyIGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGN0eC5mb3JjZUJsb2NrSW5kZW50IHx8IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgdmFyIGluZGVudFNpemUgPSBpbmRlbnQgPyAnMicgOiAnMSc7IC8vIHJvb3QgaXMgYXQgLTFcblxuICB2YXIgbGl0ZXJhbCA9IHR5cGUgPT09IFR5cGUuQkxPQ0tfRk9MREVEID8gZmFsc2UgOiB0eXBlID09PSBUeXBlLkJMT0NLX0xJVEVSQUwgPyB0cnVlIDogIWxpbmVMZW5ndGhPdmVyTGltaXQodmFsdWUsIHN0ck9wdGlvbnMuZm9sZC5saW5lV2lkdGgsIGluZGVudC5sZW5ndGgpO1xuICB2YXIgaGVhZGVyID0gbGl0ZXJhbCA/ICd8JyA6ICc+JztcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIGhlYWRlciArICdcXG4nO1xuICB2YXIgd3NTdGFydCA9ICcnO1xuICB2YXIgd3NFbmQgPSAnJztcbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXFxuXFx0IF0qJC8sIGZ1bmN0aW9uICh3cykge1xuICAgIHZhciBuID0gd3MuaW5kZXhPZignXFxuJyk7XG5cbiAgICBpZiAobiA9PT0gLTEpIHtcbiAgICAgIGhlYWRlciArPSAnLSc7IC8vIHN0cmlwXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gd3MgfHwgbiAhPT0gd3MubGVuZ3RoIC0gMSkge1xuICAgICAgaGVhZGVyICs9ICcrJzsgLy8ga2VlcFxuXG4gICAgICBpZiAob25DaG9tcEtlZXApIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuXG4gICAgd3NFbmQgPSB3cy5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgIHJldHVybiAnJztcbiAgfSkucmVwbGFjZSgvXltcXG4gXSovLCBmdW5jdGlvbiAod3MpIHtcbiAgICBpZiAod3MuaW5kZXhPZignICcpICE9PSAtMSkgaGVhZGVyICs9IGluZGVudFNpemU7XG4gICAgdmFyIG0gPSB3cy5tYXRjaCgvICskLyk7XG5cbiAgICBpZiAobSkge1xuICAgICAgd3NTdGFydCA9IHdzLnNsaWNlKDAsIC1tWzBdLmxlbmd0aCk7XG4gICAgICByZXR1cm4gbVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3NTdGFydCA9IHdzO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSk7XG4gIGlmICh3c0VuZCkgd3NFbmQgPSB3c0VuZC5yZXBsYWNlKC9cXG4rKD8hXFxufCQpL2csIFwiJCZcIi5jb25jYXQoaW5kZW50KSk7XG4gIGlmICh3c1N0YXJ0KSB3c1N0YXJ0ID0gd3NTdGFydC5yZXBsYWNlKC9cXG4rL2csIFwiJCZcIi5jb25jYXQoaW5kZW50KSk7XG5cbiAgaWYgKGNvbW1lbnQpIHtcbiAgICBoZWFkZXIgKz0gJyAjJyArIGNvbW1lbnQucmVwbGFjZSgvID9bXFxyXFxuXSsvZywgJyAnKTtcbiAgICBpZiAob25Db21tZW50KSBvbkNvbW1lbnQoKTtcbiAgfVxuXG4gIGlmICghdmFsdWUpIHJldHVybiBcIlwiLmNvbmNhdChoZWFkZXIpLmNvbmNhdChpbmRlbnRTaXplLCBcIlxcblwiKS5jb25jYXQoaW5kZW50KS5jb25jYXQod3NFbmQpO1xuXG4gIGlmIChsaXRlcmFsKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIFwiJCZcIi5jb25jYXQoaW5kZW50KSk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGhlYWRlciwgXCJcXG5cIikuY29uY2F0KGluZGVudCkuY29uY2F0KHdzU3RhcnQpLmNvbmNhdCh2YWx1ZSkuY29uY2F0KHdzRW5kKTtcbiAgfVxuXG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxuKy9nLCAnXFxuJCYnKS5yZXBsYWNlKC8oPzpefFxcbikoW1xcdCBdLiopKD86KFtcXG5cXHQgXSopXFxuKD8hW1xcblxcdCBdKSk/L2csICckMSQyJykgLy8gbW9yZS1pbmRlbnRlZCBsaW5lcyBhcmVuJ3QgZm9sZGVkXG4gIC8vICAgICAgICAgXiBpbmQubGluZSAgXiBlbXB0eSAgICAgXiBjYXB0dXJlIG5leHQgZW1wdHkgbGluZXMgb25seSBhdCBlbmQgb2YgaW5kZW50XG4gIC5yZXBsYWNlKC9cXG4rL2csIFwiJCZcIi5jb25jYXQoaW5kZW50KSk7XG4gIHZhciBib2R5ID0gZm9sZEZsb3dMaW5lcyhcIlwiLmNvbmNhdCh3c1N0YXJ0KS5jb25jYXQodmFsdWUpLmNvbmNhdCh3c0VuZCksIGluZGVudCwgRk9MRF9CTE9DSywgc3RyT3B0aW9ucy5mb2xkKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGhlYWRlciwgXCJcXG5cIikuY29uY2F0KGluZGVudCkuY29uY2F0KGJvZHkpO1xufVxuXG5mdW5jdGlvbiBwbGFpblN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgdmFyIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQsXG4gICAgICB0eXBlID0gaXRlbS50eXBlLFxuICAgICAgdmFsdWUgPSBpdGVtLnZhbHVlO1xuICB2YXIgYWN0dWFsU3RyaW5nID0gY3R4LmFjdHVhbFN0cmluZyxcbiAgICAgIGltcGxpY2l0S2V5ID0gY3R4LmltcGxpY2l0S2V5LFxuICAgICAgaW5kZW50ID0gY3R4LmluZGVudCxcbiAgICAgIGluRmxvdyA9IGN0eC5pbkZsb3c7XG5cbiAgaWYgKGltcGxpY2l0S2V5ICYmIC9bXFxuW1xcXXt9LF0vLnRlc3QodmFsdWUpIHx8IGluRmxvdyAmJiAvW1tcXF17fSxdLy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gIH1cblxuICBpZiAoIXZhbHVlIHx8IC9eW1xcblxcdCAsW1xcXXt9IyYqIXw+J1wiJUBgXXxeWz8tXSR8Xls/LV1bIFxcdF18W1xcbjpdWyBcXHRdfFsgXFx0XVxcbnxbXFxuXFx0IF0jfFtcXG5cXHQgOl0kLy50ZXN0KHZhbHVlKSkge1xuICAgIC8vIG5vdCBhbGxvd2VkOlxuICAgIC8vIC0gZW1wdHkgc3RyaW5nLCAnLScgb3IgJz8nXG4gICAgLy8gLSBzdGFydCB3aXRoIGFuIGluZGljYXRvciBjaGFyYWN0ZXIgKGV4Y2VwdCBbPzotXSkgb3IgL1s/LV0gL1xuICAgIC8vIC0gJ1xcbiAnLCAnOiAnIG9yICcgXFxuJyBhbnl3aGVyZVxuICAgIC8vIC0gJyMnIG5vdCBwcmVjZWRlZCBieSBhIG5vbi1zcGFjZSBjaGFyXG4gICAgLy8gLSBlbmQgd2l0aCAnICcgb3IgJzonXG4gICAgcmV0dXJuIGltcGxpY2l0S2V5IHx8IGluRmxvdyB8fCB2YWx1ZS5pbmRleE9mKCdcXG4nKSA9PT0gLTEgPyB2YWx1ZS5pbmRleE9mKCdcIicpICE9PSAtMSAmJiB2YWx1ZS5pbmRleE9mKFwiJ1wiKSA9PT0gLTEgPyBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkgOiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkgOiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICB9XG5cbiAgaWYgKCFpbXBsaWNpdEtleSAmJiAhaW5GbG93ICYmIHR5cGUgIT09IFR5cGUuUExBSU4gJiYgdmFsdWUuaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgLy8gV2hlcmUgYWxsb3dlZCAmIHR5cGUgbm90IHNldCBleHBsaWNpdGx5LCBwcmVmZXIgYmxvY2sgc3R5bGUgZm9yIG11bHRpbGluZSBzdHJpbmdzXG4gICAgcmV0dXJuIGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIH1cblxuICBpZiAoaW5kZW50ID09PSAnJyAmJiBjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSkge1xuICAgIGN0eC5mb3JjZUJsb2NrSW5kZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfVxuXG4gIHZhciBzdHIgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIFwiJCZcXG5cIi5jb25jYXQoaW5kZW50KSk7IC8vIFZlcmlmeSB0aGF0IG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhcyBhIHN0cmluZywgYXMgZS5nLiBwbGFpbiBudW1iZXJzIGFuZFxuICAvLyBib29sZWFucyBnZXQgcGFyc2VkIHdpdGggdGhvc2UgdHlwZXMgaW4gdjEuMiAoZS5nLiAnNDInLCAndHJ1ZScgJiAnMC45ZS0zJyksXG4gIC8vIGFuZCBvdGhlcnMgaW4gdjEuMS5cblxuICBpZiAoYWN0dWFsU3RyaW5nKSB7XG4gICAgdmFyIHRhZ3MgPSBjdHguZG9jLnNjaGVtYS50YWdzO1xuICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVTY2FsYXIoc3RyLCB0YWdzLCB0YWdzLnNjYWxhckZhbGxiYWNrKS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVkICE9PSAnc3RyaW5nJykgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgfVxuXG4gIHZhciBib2R5ID0gaW1wbGljaXRLZXkgPyBzdHIgOiBmb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBGT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCkpO1xuXG4gIGlmIChjb21tZW50ICYmICFpbkZsb3cgJiYgKGJvZHkuaW5kZXhPZignXFxuJykgIT09IC0xIHx8IGNvbW1lbnQuaW5kZXhPZignXFxuJykgIT09IC0xKSkge1xuICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICAgIHJldHVybiBhZGRDb21tZW50QmVmb3JlKGJvZHksIGluZGVudCwgY29tbWVudCk7XG4gIH1cblxuICByZXR1cm4gYm9keTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5U3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICB2YXIgZGVmYXVsdFR5cGUgPSBzdHJPcHRpb25zLmRlZmF1bHRUeXBlO1xuICB2YXIgaW1wbGljaXRLZXkgPSBjdHguaW1wbGljaXRLZXksXG4gICAgICBpbkZsb3cgPSBjdHguaW5GbG93O1xuICB2YXIgX2l0ZW0gPSBpdGVtLFxuICAgICAgdHlwZSA9IF9pdGVtLnR5cGUsXG4gICAgICB2YWx1ZSA9IF9pdGVtLnZhbHVlO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBpdGVtLCB7XG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBfc3RyaW5naWZ5ID0gZnVuY3Rpb24gX3N0cmluZ2lmeShfdHlwZSkge1xuICAgIHN3aXRjaCAoX3R5cGUpIHtcbiAgICAgIGNhc2UgVHlwZS5CTE9DS19GT0xERUQ6XG4gICAgICBjYXNlIFR5cGUuQkxPQ0tfTElURVJBTDpcbiAgICAgICAgcmV0dXJuIGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG5cbiAgICAgIGNhc2UgVHlwZS5RVU9URV9ET1VCTEU6XG4gICAgICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG5cbiAgICAgIGNhc2UgVHlwZS5RVU9URV9TSU5HTEU6XG4gICAgICAgIHJldHVybiBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG5cbiAgICAgIGNhc2UgVHlwZS5QTEFJTjpcbiAgICAgICAgcmV0dXJuIHBsYWluU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBpZiAodHlwZSAhPT0gVHlwZS5RVU9URV9ET1VCTEUgJiYgL1tcXHgwMC1cXHgwOFxceDBiLVxceDFmXFx4N2YtXFx4OWZdLy50ZXN0KHZhbHVlKSkge1xuICAgIC8vIGZvcmNlIGRvdWJsZSBxdW90ZXMgb24gY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgdHlwZSA9IFR5cGUuUVVPVEVfRE9VQkxFO1xuICB9IGVsc2UgaWYgKChpbXBsaWNpdEtleSB8fCBpbkZsb3cpICYmICh0eXBlID09PSBUeXBlLkJMT0NLX0ZPTERFRCB8fCB0eXBlID09PSBUeXBlLkJMT0NLX0xJVEVSQUwpKSB7XG4gICAgLy8gc2hvdWxkIG5vdCBoYXBwZW47IGJsb2NrcyBhcmUgbm90IHZhbGlkIGluc2lkZSBmbG93IGNvbnRhaW5lcnNcbiAgICB0eXBlID0gVHlwZS5RVU9URV9ET1VCTEU7XG4gIH1cblxuICB2YXIgcmVzID0gX3N0cmluZ2lmeSh0eXBlKTtcblxuICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgcmVzID0gX3N0cmluZ2lmeShkZWZhdWx0VHlwZSk7XG4gICAgaWYgKHJlcyA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGVmYXVsdCBzdHJpbmcgdHlwZSBcIi5jb25jYXQoZGVmYXVsdFR5cGUpKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU51bWJlcihfcmVmKSB7XG4gIHZhciBmb3JtYXQgPSBfcmVmLmZvcm1hdCxcbiAgICAgIG1pbkZyYWN0aW9uRGlnaXRzID0gX3JlZi5taW5GcmFjdGlvbkRpZ2l0cyxcbiAgICAgIHRhZyA9IF9yZWYudGFnLFxuICAgICAgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JykgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSByZXR1cm4gaXNOYU4odmFsdWUpID8gJy5uYW4nIDogdmFsdWUgPCAwID8gJy0uaW5mJyA6ICcuaW5mJztcbiAgdmFyIG4gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cbiAgaWYgKCFmb3JtYXQgJiYgbWluRnJhY3Rpb25EaWdpdHMgJiYgKCF0YWcgfHwgdGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnKSAmJiAvXlxcZC8udGVzdChuKSkge1xuICAgIHZhciBpID0gbi5pbmRleE9mKCcuJyk7XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGkgPSBuLmxlbmd0aDtcbiAgICAgIG4gKz0gJy4nO1xuICAgIH1cblxuICAgIHZhciBkID0gbWluRnJhY3Rpb25EaWdpdHMgLSAobi5sZW5ndGggLSBpIC0gMSk7XG5cbiAgICB3aGlsZSAoZC0tID4gMCkge1xuICAgICAgbiArPSAnMCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGNoZWNrRmxvd0NvbGxlY3Rpb25FbmQoZXJyb3JzLCBjc3QpIHtcbiAgdmFyIGNoYXIsIG5hbWU7XG5cbiAgc3dpdGNoIChjc3QudHlwZSkge1xuICAgIGNhc2UgVHlwZS5GTE9XX01BUDpcbiAgICAgIGNoYXIgPSAnfSc7XG4gICAgICBuYW1lID0gJ2Zsb3cgbWFwJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUeXBlLkZMT1dfU0VROlxuICAgICAgY2hhciA9ICddJztcbiAgICAgIG5hbWUgPSAnZmxvdyBzZXF1ZW5jZSc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBlcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IoY3N0LCAnTm90IGEgZmxvdyBjb2xsZWN0aW9uIT8nKSk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGFzdEl0ZW07XG5cbiAgZm9yICh2YXIgaSA9IGNzdC5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBpdGVtID0gY3N0Lml0ZW1zW2ldO1xuXG4gICAgaWYgKCFpdGVtIHx8IGl0ZW0udHlwZSAhPT0gVHlwZS5DT01NRU5UKSB7XG4gICAgICBsYXN0SXRlbSA9IGl0ZW07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAobGFzdEl0ZW0gJiYgbGFzdEl0ZW0uY2hhciAhPT0gY2hhcikge1xuICAgIHZhciBtc2cgPSBcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lLCBcIiB0byBlbmQgd2l0aCBcIikuY29uY2F0KGNoYXIpO1xuICAgIHZhciBlcnI7XG5cbiAgICBpZiAodHlwZW9mIGxhc3RJdGVtLm9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVyciA9IG5ldyBZQU1MU2VtYW50aWNFcnJvcihjc3QsIG1zZyk7XG4gICAgICBlcnIub2Zmc2V0ID0gbGFzdEl0ZW0ub2Zmc2V0ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyID0gbmV3IFlBTUxTZW1hbnRpY0Vycm9yKGxhc3RJdGVtLCBtc2cpO1xuICAgICAgaWYgKGxhc3RJdGVtLnJhbmdlICYmIGxhc3RJdGVtLnJhbmdlLmVuZCkgZXJyLm9mZnNldCA9IGxhc3RJdGVtLnJhbmdlLmVuZCAtIGxhc3RJdGVtLnJhbmdlLnN0YXJ0O1xuICAgIH1cblxuICAgIGVycm9ycy5wdXNoKGVycik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRmxvd0NvbW1lbnRTcGFjZShlcnJvcnMsIGNvbW1lbnQpIHtcbiAgdmFyIHByZXYgPSBjb21tZW50LmNvbnRleHQuc3JjW2NvbW1lbnQucmFuZ2Uuc3RhcnQgLSAxXTtcblxuICBpZiAocHJldiAhPT0gJ1xcbicgJiYgcHJldiAhPT0gJ1xcdCcgJiYgcHJldiAhPT0gJyAnKSB7XG4gICAgdmFyIG1zZyA9ICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJztcbiAgICBlcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IoY29tbWVudCwgbXNnKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvbmdLZXlFcnJvcihzb3VyY2UsIGtleSkge1xuICB2YXIgc2sgPSBTdHJpbmcoa2V5KTtcbiAgdmFyIGsgPSBzay5zdWJzdHIoMCwgOCkgKyAnLi4uJyArIHNrLnN1YnN0cigtOCk7XG4gIHJldHVybiBuZXcgWUFNTFNlbWFudGljRXJyb3Ioc291cmNlLCBcIlRoZSBcXFwiXCIuY29uY2F0KGssIFwiXFxcIiBrZXkgaXMgdG9vIGxvbmdcIikpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNvbW1lbnRzKGNvbGxlY3Rpb24sIGNvbW1lbnRzKSB7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjb21tZW50cyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc3RlcC52YWx1ZSxcbiAgICAgICAgICBhZnRlcktleSA9IF9zdGVwJHZhbHVlLmFmdGVyS2V5LFxuICAgICAgICAgIGJlZm9yZSA9IF9zdGVwJHZhbHVlLmJlZm9yZSxcbiAgICAgICAgICBjb21tZW50ID0gX3N0ZXAkdmFsdWUuY29tbWVudDtcbiAgICAgIHZhciBpdGVtID0gY29sbGVjdGlvbi5pdGVtc1tiZWZvcmVdO1xuXG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjb2xsZWN0aW9uLmNvbW1lbnQpIGNvbGxlY3Rpb24uY29tbWVudCArPSAnXFxuJyArIGNvbW1lbnQ7ZWxzZSBjb2xsZWN0aW9uLmNvbW1lbnQgPSBjb21tZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYWZ0ZXJLZXkgJiYgaXRlbS52YWx1ZSkgaXRlbSA9IGl0ZW0udmFsdWU7XG5cbiAgICAgICAgaWYgKGNvbW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChhZnRlcktleSB8fCAhaXRlbS5jb21tZW50QmVmb3JlKSBpdGVtLnNwYWNlQmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKSBpdGVtLmNvbW1lbnRCZWZvcmUgKz0gJ1xcbicgKyBjb21tZW50O2Vsc2UgaXRlbS5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG59XG5cbi8vIG9uIGVycm9yLCB3aWxsIHJldHVybiB7IHN0cjogc3RyaW5nLCBlcnJvcnM6IEVycm9yW10gfVxuZnVuY3Rpb24gcmVzb2x2ZVN0cmluZyhkb2MsIG5vZGUpIHtcbiAgdmFyIHJlcyA9IG5vZGUuc3RyVmFsdWU7XG4gIGlmICghcmVzKSByZXR1cm4gJyc7XG4gIGlmICh0eXBlb2YgcmVzID09PSAnc3RyaW5nJykgcmV0dXJuIHJlcztcbiAgcmVzLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGlmICghZXJyb3Iuc291cmNlKSBlcnJvci5zb3VyY2UgPSBub2RlO1xuICAgIGRvYy5lcnJvcnMucHVzaChlcnJvcik7XG4gIH0pO1xuICByZXR1cm4gcmVzLnN0cjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhZ0hhbmRsZShkb2MsIG5vZGUpIHtcbiAgdmFyIF9ub2RlJHRhZyA9IG5vZGUudGFnLFxuICAgICAgaGFuZGxlID0gX25vZGUkdGFnLmhhbmRsZSxcbiAgICAgIHN1ZmZpeCA9IF9ub2RlJHRhZy5zdWZmaXg7XG4gIHZhciBwcmVmaXggPSBkb2MudGFnUHJlZml4ZXMuZmluZChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLmhhbmRsZSA9PT0gaGFuZGxlO1xuICB9KTtcblxuICBpZiAoIXByZWZpeCkge1xuICAgIHZhciBkdHAgPSBkb2MuZ2V0RGVmYXVsdHMoKS50YWdQcmVmaXhlcztcbiAgICBpZiAoZHRwKSBwcmVmaXggPSBkdHAuZmluZChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHAuaGFuZGxlID09PSBoYW5kbGU7XG4gICAgfSk7XG4gICAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBZQU1MU2VtYW50aWNFcnJvcihub2RlLCBcIlRoZSBcIi5jb25jYXQoaGFuZGxlLCBcIiB0YWcgaGFuZGxlIGlzIG5vbi1kZWZhdWx0IGFuZCB3YXMgbm90IGRlY2xhcmVkLlwiKSk7XG4gIH1cblxuICBpZiAoIXN1ZmZpeCkgdGhyb3cgbmV3IFlBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIFwiVGhlIFwiLmNvbmNhdChoYW5kbGUsIFwiIHRhZyBoYXMgbm8gc3VmZml4LlwiKSk7XG5cbiAgaWYgKGhhbmRsZSA9PT0gJyEnICYmIChkb2MudmVyc2lvbiB8fCBkb2Mub3B0aW9ucy52ZXJzaW9uKSA9PT0gJzEuMCcpIHtcbiAgICBpZiAoc3VmZml4WzBdID09PSAnXicpIHtcbiAgICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBZQU1MV2FybmluZyhub2RlLCAnWUFNTCAxLjAgXiB0YWcgZXhwYW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICByZXR1cm4gc3VmZml4O1xuICAgIH1cblxuICAgIGlmICgvWzovXS8udGVzdChzdWZmaXgpKSB7XG4gICAgICAvLyB3b3JkL2ZvbyAtPiB0YWc6d29yZC55YW1sLm9yZywyMDAyOmZvb1xuICAgICAgdmFyIHZvY2FiID0gc3VmZml4Lm1hdGNoKC9eKFthLXowLTktXSspXFwvKC4qKS9pKTtcbiAgICAgIHJldHVybiB2b2NhYiA/IFwidGFnOlwiLmNvbmNhdCh2b2NhYlsxXSwgXCIueWFtbC5vcmcsMjAwMjpcIikuY29uY2F0KHZvY2FiWzJdKSA6IFwidGFnOlwiLmNvbmNhdChzdWZmaXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmVmaXgucHJlZml4ICsgZGVjb2RlVVJJQ29tcG9uZW50KHN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUYWdOYW1lKGRvYywgbm9kZSkge1xuICB2YXIgdGFnID0gbm9kZS50YWcsXG4gICAgICB0eXBlID0gbm9kZS50eXBlO1xuICB2YXIgbm9uU3BlY2lmaWMgPSBmYWxzZTtcblxuICBpZiAodGFnKSB7XG4gICAgdmFyIGhhbmRsZSA9IHRhZy5oYW5kbGUsXG4gICAgICAgIHN1ZmZpeCA9IHRhZy5zdWZmaXgsXG4gICAgICAgIHZlcmJhdGltID0gdGFnLnZlcmJhdGltO1xuXG4gICAgaWYgKHZlcmJhdGltKSB7XG4gICAgICBpZiAodmVyYmF0aW0gIT09ICchJyAmJiB2ZXJiYXRpbSAhPT0gJyEhJykgcmV0dXJuIHZlcmJhdGltO1xuICAgICAgdmFyIG1zZyA9IFwiVmVyYmF0aW0gdGFncyBhcmVuJ3QgcmVzb2x2ZWQsIHNvIFwiLmNvbmNhdCh2ZXJiYXRpbSwgXCIgaXMgaW52YWxpZC5cIik7XG4gICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIG1zZykpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlID09PSAnIScgJiYgIXN1ZmZpeCkge1xuICAgICAgbm9uU3BlY2lmaWMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVRhZ0hhbmRsZShkb2MsIG5vZGUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFR5cGUuQkxPQ0tfRk9MREVEOlxuICAgIGNhc2UgVHlwZS5CTE9DS19MSVRFUkFMOlxuICAgIGNhc2UgVHlwZS5RVU9URV9ET1VCTEU6XG4gICAgY2FzZSBUeXBlLlFVT1RFX1NJTkdMRTpcbiAgICAgIHJldHVybiBkZWZhdWx0VGFncy5TVFI7XG5cbiAgICBjYXNlIFR5cGUuRkxPV19NQVA6XG4gICAgY2FzZSBUeXBlLk1BUDpcbiAgICAgIHJldHVybiBkZWZhdWx0VGFncy5NQVA7XG5cbiAgICBjYXNlIFR5cGUuRkxPV19TRVE6XG4gICAgY2FzZSBUeXBlLlNFUTpcbiAgICAgIHJldHVybiBkZWZhdWx0VGFncy5TRVE7XG5cbiAgICBjYXNlIFR5cGUuUExBSU46XG4gICAgICByZXR1cm4gbm9uU3BlY2lmaWMgPyBkZWZhdWx0VGFncy5TVFIgOiBudWxsO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVCeVRhZ05hbWUoZG9jLCBub2RlLCB0YWdOYW1lKSB7XG4gIHZhciB0YWdzID0gZG9jLnNjaGVtYS50YWdzO1xuICB2YXIgbWF0Y2hXaXRoVGVzdCA9IFtdO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0YWdzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciB0YWcgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKHRhZy50YWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgaWYgKHRhZy50ZXN0KSBtYXRjaFdpdGhUZXN0LnB1c2godGFnKTtlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzID0gdGFnLnJlc29sdmUoZG9jLCBub2RlKTtcbiAgICAgICAgICByZXR1cm4gcmVzIGluc3RhbmNlb2YgQ29sbGVjdGlvbiA/IHJlcyA6IG5ldyBTY2FsYXIocmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgdmFyIHN0ciA9IHJlc29sdmVTdHJpbmcoZG9jLCBub2RlKTtcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIG1hdGNoV2l0aFRlc3QubGVuZ3RoID4gMCkgcmV0dXJuIHJlc29sdmVTY2FsYXIoc3RyLCBtYXRjaFdpdGhUZXN0LCB0YWdzLnNjYWxhckZhbGxiYWNrKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEZhbGxiYWNrVGFnTmFtZShfcmVmKSB7XG4gIHZhciB0eXBlID0gX3JlZi50eXBlO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgVHlwZS5GTE9XX01BUDpcbiAgICBjYXNlIFR5cGUuTUFQOlxuICAgICAgcmV0dXJuIGRlZmF1bHRUYWdzLk1BUDtcblxuICAgIGNhc2UgVHlwZS5GTE9XX1NFUTpcbiAgICBjYXNlIFR5cGUuU0VROlxuICAgICAgcmV0dXJuIGRlZmF1bHRUYWdzLlNFUTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGVmYXVsdFRhZ3MuU1RSO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUYWcoZG9jLCBub2RlLCB0YWdOYW1lKSB7XG4gIHRyeSB7XG4gICAgdmFyIHJlcyA9IHJlc29sdmVCeVRhZ05hbWUoZG9jLCBub2RlLCB0YWdOYW1lKTtcblxuICAgIGlmIChyZXMpIHtcbiAgICAgIGlmICh0YWdOYW1lICYmIG5vZGUudGFnKSByZXMudGFnID0gdGFnTmFtZTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZXJyb3Iuc291cmNlKSBlcnJvci5zb3VyY2UgPSBub2RlO1xuICAgIGRvYy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBmYWxsYmFjayA9IGdldEZhbGxiYWNrVGFnTmFtZShub2RlKTtcbiAgICBpZiAoIWZhbGxiYWNrKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGFnIFwiLmNvbmNhdCh0YWdOYW1lLCBcIiBpcyB1bmF2YWlsYWJsZVwiKSk7XG4gICAgdmFyIG1zZyA9IFwiVGhlIHRhZyBcIi5jb25jYXQodGFnTmFtZSwgXCIgaXMgdW5hdmFpbGFibGUsIGZhbGxpbmcgYmFjayB0byBcIikuY29uY2F0KGZhbGxiYWNrKTtcbiAgICBkb2Mud2FybmluZ3MucHVzaChuZXcgWUFNTFdhcm5pbmcobm9kZSwgbXNnKSk7XG5cbiAgICB2YXIgX3JlcyA9IHJlc29sdmVCeVRhZ05hbWUoZG9jLCBub2RlLCBmYWxsYmFjayk7XG5cbiAgICBfcmVzLnRhZyA9IHRhZ05hbWU7XG4gICAgcmV0dXJuIF9yZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdmFyIHJlZkVycm9yID0gbmV3IFlBTUxSZWZlcmVuY2VFcnJvcihub2RlLCBlcnJvci5tZXNzYWdlKTtcbiAgICByZWZFcnJvci5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIGRvYy5lcnJvcnMucHVzaChyZWZFcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxudmFyIGlzQ29sbGVjdGlvbkl0ZW0gPSBmdW5jdGlvbiBpc0NvbGxlY3Rpb25JdGVtKG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICByZXR1cm4gdHlwZSA9PT0gVHlwZS5NQVBfS0VZIHx8IHR5cGUgPT09IFR5cGUuTUFQX1ZBTFVFIHx8IHR5cGUgPT09IFR5cGUuU0VRX0lURU07XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlTm9kZVByb3BzKGVycm9ycywgbm9kZSkge1xuICB2YXIgY29tbWVudHMgPSB7XG4gICAgYmVmb3JlOiBbXSxcbiAgICBhZnRlcjogW11cbiAgfTtcbiAgdmFyIGhhc0FuY2hvciA9IGZhbHNlO1xuICB2YXIgaGFzVGFnID0gZmFsc2U7XG4gIHZhciBwcm9wcyA9IGlzQ29sbGVjdGlvbkl0ZW0obm9kZS5jb250ZXh0LnBhcmVudCkgPyBub2RlLmNvbnRleHQucGFyZW50LnByb3BzLmNvbmNhdChub2RlLnByb3BzKSA6IG5vZGUucHJvcHM7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHByb3BzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgIHN0YXJ0ID0gX3N0ZXAkdmFsdWUuc3RhcnQsXG4gICAgICAgICAgZW5kID0gX3N0ZXAkdmFsdWUuZW5kO1xuXG4gICAgICBzd2l0Y2ggKG5vZGUuY29udGV4dC5zcmNbc3RhcnRdKSB7XG4gICAgICAgIGNhc2UgQ2hhci5DT01NRU5UOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5jb21tZW50SGFzUmVxdWlyZWRXaGl0ZXNwYWNlKHN0YXJ0KSkge1xuICAgICAgICAgICAgICB2YXIgbXNnID0gJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnO1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgbXNnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBub2RlLmhlYWRlcixcbiAgICAgICAgICAgICAgICB2YWx1ZVJhbmdlID0gbm9kZS52YWx1ZVJhbmdlO1xuICAgICAgICAgICAgdmFyIGNjID0gdmFsdWVSYW5nZSAmJiAoc3RhcnQgPiB2YWx1ZVJhbmdlLnN0YXJ0IHx8IGhlYWRlciAmJiBzdGFydCA+IGhlYWRlci5zdGFydCkgPyBjb21tZW50cy5hZnRlciA6IGNvbW1lbnRzLmJlZm9yZTtcbiAgICAgICAgICAgIGNjLnB1c2gobm9kZS5jb250ZXh0LnNyYy5zbGljZShzdGFydCArIDEsIGVuZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAvLyBBY3R1YWwgYW5jaG9yICYgdGFnIHJlc29sdXRpb24gaXMgaGFuZGxlZCBieSBzY2hlbWEsIGhlcmUgd2UganVzdCBjb21wbGFpblxuXG4gICAgICAgIGNhc2UgQ2hhci5BTkNIT1I6XG4gICAgICAgICAgaWYgKGhhc0FuY2hvcikge1xuICAgICAgICAgICAgdmFyIF9tc2cgPSAnQSBub2RlIGNhbiBoYXZlIGF0IG1vc3Qgb25lIGFuY2hvcic7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgX21zZykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhc0FuY2hvciA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDaGFyLlRBRzpcbiAgICAgICAgICBpZiAoaGFzVGFnKSB7XG4gICAgICAgICAgICB2YXIgX21zZzIgPSAnQSBub2RlIGNhbiBoYXZlIGF0IG1vc3Qgb25lIHRhZyc7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgX21zZzIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYXNUYWcgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21tZW50czogY29tbWVudHMsXG4gICAgaGFzQW5jaG9yOiBoYXNBbmNob3IsXG4gICAgaGFzVGFnOiBoYXNUYWdcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGVWYWx1ZShkb2MsIG5vZGUpIHtcbiAgdmFyIGFuY2hvcnMgPSBkb2MuYW5jaG9ycyxcbiAgICAgIGVycm9ycyA9IGRvYy5lcnJvcnMsXG4gICAgICBzY2hlbWEgPSBkb2Muc2NoZW1hO1xuXG4gIGlmIChub2RlLnR5cGUgPT09IFR5cGUuQUxJQVMpIHtcbiAgICB2YXIgbmFtZSA9IG5vZGUucmF3VmFsdWU7XG4gICAgdmFyIHNyYyA9IGFuY2hvcnMuZ2V0Tm9kZShuYW1lKTtcblxuICAgIGlmICghc3JjKSB7XG4gICAgICB2YXIgbXNnID0gXCJBbGlhc2VkIGFuY2hvciBub3QgZm91bmQ6IFwiLmNvbmNhdChuYW1lKTtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBZQU1MUmVmZXJlbmNlRXJyb3Iobm9kZSwgbXNnKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIExhenkgcmVzb2x1dGlvbiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlc1xuXG5cbiAgICB2YXIgcmVzID0gbmV3IEFsaWFzKHNyYyk7XG5cbiAgICBhbmNob3JzLl9jc3RBbGlhc2VzLnB1c2gocmVzKTtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICB2YXIgdGFnTmFtZSA9IHJlc29sdmVUYWdOYW1lKGRvYywgbm9kZSk7XG4gIGlmICh0YWdOYW1lKSByZXR1cm4gcmVzb2x2ZVRhZyhkb2MsIG5vZGUsIHRhZ05hbWUpO1xuXG4gIGlmIChub2RlLnR5cGUgIT09IFR5cGUuUExBSU4pIHtcbiAgICB2YXIgX21zZzMgPSBcIkZhaWxlZCB0byByZXNvbHZlIFwiLmNvbmNhdChub2RlLnR5cGUsIFwiIG5vZGUgaGVyZVwiKTtcblxuICAgIGVycm9ycy5wdXNoKG5ldyBZQU1MU3ludGF4RXJyb3Iobm9kZSwgX21zZzMpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIHN0ciA9IHJlc29sdmVTdHJpbmcoZG9jLCBub2RlKTtcbiAgICByZXR1cm4gcmVzb2x2ZVNjYWxhcihzdHIsIHNjaGVtYS50YWdzLCBzY2hlbWEudGFncy5zY2FsYXJGYWxsYmFjayk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFlcnJvci5zb3VyY2UpIGVycm9yLnNvdXJjZSA9IG5vZGU7XG4gICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59IC8vIHNldHMgbm9kZS5yZXNvbHZlZCBvbiBzdWNjZXNzXG5cblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUoZG9jLCBub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG4gIGlmIChub2RlLmVycm9yKSBkb2MuZXJyb3JzLnB1c2gobm9kZS5lcnJvcik7XG5cbiAgdmFyIF9yZXNvbHZlTm9kZVByb3BzID0gcmVzb2x2ZU5vZGVQcm9wcyhkb2MuZXJyb3JzLCBub2RlKSxcbiAgICAgIGNvbW1lbnRzID0gX3Jlc29sdmVOb2RlUHJvcHMuY29tbWVudHMsXG4gICAgICBoYXNBbmNob3IgPSBfcmVzb2x2ZU5vZGVQcm9wcy5oYXNBbmNob3IsXG4gICAgICBoYXNUYWcgPSBfcmVzb2x2ZU5vZGVQcm9wcy5oYXNUYWc7XG5cbiAgaWYgKGhhc0FuY2hvcikge1xuICAgIHZhciBhbmNob3JzID0gZG9jLmFuY2hvcnM7XG4gICAgdmFyIG5hbWUgPSBub2RlLmFuY2hvcjtcbiAgICB2YXIgcHJldiA9IGFuY2hvcnMuZ2V0Tm9kZShuYW1lKTsgLy8gQXQgdGhpcyBwb2ludCwgYWxpYXNlcyBmb3IgYW55IHByZWNlZGluZyBub2RlIHdpdGggdGhlIHNhbWUgYW5jaG9yXG4gICAgLy8gbmFtZSBoYXZlIGFscmVhZHkgYmVlbiByZXNvbHZlZCwgc28gaXQgbWF5IHNhZmVseSBiZSByZW5hbWVkLlxuXG4gICAgaWYgKHByZXYpIGFuY2hvcnMubWFwW2FuY2hvcnMubmV3TmFtZShuYW1lKV0gPSBwcmV2OyAvLyBEdXJpbmcgcGFyc2luZywgd2UgbmVlZCB0byBzdG9yZSB0aGUgQ1NUIG5vZGUgaW4gYW5jaG9ycy5tYXAgYXNcbiAgICAvLyBhbmNob3JzIG5lZWQgdG8gYmUgYXZhaWxhYmxlIGR1cmluZyByZXNvbHV0aW9uIHRvIGFsbG93IGZvclxuICAgIC8vIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG5cbiAgICBhbmNob3JzLm1hcFtuYW1lXSA9IG5vZGU7XG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSBUeXBlLkFMSUFTICYmIChoYXNBbmNob3IgfHwgaGFzVGFnKSkge1xuICAgIHZhciBtc2cgPSAnQW4gYWxpYXMgbm9kZSBtdXN0IG5vdCBzcGVjaWZ5IGFueSBwcm9wZXJ0aWVzJztcbiAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIG1zZykpO1xuICB9XG5cbiAgdmFyIHJlcyA9IHJlc29sdmVOb2RlVmFsdWUoZG9jLCBub2RlKTtcblxuICBpZiAocmVzKSB7XG4gICAgcmVzLnJhbmdlID0gW25vZGUucmFuZ2Uuc3RhcnQsIG5vZGUucmFuZ2UuZW5kXTtcbiAgICBpZiAoZG9jLm9wdGlvbnMua2VlcENzdE5vZGVzKSByZXMuY3N0Tm9kZSA9IG5vZGU7XG4gICAgaWYgKGRvYy5vcHRpb25zLmtlZXBOb2RlVHlwZXMpIHJlcy50eXBlID0gbm9kZS50eXBlO1xuICAgIHZhciBjYiA9IGNvbW1lbnRzLmJlZm9yZS5qb2luKCdcXG4nKTtcblxuICAgIGlmIChjYikge1xuICAgICAgcmVzLmNvbW1lbnRCZWZvcmUgPSByZXMuY29tbWVudEJlZm9yZSA/IFwiXCIuY29uY2F0KHJlcy5jb21tZW50QmVmb3JlLCBcIlxcblwiKS5jb25jYXQoY2IpIDogY2I7XG4gICAgfVxuXG4gICAgdmFyIGNhID0gY29tbWVudHMuYWZ0ZXIuam9pbignXFxuJyk7XG4gICAgaWYgKGNhKSByZXMuY29tbWVudCA9IHJlcy5jb21tZW50ID8gXCJcIi5jb25jYXQocmVzLmNvbW1lbnQsIFwiXFxuXCIpLmNvbmNhdChjYSkgOiBjYTtcbiAgfVxuXG4gIHJldHVybiBub2RlLnJlc29sdmVkID0gcmVzO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTWFwKGRvYywgY3N0KSB7XG4gIGlmIChjc3QudHlwZSAhPT0gVHlwZS5NQVAgJiYgY3N0LnR5cGUgIT09IFR5cGUuRkxPV19NQVApIHtcbiAgICB2YXIgbXNnID0gXCJBIFwiLmNvbmNhdChjc3QudHlwZSwgXCIgbm9kZSBjYW5ub3QgYmUgcmVzb2x2ZWQgYXMgYSBtYXBwaW5nXCIpO1xuICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFN5bnRheEVycm9yKGNzdCwgbXNnKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgX3JlZiA9IGNzdC50eXBlID09PSBUeXBlLkZMT1dfTUFQID8gcmVzb2x2ZUZsb3dNYXBJdGVtcyhkb2MsIGNzdCkgOiByZXNvbHZlQmxvY2tNYXBJdGVtcyhkb2MsIGNzdCksXG4gICAgICBjb21tZW50cyA9IF9yZWYuY29tbWVudHMsXG4gICAgICBpdGVtcyA9IF9yZWYuaXRlbXM7XG5cbiAgdmFyIG1hcCA9IG5ldyBZQU1MTWFwKCk7XG4gIG1hcC5pdGVtcyA9IGl0ZW1zO1xuICByZXNvbHZlQ29tbWVudHMobWFwLCBjb21tZW50cyk7XG4gIHZhciBoYXNDb2xsZWN0aW9uS2V5ID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpS2V5ID0gaXRlbXNbaV0ua2V5O1xuICAgIGlmIChpS2V5IGluc3RhbmNlb2YgQ29sbGVjdGlvbikgaGFzQ29sbGVjdGlvbktleSA9IHRydWU7XG5cbiAgICBpZiAoZG9jLnNjaGVtYS5tZXJnZSAmJiBpS2V5ICYmIGlLZXkudmFsdWUgPT09IE1FUkdFX0tFWSkge1xuICAgICAgaXRlbXNbaV0gPSBuZXcgTWVyZ2UoaXRlbXNbaV0pO1xuICAgICAgdmFyIHNvdXJjZXMgPSBpdGVtc1tpXS52YWx1ZS5pdGVtcztcbiAgICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgICBzb3VyY2VzLnNvbWUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBbGlhcykge1xuICAgICAgICAgIC8vIER1cmluZyBwYXJzaW5nLCBhbGlhcyBzb3VyY2VzIGFyZSBDU1Qgbm9kZXM7IHRvIGFjY291bnQgZm9yXG4gICAgICAgICAgLy8gY2lyY3VsYXIgcmVmZXJlbmNlcyB0aGVpciByZXNvbHZlZCB2YWx1ZXMgY2FuJ3QgYmUgdXNlZCBoZXJlLlxuICAgICAgICAgIHZhciB0eXBlID0gbm9kZS5zb3VyY2UudHlwZTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gVHlwZS5NQVAgfHwgdHlwZSA9PT0gVHlwZS5GTE9XX01BUCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHJldHVybiBlcnJvciA9ICdNZXJnZSBub2RlcyBhbGlhc2VzIGNhbiBvbmx5IHBvaW50IHRvIG1hcHMnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9yID0gJ01lcmdlIG5vZGVzIGNhbiBvbmx5IGhhdmUgQWxpYXMgbm9kZXMgYXMgdmFsdWVzJztcbiAgICAgIH0pO1xuICAgICAgaWYgKGVycm9yKSBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKGNzdCwgZXJyb3IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgaXRlbXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGpLZXkgPSBpdGVtc1tqXS5rZXk7XG5cbiAgICAgICAgaWYgKGlLZXkgPT09IGpLZXkgfHwgaUtleSAmJiBqS2V5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpS2V5LCAndmFsdWUnKSAmJiBpS2V5LnZhbHVlID09PSBqS2V5LnZhbHVlKSB7XG4gICAgICAgICAgdmFyIF9tc2cgPSBcIk1hcCBrZXlzIG11c3QgYmUgdW5pcXVlOyBcXFwiXCIuY29uY2F0KGlLZXksIFwiXFxcIiBpcyByZXBlYXRlZFwiKTtcblxuICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IoY3N0LCBfbXNnKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaGFzQ29sbGVjdGlvbktleSAmJiAhZG9jLm9wdGlvbnMubWFwQXNNYXApIHtcbiAgICB2YXIgd2FybiA9ICdLZXlzIHdpdGggY29sbGVjdGlvbiB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZCBhcyBZQU1MIGR1ZSB0byBKUyBPYmplY3QgcmVzdHJpY3Rpb25zLiBVc2UgbWFwQXNNYXA6IHRydWUgdG8gYXZvaWQgdGhpcy4nO1xuICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBZQU1MV2FybmluZyhjc3QsIHdhcm4pKTtcbiAgfVxuXG4gIGNzdC5yZXNvbHZlZCA9IG1hcDtcbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIHZhbHVlSGFzUGFpckNvbW1lbnQgPSBmdW5jdGlvbiB2YWx1ZUhhc1BhaXJDb21tZW50KF9yZWYyKSB7XG4gIHZhciBfcmVmMiRjb250ZXh0ID0gX3JlZjIuY29udGV4dCxcbiAgICAgIGxpbmVTdGFydCA9IF9yZWYyJGNvbnRleHQubGluZVN0YXJ0LFxuICAgICAgbm9kZSA9IF9yZWYyJGNvbnRleHQubm9kZSxcbiAgICAgIHNyYyA9IF9yZWYyJGNvbnRleHQuc3JjLFxuICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3RhcnQgPSBwcm9wc1swXS5zdGFydDtcbiAgaWYgKG5vZGUgJiYgc3RhcnQgPiBub2RlLnZhbHVlUmFuZ2Uuc3RhcnQpIHJldHVybiBmYWxzZTtcbiAgaWYgKHNyY1tzdGFydF0gIT09IENoYXIuQ09NTUVOVCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBsaW5lU3RhcnQ7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgaWYgKHNyY1tpXSA9PT0gJ1xcbicpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVBhaXJDb21tZW50KGl0ZW0sIHBhaXIpIHtcbiAgaWYgKCF2YWx1ZUhhc1BhaXJDb21tZW50KGl0ZW0pKSByZXR1cm47XG4gIHZhciBjb21tZW50ID0gaXRlbS5nZXRQcm9wVmFsdWUoMCwgQ2hhci5DT01NRU5ULCB0cnVlKTtcbiAgdmFyIGZvdW5kID0gZmFsc2U7XG4gIHZhciBjYiA9IHBhaXIudmFsdWUuY29tbWVudEJlZm9yZTtcblxuICBpZiAoY2IgJiYgY2Iuc3RhcnRzV2l0aChjb21tZW50KSkge1xuICAgIHBhaXIudmFsdWUuY29tbWVudEJlZm9yZSA9IGNiLnN1YnN0cihjb21tZW50Lmxlbmd0aCArIDEpO1xuICAgIGZvdW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2MgPSBwYWlyLnZhbHVlLmNvbW1lbnQ7XG5cbiAgICBpZiAoIWl0ZW0ubm9kZSAmJiBjYyAmJiBjYy5zdGFydHNXaXRoKGNvbW1lbnQpKSB7XG4gICAgICBwYWlyLnZhbHVlLmNvbW1lbnQgPSBjYy5zdWJzdHIoY29tbWVudC5sZW5ndGggKyAxKTtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZm91bmQpIHBhaXIuY29tbWVudCA9IGNvbW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVCbG9ja01hcEl0ZW1zKGRvYywgY3N0KSB7XG4gIHZhciBjb21tZW50cyA9IFtdO1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgdmFyIGtleSA9IHVuZGVmaW5lZDtcbiAgdmFyIGtleVN0YXJ0ID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNzdC5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpdGVtID0gY3N0Lml0ZW1zW2ldO1xuXG4gICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcbiAgICAgIGNhc2UgVHlwZS5CTEFOS19MSU5FOlxuICAgICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgICBhZnRlcktleTogISFrZXksXG4gICAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFR5cGUuQ09NTUVOVDpcbiAgICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgICAgYWZ0ZXJLZXk6ICEha2V5LFxuICAgICAgICAgIGJlZm9yZTogaXRlbXMubGVuZ3RoLFxuICAgICAgICAgIGNvbW1lbnQ6IGl0ZW0uY29tbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVHlwZS5NQVBfS0VZOlxuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gICAgICAgIGlmIChpdGVtLmVycm9yKSBkb2MuZXJyb3JzLnB1c2goaXRlbS5lcnJvcik7XG4gICAgICAgIGtleSA9IHJlc29sdmVOb2RlKGRvYywgaXRlbS5ub2RlKTtcbiAgICAgICAga2V5U3RhcnQgPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUeXBlLk1BUF9WQUxVRTpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkga2V5ID0gbnVsbDtcbiAgICAgICAgICBpZiAoaXRlbS5lcnJvcikgZG9jLmVycm9ycy5wdXNoKGl0ZW0uZXJyb3IpO1xuXG4gICAgICAgICAgaWYgKCFpdGVtLmNvbnRleHQuYXRMaW5lU3RhcnQgJiYgaXRlbS5ub2RlICYmIGl0ZW0ubm9kZS50eXBlID09PSBUeXBlLk1BUCAmJiAhaXRlbS5ub2RlLmNvbnRleHQuYXRMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnTmVzdGVkIG1hcHBpbmdzIGFyZSBub3QgYWxsb3dlZCBpbiBjb21wYWN0IG1hcHBpbmdzJztcbiAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IoaXRlbS5ub2RlLCBtc2cpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWVOb2RlID0gaXRlbS5ub2RlO1xuXG4gICAgICAgICAgaWYgKCF2YWx1ZU5vZGUgJiYgaXRlbS5wcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBDb21tZW50cyBvbiBhbiBlbXB0eSBtYXBwaW5nIHZhbHVlIG5lZWQgdG8gYmUgcHJlc2VydmVkLCBzbyB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byBjb25zdHJ1Y3QgYSBtaW5pbWFsIGVtcHR5IG5vZGUgaGVyZSB0byB1c2UgaW5zdGVhZCBvZiB0aGVcbiAgICAgICAgICAgIC8vIG1pc3NpbmcgYGl0ZW0ubm9kZWAuIC0tIGVlbWVsaS95YW1sIzE5XG4gICAgICAgICAgICB2YWx1ZU5vZGUgPSBuZXcgUGxhaW5WYWx1ZShUeXBlLlBMQUlOLCBbXSk7XG4gICAgICAgICAgICB2YWx1ZU5vZGUuY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiBpdGVtLFxuICAgICAgICAgICAgICBzcmM6IGl0ZW0uY29udGV4dC5zcmNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcG9zID0gaXRlbS5yYW5nZS5zdGFydCArIDE7XG4gICAgICAgICAgICB2YWx1ZU5vZGUucmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICAgICAgICAgIGVuZDogcG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWVOb2RlLnZhbHVlUmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICAgICAgICAgIGVuZDogcG9zXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0ucmFuZ2Uub3JpZ1N0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB2YXIgb3JpZ1BvcyA9IGl0ZW0ucmFuZ2Uub3JpZ1N0YXJ0ICsgMTtcbiAgICAgICAgICAgICAgdmFsdWVOb2RlLnJhbmdlLm9yaWdTdGFydCA9IHZhbHVlTm9kZS5yYW5nZS5vcmlnRW5kID0gb3JpZ1BvcztcbiAgICAgICAgICAgICAgdmFsdWVOb2RlLnZhbHVlUmFuZ2Uub3JpZ1N0YXJ0ID0gdmFsdWVOb2RlLnZhbHVlUmFuZ2Uub3JpZ0VuZCA9IG9yaWdQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhaXIgPSBuZXcgUGFpcihrZXksIHJlc29sdmVOb2RlKGRvYywgdmFsdWVOb2RlKSk7XG4gICAgICAgICAgcmVzb2x2ZVBhaXJDb21tZW50KGl0ZW0sIHBhaXIpO1xuICAgICAgICAgIGl0ZW1zLnB1c2gocGFpcik7XG5cbiAgICAgICAgICBpZiAoa2V5ICYmIHR5cGVvZiBrZXlTdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnJhbmdlLnN0YXJ0ID4ga2V5U3RhcnQgKyAxMDI0KSBkb2MuZXJyb3JzLnB1c2goZ2V0TG9uZ0tleUVycm9yKGNzdCwga2V5KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGtleVN0YXJ0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICAgICAgICBrZXkgPSByZXNvbHZlTm9kZShkb2MsIGl0ZW0pO1xuICAgICAgICBrZXlTdGFydCA9IGl0ZW0ucmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGlmIChpdGVtLmVycm9yKSBkb2MuZXJyb3JzLnB1c2goaXRlbS5lcnJvcik7XG5cbiAgICAgICAgbmV4dDogZm9yICh2YXIgaiA9IGkgKyAxOzsgKytqKSB7XG4gICAgICAgICAgdmFyIG5leHRJdGVtID0gY3N0Lml0ZW1zW2pdO1xuXG4gICAgICAgICAgc3dpdGNoIChuZXh0SXRlbSAmJiBuZXh0SXRlbS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFR5cGUuQkxBTktfTElORTpcbiAgICAgICAgICAgIGNhc2UgVHlwZS5DT01NRU5UOlxuICAgICAgICAgICAgICBjb250aW51ZSBuZXh0O1xuXG4gICAgICAgICAgICBjYXNlIFR5cGUuTUFQX1ZBTFVFOlxuICAgICAgICAgICAgICBicmVhayBuZXh0O1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIF9tc2cyID0gJ0ltcGxpY2l0IG1hcCBrZXlzIG5lZWQgdG8gYmUgZm9sbG93ZWQgYnkgbWFwIHZhbHVlcyc7XG4gICAgICAgICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihpdGVtLCBfbXNnMikpO1xuICAgICAgICAgICAgICAgIGJyZWFrIG5leHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS52YWx1ZVJhbmdlQ29udGFpbnNOZXdsaW5lKSB7XG4gICAgICAgICAgdmFyIF9tc2czID0gJ0ltcGxpY2l0IG1hcCBrZXlzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZSc7XG4gICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihpdGVtLCBfbXNnMykpO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gIHJldHVybiB7XG4gICAgY29tbWVudHM6IGNvbW1lbnRzLFxuICAgIGl0ZW1zOiBpdGVtc1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRmxvd01hcEl0ZW1zKGRvYywgY3N0KSB7XG4gIHZhciBjb21tZW50cyA9IFtdO1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgdmFyIGtleSA9IHVuZGVmaW5lZDtcbiAgdmFyIGV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gIHZhciBuZXh0ID0gJ3snO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3N0Lml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGl0ZW0gPSBjc3QuaXRlbXNbaV07XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0uY2hhciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBjaGFyID0gaXRlbS5jaGFyLFxuICAgICAgICAgIG9mZnNldCA9IGl0ZW0ub2Zmc2V0O1xuXG4gICAgICBpZiAoY2hhciA9PT0gJz8nICYmIGtleSA9PT0gdW5kZWZpbmVkICYmICFleHBsaWNpdEtleSkge1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgICAgIG5leHQgPSAnOic7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhciA9PT0gJzonKSB7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkga2V5ID0gbnVsbDtcblxuICAgICAgICBpZiAobmV4dCA9PT0gJzonKSB7XG4gICAgICAgICAgbmV4dCA9ICcsJztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkICYmIGNoYXIgIT09ICcsJykga2V5ID0gbnVsbDtcbiAgICAgICAgICBleHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoY2hhciA9PT0gJywnKSB7XG4gICAgICAgICAgICBuZXh0ID0gJzonO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFyID09PSAnfScpIHtcbiAgICAgICAgaWYgKGkgPT09IGNzdC5pdGVtcy5sZW5ndGggLSAxKSBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gbmV4dCkge1xuICAgICAgICBuZXh0ID0gJzonO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1zZyA9IFwiRmxvdyBtYXAgY29udGFpbnMgYW4gdW5leHBlY3RlZCBcIi5jb25jYXQoY2hhcik7XG4gICAgICB2YXIgZXJyID0gbmV3IFlBTUxTeW50YXhFcnJvcihjc3QsIG1zZyk7XG4gICAgICBlcnIub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgZG9jLmVycm9ycy5wdXNoKGVycik7XG4gICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFR5cGUuQkxBTktfTElORSkge1xuICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgIGFmdGVyS2V5OiAhIWtleSxcbiAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBUeXBlLkNPTU1FTlQpIHtcbiAgICAgIGNoZWNrRmxvd0NvbW1lbnRTcGFjZShkb2MuZXJyb3JzLCBpdGVtKTtcbiAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICBhZnRlcktleTogISFrZXksXG4gICAgICAgIGJlZm9yZTogaXRlbXMubGVuZ3RoLFxuICAgICAgICBjb21tZW50OiBpdGVtLmNvbW1lbnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChuZXh0ID09PSAnLCcpIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgJ1NlcGFyYXRvciAsIG1pc3NpbmcgaW4gZmxvdyBtYXAnKSk7XG4gICAgICBrZXkgPSByZXNvbHZlTm9kZShkb2MsIGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dCAhPT0gJywnKSBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKGl0ZW0sICdJbmRpY2F0b3IgOiBtaXNzaW5nIGluIGZsb3cgbWFwIGVudHJ5JykpO1xuICAgICAgaXRlbXMucHVzaChuZXcgUGFpcihrZXksIHJlc29sdmVOb2RlKGRvYywgaXRlbSkpKTtcbiAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICAgIGV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tGbG93Q29sbGVjdGlvbkVuZChkb2MuZXJyb3JzLCBjc3QpO1xuICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gIHJldHVybiB7XG4gICAgY29tbWVudHM6IGNvbW1lbnRzLFxuICAgIGl0ZW1zOiBpdGVtc1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2VxKGRvYywgY3N0KSB7XG4gIGlmIChjc3QudHlwZSAhPT0gVHlwZS5TRVEgJiYgY3N0LnR5cGUgIT09IFR5cGUuRkxPV19TRVEpIHtcbiAgICB2YXIgbXNnID0gXCJBIFwiLmNvbmNhdChjc3QudHlwZSwgXCIgbm9kZSBjYW5ub3QgYmUgcmVzb2x2ZWQgYXMgYSBzZXF1ZW5jZVwiKTtcbiAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTeW50YXhFcnJvcihjc3QsIG1zZykpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBjc3QudHlwZSA9PT0gVHlwZS5GTE9XX1NFUSA/IHJlc29sdmVGbG93U2VxSXRlbXMoZG9jLCBjc3QpIDogcmVzb2x2ZUJsb2NrU2VxSXRlbXMoZG9jLCBjc3QpLFxuICAgICAgY29tbWVudHMgPSBfcmVmLmNvbW1lbnRzLFxuICAgICAgaXRlbXMgPSBfcmVmLml0ZW1zO1xuXG4gIHZhciBzZXEgPSBuZXcgWUFNTFNlcSgpO1xuICBzZXEuaXRlbXMgPSBpdGVtcztcbiAgcmVzb2x2ZUNvbW1lbnRzKHNlcSwgY29tbWVudHMpO1xuXG4gIGlmICghZG9jLm9wdGlvbnMubWFwQXNNYXAgJiYgaXRlbXMuc29tZShmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXQgaW5zdGFuY2VvZiBQYWlyICYmIGl0LmtleSBpbnN0YW5jZW9mIENvbGxlY3Rpb247XG4gIH0pKSB7XG4gICAgdmFyIHdhcm4gPSAnS2V5cyB3aXRoIGNvbGxlY3Rpb24gdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWQgYXMgWUFNTCBkdWUgdG8gSlMgT2JqZWN0IHJlc3RyaWN0aW9ucy4gVXNlIG1hcEFzTWFwOiB0cnVlIHRvIGF2b2lkIHRoaXMuJztcbiAgICBkb2Mud2FybmluZ3MucHVzaChuZXcgWUFNTFdhcm5pbmcoY3N0LCB3YXJuKSk7XG4gIH1cblxuICBjc3QucmVzb2x2ZWQgPSBzZXE7XG4gIHJldHVybiBzZXE7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVCbG9ja1NlcUl0ZW1zKGRvYywgY3N0KSB7XG4gIHZhciBjb21tZW50cyA9IFtdO1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNzdC5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpdGVtID0gY3N0Lml0ZW1zW2ldO1xuXG4gICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcbiAgICAgIGNhc2UgVHlwZS5CTEFOS19MSU5FOlxuICAgICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVHlwZS5DT01NRU5UOlxuICAgICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgICBjb21tZW50OiBpdGVtLmNvbW1lbnQsXG4gICAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFR5cGUuU0VRX0lURU06XG4gICAgICAgIGlmIChpdGVtLmVycm9yKSBkb2MuZXJyb3JzLnB1c2goaXRlbS5lcnJvcik7XG4gICAgICAgIGl0ZW1zLnB1c2gocmVzb2x2ZU5vZGUoZG9jLCBpdGVtLm5vZGUpKTtcblxuICAgICAgICBpZiAoaXRlbS5oYXNQcm9wcykge1xuICAgICAgICAgIHZhciBtc2cgPSAnU2VxdWVuY2UgaXRlbXMgY2Fubm90IGhhdmUgdGFncyBvciBhbmNob3JzIGJlZm9yZSB0aGUgLSBpbmRpY2F0b3InO1xuICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgbXNnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGl0ZW0uZXJyb3IpIGRvYy5lcnJvcnMucHVzaChpdGVtLmVycm9yKTtcbiAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MU3ludGF4RXJyb3IoaXRlbSwgXCJVbmV4cGVjdGVkIFwiLmNvbmNhdChpdGVtLnR5cGUsIFwiIG5vZGUgaW4gc2VxdWVuY2VcIikpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbW1lbnRzOiBjb21tZW50cyxcbiAgICBpdGVtczogaXRlbXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZsb3dTZXFJdGVtcyhkb2MsIGNzdCkge1xuICB2YXIgY29tbWVudHMgPSBbXTtcbiAgdmFyIGl0ZW1zID0gW107XG4gIHZhciBleHBsaWNpdEtleSA9IGZhbHNlO1xuICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuICB2YXIga2V5U3RhcnQgPSBudWxsO1xuICB2YXIgbmV4dCA9ICdbJztcbiAgdmFyIHByZXZJdGVtID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNzdC5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpdGVtID0gY3N0Lml0ZW1zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVtLmNoYXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgY2hhciA9IGl0ZW0uY2hhcixcbiAgICAgICAgICBvZmZzZXQgPSBpdGVtLm9mZnNldDtcblxuICAgICAgaWYgKGNoYXIgIT09ICc6JyAmJiAoZXhwbGljaXRLZXkgfHwga2V5ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIGlmIChleHBsaWNpdEtleSAmJiBrZXkgPT09IHVuZGVmaW5lZCkga2V5ID0gbmV4dCA/IGl0ZW1zLnBvcCgpIDogbnVsbDtcbiAgICAgICAgaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgICAgICAgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBrZXlTdGFydCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFyID09PSBuZXh0KSB7XG4gICAgICAgIG5leHQgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghbmV4dCAmJiBjaGFyID09PSAnPycpIHtcbiAgICAgICAgZXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChuZXh0ICE9PSAnWycgJiYgY2hhciA9PT0gJzonICYmIGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChuZXh0ID09PSAnLCcpIHtcbiAgICAgICAgICBrZXkgPSBpdGVtcy5wb3AoKTtcblxuICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBQYWlyKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ0NoYWluaW5nIGZsb3cgc2VxdWVuY2UgcGFpcnMgaXMgaW52YWxpZCc7XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IFlBTUxTZW1hbnRpY0Vycm9yKGNzdCwgbXNnKTtcbiAgICAgICAgICAgIGVyci5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWV4cGxpY2l0S2V5ICYmIHR5cGVvZiBrZXlTdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBrZXlFbmQgPSBpdGVtLnJhbmdlID8gaXRlbS5yYW5nZS5zdGFydCA6IGl0ZW0ub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGtleUVuZCA+IGtleVN0YXJ0ICsgMTAyNCkgZG9jLmVycm9ycy5wdXNoKGdldExvbmdLZXlFcnJvcihjc3QsIGtleSkpO1xuICAgICAgICAgICAgdmFyIHNyYyA9IHByZXZJdGVtLmNvbnRleHQuc3JjO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IGtleVN0YXJ0OyBfaSA8IGtleUVuZDsgKytfaSkge1xuICAgICAgICAgICAgICBpZiAoc3JjW19pXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgX21zZyA9ICdJbXBsaWNpdCBrZXlzIG9mIGZsb3cgc2VxdWVuY2UgcGFpcnMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJztcbiAgICAgICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKHByZXZJdGVtLCBfbXNnKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleVN0YXJ0ID0gbnVsbDtcbiAgICAgICAgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKG5leHQgPT09ICdbJyB8fCBjaGFyICE9PSAnXScgfHwgaSA8IGNzdC5pdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHZhciBfbXNnMiA9IFwiRmxvdyBzZXF1ZW5jZSBjb250YWlucyBhbiB1bmV4cGVjdGVkIFwiLmNvbmNhdChjaGFyKTtcblxuICAgICAgICB2YXIgX2VyciA9IG5ldyBZQU1MU3ludGF4RXJyb3IoY3N0LCBfbXNnMik7XG5cbiAgICAgICAgX2Vyci5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGRvYy5lcnJvcnMucHVzaChfZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gVHlwZS5CTEFOS19MSU5FKSB7XG4gICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBUeXBlLkNPTU1FTlQpIHtcbiAgICAgIGNoZWNrRmxvd0NvbW1lbnRTcGFjZShkb2MuZXJyb3JzLCBpdGVtKTtcbiAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICBjb21tZW50OiBpdGVtLmNvbW1lbnQsXG4gICAgICAgIGJlZm9yZTogaXRlbXMubGVuZ3RoXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgdmFyIF9tc2czID0gXCJFeHBlY3RlZCBhIFwiLmNvbmNhdChuZXh0LCBcIiBpbiBmbG93IHNlcXVlbmNlXCIpO1xuXG4gICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgX21zZzMpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gcmVzb2x2ZU5vZGUoZG9jLCBpdGVtKTtcblxuICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICBwcmV2SXRlbSA9IGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSwgdmFsdWUpKTtcbiAgICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBrZXlTdGFydCA9IGl0ZW0ucmFuZ2Uuc3RhcnQ7XG4gICAgICBuZXh0ID0gJywnO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRmxvd0NvbGxlY3Rpb25FbmQoZG9jLmVycm9ycywgY3N0KTtcbiAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICByZXR1cm4ge1xuICAgIGNvbW1lbnRzOiBjb21tZW50cyxcbiAgICBpdGVtczogaXRlbXNcbiAgfTtcbn1cblxuZXhwb3J0IHsgQWxpYXMgYXMgQSwgQ29sbGVjdGlvbiBhcyBDLCBNZXJnZSBhcyBNLCBOb2RlIGFzIE4sIFBhaXIgYXMgUCwgU2NhbGFyIGFzIFMsIFlBTUxTZXEgYXMgWSwgYm9vbE9wdGlvbnMgYXMgYSwgYmluYXJ5T3B0aW9ucyBhcyBiLCBzdHJpbmdpZnlTdHJpbmcgYXMgYywgWUFNTE1hcCBhcyBkLCBpc0VtcHR5UGF0aCBhcyBlLCBhZGRDb21tZW50IGFzIGYsIHJlc29sdmVNYXAgYXMgZywgcmVzb2x2ZVNlcSBhcyBoLCBpbnRPcHRpb25zIGFzIGksIHJlc29sdmVTdHJpbmcgYXMgaiwgc3RyaW5naWZ5TnVtYmVyIGFzIGssIGZpbmRQYWlyIGFzIGwsIG51bGxPcHRpb25zIGFzIG4sIHJlc29sdmVOb2RlIGFzIHIsIHN0ck9wdGlvbnMgYXMgcywgdG9KU09OIGFzIHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/resolveSeq-492ab440.js\n")},"./node_modules/yaml/browser/dist/warnings-df54cb69.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"a\": () => (/* binding */ warnOptionDeprecation),\n/* harmony export */   \"b\": () => (/* binding */ binary),\n/* harmony export */   \"c\": () => (/* binding */ warnFileDeprecation),\n/* harmony export */   \"f\": () => (/* binding */ floatTime),\n/* harmony export */   \"i\": () => (/* binding */ intTime),\n/* harmony export */   \"o\": () => (/* binding */ omap),\n/* harmony export */   \"p\": () => (/* binding */ pairs),\n/* harmony export */   \"s\": () => (/* binding */ set),\n/* harmony export */   \"t\": () => (/* binding */ timestamp),\n/* harmony export */   \"w\": () => (/* binding */ warn)\n/* harmony export */ });\n/* harmony import */ var _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlainValue-b8036b75.js */ \"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\");\n/* harmony import */ var _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolveSeq-492ab440.js */ \"./node_modules/yaml/browser/dist/resolveSeq-492ab440.js\");\n\n\n\n/* global atob, btoa, Buffer */\nvar binary = {\n  identify: function identify(value) {\n    return value instanceof Uint8Array;\n  },\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: function resolve(doc, node) {\n    var src = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.j)(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      var str = atob(src.replace(/[\\n\\r]/g, ''));\n      var buffer = new Uint8Array(str.length);\n\n      for (var i = 0; i < str.length; ++i) {\n        buffer[i] = str.charCodeAt(i);\n      }\n\n      return buffer;\n    } else {\n      var msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.o(node, msg));\n      return null;\n    }\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.b,\n  stringify: function stringify(_ref, ctx, onComment, onChompKeep) {\n    var comment = _ref.comment,\n        type = _ref.type,\n        value = _ref.value;\n    var src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      var s = '';\n\n      for (var i = 0; i < value.length; ++i) {\n        s += String.fromCharCode(value[i]);\n      }\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.b.defaultType;\n\n    if (type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      var lineWidth = _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.b.lineWidth;\n      var n = Math.ceil(src.length / lineWidth);\n      var lines = new Array(n);\n\n      for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) {\n        lines[_i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.c)({\n      comment: comment,\n      type: type,\n      value: value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  var seq = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.h)(doc, cst);\n\n  for (var i = 0; i < seq.items.length; ++i) {\n    var item = seq.items[i];\n    if (item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P) continue;else if (item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d) {\n      if (item.items.length > 1) {\n        var msg = 'Each pair must have its own sequence indicator';\n        throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, msg);\n      }\n\n      var pair = item.items[0] || new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? \"\".concat(item.commentBefore, \"\\n\").concat(pair.commentBefore) : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? \"\".concat(item.comment, \"\\n\").concat(pair.comment) : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P ? item : new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P(item);\n  }\n\n  return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n  var pairs = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.Y(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(iterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var it = _step.value;\n      var key = void 0,\n          value = void 0;\n\n      if (Array.isArray(it)) {\n        if (it.length === 2) {\n          key = it[0];\n          value = it[1];\n        } else throw new TypeError(\"Expected [key, value] tuple: \".concat(it));\n      } else if (it && it instanceof Object) {\n        var keys = Object.keys(it);\n\n        if (keys.length === 1) {\n          key = keys[0];\n          value = it[key];\n        } else throw new TypeError(\"Expected { key: value } tuple: \".concat(it));\n      } else {\n        key = it;\n      }\n\n      var pair = schema.createPair(key, value, ctx);\n      pairs.items.push(pair);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return pairs;\n}\nvar pairs = {\n  default: false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nvar YAMLOMap = /*#__PURE__*/function (_YAMLSeq) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(YAMLOMap, _YAMLSeq);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(YAMLOMap);\n\n  function YAMLOMap() {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, YAMLOMap);\n\n    _this = _super.call(this);\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"add\", _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d.prototype.add.bind((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this)));\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"delete\", _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d.prototype[\"delete\"].bind((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this)));\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"get\", _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d.prototype.get.bind((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this)));\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"has\", _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d.prototype.has.bind((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this)));\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"set\", _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d.prototype.set.bind((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this)));\n\n    _this.tag = YAMLOMap.tag;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(YAMLOMap, [{\n    key: \"toJSON\",\n    value: function toJSON$1(_, ctx) {\n      var map = new Map();\n      if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n      var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pair = _step.value;\n          var key = void 0,\n              value = void 0;\n\n          if (pair instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P) {\n            key = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.t)(pair.key, '', ctx);\n            value = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.t)(pair.value, key, ctx);\n          } else {\n            key = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.t)(pair, '', ctx);\n          }\n\n          if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n          map.set(key, value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return map;\n    }\n  }]);\n\n  return YAMLOMap;\n}(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.Y);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  var pairs = parsePairs(doc, cst);\n  var seenKeys = [];\n\n  var _iterator2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(pairs.items),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value.key;\n\n      if (key instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S) {\n        if (seenKeys.includes(key.value)) {\n          var msg = 'Ordered maps must not include duplicate keys';\n          throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, msg);\n        } else {\n          seenKeys.push(key.value);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  var pairs = createPairs(schema, iterable, ctx);\n  var omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nvar omap = {\n  identify: function identify(value) {\n    return value instanceof Map;\n  },\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nvar YAMLSet = /*#__PURE__*/function (_YAMLMap) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(YAMLSet, _YAMLMap);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(YAMLSet);\n\n  function YAMLSet() {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, YAMLSet);\n\n    _this = _super.call(this);\n    _this.tag = YAMLSet.tag;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(YAMLSet, [{\n    key: \"add\",\n    value: function add(key) {\n      var pair = key instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P ? key : new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P(key);\n      var prev = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.l)(this.items, pair.key);\n      if (!prev) this.items.push(pair);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepPair) {\n      var pair = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.l)(this.items, key);\n      return !keepPair && pair instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P ? pair.key instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S ? pair.key.value : pair.key : pair;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      if (typeof value !== 'boolean') throw new Error(\"Expected boolean value for set(key, value) in a YAML set, not \".concat((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(value)));\n      var prev = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.l)(this.items, key);\n\n      if (prev && !value) {\n        this.items.splice(this.items.indexOf(prev), 1);\n      } else if (!prev && value) {\n        this.items.push(new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P(key));\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx) {\n      return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(YAMLSet.prototype), \"toJSON\", this).call(this, _, ctx, Set);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n      if (this.hasAllNullValues()) return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(YAMLSet.prototype), \"toString\", this).call(this, ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n    }\n  }]);\n\n  return YAMLSet;\n}(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  var map = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.g)(doc, cst);\n  if (!map.hasAllNullValues()) throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  var set = new YAMLSet();\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(iterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var value = _step.value;\n      set.items.push(schema.createPair(value, null, ctx));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return set;\n}\n\nvar set = {\n  identify: function identify(value) {\n    return value instanceof Set;\n  },\n  nodeClass: YAMLSet,\n  default: false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nvar parseSexagesimal = function parseSexagesimal(sign, parts) {\n  var n = parts.split(':').reduce(function (n, p) {\n    return n * 60 + Number(p);\n  }, 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nvar stringifySexagesimal = function stringifySexagesimal(_ref) {\n  var value = _ref.value;\n  if (isNaN(value) || !isFinite(value)) return (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k)(value);\n  var sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  var parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(function (n) {\n    return n < 10 ? '0' + String(n) : String(n);\n  }).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nvar intTime = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: function resolve(str, sign, parts) {\n    return parseSexagesimal(sign, parts.replace(/_/g, ''));\n  },\n  stringify: stringifySexagesimal\n};\nvar floatTime = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: function resolve(str, sign, parts) {\n    return parseSexagesimal(sign, parts.replace(/_/g, ''));\n  },\n  stringify: stringifySexagesimal\n};\nvar timestamp = {\n  identify: function identify(value) {\n    return value instanceof Date;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: function resolve(str, year, month, day, hour, minute, second, millisec, tz) {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      var d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '');\n  }\n};\n\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\nfunction shouldWarn(deprecation) {\n  var env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    var emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? \"\".concat(type, \": \").concat(warning) : warning);\n    }\n  }\n}\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    var path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(\"The endpoint 'yaml/\".concat(path, \"' will be removed in a future release.\"), 'DeprecationWarning');\n  }\n}\nvar warned = {};\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    var msg = \"The option '\".concat(name, \"' will be removed in a future release\");\n    msg += alternative ? \", use '\".concat(alternative, \"' instead.\") : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvd2FybmluZ3MtZGY1NGNiNjkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXFUO0FBQ3JFOztBQUVoUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsY0FBYywwREFBYTs7QUFFM0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLHdFQUF3RTtBQUN4RSwwQkFBMEIsc0RBQWtCO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVyxzREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLDhFQUE4RTtBQUM5RTs7QUFFQSxzQkFBc0Isa0VBQXlCOztBQUUvQyxpQkFBaUIsbUVBQWlCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixnRUFBdUI7QUFDN0M7QUFDQTs7QUFFQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBOztBQUVBLGtDQUFrQyxvRUFBa0I7QUFDcEQ7O0FBRUEsV0FBVywwREFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFlBQVksMERBQVU7O0FBRXRCLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQSx3QkFBd0Isc0RBQUksV0FBVyx5QkFBeUIsc0RBQU87QUFDdkU7QUFDQTtBQUNBLGtCQUFrQixzREFBaUI7QUFDbkM7O0FBRUEsc0NBQXNDLHNEQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFJLGNBQWMsc0RBQUk7QUFD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O0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9wLXh5ei8uL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC93YXJuaW5ncy1kZjU0Y2I2OS5qcz82NDdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG8gYXMgWUFNTFJlZmVyZW5jZUVycm9yLCBUIGFzIFR5cGUsIGcgYXMgWUFNTFNlbWFudGljRXJyb3IsIF8gYXMgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIsIGUgYXMgX2RlZmluZVByb3BlcnR5LCBqIGFzIF9pbmhlcml0cywgayBhcyBfY3JlYXRlU3VwZXIsIGMgYXMgX2NsYXNzQ2FsbENoZWNrLCBwIGFzIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQsIGIgYXMgX2NyZWF0ZUNsYXNzLCBhIGFzIF90eXBlb2YsIGwgYXMgX2dldCwgbSBhcyBfZ2V0UHJvdG90eXBlT2YgfSBmcm9tICcuL1BsYWluVmFsdWUtYjgwMzZiNzUuanMnO1xuaW1wb3J0IHsgaiBhcyByZXNvbHZlU3RyaW5nLCBiIGFzIGJpbmFyeU9wdGlvbnMsIGMgYXMgc3RyaW5naWZ5U3RyaW5nLCBoIGFzIHJlc29sdmVTZXEsIFAgYXMgUGFpciwgZCBhcyBZQU1MTWFwLCBZIGFzIFlBTUxTZXEsIHQgYXMgdG9KU09OLCBTIGFzIFNjYWxhciwgbCBhcyBmaW5kUGFpciwgZyBhcyByZXNvbHZlTWFwLCBrIGFzIHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4vcmVzb2x2ZVNlcS00OTJhYjQ0MC5qcyc7XG5cbi8qIGdsb2JhbCBhdG9iLCBidG9hLCBCdWZmZXIgKi9cbnZhciBiaW5hcnkgPSB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gIH0sXG4gIC8vIEJ1ZmZlciBpbmhlcml0cyBmcm9tIFVpbnQ4QXJyYXlcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCdWZmZXIgaW4gbm9kZSBhbmQgYW4gVWludDhBcnJheSBpbiBicm93c2Vyc1xuICAgKlxuICAgKiBUbyB1c2UgdGhlIHJlc3VsdGluZyBidWZmZXIgYXMgYW4gaW1hZ2UsIHlvdSdsbCB3YW50IHRvIGRvIHNvbWV0aGluZyBsaWtlOlxuICAgKlxuICAgKiAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvdG8nKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAqL1xuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKGRvYywgbm9kZSkge1xuICAgIHZhciBzcmMgPSByZXNvbHZlU3RyaW5nKGRvYywgbm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNyYywgJ2Jhc2U2NCcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIE9uIElFIDExLCBhdG9iKCkgY2FuJ3QgaGFuZGxlIG5ld2xpbmVzXG4gICAgICB2YXIgc3RyID0gYXRvYihzcmMucmVwbGFjZSgvW1xcblxccl0vZywgJycpKTtcbiAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYnVmZmVyW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtc2cgPSAnVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IHJlYWRpbmcgYmluYXJ5IHRhZ3M7IGVpdGhlciBCdWZmZXIgb3IgYXRvYiBpcyByZXF1aXJlZCc7XG4gICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxSZWZlcmVuY2VFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgb3B0aW9uczogYmluYXJ5T3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoX3JlZiwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgdmFyIGNvbW1lbnQgPSBfcmVmLmNvbW1lbnQsXG4gICAgICAgIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICB2YXIgc3JjO1xuXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNyYyA9IHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyID8gdmFsdWUudG9TdHJpbmcoJ2Jhc2U2NCcpIDogQnVmZmVyLmZyb20odmFsdWUuYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHMgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWVbaV0pO1xuICAgICAgfVxuXG4gICAgICBzcmMgPSBidG9hKHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB3cml0aW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGJ0b2EgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHR5cGUgPSBiaW5hcnlPcHRpb25zLmRlZmF1bHRUeXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IFR5cGUuUVVPVEVfRE9VQkxFKSB7XG4gICAgICB2YWx1ZSA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IGJpbmFyeU9wdGlvbnMubGluZVdpZHRoO1xuICAgICAgdmFyIG4gPSBNYXRoLmNlaWwoc3JjLmxlbmd0aCAvIGxpbmVXaWR0aCk7XG4gICAgICB2YXIgbGluZXMgPSBuZXcgQXJyYXkobik7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMCwgbyA9IDA7IF9pIDwgbjsgKytfaSwgbyArPSBsaW5lV2lkdGgpIHtcbiAgICAgICAgbGluZXNbX2ldID0gc3JjLnN1YnN0cihvLCBsaW5lV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGxpbmVzLmpvaW4odHlwZSA9PT0gVHlwZS5CTE9DS19MSVRFUkFMID8gJ1xcbicgOiAnICcpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcoe1xuICAgICAgY29tbWVudDogY29tbWVudCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJzZVBhaXJzKGRvYywgY3N0KSB7XG4gIHZhciBzZXEgPSByZXNvbHZlU2VxKGRvYywgY3N0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcS5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpdGVtID0gc2VxLml0ZW1zW2ldO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUGFpcikgY29udGludWU7ZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIFlBTUxNYXApIHtcbiAgICAgIGlmIChpdGVtLml0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIG1zZyA9ICdFYWNoIHBhaXIgbXVzdCBoYXZlIGl0cyBvd24gc2VxdWVuY2UgaW5kaWNhdG9yJztcbiAgICAgICAgdGhyb3cgbmV3IFlBTUxTZW1hbnRpY0Vycm9yKGNzdCwgbXNnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhaXIgPSBpdGVtLml0ZW1zWzBdIHx8IG5ldyBQYWlyKCk7XG4gICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKSBwYWlyLmNvbW1lbnRCZWZvcmUgPSBwYWlyLmNvbW1lbnRCZWZvcmUgPyBcIlwiLmNvbmNhdChpdGVtLmNvbW1lbnRCZWZvcmUsIFwiXFxuXCIpLmNvbmNhdChwYWlyLmNvbW1lbnRCZWZvcmUpIDogaXRlbS5jb21tZW50QmVmb3JlO1xuICAgICAgaWYgKGl0ZW0uY29tbWVudCkgcGFpci5jb21tZW50ID0gcGFpci5jb21tZW50ID8gXCJcIi5jb25jYXQoaXRlbS5jb21tZW50LCBcIlxcblwiKS5jb25jYXQocGFpci5jb21tZW50KSA6IGl0ZW0uY29tbWVudDtcbiAgICAgIGl0ZW0gPSBwYWlyO1xuICAgIH1cbiAgICBzZXEuaXRlbXNbaV0gPSBpdGVtIGluc3RhbmNlb2YgUGFpciA/IGl0ZW0gOiBuZXcgUGFpcihpdGVtKTtcbiAgfVxuXG4gIHJldHVybiBzZXE7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWlycyhzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgdmFyIHBhaXJzID0gbmV3IFlBTUxTZXEoc2NoZW1hKTtcbiAgcGFpcnMudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJztcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaXRlcmFibGUpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGl0ID0gX3N0ZXAudmFsdWU7XG4gICAgICB2YXIga2V5ID0gdm9pZCAwLFxuICAgICAgICAgIHZhbHVlID0gdm9pZCAwO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdCkpIHtcbiAgICAgICAgaWYgKGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGtleSA9IGl0WzBdO1xuICAgICAgICAgIHZhbHVlID0gaXRbMV07XG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgW2tleSwgdmFsdWVdIHR1cGxlOiBcIi5jb25jYXQoaXQpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXQgJiYgaXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhpdCk7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1swXTtcbiAgICAgICAgICB2YWx1ZSA9IGl0W2tleV07XG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgeyBrZXk6IHZhbHVlIH0gdHVwbGU6IFwiLmNvbmNhdChpdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gaXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWlyID0gc2NoZW1hLmNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgY3R4KTtcbiAgICAgIHBhaXJzLml0ZW1zLnB1c2gocGFpcik7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICByZXR1cm4gcGFpcnM7XG59XG52YXIgcGFpcnMgPSB7XG4gIGRlZmF1bHQ6IGZhbHNlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsXG4gIHJlc29sdmU6IHBhcnNlUGFpcnMsXG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZVBhaXJzXG59O1xuXG52YXIgWUFNTE9NYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9ZQU1MU2VxKSB7XG4gIF9pbmhlcml0cyhZQU1MT01hcCwgX1lBTUxTZXEpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoWUFNTE9NYXApO1xuXG4gIGZ1bmN0aW9uIFlBTUxPTWFwKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBZQU1MT01hcCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImFkZFwiLCBZQU1MTWFwLnByb3RvdHlwZS5hZGQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRlbGV0ZVwiLCBZQU1MTWFwLnByb3RvdHlwZS5kZWxldGUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdldFwiLCBZQU1MTWFwLnByb3RvdHlwZS5nZXQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhc1wiLCBZQU1MTWFwLnByb3RvdHlwZS5oYXMuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNldFwiLCBZQU1MTWFwLnByb3RvdHlwZS5zZXQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuXG4gICAgX3RoaXMudGFnID0gWUFNTE9NYXAudGFnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhZQU1MT01hcCwgW3tcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTiQxKF8sIGN0eCkge1xuICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKSBjdHgub25DcmVhdGUobWFwKTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuaXRlbXMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwYWlyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGtleSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgdmFsdWUgPSB2b2lkIDA7XG5cbiAgICAgICAgICBpZiAocGFpciBpbnN0YW5jZW9mIFBhaXIpIHtcbiAgICAgICAgICAgIGtleSA9IHRvSlNPTihwYWlyLmtleSwgJycsIGN0eCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvSlNPTihwYWlyLnZhbHVlLCBrZXksIGN0eCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IHRvSlNPTihwYWlyLCAnJywgY3R4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWFwLmhhcyhrZXkpKSB0aHJvdyBuZXcgRXJyb3IoJ09yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzJyk7XG4gICAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBZQU1MT01hcDtcbn0oWUFNTFNlcSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShZQU1MT01hcCwgXCJ0YWdcIiwgJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnKTtcblxuZnVuY3Rpb24gcGFyc2VPTWFwKGRvYywgY3N0KSB7XG4gIHZhciBwYWlycyA9IHBhcnNlUGFpcnMoZG9jLCBjc3QpO1xuICB2YXIgc2VlbktleXMgPSBbXTtcblxuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBhaXJzLml0ZW1zKSxcbiAgICAgIF9zdGVwMjtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAyLnZhbHVlLmtleTtcblxuICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIFNjYWxhcikge1xuICAgICAgICBpZiAoc2VlbktleXMuaW5jbHVkZXMoa2V5LnZhbHVlKSkge1xuICAgICAgICAgIHZhciBtc2cgPSAnT3JkZXJlZCBtYXBzIG11c3Qgbm90IGluY2x1ZGUgZHVwbGljYXRlIGtleXMnO1xuICAgICAgICAgIHRocm93IG5ldyBZQU1MU2VtYW50aWNFcnJvcihjc3QsIG1zZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXMucHVzaChrZXkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBZQU1MT01hcCgpLCBwYWlycyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9NYXAoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gIHZhciBwYWlycyA9IGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCk7XG4gIHZhciBvbWFwID0gbmV3IFlBTUxPTWFwKCk7XG4gIG9tYXAuaXRlbXMgPSBwYWlycy5pdGVtcztcbiAgcmV0dXJuIG9tYXA7XG59XG5cbnZhciBvbWFwID0ge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG4gIH0sXG4gIG5vZGVDbGFzczogWUFNTE9NYXAsXG4gIGRlZmF1bHQ6IGZhbHNlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJyxcbiAgcmVzb2x2ZTogcGFyc2VPTWFwLFxuICBjcmVhdGVOb2RlOiBjcmVhdGVPTWFwXG59O1xuXG52YXIgWUFNTFNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1lBTUxNYXApIHtcbiAgX2luaGVyaXRzKFlBTUxTZXQsIF9ZQU1MTWFwKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFlBTUxTZXQpO1xuXG4gIGZ1bmN0aW9uIFlBTUxTZXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBTUxTZXQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy50YWcgPSBZQU1MU2V0LnRhZztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWUFNTFNldCwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChrZXkpIHtcbiAgICAgIHZhciBwYWlyID0ga2V5IGluc3RhbmNlb2YgUGFpciA/IGtleSA6IG5ldyBQYWlyKGtleSk7XG4gICAgICB2YXIgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIHBhaXIua2V5KTtcbiAgICAgIGlmICghcHJldikgdGhpcy5pdGVtcy5wdXNoKHBhaXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSwga2VlcFBhaXIpIHtcbiAgICAgIHZhciBwYWlyID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgIHJldHVybiAha2VlcFBhaXIgJiYgcGFpciBpbnN0YW5jZW9mIFBhaXIgPyBwYWlyLmtleSBpbnN0YW5jZW9mIFNjYWxhciA/IHBhaXIua2V5LnZhbHVlIDogcGFpci5rZXkgOiBwYWlyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYm9vbGVhbiB2YWx1ZSBmb3Igc2V0KGtleSwgdmFsdWUpIGluIGEgWUFNTCBzZXQsIG5vdCBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpKTtcbiAgICAgIHZhciBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcblxuICAgICAgaWYgKHByZXYgJiYgIXZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihwcmV2KSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKCFwcmV2ICYmIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihZQU1MU2V0LnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcywgXywgY3R4LCBTZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgIGlmICghY3R4KSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICBpZiAodGhpcy5oYXNBbGxOdWxsVmFsdWVzKCkpIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihZQU1MU2V0LnByb3RvdHlwZSksIFwidG9TdHJpbmdcIiwgdGhpcykuY2FsbCh0aGlzLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBZQU1MU2V0O1xufShZQU1MTWFwKTtcblxuX2RlZmluZVByb3BlcnR5KFlBTUxTZXQsIFwidGFnXCIsICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnKTtcblxuZnVuY3Rpb24gcGFyc2VTZXQoZG9jLCBjc3QpIHtcbiAgdmFyIG1hcCA9IHJlc29sdmVNYXAoZG9jLCBjc3QpO1xuICBpZiAoIW1hcC5oYXNBbGxOdWxsVmFsdWVzKCkpIHRocm93IG5ldyBZQU1MU2VtYW50aWNFcnJvcihjc3QsICdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgWUFNTFNldCgpLCBtYXApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTZXQoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gIHZhciBzZXQgPSBuZXcgWUFNTFNldCgpO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpdGVyYWJsZSksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdmFsdWUgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHNldC5pdGVtcy5wdXNoKHNjaGVtYS5jcmVhdGVQYWlyKHZhbHVlLCBudWxsLCBjdHgpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHJldHVybiBzZXQ7XG59XG5cbnZhciBzZXQgPSB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbiAgfSxcbiAgbm9kZUNsYXNzOiBZQU1MU2V0LFxuICBkZWZhdWx0OiBmYWxzZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c2V0JyxcbiAgcmVzb2x2ZTogcGFyc2VTZXQsXG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZVNldFxufTtcblxudmFyIHBhcnNlU2V4YWdlc2ltYWwgPSBmdW5jdGlvbiBwYXJzZVNleGFnZXNpbWFsKHNpZ24sIHBhcnRzKSB7XG4gIHZhciBuID0gcGFydHMuc3BsaXQoJzonKS5yZWR1Y2UoZnVuY3Rpb24gKG4sIHApIHtcbiAgICByZXR1cm4gbiAqIDYwICsgTnVtYmVyKHApO1xuICB9LCAwKTtcbiAgcmV0dXJuIHNpZ24gPT09ICctJyA/IC1uIDogbjtcbn07IC8vIGhoaGg6bW06c3Muc3NzXG5cblxudmFyIHN0cmluZ2lmeVNleGFnZXNpbWFsID0gZnVuY3Rpb24gc3RyaW5naWZ5U2V4YWdlc2ltYWwoX3JlZikge1xuICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHJldHVybiBzdHJpbmdpZnlOdW1iZXIodmFsdWUpO1xuICB2YXIgc2lnbiA9ICcnO1xuXG4gIGlmICh2YWx1ZSA8IDApIHtcbiAgICBzaWduID0gJy0nO1xuICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuICB9XG5cbiAgdmFyIHBhcnRzID0gW3ZhbHVlICUgNjBdOyAvLyBzZWNvbmRzLCBpbmNsdWRpbmcgbXNcblxuICBpZiAodmFsdWUgPCA2MCkge1xuICAgIHBhcnRzLnVuc2hpZnQoMCk7IC8vIGF0IGxlYXN0IG9uZSA6IGlzIHJlcXVpcmVkXG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKCh2YWx1ZSAtIHBhcnRzWzBdKSAvIDYwKTtcbiAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlICUgNjApOyAvLyBtaW51dGVzXG5cbiAgICBpZiAodmFsdWUgPj0gNjApIHtcbiAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCgodmFsdWUgLSBwYXJ0c1swXSkgLyA2MCk7XG4gICAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlKTsgLy8gaG91cnNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2lnbiArIHBhcnRzLm1hcChmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBTdHJpbmcobikgOiBTdHJpbmcobik7XG4gIH0pLmpvaW4oJzonKS5yZXBsYWNlKC8wMDAwMDBcXGQqJC8sICcnKSAvLyAlIDYwIG1heSBpbnRyb2R1Y2UgZXJyb3JcbiAgO1xufTtcblxudmFyIGludFRpbWUgPSB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdUSU1FJyxcbiAgdGVzdDogL14oWy0rXT8pKFswLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrKSQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0ciwgc2lnbiwgcGFydHMpIHtcbiAgICByZXR1cm4gcGFyc2VTZXhhZ2VzaW1hbChzaWduLCBwYXJ0cy5yZXBsYWNlKC9fL2csICcnKSk7XG4gIH0sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG52YXIgZmxvYXRUaW1lID0ge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICBmb3JtYXQ6ICdUSU1FJyxcbiAgdGVzdDogL14oWy0rXT8pKFswLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFwuWzAtOV9dKikkLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIsIHNpZ24sIHBhcnRzKSB7XG4gICAgcmV0dXJuIHBhcnNlU2V4YWdlc2ltYWwoc2lnbiwgcGFydHMucmVwbGFjZSgvXy9nLCAnJykpO1xuICB9LFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeVNleGFnZXNpbWFsXG59O1xudmFyIHRpbWVzdGFtcCA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJyxcbiAgLy8gSWYgdGhlIHRpbWUgem9uZSBpcyBvbWl0dGVkLCB0aGUgdGltZXN0YW1wIGlzIGFzc3VtZWQgdG8gYmUgc3BlY2lmaWVkIGluIFVUQy4gVGhlIHRpbWUgcGFydFxuICAvLyBtYXkgYmUgb21pdHRlZCBhbHRvZ2V0aGVyLCByZXN1bHRpbmcgaW4gYSBkYXRlIGZvcm1hdC4gSW4gc3VjaCBhIGNhc2UsIHRoZSB0aW1lIHBhcnQgaXNcbiAgLy8gYXNzdW1lZCB0byBiZSAwMDowMDowMFogKHN0YXJ0IG9mIGRheSwgVVRDKS5cbiAgdGVzdDogUmVnRXhwKCdeKD86JyArICcoWzAtOV17NH0pLShbMC05XXsxLDJ9KS0oWzAtOV17MSwyfSknICsgLy8gWVlZWS1NbS1EZFxuICAnKD86KD86dHxUfFsgXFxcXHRdKyknICsgLy8gdCB8IFQgfCB3aGl0ZXNwYWNlXG4gICcoWzAtOV17MSwyfSk6KFswLTldezEsMn0pOihbMC05XXsxLDJ9KFxcXFwuWzAtOV0rKT8pJyArIC8vIEhoOk1tOlNzKC5zcyk/XG4gICcoPzpbIFxcXFx0XSooWnxbLStdWzAxMl0/WzAtOV0oPzo6WzAtOV17Mn0pPykpPycgKyAvLyBaIHwgKzUgfCAtMDM6MzBcbiAgJyk/JyArICcpJCcpLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0ciwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2VjLCB0eikge1xuICAgIGlmIChtaWxsaXNlYykgbWlsbGlzZWMgPSAobWlsbGlzZWMgKyAnMDAnKS5zdWJzdHIoMSwgMyk7XG4gICAgdmFyIGRhdGUgPSBEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciB8fCAwLCBtaW51dGUgfHwgMCwgc2Vjb25kIHx8IDAsIG1pbGxpc2VjIHx8IDApO1xuXG4gICAgaWYgKHR6ICYmIHR6ICE9PSAnWicpIHtcbiAgICAgIHZhciBkID0gcGFyc2VTZXhhZ2VzaW1hbCh0elswXSwgdHouc2xpY2UoMSkpO1xuICAgICAgaWYgKE1hdGguYWJzKGQpIDwgMzApIGQgKj0gNjA7XG4gICAgICBkYXRlIC09IDYwMDAwICogZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gIH0sXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KF9yZWYyKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvKChUMDA6MDApPzowMCk/XFwuMDAwWiQvLCAnJyk7XG4gIH1cbn07XG5cbi8qIGdsb2JhbCBjb25zb2xlLCBwcm9jZXNzLCBZQU1MX1NJTEVOQ0VfREVQUkVDQVRJT05fV0FSTklOR1MsIFlBTUxfU0lMRU5DRV9XQVJOSU5HUyAqL1xuZnVuY3Rpb24gc2hvdWxkV2FybihkZXByZWNhdGlvbikge1xuICB2YXIgZW52ID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52IHx8IHt9O1xuXG4gIGlmIChkZXByZWNhdGlvbikge1xuICAgIGlmICh0eXBlb2YgWUFNTF9TSUxFTkNFX0RFUFJFQ0FUSU9OX1dBUk5JTkdTICE9PSAndW5kZWZpbmVkJykgcmV0dXJuICFZQU1MX1NJTEVOQ0VfREVQUkVDQVRJT05fV0FSTklOR1M7XG4gICAgcmV0dXJuICFlbnYuWUFNTF9TSUxFTkNFX0RFUFJFQ0FUSU9OX1dBUk5JTkdTO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBZQU1MX1NJTEVOQ0VfV0FSTklOR1MgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gIVlBTUxfU0lMRU5DRV9XQVJOSU5HUztcbiAgcmV0dXJuICFlbnYuWUFNTF9TSUxFTkNFX1dBUk5JTkdTO1xufVxuXG5mdW5jdGlvbiB3YXJuKHdhcm5pbmcsIHR5cGUpIHtcbiAgaWYgKHNob3VsZFdhcm4oZmFsc2UpKSB7XG4gICAgdmFyIGVtaXQgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbWl0V2FybmluZzsgLy8gVGhpcyB3aWxsIHRocm93IGluIEplc3QgaWYgYHdhcm5pbmdgIGlzIGFuIEVycm9yIGluc3RhbmNlIGR1ZSB0b1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9qZXN0L2lzc3Vlcy8yNTQ5XG5cbiAgICBpZiAoZW1pdCkgZW1pdCh3YXJuaW5nLCB0eXBlKTtlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4odHlwZSA/IFwiXCIuY29uY2F0KHR5cGUsIFwiOiBcIikuY29uY2F0KHdhcm5pbmcpIDogd2FybmluZyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB3YXJuRmlsZURlcHJlY2F0aW9uKGZpbGVuYW1lKSB7XG4gIGlmIChzaG91bGRXYXJuKHRydWUpKSB7XG4gICAgdmFyIHBhdGggPSBmaWxlbmFtZS5yZXBsYWNlKC8uKnlhbWxbL1xcXFxdL2ksICcnKS5yZXBsYWNlKC9cXC5qcyQvLCAnJykucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgIHdhcm4oXCJUaGUgZW5kcG9pbnQgJ3lhbWwvXCIuY29uY2F0KHBhdGgsIFwiJyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIiksICdEZXByZWNhdGlvbldhcm5pbmcnKTtcbiAgfVxufVxudmFyIHdhcm5lZCA9IHt9O1xuZnVuY3Rpb24gd2Fybk9wdGlvbkRlcHJlY2F0aW9uKG5hbWUsIGFsdGVybmF0aXZlKSB7XG4gIGlmICghd2FybmVkW25hbWVdICYmIHNob3VsZFdhcm4odHJ1ZSkpIHtcbiAgICB3YXJuZWRbbmFtZV0gPSB0cnVlO1xuICAgIHZhciBtc2cgPSBcIlRoZSBvcHRpb24gJ1wiLmNvbmNhdChuYW1lLCBcIicgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2VcIik7XG4gICAgbXNnICs9IGFsdGVybmF0aXZlID8gXCIsIHVzZSAnXCIuY29uY2F0KGFsdGVybmF0aXZlLCBcIicgaW5zdGVhZC5cIikgOiAnLic7XG4gICAgd2Fybihtc2csICdEZXByZWNhdGlvbldhcm5pbmcnKTtcbiAgfVxufVxuXG5leHBvcnQgeyB3YXJuT3B0aW9uRGVwcmVjYXRpb24gYXMgYSwgYmluYXJ5IGFzIGIsIHdhcm5GaWxlRGVwcmVjYXRpb24gYXMgYywgZmxvYXRUaW1lIGFzIGYsIGludFRpbWUgYXMgaSwgb21hcCBhcyBvLCBwYWlycyBhcyBwLCBzZXQgYXMgcywgdGltZXN0YW1wIGFzIHQsIHdhcm4gYXMgdyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/warnings-df54cb69.js\n")},"./package.json":n=>{"use strict";n.exports=JSON.parse('{"name":"teleop-xyz","version":"0.3.3","description":"","main":"src/index.js","files":["dist","src/*"],"scripts":{"build":"webpack","watch":"webpack --watch"},"author":"","license":"Apache-2.0","dependencies":{"debug":"^3.1.0","gamepad.js":"^1.0.4","yaml":"^1.10.2"},"devDependencies":{"@babel/cli":"^7.13.14","@babel/core":"^7.13.14","@babel/preset-env":"^7.13.12","babel-eslint":"^10.1.0","babel-preset-es2015":"^6.24.1","babelify":"^10.0.0","browserify":"^17.0.0","compression-webpack-plugin":"^7.1.2","constants-browserify":"^1.0.0","es2015":"^0.0.0","eslint":"^7.23.0","http-browserify":"^1.7.0","https-browserify":"^1.0.0","nodemon":"^2.0.7","path-browserify":"^1.0.1","webpack":"^5.25.0","webpack-bundle-analyzer":"^4.4.0","webpack-cli":"^4.5.0","webpack-node-externals":"^2.5.2","zlib-browserify":"0.0.3"},"babel":{"presets":["@babel/preset-env"],"sourceType":"module"},"eslintConfig":{"parser":"babel-eslint","env":{"browser":true,"node":true},"parserOptions":{"sourceType":"module","allowImportExportEverywhere":true}}}')}},__webpack_module_cache__={};function __webpack_require__(n){var I=__webpack_module_cache__[n];if(void 0!==I)return I.exports;var g=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n].call(g.exports,g,g.exports,__webpack_require__),g.exports}__webpack_require__.d=(n,I)=>{for(var g in I)__webpack_require__.o(I,g)&&!__webpack_require__.o(n,g)&&Object.defineProperty(n,g,{enumerable:!0,get:I[g]})},__webpack_require__.o=(n,I)=>Object.prototype.hasOwnProperty.call(n,I),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.js");teleopxyz=__webpack_exports__})();