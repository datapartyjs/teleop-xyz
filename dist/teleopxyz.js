var teleopxyz;(()=>{var __webpack_modules__={924:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar GetIntrinsic = __webpack_require__(210);\n\nvar callBind = __webpack_require__(559);\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLEdBQWU7O0FBRTFDLGVBQWUsbUJBQU8sQ0FBQyxHQUFJOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzPzU0NWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///924\n")},559:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar bind = __webpack_require__(612);\nvar GetIntrinsic = __webpack_require__(210);\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxHQUFlO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLEdBQWU7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTLFVBQVU7QUFDdkMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQsRUFBRTtBQUNGLENBQUMsb0JBQW9CO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcz8zZWIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0J2xlbmd0aCcsXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///559\n")},227:(module,exports,__webpack_require__)=>{eval("/* provided dependency */ var process = __webpack_require__(155);\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(447)(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI3LmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0Qzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLE9BQU8sNkJBQTZCLE9BQU87QUFDN0QsTUFBTSxPQUFPO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsR0FBVTs7QUFFbkMsT0FBTyxZQUFZOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcz8zNGViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///227\n")},447:(module,__unused_webpack_exports,__webpack_require__)=>{eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(824);\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ3LmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLEdBQUk7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcz9kYzkwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///447\n")},804:module=>{eval("\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA0LmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcz9iZmFkIl0sInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///804\n")},648:module=>{"use strict";eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBLCtFQUErRSxzQ0FBc0M7O0FBRXJIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanM/Njg4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///648\n")},612:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar implementation = __webpack_require__(648);\n\nmodule.exports = Function.prototype.bind || implementation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLEdBQWtCOztBQUUvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzPzBmN2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///612\n")},210:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(405)();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(612);\nvar hasOwn = __webpack_require__(642);\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOENBQThDO0FBQ2hGLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsR0FBRztBQUNILGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsR0FBYTs7QUFFdEMsdURBQXVELHVCQUF1Qjs7QUFFOUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxHQUFHO0FBQ0gsZ0RBQWdEO0FBQ2hELEdBQUc7QUFDSCxzREFBc0Q7QUFDdEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxHQUFlO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxHQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzPzAwY2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbikge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcycpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///210\n")},405:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(419);\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsR0FBUzs7QUFFckM7QUFDQSx5Q0FBeUM7QUFDekMscUNBQXFDO0FBQ3JDLDhDQUE4QztBQUM5QywwQ0FBMEM7O0FBRTFDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanM/NTE1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///405\n")},419:module=>{"use strict";eval("\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0YsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDLGtFQUFrRTtBQUNsRSxxRUFBcUU7O0FBRXJFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsdUNBQXVDOztBQUV2QywyREFBMkQ7QUFDM0QsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQywyRUFBMkU7O0FBRTNFLHlHQUF5Rzs7QUFFekc7QUFDQSw2Q0FBNkM7O0FBRTdDLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzPzE2OTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///419\n")},410:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar hasSymbols = __webpack_require__(419);\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGlCQUFpQixtQkFBTyxDQUFDLEdBQW1COztBQUU1QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvaGFzLXRvc3RyaW5ndGFnL3NoYW1zLmpzPzA3YTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///410\n")},642:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar bind = __webpack_require__(612);\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxHQUFlOztBQUVsQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzP2EwZDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///642\n")},717:module=>{eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcz8zZmI1Il0sInNvdXJjZXNDb250ZW50IjpbImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///717\n")},584:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar hasToStringTag = __webpack_require__(410)();\nvar callBound = __webpack_require__(924);\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTg0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLEdBQXVCO0FBQ3BELGdCQUFnQixtQkFBTyxDQUFDLEdBQXFCOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwyREFBMkQ7O0FBRTNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcz9lMzljIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///584\n")},662:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = __webpack_require__(410)();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLEdBQXVCO0FBQ3BEO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy9pcy1nZW5lcmF0b3ItZnVuY3Rpb24vaW5kZXguanM/MGEzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0R2VuZXJhdG9yRnVuYyA9IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24qKCkge30nKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdH1cbn07XG52YXIgR2VuZXJhdG9yRnVuY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbChmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRpZiAoIWdldFByb3RvKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICh0eXBlb2YgR2VuZXJhdG9yRnVuY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG5cdFx0R2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///662\n")},692:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar forEach = __webpack_require__(804);\nvar availableTypedArrays = __webpack_require__(83);\nvar callBound = __webpack_require__(924);\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(410)();\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(882);\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxHQUFTO0FBQy9CLDJCQUEyQixtQkFBTyxDQUFDLEVBQXdCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLEdBQXFCOztBQUU3QztBQUNBLHFCQUFxQixtQkFBTyxDQUFDLEdBQXVCOztBQUVwRCw0Q0FBNEMscUJBQU07QUFDbEQ7O0FBRUE7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsR0FBOEM7QUFDakUsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzP2Y0ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGFueVRydWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWFueVRydWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBhbnlUcnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSkge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdHJldHVybiAkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///692\n")},824:module=>{eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzPzE0NjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///824\n")},470:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/* provided dependency */ var process = __webpack_require__(155);\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcwLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1Qyw4QkFBOEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLFlBQVk7QUFDWjtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLE1BQU07QUFDTixnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhEQUE4RDs7QUFFOUQ7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzP2RmN2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gJ3BhdGgnIG1vZHVsZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEgKG9ubHkgdGhlIHBvc2l4IHBhcnQpXG4vLyB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzc2VydFBhdGgocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAnICsgSlNPTi5zdHJpbmdpZnkocGF0aCkpO1xuICB9XG59XG5cbi8vIFJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCB3aXRoIGRpcmVjdG9yeSBuYW1lc1xuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aCwgYWxsb3dBYm92ZVJvb3QpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICB2YXIgbGFzdFNsYXNoID0gLTE7XG4gIHZhciBkb3RzID0gMDtcbiAgdmFyIGNvZGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA8IHBhdGgubGVuZ3RoKVxuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBlbHNlIGlmIChjb2RlID09PSA0NyAvKi8qLylcbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGNvZGUgPSA0NyAvKi8qLztcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgIGlmIChsYXN0U2xhc2ggPT09IGkgLSAxIHx8IGRvdHMgPT09IDEpIHtcbiAgICAgICAgLy8gTk9PUFxuICAgICAgfSBlbHNlIGlmIChsYXN0U2xhc2ggIT09IGkgLSAxICYmIGRvdHMgPT09IDIpIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8IGxhc3RTZWdtZW50TGVuZ3RoICE9PSAyIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gNDYgLyouKi8gfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDIpICE9PSA0NiAvKi4qLykge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIGxhc3RTbGFzaEluZGV4ID0gcmVzLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggIT09IHJlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMgPSAnJztcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KTtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IHJlcy5sZW5ndGggLSAxIC0gcmVzLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzLmxlbmd0aCA9PT0gMiB8fCByZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXMgPSAnJztcbiAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXMgKz0gJy8uLic7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzID0gJy4uJztcbiAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICByZXMgKz0gJy8nICsgcGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlcyA9IHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gaSAtIGxhc3RTbGFzaCAtIDE7XG4gICAgICB9XG4gICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgZG90cyA9IDA7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSA0NiAvKi4qLyAmJiBkb3RzICE9PSAtMSkge1xuICAgICAgKytkb3RzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3RzID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIF9mb3JtYXQoc2VwLCBwYXRoT2JqZWN0KSB7XG4gIHZhciBkaXIgPSBwYXRoT2JqZWN0LmRpciB8fCBwYXRoT2JqZWN0LnJvb3Q7XG4gIHZhciBiYXNlID0gcGF0aE9iamVjdC5iYXNlIHx8IChwYXRoT2JqZWN0Lm5hbWUgfHwgJycpICsgKHBhdGhPYmplY3QuZXh0IHx8ICcnKTtcbiAgaWYgKCFkaXIpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBpZiAoZGlyID09PSBwYXRoT2JqZWN0LnJvb3QpIHtcbiAgICByZXR1cm4gZGlyICsgYmFzZTtcbiAgfVxuICByZXR1cm4gZGlyICsgc2VwICsgYmFzZTtcbn1cblxudmFyIHBvc2l4ID0ge1xuICAvLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgdmFyIHJlc29sdmVkUGF0aCA9ICcnO1xuICAgIHZhciByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG4gICAgdmFyIGN3ZDtcblxuICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgICB2YXIgcGF0aDtcbiAgICAgIGlmIChpID49IDApXG4gICAgICAgIHBhdGggPSBhcmd1bWVudHNbaV07XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGN3ZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGN3ZCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgICAgIHBhdGggPSBjd2Q7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICAgIC8vIFNraXAgZW1wdHkgZW50cmllc1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAgIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocmVzb2x2ZWRQYXRoLCAhcmVzb2x2ZWRBYnNvbHV0ZSk7XG5cbiAgICBpZiAocmVzb2x2ZWRBYnNvbHV0ZSkge1xuICAgICAgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPiAwKVxuICAgICAgICByZXR1cm4gJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gJy8nO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiByZXNvbHZlZFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnLic7XG4gICAgfVxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuXG4gICAgdmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICAgIHZhciB0cmFpbGluZ1NlcGFyYXRvciA9IHBhdGguY2hhckNvZGVBdChwYXRoLmxlbmd0aCAtIDEpID09PSA0NyAvKi8qLztcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgIHBhdGggPSBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoLCAhaXNBYnNvbHV0ZSk7XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDAgJiYgIWlzQWJzb2x1dGUpIHBhdGggPSAnLic7XG4gICAgaWYgKHBhdGgubGVuZ3RoID4gMCAmJiB0cmFpbGluZ1NlcGFyYXRvcikgcGF0aCArPSAnLyc7XG5cbiAgICBpZiAoaXNBYnNvbHV0ZSkgcmV0dXJuICcvJyArIHBhdGg7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0sXG5cbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwICYmIHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gIH0sXG5cbiAgam9pbjogZnVuY3Rpb24gam9pbigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiAnLic7XG4gICAgdmFyIGpvaW5lZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGFzc2VydFBhdGgoYXJnKTtcbiAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgam9pbmVkID0gYXJnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgam9pbmVkICs9ICcvJyArIGFyZztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuICcuJztcbiAgICByZXR1cm4gcG9zaXgubm9ybWFsaXplKGpvaW5lZCk7XG4gIH0sXG5cbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gICAgYXNzZXJ0UGF0aChmcm9tKTtcbiAgICBhc3NlcnRQYXRoKHRvKTtcblxuICAgIGlmIChmcm9tID09PSB0bykgcmV0dXJuICcnO1xuXG4gICAgZnJvbSA9IHBvc2l4LnJlc29sdmUoZnJvbSk7XG4gICAgdG8gPSBwb3NpeC5yZXNvbHZlKHRvKTtcblxuICAgIGlmIChmcm9tID09PSB0bykgcmV0dXJuICcnO1xuXG4gICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgIHZhciBmcm9tU3RhcnQgPSAxO1xuICAgIGZvciAoOyBmcm9tU3RhcnQgPCBmcm9tLmxlbmd0aDsgKytmcm9tU3RhcnQpIHtcbiAgICAgIGlmIChmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0KSAhPT0gNDcgLyovKi8pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZnJvbUVuZCA9IGZyb20ubGVuZ3RoO1xuICAgIHZhciBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDtcblxuICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcbiAgICB2YXIgdG9TdGFydCA9IDE7XG4gICAgZm9yICg7IHRvU3RhcnQgPCB0by5sZW5ndGg7ICsrdG9TdGFydCkge1xuICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCkgIT09IDQ3IC8qLyovKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHRvRW5kID0gdG8ubGVuZ3RoO1xuICAgIHZhciB0b0xlbiA9IHRvRW5kIC0gdG9TdGFydDtcblxuICAgIC8vIENvbXBhcmUgcGF0aHMgdG8gZmluZCB0aGUgbG9uZ2VzdCBjb21tb24gcGF0aCBmcm9tIHJvb3RcbiAgICB2YXIgbGVuZ3RoID0gZnJvbUxlbiA8IHRvTGVuID8gZnJvbUxlbiA6IHRvTGVuO1xuICAgIHZhciBsYXN0Q29tbW9uU2VwID0gLTE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDw9IGxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgIGlmICh0b0xlbiA+IGxlbmd0aCkge1xuICAgICAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgdG9gLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyJzsgdG89Jy9mb28vYmFyL2JheidcbiAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSArIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSByb290XG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nLyc7IHRvPScvZm9vJ1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbUxlbiA+IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGBmcm9tYC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhci9iYXonOyB0bz0nL2Zvby9iYXInXG4gICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIHJvb3QuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvbyc7IHRvPScvJ1xuICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIGZyb21Db2RlID0gZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpO1xuICAgICAgdmFyIHRvQ29kZSA9IHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpO1xuICAgICAgaWYgKGZyb21Db2RlICE9PSB0b0NvZGUpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZWxzZSBpZiAoZnJvbUNvZGUgPT09IDQ3IC8qLyovKVxuICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgLy8gR2VuZXJhdGUgdGhlIHJlbGF0aXZlIHBhdGggYmFzZWQgb24gdGhlIHBhdGggZGlmZmVyZW5jZSBiZXR3ZWVuIGB0b2BcbiAgICAvLyBhbmQgYGZyb21gXG4gICAgZm9yIChpID0gZnJvbVN0YXJ0ICsgbGFzdENvbW1vblNlcCArIDE7IGkgPD0gZnJvbUVuZDsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gZnJvbUVuZCB8fCBmcm9tLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgIG91dCArPSAnLi4nO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgb3V0ICs9ICcvLi4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExhc3RseSwgYXBwZW5kIHRoZSByZXN0IG9mIHRoZSBkZXN0aW5hdGlvbiAoYHRvYCkgcGF0aCB0aGF0IGNvbWVzIGFmdGVyXG4gICAgLy8gdGhlIGNvbW1vbiBwYXRoIHBhcnRzXG4gICAgaWYgKG91dC5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIG91dCArIHRvLnNsaWNlKHRvU3RhcnQgKyBsYXN0Q29tbW9uU2VwKTtcbiAgICBlbHNlIHtcbiAgICAgIHRvU3RhcnQgKz0gbGFzdENvbW1vblNlcDtcbiAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQpID09PSA0NyAvKi8qLylcbiAgICAgICAgKyt0b1N0YXJ0O1xuICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQpO1xuICAgIH1cbiAgfSxcblxuICBfbWFrZUxvbmc6IGZ1bmN0aW9uIF9tYWtlTG9uZyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0sXG5cbiAgZGlybmFtZTogZnVuY3Rpb24gZGlybmFtZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICAgIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkgcmV0dXJuICcvLyc7XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbiAgfSxcblxuICBiYXNlbmFtZTogZnVuY3Rpb24gYmFzZW5hbWUocGF0aCwgZXh0KSB7XG4gICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBleHQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgZXh0Lmxlbmd0aCA+IDAgJiYgZXh0Lmxlbmd0aCA8PSBwYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKGV4dC5sZW5ndGggPT09IHBhdGgubGVuZ3RoICYmIGV4dCA9PT0gcGF0aCkgcmV0dXJuICcnO1xuICAgICAgdmFyIGV4dElkeCA9IGV4dC5sZW5ndGggLSAxO1xuICAgICAgdmFyIGZpcnN0Tm9uU2xhc2hFbmQgPSAtMTtcbiAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2VcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgaXQgaWYgdGhlIGV4dGVuc2lvbiBlbmRzIHVwIG5vdCBtYXRjaGluZ1xuICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRJZHggPj0gMCkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBleHBsaWNpdCBleHRlbnNpb25cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpKSB7XG4gICAgICAgICAgICAgIGlmICgtLWV4dElkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBleHRlbnNpb24sIHNvIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91ciBwYXRoXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRXh0ZW5zaW9uIGRvZXMgbm90IG1hdGNoLCBzbyBvdXIgcmVzdWx0IGlzIHRoZSBlbnRpcmUgcGF0aFxuICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgZXh0SWR4ID0gLTE7XG4gICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO2Vsc2UgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IHBhdGgubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgZXh0bmFtZTogZnVuY3Rpb24gZXh0bmFtZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gIH0sXG5cbiAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQocGF0aE9iamVjdCkge1xuICAgIGlmIChwYXRoT2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBwYXRoT2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBwYXRoT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIF9mb3JtYXQoJy8nLCBwYXRoT2JqZWN0KTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICB2YXIgcmV0ID0geyByb290OiAnJywgZGlyOiAnJywgYmFzZTogJycsIGV4dDogJycsIG5hbWU6ICcnIH07XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gcmV0O1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBpc0Fic29sdXRlID0gY29kZSA9PT0gNDcgLyovKi87XG4gICAgdmFyIHN0YXJ0O1xuICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICByZXQucm9vdCA9ICcvJztcbiAgICAgIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG5cbiAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuXG4gICAgLy8gR2V0IG5vbi1kaXIgaW5mb1xuICAgIGZvciAoOyBpID49IHN0YXJ0OyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSkgc3RhcnREb3QgPSBpO2Vsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKSBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgaWYgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKSByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZSgxLCBlbmQpO2Vsc2UgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKDEsIHN0YXJ0RG90KTtcbiAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKDEsIGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICByZXQuZXh0ID0gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRQYXJ0ID4gMCkgcmV0LmRpciA9IHBhdGguc2xpY2UoMCwgc3RhcnRQYXJ0IC0gMSk7ZWxzZSBpZiAoaXNBYnNvbHV0ZSkgcmV0LmRpciA9ICcvJztcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgc2VwOiAnLycsXG4gIGRlbGltaXRlcjogJzonLFxuICB3aW4zMjogbnVsbCxcbiAgcG9zaXg6IG51bGxcbn07XG5cbnBvc2l4LnBvc2l4ID0gcG9zaXg7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zaXg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///470\n")},155:module=>{eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///155\n")},384:module=>{eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzP2Q2MGEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///384\n")},955:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n\n\nvar isArgumentsObject = __webpack_require__(584);\nvar isGeneratorFunction = __webpack_require__(662);\nvar whichTypedArray = __webpack_require__(430);\nvar isTypedArray = __webpack_require__(692);\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRWE7O0FBRWIsd0JBQXdCLG1CQUFPLENBQUMsR0FBYztBQUM5QywwQkFBMEIsbUJBQU8sQ0FBQyxHQUF1QjtBQUN6RCxzQkFBc0IsbUJBQU8sQ0FBQyxHQUFtQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyxHQUFnQjs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0Isb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7O0FBR3pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzP2JkNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL3R5cGVzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHNPYmplY3QgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gcmVxdWlyZSgnaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uJyk7XG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIEJpZ0ludFN1cHBvcnRlZCA9IHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIFN5bWJvbFN1cHBvcnRlZCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgT2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIG51bWJlclZhbHVlID0gdW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBzdHJpbmdWYWx1ZSA9IHVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgYm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7XG5cbmlmIChCaWdJbnRTdXBwb3J0ZWQpIHtcbiAgdmFyIGJpZ0ludFZhbHVlID0gdW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuaWYgKFN5bWJvbFN1cHBvcnRlZCkge1xuICB2YXIgc3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBwcm90b3R5cGVWYWx1ZU9mKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcHJvdG90eXBlVmFsdWVPZih2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gaXNBcmd1bWVudHNPYmplY3Q7XG5leHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBpc0dlbmVyYXRvckZ1bmN0aW9uO1xuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG5cbi8vIFRha2VuIGZyb20gaGVyZSBhbmQgbW9kaWZpZWQgZm9yIGJldHRlciBicm93c2VyIHN1cHBvcnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcC1pcy1wcm9taXNlL2Jsb2IvY2RhMzVhNTEzYmRhMDNmOTc3YWQ1Y2RlM2EwNzlkMjM3ZTgyZDdlZi9pbmRleC5qc1xuZnVuY3Rpb24gaXNQcm9taXNlKGlucHV0KSB7XG5cdHJldHVybiAoXG5cdFx0KFxuXHRcdFx0dHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRpbnB1dCBpbnN0YW5jZW9mIFByb21pc2Vcblx0XHQpIHx8XG5cdFx0KFxuXHRcdFx0aW5wdXQgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQuY2F0Y2ggPT09ICdmdW5jdGlvbidcblx0XHQpXG5cdCk7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGlzVHlwZWRBcnJheSh2YWx1ZSkgfHxcbiAgICBpc0RhdGFWaWV3KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyVmlldyA9IGlzQXJyYXlCdWZmZXJWaWV3O1xuXG5cbmZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4QXJyYXkgPSBpc1VpbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDhDbGFtcGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OENsYW1wZWRBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhDbGFtcGVkQXJyYXkgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQxNkFycmF5ID0gaXNVaW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MzJBcnJheSA9IGlzVWludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQ4QXJyYXkgPSBpc0ludDhBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MTZBcnJheSA9IGlzSW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MzJBcnJheSA9IGlzSW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0MzJBcnJheSA9IGlzRmxvYXQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0NjRBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQ2NEFycmF5ID0gaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnSW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ0ludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ0ludDY0QXJyYXkgPSBpc0JpZ0ludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdVaW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnVWludDY0QXJyYXkgPSBpc0JpZ1VpbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcF0nO1xufVxuaXNNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc01hcFRvU3RyaW5nKG5ldyBNYXAoKSlcbik7XG5cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbn1cbmV4cG9ydHMuaXNNYXAgPSBpc01hcDtcblxuZnVuY3Rpb24gaXNTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXRdJztcbn1cbmlzU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNTZXRUb1N0cmluZyhuZXcgU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTZXRUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2V0O1xufVxuZXhwb3J0cy5pc1NldCA9IGlzU2V0O1xuXG5mdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrTWFwXSc7XG59XG5pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXAoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgV2Vha01hcDtcbn1cbmV4cG9ydHMuaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuXG5mdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrU2V0XSc7XG59XG5pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cbmlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGFWaWV3XSc7XG59XG5pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLCAwLCAxKSlcbik7XG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3O1xufVxuZXhwb3J0cy5pc0RhdGFWaWV3ID0gaXNEYXRhVmlldztcblxuLy8gU3RvcmUgYSBjb3B5IG9mIFNoYXJlZEFycmF5QnVmZmVyIGluIGNhc2UgaXQncyBkZWxldGVkIGVsc2V3aGVyZVxudmFyIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nO1xufVxuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNvcHkoKSk7XG4gIH1cblxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5O1xufVxuZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbn1cbmV4cG9ydHMuaXNBc3luY0Z1bmN0aW9uID0gaXNBc3luY0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc0dlbmVyYXRvck9iamVjdCA9IGlzR2VuZXJhdG9yT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSc7XG59XG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcblxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdDtcblxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpbmdPYmplY3QgPSBpc1N0cmluZ09iamVjdDtcblxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xufVxuZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTeW1ib2xPYmplY3QgPSBpc1N5bWJvbE9iamVjdDtcblxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHxcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FueUFycmF5QnVmZmVyID0gaXNBbnlBcnJheUJ1ZmZlcjtcblxuWydpc1Byb3h5JywgJ2lzRXh0ZXJuYWwnLCAnaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbWV0aG9kLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpO1xuICAgIH1cbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///955\n")},539:(__unused_webpack_module,exports,__webpack_require__)=>{eval("/* provided dependency */ var process = __webpack_require__(155);\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = __webpack_require__(955);\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(384);\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(717);\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM5LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhLE9BQU8sb0JBQW9CLE9BQU87QUFDL0M7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQSxRQUFRLFNBQVMsT0FBTztBQUN4QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxJQUFJLE9BQU87QUFDWCxpQkFBaUIsT0FBTztBQUN4QixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7O0FBR2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esd0NBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkIsMkNBQWdEOztBQUVoRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVc7QUFDWDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSwyQ0FBc0M7O0FBRXRDLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxxQ0FBcUM7QUFDeEUsNEJBQTRCLE9BQU8sc0RBQXNEO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzPzMwMjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpIHtcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcbiAgZGVidWdFbnYgPSBkZWJ1Z0Vudi5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgLnRvVXBwZXJDYXNlKCk7XG4gIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpO1xufVxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChkZWJ1Z0VudlJlZ2V4LnRlc3Qoc2V0KSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9zdXBwb3J0L3R5cGVzJyk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5leHBvcnRzLnR5cGVzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmV4cG9ydHMudHlwZXMuaXNOYXRpdmVFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIHJldCkpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSkgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///539\n")},430:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar forEach = __webpack_require__(804);\nvar availableTypedArrays = __webpack_require__(83);\nvar callBound = __webpack_require__(924);\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(410)();\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(882);\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = __webpack_require__(692);\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxHQUFTO0FBQy9CLDJCQUEyQixtQkFBTyxDQUFDLEVBQXdCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLEdBQXFCOztBQUU3QztBQUNBLHFCQUFxQixtQkFBTyxDQUFDLEdBQXVCOztBQUVwRCw0Q0FBNEMscUJBQU07QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxHQUE4QztBQUNqRSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyxHQUFnQjs7QUFFM0M7QUFDQSw2QkFBNkI7QUFDN0IsMERBQTBEO0FBQzFEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanM/ZWRjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRpZiAodHlwZW9mIGdbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZE5hbWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kTmFtZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG5hbWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmIChuYW1lID09PSB0eXBlZEFycmF5KSB7XG5cdFx0XHRcdFx0Zm91bmROYW1lID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmROYW1lO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghaXNUeXBlZEFycmF5KHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///430\n")},391:function(__unused_webpack_module,exports,__webpack_require__){eval("(function() {\n  var MarkedYAMLError, events, nodes;\n\n  events = __webpack_require__(63);\n\n  ({MarkedYAMLError} = __webpack_require__(372));\n\n  nodes = __webpack_require__(914);\n\n  /*\n  Thrown for errors encountered during composing.\n  */\n  this.ComposerError = class ComposerError extends MarkedYAMLError {};\n\n  /*\n  The composer class handles the construction of representation trees from events.\n\n  This uses the methods from {Parser} to process the event stream, and provides a similar stream-like\n  interface to representation trees via {Composer#check_node}, {Composer#get_node}, and\n  {Composer#get_single_node}.\n  */\n  this.Composer = (function() {\n    var ctor;\n\n    class Composer {\n      constructor() {\n        return ctor.apply(this, arguments);\n      }\n\n      /*\n      Initialise a `Composer` instance.\n      */\n      initialise() {\n        // @property {Object} A mapping from anchor names to nodes.\n        return this.anchors = {};\n      }\n\n      /*\n      Checks if a document can be composed from the event stream.\n\n      So long as the event stream hasn't ended (no [StreamEndEvent]), another document can be composed.\n\n      @return {Boolean} True if a document can be composed, false otherwise.\n      */\n      check_node() {\n        if (this.check_event(events.StreamStartEvent)) {\n          // Drop the STREAM-START event.\n          this.get_event();\n        }\n        // Are there more documents available?\n        return !this.check_event(events.StreamEndEvent);\n      }\n\n      /*\n      Compose a document from the remaining event stream.\n\n      {Composer#check_node} must be called before calling this method.\n\n      @return {Node} The next document in the stream. Returns `undefined` if the event stream has ended.\n      */\n      get_node() {\n        if (!this.check_event(events.StreamEndEvent)) {\n          return this.compose_document();\n        }\n      }\n\n      /*\n      Compose a single document from the entire event stream.\n\n      @throw {ComposerError} if there's more than one document is in the stream.\n\n      @return {Node} The single document in the stream.\n      */\n      get_single_node() {\n        var document, event;\n        // Drop the STREAM-START event.\n        this.get_event();\n        // Compose a document if the stream is not empty.\n        document = null;\n        if (!this.check_event(events.StreamEndEvent)) {\n          document = this.compose_document();\n        }\n        // Ensure that the stream contains no more documents.\n        if (!this.check_event(events.StreamEndEvent)) {\n          event = this.get_event();\n          throw new exports.ComposerError('expected a single document in the stream', document.start_mark, 'but found another document', event.start_mark);\n        }\n        // Drop the STREAM-END event.\n        this.get_event();\n        return document;\n      }\n\n      /*\n      Compose a document node from the event stream.\n\n      A 'document' node is any single {Node} subclass.  {DocumentStart} and {DocumentEnd} events delimit\n      the events used for composition.\n\n      @private\n\n      @return {Node} The document node.\n      */\n      compose_document() {\n        var node;\n        // Drop the DOCUMENT-START event.\n        this.get_event();\n        // Compose the root node.\n        node = this.compose_node();\n        // Drop the DOCUMENT-END node.\n        this.get_event();\n        // Reset the anchors\n        this.anchors = {};\n        return node;\n      }\n\n      /*\n      Compose a node from the event stream.\n\n      Composes a {ScalarNode}, {SequenceNode}, or {MappingNode} from the event stream, depending on the\n      first event encountered ({ScalarEvent}, {SequenceStartEvent}, or {MappingStartEvent}\n      respectively).\n\n      @private\n\n      @param parent {Node} The parent of the new node.\n      @param index {Number} The index of the new node within the parent's children.\n      @throw {ComposerError} if an alias is encountered for an undefined anchor.\n      @throw {ComposerError} if a duplicate anchor is envountered.\n      @return {Node} The composed node.\n      */\n      compose_node(parent, index) {\n        var anchor, event, node;\n        if (this.check_event(events.AliasEvent)) {\n          event = this.get_event();\n          anchor = event.anchor;\n          if (!(anchor in this.anchors)) {\n            throw new exports.ComposerError(null, null, `found undefined alias ${anchor}`, event.start_mark);\n          }\n          return this.anchors[anchor];\n        }\n        event = this.peek_event();\n        anchor = event.anchor;\n        if (anchor !== null && anchor in this.anchors) {\n          throw new exports.ComposerError(`found duplicate anchor ${anchor}; first occurence`, this.anchors[anchor].start_mark, 'second occurrence', event.start_mark);\n        }\n        this.descend_resolver(parent, index);\n        if (this.check_event(events.ScalarEvent)) {\n          node = this.compose_scalar_node(anchor);\n        } else if (this.check_event(events.SequenceStartEvent)) {\n          node = this.compose_sequence_node(anchor);\n        } else if (this.check_event(events.MappingStartEvent)) {\n          node = this.compose_mapping_node(anchor);\n        }\n        this.ascend_resolver();\n        return node;\n      }\n\n      /*\n      Compose a {ScalarNode} from the event stream.\n\n      @private\n\n      @param anchor {String} The anchor name for the node (if any).\n      @return {ScalarNode} The node composed from a {ScalarEvent}.\n      */\n      compose_scalar_node(anchor) {\n        var event, node, tag;\n        event = this.get_event();\n        tag = event.tag;\n        if (tag === null || tag === '!') {\n          tag = this.resolve(nodes.ScalarNode, event.value, event.implicit);\n        }\n        node = new nodes.ScalarNode(tag, event.value, event.start_mark, event.end_mark, event.style);\n        if (anchor !== null) {\n          this.anchors[anchor] = node;\n        }\n        return node;\n      }\n\n      /*\n      Compose a {SequenceNode} from the event stream.\n\n      The contents of the node are composed from events between a {SequenceStartEvent} and a\n      {SequenceEndEvent}.\n\n      @private\n\n      @param anchor {String} The anchor name for the node (if any).\n      @return {SequenceNode} The composed node.\n      */\n      compose_sequence_node(anchor) {\n        var end_event, index, node, start_event, tag;\n        start_event = this.get_event();\n        tag = start_event.tag;\n        if (tag === null || tag === '!') {\n          tag = this.resolve(nodes.SequenceNode, null, start_event.implicit);\n        }\n        node = new nodes.SequenceNode(tag, [], start_event.start_mark, null, start_event.flow_style);\n        if (anchor !== null) {\n          this.anchors[anchor] = node;\n        }\n        index = 0;\n        while (!this.check_event(events.SequenceEndEvent)) {\n          node.value.push(this.compose_node(node, index));\n          index++;\n        }\n        end_event = this.get_event();\n        node.end_mark = end_event.end_mark;\n        return node;\n      }\n\n      /*\n      Compose a {MappingNode} from the event stream.\n\n      The contents of the node are composed from events between a {MappingStartEvent} and a\n      {MappingEndEvent}.\n\n      @private\n\n      @param anchor {String} The anchor name for the node (if any).\n      @return {MappingNode} The composed node.\n      */\n      compose_mapping_node(anchor) {\n        var end_event, item_key, item_value, node, start_event, tag;\n        start_event = this.get_event();\n        tag = start_event.tag;\n        if (tag === null || tag === '!') {\n          tag = this.resolve(nodes.MappingNode, null, start_event.implicit);\n        }\n        node = new nodes.MappingNode(tag, [], start_event.start_mark, null, start_event.flow_style);\n        if (anchor !== null) {\n          this.anchors[anchor] = node;\n        }\n        while (!this.check_event(events.MappingEndEvent)) {\n          item_key = this.compose_node(node);\n          item_value = this.compose_node(node, item_key);\n          node.value.push([item_key, item_value]);\n        }\n        end_event = this.get_event();\n        node.end_mark = end_event.end_mark;\n        return node;\n      }\n\n    };\n\n    ctor = Composer.prototype.initialise;\n\n    return Composer;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLEVBQVU7O0FBRTdCLElBQUksaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxHQUFVOztBQUV6QyxVQUFVLG1CQUFPLENBQUMsR0FBUzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsUUFBUTtBQUN0Qyx5Q0FBeUMsb0JBQW9CLEdBQUcsa0JBQWtCO0FBQ2xGLEdBQUcseUJBQXlCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTyxxQkFBcUI7O0FBRTVCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGVBQWU7O0FBRTdCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxNQUFNLFlBQVksZUFBZSxLQUFLLGFBQWE7QUFDMUY7O0FBRUE7O0FBRUEsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFdBQVcsR0FBRyxhQUFhLE1BQU0sYUFBYTtBQUNoRSxnQ0FBZ0MsWUFBWSxHQUFHLG1CQUFtQixNQUFNO0FBQ3hFOztBQUVBOztBQUVBLHFCQUFxQixNQUFNO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGVBQWU7QUFDN0IsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLE9BQU87QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZOztBQUU3Qjs7QUFFQSxxQkFBcUIsUUFBUTtBQUM3QixlQUFlLFlBQVksMEJBQTBCLFlBQVk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjOztBQUUvQixtRUFBbUUsb0JBQW9CO0FBQ3ZGLE9BQU8saUJBQWlCOztBQUV4Qjs7QUFFQSxxQkFBcUIsUUFBUTtBQUM3QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGFBQWE7O0FBRTlCLG1FQUFtRSxtQkFBbUI7QUFDdEYsT0FBTyxnQkFBZ0I7O0FBRXZCOztBQUVBLHFCQUFxQixRQUFRO0FBQzdCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwtanMvbGliL2NvbXBvc2VyLmpzP2NiYWMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBldmVudHMsIG5vZGVzO1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG5cbiAgKHtNYXJrZWRZQU1MRXJyb3J9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKSk7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgLypcbiAgVGhyb3duIGZvciBlcnJvcnMgZW5jb3VudGVyZWQgZHVyaW5nIGNvbXBvc2luZy5cbiAgKi9cbiAgdGhpcy5Db21wb3NlckVycm9yID0gY2xhc3MgQ29tcG9zZXJFcnJvciBleHRlbmRzIE1hcmtlZFlBTUxFcnJvciB7fTtcblxuICAvKlxuICBUaGUgY29tcG9zZXIgY2xhc3MgaGFuZGxlcyB0aGUgY29uc3RydWN0aW9uIG9mIHJlcHJlc2VudGF0aW9uIHRyZWVzIGZyb20gZXZlbnRzLlxuXG4gIFRoaXMgdXNlcyB0aGUgbWV0aG9kcyBmcm9tIHtQYXJzZXJ9IHRvIHByb2Nlc3MgdGhlIGV2ZW50IHN0cmVhbSwgYW5kIHByb3ZpZGVzIGEgc2ltaWxhciBzdHJlYW0tbGlrZVxuICBpbnRlcmZhY2UgdG8gcmVwcmVzZW50YXRpb24gdHJlZXMgdmlhIHtDb21wb3NlciNjaGVja19ub2RlfSwge0NvbXBvc2VyI2dldF9ub2RlfSwgYW5kXG4gIHtDb21wb3NlciNnZXRfc2luZ2xlX25vZGV9LlxuICAqL1xuICB0aGlzLkNvbXBvc2VyID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdG9yO1xuXG4gICAgY2xhc3MgQ29tcG9zZXIge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBJbml0aWFsaXNlIGEgYENvbXBvc2VyYCBpbnN0YW5jZS5cbiAgICAgICovXG4gICAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICAvLyBAcHJvcGVydHkge09iamVjdH0gQSBtYXBwaW5nIGZyb20gYW5jaG9yIG5hbWVzIHRvIG5vZGVzLlxuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JzID0ge307XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBDaGVja3MgaWYgYSBkb2N1bWVudCBjYW4gYmUgY29tcG9zZWQgZnJvbSB0aGUgZXZlbnQgc3RyZWFtLlxuXG4gICAgICBTbyBsb25nIGFzIHRoZSBldmVudCBzdHJlYW0gaGFzbid0IGVuZGVkIChubyBbU3RyZWFtRW5kRXZlbnRdKSwgYW5vdGhlciBkb2N1bWVudCBjYW4gYmUgY29tcG9zZWQuXG5cbiAgICAgIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgYSBkb2N1bWVudCBjYW4gYmUgY29tcG9zZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICovXG4gICAgICBjaGVja19ub2RlKCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja19ldmVudChldmVudHMuU3RyZWFtU3RhcnRFdmVudCkpIHtcbiAgICAgICAgICAvLyBEcm9wIHRoZSBTVFJFQU0tU1RBUlQgZXZlbnQuXG4gICAgICAgICAgdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcmUgdGhlcmUgbW9yZSBkb2N1bWVudHMgYXZhaWxhYmxlP1xuICAgICAgICByZXR1cm4gIXRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLlN0cmVhbUVuZEV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIENvbXBvc2UgYSBkb2N1bWVudCBmcm9tIHRoZSByZW1haW5pbmcgZXZlbnQgc3RyZWFtLlxuXG4gICAgICB7Q29tcG9zZXIjY2hlY2tfbm9kZX0gbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXG5cbiAgICAgIEByZXR1cm4ge05vZGV9IFRoZSBuZXh0IGRvY3VtZW50IGluIHRoZSBzdHJlYW0uIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGV2ZW50IHN0cmVhbSBoYXMgZW5kZWQuXG4gICAgICAqL1xuICAgICAgZ2V0X25vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja19ldmVudChldmVudHMuU3RyZWFtRW5kRXZlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9zZV9kb2N1bWVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBDb21wb3NlIGEgc2luZ2xlIGRvY3VtZW50IGZyb20gdGhlIGVudGlyZSBldmVudCBzdHJlYW0uXG5cbiAgICAgIEB0aHJvdyB7Q29tcG9zZXJFcnJvcn0gaWYgdGhlcmUncyBtb3JlIHRoYW4gb25lIGRvY3VtZW50IGlzIGluIHRoZSBzdHJlYW0uXG5cbiAgICAgIEByZXR1cm4ge05vZGV9IFRoZSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbS5cbiAgICAgICovXG4gICAgICBnZXRfc2luZ2xlX25vZGUoKSB7XG4gICAgICAgIHZhciBkb2N1bWVudCwgZXZlbnQ7XG4gICAgICAgIC8vIERyb3AgdGhlIFNUUkVBTS1TVEFSVCBldmVudC5cbiAgICAgICAgdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgICAgLy8gQ29tcG9zZSBhIGRvY3VtZW50IGlmIHRoZSBzdHJlYW0gaXMgbm90IGVtcHR5LlxuICAgICAgICBkb2N1bWVudCA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5jaGVja19ldmVudChldmVudHMuU3RyZWFtRW5kRXZlbnQpKSB7XG4gICAgICAgICAgZG9jdW1lbnQgPSB0aGlzLmNvbXBvc2VfZG9jdW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc3RyZWFtIGNvbnRhaW5zIG5vIG1vcmUgZG9jdW1lbnRzLlxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLlN0cmVhbUVuZEV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db21wb3NlckVycm9yKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtJywgZG9jdW1lbnQuc3RhcnRfbWFyaywgJ2J1dCBmb3VuZCBhbm90aGVyIGRvY3VtZW50JywgZXZlbnQuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJvcCB0aGUgU1RSRUFNLUVORCBldmVudC5cbiAgICAgICAgdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgQ29tcG9zZSBhIGRvY3VtZW50IG5vZGUgZnJvbSB0aGUgZXZlbnQgc3RyZWFtLlxuXG4gICAgICBBICdkb2N1bWVudCcgbm9kZSBpcyBhbnkgc2luZ2xlIHtOb2RlfSBzdWJjbGFzcy4gIHtEb2N1bWVudFN0YXJ0fSBhbmQge0RvY3VtZW50RW5kfSBldmVudHMgZGVsaW1pdFxuICAgICAgdGhlIGV2ZW50cyB1c2VkIGZvciBjb21wb3NpdGlvbi5cblxuICAgICAgQHByaXZhdGVcblxuICAgICAgQHJldHVybiB7Tm9kZX0gVGhlIGRvY3VtZW50IG5vZGUuXG4gICAgICAqL1xuICAgICAgY29tcG9zZV9kb2N1bWVudCgpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIC8vIERyb3AgdGhlIERPQ1VNRU5ULVNUQVJUIGV2ZW50LlxuICAgICAgICB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgICAvLyBDb21wb3NlIHRoZSByb290IG5vZGUuXG4gICAgICAgIG5vZGUgPSB0aGlzLmNvbXBvc2Vfbm9kZSgpO1xuICAgICAgICAvLyBEcm9wIHRoZSBET0NVTUVOVC1FTkQgbm9kZS5cbiAgICAgICAgdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgICAgLy8gUmVzZXQgdGhlIGFuY2hvcnNcbiAgICAgICAgdGhpcy5hbmNob3JzID0ge307XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgQ29tcG9zZSBhIG5vZGUgZnJvbSB0aGUgZXZlbnQgc3RyZWFtLlxuXG4gICAgICBDb21wb3NlcyBhIHtTY2FsYXJOb2RlfSwge1NlcXVlbmNlTm9kZX0sIG9yIHtNYXBwaW5nTm9kZX0gZnJvbSB0aGUgZXZlbnQgc3RyZWFtLCBkZXBlbmRpbmcgb24gdGhlXG4gICAgICBmaXJzdCBldmVudCBlbmNvdW50ZXJlZCAoe1NjYWxhckV2ZW50fSwge1NlcXVlbmNlU3RhcnRFdmVudH0sIG9yIHtNYXBwaW5nU3RhcnRFdmVudH1cbiAgICAgIHJlc3BlY3RpdmVseSkuXG5cbiAgICAgIEBwcml2YXRlXG5cbiAgICAgIEBwYXJhbSBwYXJlbnQge05vZGV9IFRoZSBwYXJlbnQgb2YgdGhlIG5ldyBub2RlLlxuICAgICAgQHBhcmFtIGluZGV4IHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgbmV3IG5vZGUgd2l0aGluIHRoZSBwYXJlbnQncyBjaGlsZHJlbi5cbiAgICAgIEB0aHJvdyB7Q29tcG9zZXJFcnJvcn0gaWYgYW4gYWxpYXMgaXMgZW5jb3VudGVyZWQgZm9yIGFuIHVuZGVmaW5lZCBhbmNob3IuXG4gICAgICBAdGhyb3cge0NvbXBvc2VyRXJyb3J9IGlmIGEgZHVwbGljYXRlIGFuY2hvciBpcyBlbnZvdW50ZXJlZC5cbiAgICAgIEByZXR1cm4ge05vZGV9IFRoZSBjb21wb3NlZCBub2RlLlxuICAgICAgKi9cbiAgICAgIGNvbXBvc2Vfbm9kZShwYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBhbmNob3IsIGV2ZW50LCBub2RlO1xuICAgICAgICBpZiAodGhpcy5jaGVja19ldmVudChldmVudHMuQWxpYXNFdmVudCkpIHtcbiAgICAgICAgICBldmVudCA9IHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICAgICAgYW5jaG9yID0gZXZlbnQuYW5jaG9yO1xuICAgICAgICAgIGlmICghKGFuY2hvciBpbiB0aGlzLmFuY2hvcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db21wb3NlckVycm9yKG51bGwsIG51bGwsIGBmb3VuZCB1bmRlZmluZWQgYWxpYXMgJHthbmNob3J9YCwgZXZlbnQuc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmFuY2hvcnNbYW5jaG9yXTtcbiAgICAgICAgfVxuICAgICAgICBldmVudCA9IHRoaXMucGVla19ldmVudCgpO1xuICAgICAgICBhbmNob3IgPSBldmVudC5hbmNob3I7XG4gICAgICAgIGlmIChhbmNob3IgIT09IG51bGwgJiYgYW5jaG9yIGluIHRoaXMuYW5jaG9ycykge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbXBvc2VyRXJyb3IoYGZvdW5kIGR1cGxpY2F0ZSBhbmNob3IgJHthbmNob3J9OyBmaXJzdCBvY2N1cmVuY2VgLCB0aGlzLmFuY2hvcnNbYW5jaG9yXS5zdGFydF9tYXJrLCAnc2Vjb25kIG9jY3VycmVuY2UnLCBldmVudC5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc2NlbmRfcmVzb2x2ZXIocGFyZW50LCBpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5TY2FsYXJFdmVudCkpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5jb21wb3NlX3NjYWxhcl9ub2RlKGFuY2hvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja19ldmVudChldmVudHMuU2VxdWVuY2VTdGFydEV2ZW50KSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmNvbXBvc2Vfc2VxdWVuY2Vfbm9kZShhbmNob3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLk1hcHBpbmdTdGFydEV2ZW50KSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmNvbXBvc2VfbWFwcGluZ19ub2RlKGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc2NlbmRfcmVzb2x2ZXIoKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBDb21wb3NlIGEge1NjYWxhck5vZGV9IGZyb20gdGhlIGV2ZW50IHN0cmVhbS5cblxuICAgICAgQHByaXZhdGVcblxuICAgICAgQHBhcmFtIGFuY2hvciB7U3RyaW5nfSBUaGUgYW5jaG9yIG5hbWUgZm9yIHRoZSBub2RlIChpZiBhbnkpLlxuICAgICAgQHJldHVybiB7U2NhbGFyTm9kZX0gVGhlIG5vZGUgY29tcG9zZWQgZnJvbSBhIHtTY2FsYXJFdmVudH0uXG4gICAgICAqL1xuICAgICAgY29tcG9zZV9zY2FsYXJfbm9kZShhbmNob3IpIHtcbiAgICAgICAgdmFyIGV2ZW50LCBub2RlLCB0YWc7XG4gICAgICAgIGV2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgICAgdGFnID0gZXZlbnQudGFnO1xuICAgICAgICBpZiAodGFnID09PSBudWxsIHx8IHRhZyA9PT0gJyEnKSB7XG4gICAgICAgICAgdGFnID0gdGhpcy5yZXNvbHZlKG5vZGVzLlNjYWxhck5vZGUsIGV2ZW50LnZhbHVlLCBldmVudC5pbXBsaWNpdCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKHRhZywgZXZlbnQudmFsdWUsIGV2ZW50LnN0YXJ0X21hcmssIGV2ZW50LmVuZF9tYXJrLCBldmVudC5zdHlsZSk7XG4gICAgICAgIGlmIChhbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmFuY2hvcnNbYW5jaG9yXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBDb21wb3NlIGEge1NlcXVlbmNlTm9kZX0gZnJvbSB0aGUgZXZlbnQgc3RyZWFtLlxuXG4gICAgICBUaGUgY29udGVudHMgb2YgdGhlIG5vZGUgYXJlIGNvbXBvc2VkIGZyb20gZXZlbnRzIGJldHdlZW4gYSB7U2VxdWVuY2VTdGFydEV2ZW50fSBhbmQgYVxuICAgICAge1NlcXVlbmNlRW5kRXZlbnR9LlxuXG4gICAgICBAcHJpdmF0ZVxuXG4gICAgICBAcGFyYW0gYW5jaG9yIHtTdHJpbmd9IFRoZSBhbmNob3IgbmFtZSBmb3IgdGhlIG5vZGUgKGlmIGFueSkuXG4gICAgICBAcmV0dXJuIHtTZXF1ZW5jZU5vZGV9IFRoZSBjb21wb3NlZCBub2RlLlxuICAgICAgKi9cbiAgICAgIGNvbXBvc2Vfc2VxdWVuY2Vfbm9kZShhbmNob3IpIHtcbiAgICAgICAgdmFyIGVuZF9ldmVudCwgaW5kZXgsIG5vZGUsIHN0YXJ0X2V2ZW50LCB0YWc7XG4gICAgICAgIHN0YXJ0X2V2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgICAgdGFnID0gc3RhcnRfZXZlbnQudGFnO1xuICAgICAgICBpZiAodGFnID09PSBudWxsIHx8IHRhZyA9PT0gJyEnKSB7XG4gICAgICAgICAgdGFnID0gdGhpcy5yZXNvbHZlKG5vZGVzLlNlcXVlbmNlTm9kZSwgbnVsbCwgc3RhcnRfZXZlbnQuaW1wbGljaXQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuU2VxdWVuY2VOb2RlKHRhZywgW10sIHN0YXJ0X2V2ZW50LnN0YXJ0X21hcmssIG51bGwsIHN0YXJ0X2V2ZW50LmZsb3dfc3R5bGUpO1xuICAgICAgICBpZiAoYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5hbmNob3JzW2FuY2hvcl0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5TZXF1ZW5jZUVuZEV2ZW50KSkge1xuICAgICAgICAgIG5vZGUudmFsdWUucHVzaCh0aGlzLmNvbXBvc2Vfbm9kZShub2RlLCBpbmRleCkpO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZW5kX2V2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgICAgbm9kZS5lbmRfbWFyayA9IGVuZF9ldmVudC5lbmRfbWFyaztcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBDb21wb3NlIGEge01hcHBpbmdOb2RlfSBmcm9tIHRoZSBldmVudCBzdHJlYW0uXG5cbiAgICAgIFRoZSBjb250ZW50cyBvZiB0aGUgbm9kZSBhcmUgY29tcG9zZWQgZnJvbSBldmVudHMgYmV0d2VlbiBhIHtNYXBwaW5nU3RhcnRFdmVudH0gYW5kIGFcbiAgICAgIHtNYXBwaW5nRW5kRXZlbnR9LlxuXG4gICAgICBAcHJpdmF0ZVxuXG4gICAgICBAcGFyYW0gYW5jaG9yIHtTdHJpbmd9IFRoZSBhbmNob3IgbmFtZSBmb3IgdGhlIG5vZGUgKGlmIGFueSkuXG4gICAgICBAcmV0dXJuIHtNYXBwaW5nTm9kZX0gVGhlIGNvbXBvc2VkIG5vZGUuXG4gICAgICAqL1xuICAgICAgY29tcG9zZV9tYXBwaW5nX25vZGUoYW5jaG9yKSB7XG4gICAgICAgIHZhciBlbmRfZXZlbnQsIGl0ZW1fa2V5LCBpdGVtX3ZhbHVlLCBub2RlLCBzdGFydF9ldmVudCwgdGFnO1xuICAgICAgICBzdGFydF9ldmVudCA9IHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICAgIHRhZyA9IHN0YXJ0X2V2ZW50LnRhZztcbiAgICAgICAgaWYgKHRhZyA9PT0gbnVsbCB8fCB0YWcgPT09ICchJykge1xuICAgICAgICAgIHRhZyA9IHRoaXMucmVzb2x2ZShub2Rlcy5NYXBwaW5nTm9kZSwgbnVsbCwgc3RhcnRfZXZlbnQuaW1wbGljaXQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTWFwcGluZ05vZGUodGFnLCBbXSwgc3RhcnRfZXZlbnQuc3RhcnRfbWFyaywgbnVsbCwgc3RhcnRfZXZlbnQuZmxvd19zdHlsZSk7XG4gICAgICAgIGlmIChhbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmFuY2hvcnNbYW5jaG9yXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCF0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5NYXBwaW5nRW5kRXZlbnQpKSB7XG4gICAgICAgICAgaXRlbV9rZXkgPSB0aGlzLmNvbXBvc2Vfbm9kZShub2RlKTtcbiAgICAgICAgICBpdGVtX3ZhbHVlID0gdGhpcy5jb21wb3NlX25vZGUobm9kZSwgaXRlbV9rZXkpO1xuICAgICAgICAgIG5vZGUudmFsdWUucHVzaChbaXRlbV9rZXksIGl0ZW1fdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbmRfZXZlbnQgPSB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgICBub2RlLmVuZF9tYXJrID0gZW5kX2V2ZW50LmVuZF9tYXJrO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBjdG9yID0gQ29tcG9zZXIucHJvdG90eXBlLmluaXRpYWxpc2U7XG5cbiAgICByZXR1cm4gQ29tcG9zZXI7XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///391\n")},574:function(__unused_webpack_module,exports,__webpack_require__){eval("(function() {\n  var MarkedYAMLError, nodes, util,\n    indexOf = [].indexOf;\n\n  ({MarkedYAMLError} = __webpack_require__(372));\n\n  nodes = __webpack_require__(914);\n\n  util = __webpack_require__(823);\n\n  /*\n  Thrown for errors encountered during construction.\n  */\n  this.ConstructorError = class ConstructorError extends MarkedYAMLError {};\n\n  /*\n  The constructor class handles the construction of Javascript objects from representation trees\n  ({Node}s).\n\n  This uses the methods from {Composer} to process the representation stream, and provides a similar\n  stream-like interface to Javascript objects via {BaseConstructor#check_node},\n  {BaseConstructor#get_node}, and {BaseConstructor#get_single_node}.\n  */\n  this.BaseConstructor = (function() {\n    var ctor;\n\n    class BaseConstructor {\n      constructor() {\n        return ctor.apply(this, arguments);\n      }\n\n      /*\n      Add a constructor function for a specific tag.\n\n      The constructor will be used to turn {Node Nodes} with the given tag into a Javascript object.\n\n      @param tag {String} The tag for which the constructor should apply.\n      @param constructor {Function<Node,any>} A function that turns a {Node} with the given tag into a\n        Javascript object.\n      @return {Function<Node,Any>} Returns the supplied `constructor`.\n      */\n      static add_constructor(tag, constructor) {\n        if (!this.prototype.hasOwnProperty('yaml_constructors')) {\n          this.prototype.yaml_constructors = util.extend({}, this.prototype.yaml_constructors);\n        }\n        return this.prototype.yaml_constructors[tag] = constructor;\n      }\n\n      /*\n      Add a constructor function for a tag prefix.\n\n      The constructor will be used to turn {Node Nodes} with the given tag prefix into a Javascript\n      object.\n\n      @param tag_prefix {String} The tag prefix for which the constructor should apply.\n      @param multi_constructor {Function<Node,any>} A function that turns a {Node} with the given tag\n      prefix into a Javascript object.\n      @return {Function<Node,Any>} Returns the supplied `multi_constructor`.\n      */\n      static add_multi_constructor(tag_prefix, multi_constructor) {\n        if (!this.prototype.hasOwnProperty('yaml_multi_constructors')) {\n          this.prototype.yaml_multi_constructors = util.extend({}, this.prototype.yaml_multi_constructors);\n        }\n        return this.prototype.yaml_multi_constructors[tag_prefix] = multi_constructor;\n      }\n\n      /*\n      Initialise a new instance.\n      */\n      initialise() {\n        // @param {Object} A map from {Node#unique_id} to the constructed Javascript object for the node.\n        this.constructed_objects = {};\n        // @param {Array<String>} An array of {Node#unique_id}s that are being constructed.\n        this.constructing_nodes = [];\n        // @param {Function<any>} An array of functions to be exectied after docmuent construction.\n        return this.deferred_constructors = [];\n      }\n\n      /*\n      Checks if a document can be constructed from the representation stream.\n\n      So long as the representation stream hasn't ended, another document can be constructed.\n\n      @return {Boolean} True if a document can be constructed, false otherwise.\n      */\n      check_data() {\n        return this.check_node();\n      }\n\n      /*\n      Construct a document from the remaining representation stream.\n\n      {Constructor#check_data} must be called before calling this method.\n\n      @return {any} The next document in the stream. Returns `undefined` if the stream has ended.\n      */\n      get_data() {\n        if (this.check_node()) {\n          return this.construct_document(this.get_node());\n        }\n      }\n\n      /*\n      Construct a single document from the entire representation stream.\n\n      @throw {ComposerError} if there's more than one document is in the stream.\n\n      @return {Node} The single document in the stream.\n      */\n      get_single_data() {\n        var node;\n        node = this.get_single_node();\n        if (node != null) {\n          return this.construct_document(node);\n        }\n        return null;\n      }\n\n      /*\n      Construct a document node\n\n      @private\n      */\n      construct_document(node) {\n        var data;\n        data = this.construct_object(node);\n        while (!util.is_empty(this.deferred_constructors)) {\n          this.deferred_constructors.pop()();\n        }\n        return data;\n      }\n\n      defer(f) {\n        return this.deferred_constructors.push(f);\n      }\n\n      construct_object(node) {\n        var constructor, object, ref, tag_prefix, tag_suffix;\n        if (node.unique_id in this.constructed_objects) {\n          return this.constructed_objects[node.unique_id];\n        }\n        if (ref = node.unique_id, indexOf.call(this.constructing_nodes, ref) >= 0) {\n          throw new exports.ConstructorError(null, null, 'found unconstructable recursive node', node.start_mark);\n        }\n        this.constructing_nodes.push(node.unique_id);\n        constructor = null;\n        tag_suffix = null;\n        if (node.tag in this.yaml_constructors) {\n          constructor = this.yaml_constructors[node.tag];\n        } else {\n          for (tag_prefix in this.yaml_multi_constructors) {\n            if (node.tag.indexOf(tag_prefix === 0)) {\n              tag_suffix = node.tag.slice(tag_prefix.length);\n              constructor = this.yaml_multi_constructors[tag_prefix];\n              break;\n            }\n          }\n          if (constructor == null) {\n            if (null in this.yaml_multi_constructors) {\n              tag_suffix = node.tag;\n              constructor = this.yaml_multi_constructors[null];\n            } else if (null in this.yaml_constructors) {\n              constructor = this.yaml_constructors[null];\n            } else if (node instanceof nodes.ScalarNode) {\n              constructor = this.construct_scalar;\n            } else if (node instanceof nodes.SequenceNode) {\n              constructor = this.construct_sequence;\n            } else if (node instanceof nodes.MappingNode) {\n              constructor = this.construct_mapping;\n            }\n          }\n        }\n        object = constructor.call(this, tag_suffix != null ? tag_suffix : node, node);\n        this.constructed_objects[node.unique_id] = object;\n        this.constructing_nodes.pop();\n        return object;\n      }\n\n      construct_scalar(node) {\n        if (!(node instanceof nodes.ScalarNode)) {\n          throw new exports.ConstructorError(null, null, `expected a scalar node but found ${node.id}`, node.start_mark);\n        }\n        return node.value;\n      }\n\n      construct_sequence(node) {\n        var child, i, len, ref, results;\n        if (!(node instanceof nodes.SequenceNode)) {\n          throw new exports.ConstructorError(null, null, `expected a sequence node but found ${node.id}`, node.start_mark);\n        }\n        ref = node.value;\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          results.push(this.construct_object(child));\n        }\n        return results;\n      }\n\n      construct_mapping(node) {\n        var i, key, key_node, len, mapping, ref, value, value_node;\n        if (!(node instanceof nodes.MappingNode)) {\n          throw new ConstructorError(null, null, `expected a mapping node but found ${node.id}`, node.start_mark);\n        }\n        mapping = {};\n        ref = node.value;\n        for (i = 0, len = ref.length; i < len; i++) {\n          [key_node, value_node] = ref[i];\n          key = this.construct_object(key_node);\n          if (typeof key === 'object') {\n            throw new exports.ConstructorError('while constructing a mapping', node.start_mark, 'found unhashable key', key_node.start_mark);\n          }\n          value = this.construct_object(value_node);\n          mapping[key] = value;\n        }\n        return mapping;\n      }\n\n      construct_pairs(node) {\n        var i, key, key_node, len, pairs, ref, value, value_node;\n        if (!(node instanceof nodes.MappingNode)) {\n          throw new exports.ConstructorError(null, null, `expected a mapping node but found ${node.id}`, node.start_mark);\n        }\n        pairs = [];\n        ref = node.value;\n        for (i = 0, len = ref.length; i < len; i++) {\n          [key_node, value_node] = ref[i];\n          key = this.construct_object(key_node);\n          value = this.construct_object(value_node);\n          pairs.push([key, value]);\n        }\n        return pairs;\n      }\n\n    };\n\n    /*\n    @property {Object} A map from a YAML tag to a constructor function for data with that tag.\n    @private\n    */\n    BaseConstructor.prototype.yaml_constructors = {};\n\n    /*\n    @property {Object} A map from a YAML tag prefix to a constructor function for data with that tag\n                       prefix.\n    @private\n    */\n    BaseConstructor.prototype.yaml_multi_constructors = {};\n\n    ctor = BaseConstructor.prototype.initialise;\n\n    return BaseConstructor;\n\n  }).call(this);\n\n  this.Constructor = (function() {\n    var BOOL_VALUES, TIMESTAMP_PARTS, TIMESTAMP_REGEX;\n\n    class Constructor extends this.BaseConstructor {\n      construct_scalar(node) {\n        var i, key_node, len, ref, value_node;\n        if (node instanceof nodes.MappingNode) {\n          ref = node.value;\n          for (i = 0, len = ref.length; i < len; i++) {\n            [key_node, value_node] = ref[i];\n            if (key_node.tag === 'tag:yaml.org,2002:value') {\n              return this.construct_scalar(value_node);\n            }\n          }\n        }\n        return super.construct_scalar(node);\n      }\n\n      flatten_mapping(node) {\n        var i, index, j, key_node, len, len1, merge, ref, submerge, subnode, value, value_node;\n        merge = [];\n        index = 0;\n        while (index < node.value.length) {\n          [key_node, value_node] = node.value[index];\n          if (key_node.tag === 'tag:yaml.org,2002:merge') {\n            node.value.splice(index, 1);\n            //delete node.value[index]\n            if (value_node instanceof nodes.MappingNode) {\n              this.flatten_mapping(value_node);\n              merge = merge.concat(value_node.value);\n            } else if (value_node instanceof nodes.SequenceNode) {\n              submerge = [];\n              ref = value_node.value;\n              for (i = 0, len = ref.length; i < len; i++) {\n                subnode = ref[i];\n                if (!(subnode instanceof nodes.MappingNode)) {\n                  throw new exports.ConstructorError('while constructing a mapping', node.start_mark, `expected a mapping for merging, but found ${subnode.id}`, subnode.start_mark);\n                }\n                this.flatten_mapping(subnode);\n                submerge.push(subnode.value);\n              }\n              submerge.reverse();\n              for (j = 0, len1 = submerge.length; j < len1; j++) {\n                value = submerge[j];\n                merge = merge.concat(value);\n              }\n            } else {\n              throw new exports.ConstructorError('while constructing a mapping', node.start_mark, `expected a mapping or list of mappings for merging but found ${value_node.id}`, value_node.start_mark);\n            }\n          } else if (key_node.tag === 'tag:yaml.org,2002:value') {\n            key_node.tag = 'tag:yaml.org,2002:str';\n            index++;\n          } else {\n            index++;\n          }\n        }\n        if (merge.length) {\n          return node.value = merge.concat(node.value);\n        }\n      }\n\n      construct_mapping(node) {\n        if (node instanceof nodes.MappingNode) {\n          this.flatten_mapping(node);\n        }\n        return super.construct_mapping(node);\n      }\n\n      construct_yaml_null(node) {\n        this.construct_scalar(node);\n        return null;\n      }\n\n      construct_yaml_bool(node) {\n        var value;\n        value = this.construct_scalar(node);\n        return BOOL_VALUES[value.toLowerCase()];\n      }\n\n      construct_yaml_int(node) {\n        var base, digit, digits, i, len, part, ref, sign, value;\n        value = this.construct_scalar(node);\n        value = value.replace(/_/g, '');\n        sign = value[0] === '-' ? -1 : 1;\n        if (ref = value[0], indexOf.call('+-', ref) >= 0) {\n          value = value.slice(1);\n        }\n        if (value === '0') {\n          return 0;\n        } else if (value.indexOf('0b') === 0) {\n          return sign * parseInt(value.slice(2), 2);\n        } else if (value.indexOf('0x') === 0) {\n          return sign * parseInt(value.slice(2), 16);\n        } else if (value.indexOf('0o') === 0) {\n          return sign * parseInt(value.slice(2), 8);\n        } else if (value[0] === '0') {\n          return sign * parseInt(value, 8);\n        } else if (indexOf.call(value, ':') >= 0) {\n          digits = (function() {\n            var i, len, ref1, results;\n            ref1 = value.split(/:/g);\n            results = [];\n            for (i = 0, len = ref1.length; i < len; i++) {\n              part = ref1[i];\n              results.push(parseInt(part));\n            }\n            return results;\n          })();\n          digits.reverse();\n          base = 1;\n          value = 0;\n          for (i = 0, len = digits.length; i < len; i++) {\n            digit = digits[i];\n            value += digit * base;\n            base *= 60;\n          }\n          return sign * value;\n        } else {\n          return sign * parseInt(value);\n        }\n      }\n\n      construct_yaml_float(node) {\n        var base, digit, digits, i, len, part, ref, sign, value;\n        value = this.construct_scalar(node);\n        value = value.replace(/_/g, '').toLowerCase();\n        sign = value[0] === '-' ? -1 : 1;\n        if (ref = value[0], indexOf.call('+-', ref) >= 0) {\n          value = value.slice(1);\n        }\n        if (value === '.inf') {\n          return sign * 2e308;\n        } else if (value === '.nan') {\n          return 0/0;\n        } else if (indexOf.call(value, ':') >= 0) {\n          digits = (function() {\n            var i, len, ref1, results;\n            ref1 = value.split(/:/g);\n            results = [];\n            for (i = 0, len = ref1.length; i < len; i++) {\n              part = ref1[i];\n              results.push(parseFloat(part));\n            }\n            return results;\n          })();\n          digits.reverse();\n          base = 1;\n          value = 0.0;\n          for (i = 0, len = digits.length; i < len; i++) {\n            digit = digits[i];\n            value += digit * base;\n            base *= 60;\n          }\n          return sign * value;\n        } else {\n          return sign * parseFloat(value);\n        }\n      }\n\n      construct_yaml_binary(node) {\n        var error, value;\n        value = this.construct_scalar(node);\n        try {\n          if (typeof window !== \"undefined\" && window !== null) {\n            return atob(value);\n          }\n          return new Buffer(value, 'base64').toString('ascii');\n        } catch (error1) {\n          error = error1;\n          throw new exports.ConstructorError(null, null, `failed to decode base64 data: ${error}`, node.start_mark);\n        }\n      }\n\n      construct_yaml_timestamp(node) {\n        var date, day, fraction, hour, index, key, match, millisecond, minute, month, second, tz_hour, tz_minute, tz_sign, value, values, year;\n        value = this.construct_scalar(node);\n        match = node.value.match(TIMESTAMP_REGEX);\n        values = {};\n        for (key in TIMESTAMP_PARTS) {\n          index = TIMESTAMP_PARTS[key];\n          values[key] = match[index];\n        }\n        year = parseInt(values.year);\n        month = parseInt(values.month) - 1;\n        day = parseInt(values.day);\n        if (!values.hour) {\n          return new Date(Date.UTC(year, month, day));\n        }\n        hour = parseInt(values.hour);\n        minute = parseInt(values.minute);\n        second = parseInt(values.second);\n        millisecond = 0;\n        if (values.fraction) {\n          fraction = values.fraction.slice(0, 6);\n          while (fraction.length < 6) {\n            fraction += '0';\n          }\n          fraction = parseInt(fraction);\n          millisecond = Math.round(fraction / 1000);\n        }\n        if (values.tz_sign) {\n          tz_sign = values.tz_sign === '-' ? 1 : -1;\n          if (tz_hour = parseInt(values.tz_hour)) {\n            hour += tz_sign * tz_hour;\n          }\n          if (tz_minute = parseInt(values.tz_minute)) {\n            minute += tz_sign * tz_minute;\n          }\n        }\n        date = new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));\n        return date;\n      }\n\n      construct_yaml_pair_list(type, node) {\n        var list;\n        list = [];\n        if (!(node instanceof nodes.SequenceNode)) {\n          throw new exports.ConstructorError(`while constructing ${type}`, node.start_mark, `expected a sequence but found ${node.id}`, node.start_mark);\n        }\n        this.defer(() => {\n          var i, key, key_node, len, ref, results, subnode, value, value_node;\n          ref = node.value;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subnode = ref[i];\n            if (!(subnode instanceof nodes.MappingNode)) {\n              throw new exports.ConstructorError(`while constructing ${type}`, node.start_mark, `expected a mapping of length 1 but found ${subnode.id}`, subnode.start_mark);\n            }\n            if (subnode.value.length !== 1) {\n              throw new exports.ConstructorError(`while constructing ${type}`, node.start_mark, `expected a mapping of length 1 but found ${subnode.id}`, subnode.start_mark);\n            }\n            [key_node, value_node] = subnode.value[0];\n            key = this.construct_object(key_node);\n            value = this.construct_object(value_node);\n            results.push(list.push([key, value]));\n          }\n          return results;\n        });\n        return list;\n      }\n\n      construct_yaml_omap(node) {\n        return this.construct_yaml_pair_list('an ordered map', node);\n      }\n\n      construct_yaml_pairs(node) {\n        return this.construct_yaml_pair_list('pairs', node);\n      }\n\n      construct_yaml_set(node) {\n        var data;\n        data = [];\n        this.defer(() => {\n          var item, results;\n          results = [];\n          for (item in this.construct_mapping(node)) {\n            results.push(data.push(item));\n          }\n          return results;\n        });\n        return data;\n      }\n\n      construct_yaml_str(node) {\n        return this.construct_scalar(node);\n      }\n\n      construct_yaml_seq(node) {\n        var data;\n        data = [];\n        this.defer(() => {\n          var i, item, len, ref, results;\n          ref = this.construct_sequence(node);\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            item = ref[i];\n            results.push(data.push(item));\n          }\n          return results;\n        });\n        return data;\n      }\n\n      construct_yaml_map(node) {\n        var data;\n        data = {};\n        this.defer(() => {\n          var key, ref, results, value;\n          ref = this.construct_mapping(node);\n          results = [];\n          for (key in ref) {\n            value = ref[key];\n            results.push(data[key] = value);\n          }\n          return results;\n        });\n        return data;\n      }\n\n      construct_yaml_object(node, klass) {\n        var data;\n        data = new klass;\n        this.defer(() => {\n          var key, ref, results, value;\n          ref = this.construct_mapping(node, true);\n          results = [];\n          for (key in ref) {\n            value = ref[key];\n            results.push(data[key] = value);\n          }\n          return results;\n        });\n        return data;\n      }\n\n      construct_undefined(node) {\n        throw new exports.ConstructorError(null, null, `could not determine a constructor for the tag ${node.tag}`, node.start_mark);\n      }\n\n    };\n\n    BOOL_VALUES = {\n      on: true,\n      off: false,\n      true: true,\n      false: false,\n      yes: true,\n      no: false\n    };\n\n    TIMESTAMP_REGEX = /^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:(?:[Tt]|[\\x20\\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[\\x20\\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?)?$/; //  1: year\n    //  2: month\n    //  3: day\n    //  4: hour\n    //  5: minute\n    //  6: second\n    //  7: fraction\n    //  9: tz_sign\n    // 10: tz_hour\n    // 11: tz_minute\n    //  8: tz\n\n    TIMESTAMP_PARTS = {\n      year: 1,\n      month: 2,\n      day: 3,\n      hour: 4,\n      minute: 5,\n      second: 6,\n      fraction: 7,\n      tz: 8,\n      tz_sign: 9,\n      tz_hour: 10,\n      tz_minute: 11\n    };\n\n    return Constructor;\n\n  }).call(this);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:null', this.Constructor.prototype.construct_yaml_null);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:bool', this.Constructor.prototype.construct_yaml_bool);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:int', this.Constructor.prototype.construct_yaml_int);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:float', this.Constructor.prototype.construct_yaml_float);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:binary', this.Constructor.prototype.construct_yaml_binary);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:timestamp', this.Constructor.prototype.construct_yaml_timestamp);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:omap', this.Constructor.prototype.construct_yaml_omap);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:pairs', this.Constructor.prototype.construct_yaml_pairs);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:set', this.Constructor.prototype.construct_yaml_set);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:str', this.Constructor.prototype.construct_yaml_str);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:seq', this.Constructor.prototype.construct_yaml_seq);\n\n  this.Constructor.add_constructor('tag:yaml.org,2002:map', this.Constructor.prototype.construct_yaml_map);\n\n  this.Constructor.add_constructor(null, this.Constructor.prototype.construct_undefined);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsR0FBVTs7QUFFekMsVUFBVSxtQkFBTyxDQUFDLEdBQVM7O0FBRTNCLFNBQVMsbUJBQU8sQ0FBQyxHQUFROztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxLQUFLOztBQUVULDhCQUE4QixVQUFVO0FBQ3hDLG1EQUFtRCwyQkFBMkI7QUFDOUUsR0FBRyx5QkFBeUIsT0FBTyxnQ0FBZ0M7QUFDbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLFlBQVk7O0FBRXhELGtCQUFrQixRQUFRO0FBQzFCLDBCQUEwQixvQkFBb0IseUJBQXlCLE1BQU07QUFDN0U7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLFlBQVk7QUFDeEQ7O0FBRUEseUJBQXlCLFFBQVE7QUFDakMsZ0NBQWdDLG9CQUFvQix5QkFBeUIsTUFBTTtBQUNuRjtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUSxZQUFZLGdCQUFnQjtBQUN2RDtBQUNBLG1CQUFtQixlQUFlLGFBQWEsZUFBZTtBQUM5RDtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPLHdCQUF3Qjs7QUFFL0IsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsZUFBZTs7QUFFN0IsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkZBQTZGLFFBQVE7QUFDckc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixRQUFRO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLFFBQVE7QUFDdEc7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQSxtSkFBbUosV0FBVztBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtLQUFrSyxjQUFjO0FBQ2hMO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwwRkFBMEYsTUFBTTtBQUNoRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxLQUFLLHFEQUFxRCxRQUFRO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0EsdUVBQXVFLEtBQUssZ0VBQWdFLFdBQVc7QUFDdko7QUFDQTtBQUNBLHVFQUF1RSxLQUFLLGdFQUFnRSxXQUFXO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSx3R0FBd0csU0FBUztBQUNqSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtOQUFrTjtBQUNsTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMveWFtbC1qcy9saWIvY29uc3RydWN0b3IuanM/N2U0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIG5vZGVzLCB1dGlsLFxuICAgIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG4gICh7TWFya2VkWUFNTEVycm9yfSA9IHJlcXVpcmUoJy4vZXJyb3JzJykpO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKlxuICBUaHJvd24gZm9yIGVycm9ycyBlbmNvdW50ZXJlZCBkdXJpbmcgY29uc3RydWN0aW9uLlxuICAqL1xuICB0aGlzLkNvbnN0cnVjdG9yRXJyb3IgPSBjbGFzcyBDb25zdHJ1Y3RvckVycm9yIGV4dGVuZHMgTWFya2VkWUFNTEVycm9yIHt9O1xuXG4gIC8qXG4gIFRoZSBjb25zdHJ1Y3RvciBjbGFzcyBoYW5kbGVzIHRoZSBjb25zdHJ1Y3Rpb24gb2YgSmF2YXNjcmlwdCBvYmplY3RzIGZyb20gcmVwcmVzZW50YXRpb24gdHJlZXNcbiAgKHtOb2RlfXMpLlxuXG4gIFRoaXMgdXNlcyB0aGUgbWV0aG9kcyBmcm9tIHtDb21wb3Nlcn0gdG8gcHJvY2VzcyB0aGUgcmVwcmVzZW50YXRpb24gc3RyZWFtLCBhbmQgcHJvdmlkZXMgYSBzaW1pbGFyXG4gIHN0cmVhbS1saWtlIGludGVyZmFjZSB0byBKYXZhc2NyaXB0IG9iamVjdHMgdmlhIHtCYXNlQ29uc3RydWN0b3IjY2hlY2tfbm9kZX0sXG4gIHtCYXNlQ29uc3RydWN0b3IjZ2V0X25vZGV9LCBhbmQge0Jhc2VDb25zdHJ1Y3RvciNnZXRfc2luZ2xlX25vZGV9LlxuICAqL1xuICB0aGlzLkJhc2VDb25zdHJ1Y3RvciA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY3RvcjtcblxuICAgIGNsYXNzIEJhc2VDb25zdHJ1Y3RvciB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIEFkZCBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBhIHNwZWNpZmljIHRhZy5cblxuICAgICAgVGhlIGNvbnN0cnVjdG9yIHdpbGwgYmUgdXNlZCB0byB0dXJuIHtOb2RlIE5vZGVzfSB3aXRoIHRoZSBnaXZlbiB0YWcgaW50byBhIEphdmFzY3JpcHQgb2JqZWN0LlxuXG4gICAgICBAcGFyYW0gdGFnIHtTdHJpbmd9IFRoZSB0YWcgZm9yIHdoaWNoIHRoZSBjb25zdHJ1Y3RvciBzaG91bGQgYXBwbHkuXG4gICAgICBAcGFyYW0gY29uc3RydWN0b3Ige0Z1bmN0aW9uPE5vZGUsYW55Pn0gQSBmdW5jdGlvbiB0aGF0IHR1cm5zIGEge05vZGV9IHdpdGggdGhlIGdpdmVuIHRhZyBpbnRvIGFcbiAgICAgICAgSmF2YXNjcmlwdCBvYmplY3QuXG4gICAgICBAcmV0dXJuIHtGdW5jdGlvbjxOb2RlLEFueT59IFJldHVybnMgdGhlIHN1cHBsaWVkIGBjb25zdHJ1Y3RvcmAuXG4gICAgICAqL1xuICAgICAgc3RhdGljIGFkZF9jb25zdHJ1Y3Rvcih0YWcsIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3lhbWxfY29uc3RydWN0b3JzJykpIHtcbiAgICAgICAgICB0aGlzLnByb3RvdHlwZS55YW1sX2NvbnN0cnVjdG9ycyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLnByb3RvdHlwZS55YW1sX2NvbnN0cnVjdG9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlLnlhbWxfY29uc3RydWN0b3JzW3RhZ10gPSBjb25zdHJ1Y3RvcjtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIEFkZCBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBhIHRhZyBwcmVmaXguXG5cbiAgICAgIFRoZSBjb25zdHJ1Y3RvciB3aWxsIGJlIHVzZWQgdG8gdHVybiB7Tm9kZSBOb2Rlc30gd2l0aCB0aGUgZ2l2ZW4gdGFnIHByZWZpeCBpbnRvIGEgSmF2YXNjcmlwdFxuICAgICAgb2JqZWN0LlxuXG4gICAgICBAcGFyYW0gdGFnX3ByZWZpeCB7U3RyaW5nfSBUaGUgdGFnIHByZWZpeCBmb3Igd2hpY2ggdGhlIGNvbnN0cnVjdG9yIHNob3VsZCBhcHBseS5cbiAgICAgIEBwYXJhbSBtdWx0aV9jb25zdHJ1Y3RvciB7RnVuY3Rpb248Tm9kZSxhbnk+fSBBIGZ1bmN0aW9uIHRoYXQgdHVybnMgYSB7Tm9kZX0gd2l0aCB0aGUgZ2l2ZW4gdGFnXG4gICAgICBwcmVmaXggaW50byBhIEphdmFzY3JpcHQgb2JqZWN0LlxuICAgICAgQHJldHVybiB7RnVuY3Rpb248Tm9kZSxBbnk+fSBSZXR1cm5zIHRoZSBzdXBwbGllZCBgbXVsdGlfY29uc3RydWN0b3JgLlxuICAgICAgKi9cbiAgICAgIHN0YXRpYyBhZGRfbXVsdGlfY29uc3RydWN0b3IodGFnX3ByZWZpeCwgbXVsdGlfY29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgneWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnMnKSkge1xuICAgICAgICAgIHRoaXMucHJvdG90eXBlLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzID0gdXRpbC5leHRlbmQoe30sIHRoaXMucHJvdG90eXBlLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnNbdGFnX3ByZWZpeF0gPSBtdWx0aV9jb25zdHJ1Y3RvcjtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIEluaXRpYWxpc2UgYSBuZXcgaW5zdGFuY2UuXG4gICAgICAqL1xuICAgICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgLy8gQHBhcmFtIHtPYmplY3R9IEEgbWFwIGZyb20ge05vZGUjdW5pcXVlX2lkfSB0byB0aGUgY29uc3RydWN0ZWQgSmF2YXNjcmlwdCBvYmplY3QgZm9yIHRoZSBub2RlLlxuICAgICAgICB0aGlzLmNvbnN0cnVjdGVkX29iamVjdHMgPSB7fTtcbiAgICAgICAgLy8gQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBBbiBhcnJheSBvZiB7Tm9kZSN1bmlxdWVfaWR9cyB0aGF0IGFyZSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rpbmdfbm9kZXMgPSBbXTtcbiAgICAgICAgLy8gQHBhcmFtIHtGdW5jdGlvbjxhbnk+fSBBbiBhcnJheSBvZiBmdW5jdGlvbnMgdG8gYmUgZXhlY3RpZWQgYWZ0ZXIgZG9jbXVlbnQgY29uc3RydWN0aW9uLlxuICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZF9jb25zdHJ1Y3RvcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIENoZWNrcyBpZiBhIGRvY3VtZW50IGNhbiBiZSBjb25zdHJ1Y3RlZCBmcm9tIHRoZSByZXByZXNlbnRhdGlvbiBzdHJlYW0uXG5cbiAgICAgIFNvIGxvbmcgYXMgdGhlIHJlcHJlc2VudGF0aW9uIHN0cmVhbSBoYXNuJ3QgZW5kZWQsIGFub3RoZXIgZG9jdW1lbnQgY2FuIGJlIGNvbnN0cnVjdGVkLlxuXG4gICAgICBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGEgZG9jdW1lbnQgY2FuIGJlIGNvbnN0cnVjdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAqL1xuICAgICAgY2hlY2tfZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tfbm9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgQ29uc3RydWN0IGEgZG9jdW1lbnQgZnJvbSB0aGUgcmVtYWluaW5nIHJlcHJlc2VudGF0aW9uIHN0cmVhbS5cblxuICAgICAge0NvbnN0cnVjdG9yI2NoZWNrX2RhdGF9IG11c3QgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuXG4gICAgICBAcmV0dXJuIHthbnl9IFRoZSBuZXh0IGRvY3VtZW50IGluIHRoZSBzdHJlYW0uIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIHN0cmVhbSBoYXMgZW5kZWQuXG4gICAgICAqL1xuICAgICAgZ2V0X2RhdGEoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrX25vZGUoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdF9kb2N1bWVudCh0aGlzLmdldF9ub2RlKCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBDb25zdHJ1Y3QgYSBzaW5nbGUgZG9jdW1lbnQgZnJvbSB0aGUgZW50aXJlIHJlcHJlc2VudGF0aW9uIHN0cmVhbS5cblxuICAgICAgQHRocm93IHtDb21wb3NlckVycm9yfSBpZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUgZG9jdW1lbnQgaXMgaW4gdGhlIHN0cmVhbS5cblxuICAgICAgQHJldHVybiB7Tm9kZX0gVGhlIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLlxuICAgICAgKi9cbiAgICAgIGdldF9zaW5nbGVfZGF0YSgpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIG5vZGUgPSB0aGlzLmdldF9zaW5nbGVfbm9kZSgpO1xuICAgICAgICBpZiAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0X2RvY3VtZW50KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgQ29uc3RydWN0IGEgZG9jdW1lbnQgbm9kZVxuXG4gICAgICBAcHJpdmF0ZVxuICAgICAgKi9cbiAgICAgIGNvbnN0cnVjdF9kb2N1bWVudChub2RlKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBkYXRhID0gdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KG5vZGUpO1xuICAgICAgICB3aGlsZSAoIXV0aWwuaXNfZW1wdHkodGhpcy5kZWZlcnJlZF9jb25zdHJ1Y3RvcnMpKSB7XG4gICAgICAgICAgdGhpcy5kZWZlcnJlZF9jb25zdHJ1Y3RvcnMucG9wKCkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cblxuICAgICAgZGVmZXIoZikge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZF9jb25zdHJ1Y3RvcnMucHVzaChmKTtcbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0X29iamVjdChub2RlKSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3Rvciwgb2JqZWN0LCByZWYsIHRhZ19wcmVmaXgsIHRhZ19zdWZmaXg7XG4gICAgICAgIGlmIChub2RlLnVuaXF1ZV9pZCBpbiB0aGlzLmNvbnN0cnVjdGVkX29iamVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RlZF9vYmplY3RzW25vZGUudW5pcXVlX2lkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmID0gbm9kZS51bmlxdWVfaWQsIGluZGV4T2YuY2FsbCh0aGlzLmNvbnN0cnVjdGluZ19ub2RlcywgcmVmKSA+PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCAnZm91bmQgdW5jb25zdHJ1Y3RhYmxlIHJlY3Vyc2l2ZSBub2RlJywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnN0cnVjdGluZ19ub2Rlcy5wdXNoKG5vZGUudW5pcXVlX2lkKTtcbiAgICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICB0YWdfc3VmZml4ID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGUudGFnIGluIHRoaXMueWFtbF9jb25zdHJ1Y3RvcnMpIHtcbiAgICAgICAgICBjb25zdHJ1Y3RvciA9IHRoaXMueWFtbF9jb25zdHJ1Y3RvcnNbbm9kZS50YWddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodGFnX3ByZWZpeCBpbiB0aGlzLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50YWcuaW5kZXhPZih0YWdfcHJlZml4ID09PSAwKSkge1xuICAgICAgICAgICAgICB0YWdfc3VmZml4ID0gbm9kZS50YWcuc2xpY2UodGFnX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgICBjb25zdHJ1Y3RvciA9IHRoaXMueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnNbdGFnX3ByZWZpeF07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG51bGwgaW4gdGhpcy55YW1sX211bHRpX2NvbnN0cnVjdG9ycykge1xuICAgICAgICAgICAgICB0YWdfc3VmZml4ID0gbm9kZS50YWc7XG4gICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gdGhpcy55YW1sX211bHRpX2NvbnN0cnVjdG9yc1tudWxsXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVsbCBpbiB0aGlzLnlhbWxfY29uc3RydWN0b3JzKSB7XG4gICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gdGhpcy55YW1sX2NvbnN0cnVjdG9yc1tudWxsXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNjYWxhck5vZGUpIHtcbiAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdF9zY2FsYXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5TZXF1ZW5jZU5vZGUpIHtcbiAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RfbWFwcGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gY29uc3RydWN0b3IuY2FsbCh0aGlzLCB0YWdfc3VmZml4ICE9IG51bGwgPyB0YWdfc3VmZml4IDogbm9kZSwgbm9kZSk7XG4gICAgICAgIHRoaXMuY29uc3RydWN0ZWRfb2JqZWN0c1tub2RlLnVuaXF1ZV9pZF0gPSBvYmplY3Q7XG4gICAgICAgIHRoaXMuY29uc3RydWN0aW5nX25vZGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpIHtcbiAgICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNjYWxhck5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCBgZXhwZWN0ZWQgYSBzY2FsYXIgbm9kZSBidXQgZm91bmQgJHtub2RlLmlkfWAsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdF9zZXF1ZW5jZShub2RlKSB7XG4gICAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5TZXF1ZW5jZU5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCBgZXhwZWN0ZWQgYSBzZXF1ZW5jZSBub2RlIGJ1dCBmb3VuZCAke25vZGUuaWR9YCwgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSBub2RlLnZhbHVlO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmNvbnN0cnVjdF9vYmplY3QoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0X21hcHBpbmcobm9kZSkge1xuICAgICAgICB2YXIgaSwga2V5LCBrZXlfbm9kZSwgbGVuLCBtYXBwaW5nLCByZWYsIHZhbHVlLCB2YWx1ZV9ub2RlO1xuICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENvbnN0cnVjdG9yRXJyb3IobnVsbCwgbnVsbCwgYGV4cGVjdGVkIGEgbWFwcGluZyBub2RlIGJ1dCBmb3VuZCAke25vZGUuaWR9YCwgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBtYXBwaW5nID0ge307XG4gICAgICAgIHJlZiA9IG5vZGUudmFsdWU7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIFtrZXlfbm9kZSwgdmFsdWVfbm9kZV0gPSByZWZbaV07XG4gICAgICAgICAga2V5ID0gdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KGtleV9ub2RlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IoJ3doaWxlIGNvbnN0cnVjdGluZyBhIG1hcHBpbmcnLCBub2RlLnN0YXJ0X21hcmssICdmb3VuZCB1bmhhc2hhYmxlIGtleScsIGtleV9ub2RlLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X29iamVjdCh2YWx1ZV9ub2RlKTtcbiAgICAgICAgICBtYXBwaW5nW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGluZztcbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0X3BhaXJzKG5vZGUpIHtcbiAgICAgICAgdmFyIGksIGtleSwga2V5X25vZGUsIGxlbiwgcGFpcnMsIHJlZiwgdmFsdWUsIHZhbHVlX25vZGU7XG4gICAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKG51bGwsIG51bGwsIGBleHBlY3RlZCBhIG1hcHBpbmcgbm9kZSBidXQgZm91bmQgJHtub2RlLmlkfWAsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgcGFpcnMgPSBbXTtcbiAgICAgICAgcmVmID0gbm9kZS52YWx1ZTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgW2tleV9ub2RlLCB2YWx1ZV9ub2RlXSA9IHJlZltpXTtcbiAgICAgICAgICBrZXkgPSB0aGlzLmNvbnN0cnVjdF9vYmplY3Qoa2V5X25vZGUpO1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KHZhbHVlX25vZGUpO1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFpcnM7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgLypcbiAgICBAcHJvcGVydHkge09iamVjdH0gQSBtYXAgZnJvbSBhIFlBTUwgdGFnIHRvIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIGRhdGEgd2l0aCB0aGF0IHRhZy5cbiAgICBAcHJpdmF0ZVxuICAgICovXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS55YW1sX2NvbnN0cnVjdG9ycyA9IHt9O1xuXG4gICAgLypcbiAgICBAcHJvcGVydHkge09iamVjdH0gQSBtYXAgZnJvbSBhIFlBTUwgdGFnIHByZWZpeCB0byBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBkYXRhIHdpdGggdGhhdCB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4LlxuICAgIEBwcml2YXRlXG4gICAgKi9cbiAgICBCYXNlQ29uc3RydWN0b3IucHJvdG90eXBlLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzID0ge307XG5cbiAgICBjdG9yID0gQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS5pbml0aWFsaXNlO1xuXG4gICAgcmV0dXJuIEJhc2VDb25zdHJ1Y3RvcjtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJPT0xfVkFMVUVTLCBUSU1FU1RBTVBfUEFSVFMsIFRJTUVTVEFNUF9SRUdFWDtcblxuICAgIGNsYXNzIENvbnN0cnVjdG9yIGV4dGVuZHMgdGhpcy5CYXNlQ29uc3RydWN0b3Ige1xuICAgICAgY29uc3RydWN0X3NjYWxhcihub2RlKSB7XG4gICAgICAgIHZhciBpLCBrZXlfbm9kZSwgbGVuLCByZWYsIHZhbHVlX25vZGU7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpIHtcbiAgICAgICAgICByZWYgPSBub2RlLnZhbHVlO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgW2tleV9ub2RlLCB2YWx1ZV9ub2RlXSA9IHJlZltpXTtcbiAgICAgICAgICAgIGlmIChrZXlfbm9kZS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjp2YWx1ZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0X3NjYWxhcih2YWx1ZV9ub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNvbnN0cnVjdF9zY2FsYXIobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGZsYXR0ZW5fbWFwcGluZyhub2RlKSB7XG4gICAgICAgIHZhciBpLCBpbmRleCwgaiwga2V5X25vZGUsIGxlbiwgbGVuMSwgbWVyZ2UsIHJlZiwgc3VibWVyZ2UsIHN1Ym5vZGUsIHZhbHVlLCB2YWx1ZV9ub2RlO1xuICAgICAgICBtZXJnZSA9IFtdO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IG5vZGUudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgW2tleV9ub2RlLCB2YWx1ZV9ub2RlXSA9IG5vZGUudmFsdWVbaW5kZXhdO1xuICAgICAgICAgIGlmIChrZXlfbm9kZS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIC8vZGVsZXRlIG5vZGUudmFsdWVbaW5kZXhdXG4gICAgICAgICAgICBpZiAodmFsdWVfbm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmxhdHRlbl9tYXBwaW5nKHZhbHVlX25vZGUpO1xuICAgICAgICAgICAgICBtZXJnZSA9IG1lcmdlLmNvbmNhdCh2YWx1ZV9ub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVfbm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNlcXVlbmNlTm9kZSkge1xuICAgICAgICAgICAgICBzdWJtZXJnZSA9IFtdO1xuICAgICAgICAgICAgICByZWYgPSB2YWx1ZV9ub2RlLnZhbHVlO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJub2RlID0gcmVmW2ldO1xuICAgICAgICAgICAgICAgIGlmICghKHN1Ym5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IoJ3doaWxlIGNvbnN0cnVjdGluZyBhIG1hcHBpbmcnLCBub2RlLnN0YXJ0X21hcmssIGBleHBlY3RlZCBhIG1hcHBpbmcgZm9yIG1lcmdpbmcsIGJ1dCBmb3VuZCAke3N1Ym5vZGUuaWR9YCwgc3Vibm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mbGF0dGVuX21hcHBpbmcoc3Vibm9kZSk7XG4gICAgICAgICAgICAgICAgc3VibWVyZ2UucHVzaChzdWJub2RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdWJtZXJnZS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSBzdWJtZXJnZS5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN1Ym1lcmdlW2pdO1xuICAgICAgICAgICAgICAgIG1lcmdlID0gbWVyZ2UuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcignd2hpbGUgY29uc3RydWN0aW5nIGEgbWFwcGluZycsIG5vZGUuc3RhcnRfbWFyaywgYGV4cGVjdGVkIGEgbWFwcGluZyBvciBsaXN0IG9mIG1hcHBpbmdzIGZvciBtZXJnaW5nIGJ1dCBmb3VuZCAke3ZhbHVlX25vZGUuaWR9YCwgdmFsdWVfbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGtleV9ub2RlLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOnZhbHVlJykge1xuICAgICAgICAgICAga2V5X25vZGUudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cic7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVyZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUgPSBtZXJnZS5jb25jYXQobm9kZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0X21hcHBpbmcobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgICAgdGhpcy5mbGF0dGVuX21hcHBpbmcobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNvbnN0cnVjdF9tYXBwaW5nKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RfeWFtbF9udWxsKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0X3lhbWxfYm9vbChub2RlKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdF9zY2FsYXIobm9kZSk7XG4gICAgICAgIHJldHVybiBCT09MX1ZBTFVFU1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0X3lhbWxfaW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGJhc2UsIGRpZ2l0LCBkaWdpdHMsIGksIGxlbiwgcGFydCwgcmVmLCBzaWduLCB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdF9zY2FsYXIobm9kZSk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICAgIHNpZ24gPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICBpZiAocmVmID0gdmFsdWVbMF0sIGluZGV4T2YuY2FsbCgnKy0nLCByZWYpID49IDApIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignMGInKSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoJzB4JykgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignMG8nKSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDgpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlWzBdID09PSAnMCcpIHtcbiAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCA4KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleE9mLmNhbGwodmFsdWUsICc6JykgPj0gMCkge1xuICAgICAgICAgIGRpZ2l0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgICAgICByZWYxID0gdmFsdWUuc3BsaXQoLzovZyk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIHBhcnQgPSByZWYxW2ldO1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocGFyc2VJbnQocGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgICBkaWdpdHMucmV2ZXJzZSgpO1xuICAgICAgICAgIGJhc2UgPSAxO1xuICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkaWdpdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgdmFsdWUgKz0gZGlnaXQgKiBiYXNlO1xuICAgICAgICAgICAgYmFzZSAqPSA2MDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RfeWFtbF9mbG9hdChub2RlKSB7XG4gICAgICAgIHZhciBiYXNlLCBkaWdpdCwgZGlnaXRzLCBpLCBsZW4sIHBhcnQsIHJlZiwgc2lnbiwgdmFsdWU7XG4gICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHNpZ24gPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICBpZiAocmVmID0gdmFsdWVbMF0sIGluZGV4T2YuY2FsbCgnKy0nLCByZWYpID49IDApIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgICAgICAgcmV0dXJuIHNpZ24gKiAyZTMwODtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJy5uYW4nKSB7XG4gICAgICAgICAgcmV0dXJuIDAvMDtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleE9mLmNhbGwodmFsdWUsICc6JykgPj0gMCkge1xuICAgICAgICAgIGRpZ2l0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgICAgICByZWYxID0gdmFsdWUuc3BsaXQoLzovZyk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIHBhcnQgPSByZWYxW2ldO1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocGFyc2VGbG9hdChwYXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICB9KSgpO1xuICAgICAgICAgIGRpZ2l0cy5yZXZlcnNlKCk7XG4gICAgICAgICAgYmFzZSA9IDE7XG4gICAgICAgICAgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZGlnaXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIHZhbHVlICs9IGRpZ2l0ICogYmFzZTtcbiAgICAgICAgICAgIGJhc2UgKj0gNjA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzaWduICogdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RfeWFtbF9iaW5hcnkobm9kZSkge1xuICAgICAgICB2YXIgZXJyb3IsIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X3NjYWxhcihub2RlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhdG9iKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgICAgZXJyb3IgPSBlcnJvcjE7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCBgZmFpbGVkIHRvIGRlY29kZSBiYXNlNjQgZGF0YTogJHtlcnJvcn1gLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdF95YW1sX3RpbWVzdGFtcChub2RlKSB7XG4gICAgICAgIHZhciBkYXRlLCBkYXksIGZyYWN0aW9uLCBob3VyLCBpbmRleCwga2V5LCBtYXRjaCwgbWlsbGlzZWNvbmQsIG1pbnV0ZSwgbW9udGgsIHNlY29uZCwgdHpfaG91ciwgdHpfbWludXRlLCB0el9zaWduLCB2YWx1ZSwgdmFsdWVzLCB5ZWFyO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X3NjYWxhcihub2RlKTtcbiAgICAgICAgbWF0Y2ggPSBub2RlLnZhbHVlLm1hdGNoKFRJTUVTVEFNUF9SRUdFWCk7XG4gICAgICAgIHZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGtleSBpbiBUSU1FU1RBTVBfUEFSVFMpIHtcbiAgICAgICAgICBpbmRleCA9IFRJTUVTVEFNUF9QQVJUU1trZXldO1xuICAgICAgICAgIHZhbHVlc1trZXldID0gbWF0Y2hbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHllYXIgPSBwYXJzZUludCh2YWx1ZXMueWVhcik7XG4gICAgICAgIG1vbnRoID0gcGFyc2VJbnQodmFsdWVzLm1vbnRoKSAtIDE7XG4gICAgICAgIGRheSA9IHBhcnNlSW50KHZhbHVlcy5kYXkpO1xuICAgICAgICBpZiAoIXZhbHVlcy5ob3VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBob3VyID0gcGFyc2VJbnQodmFsdWVzLmhvdXIpO1xuICAgICAgICBtaW51dGUgPSBwYXJzZUludCh2YWx1ZXMubWludXRlKTtcbiAgICAgICAgc2Vjb25kID0gcGFyc2VJbnQodmFsdWVzLnNlY29uZCk7XG4gICAgICAgIG1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgaWYgKHZhbHVlcy5mcmFjdGlvbikge1xuICAgICAgICAgIGZyYWN0aW9uID0gdmFsdWVzLmZyYWN0aW9uLnNsaWNlKDAsIDYpO1xuICAgICAgICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWN0aW9uID0gcGFyc2VJbnQoZnJhY3Rpb24pO1xuICAgICAgICAgIG1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChmcmFjdGlvbiAvIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMudHpfc2lnbikge1xuICAgICAgICAgIHR6X3NpZ24gPSB2YWx1ZXMudHpfc2lnbiA9PT0gJy0nID8gMSA6IC0xO1xuICAgICAgICAgIGlmICh0el9ob3VyID0gcGFyc2VJbnQodmFsdWVzLnR6X2hvdXIpKSB7XG4gICAgICAgICAgICBob3VyICs9IHR6X3NpZ24gKiB0el9ob3VyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHpfbWludXRlID0gcGFyc2VJbnQodmFsdWVzLnR6X21pbnV0ZSkpIHtcbiAgICAgICAgICAgIG1pbnV0ZSArPSB0el9zaWduICogdHpfbWludXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKSk7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RfeWFtbF9wYWlyX2xpc3QodHlwZSwgbm9kZSkge1xuICAgICAgICB2YXIgbGlzdDtcbiAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2VxdWVuY2VOb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IoYHdoaWxlIGNvbnN0cnVjdGluZyAke3R5cGV9YCwgbm9kZS5zdGFydF9tYXJrLCBgZXhwZWN0ZWQgYSBzZXF1ZW5jZSBidXQgZm91bmQgJHtub2RlLmlkfWAsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgdmFyIGksIGtleSwga2V5X25vZGUsIGxlbiwgcmVmLCByZXN1bHRzLCBzdWJub2RlLCB2YWx1ZSwgdmFsdWVfbm9kZTtcbiAgICAgICAgICByZWYgPSBub2RlLnZhbHVlO1xuICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHN1Ym5vZGUgPSByZWZbaV07XG4gICAgICAgICAgICBpZiAoIShzdWJub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IoYHdoaWxlIGNvbnN0cnVjdGluZyAke3R5cGV9YCwgbm9kZS5zdGFydF9tYXJrLCBgZXhwZWN0ZWQgYSBtYXBwaW5nIG9mIGxlbmd0aCAxIGJ1dCBmb3VuZCAke3N1Ym5vZGUuaWR9YCwgc3Vibm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJub2RlLnZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKGB3aGlsZSBjb25zdHJ1Y3RpbmcgJHt0eXBlfWAsIG5vZGUuc3RhcnRfbWFyaywgYGV4cGVjdGVkIGEgbWFwcGluZyBvZiBsZW5ndGggMSBidXQgZm91bmQgJHtzdWJub2RlLmlkfWAsIHN1Ym5vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBba2V5X25vZGUsIHZhbHVlX25vZGVdID0gc3Vibm9kZS52YWx1ZVswXTtcbiAgICAgICAgICAgIGtleSA9IHRoaXMuY29uc3RydWN0X29iamVjdChrZXlfbm9kZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X29iamVjdCh2YWx1ZV9ub2RlKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChsaXN0LnB1c2goW2tleSwgdmFsdWVdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdF95YW1sX29tYXAobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RfeWFtbF9wYWlyX2xpc3QoJ2FuIG9yZGVyZWQgbWFwJywgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdF95YW1sX3BhaXJzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0X3lhbWxfcGFpcl9saXN0KCdwYWlycycsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RfeWFtbF9zZXQobm9kZSkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmRlZmVyKCgpID0+IHtcbiAgICAgICAgICB2YXIgaXRlbSwgcmVzdWx0cztcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChpdGVtIGluIHRoaXMuY29uc3RydWN0X21hcHBpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChkYXRhLnB1c2goaXRlbSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RfeWFtbF9zdHIobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RfeWFtbF9zZXEobm9kZSkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmRlZmVyKCgpID0+IHtcbiAgICAgICAgICB2YXIgaSwgaXRlbSwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgcmVmID0gdGhpcy5jb25zdHJ1Y3Rfc2VxdWVuY2Uobm9kZSk7XG4gICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IHJlZltpXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChkYXRhLnB1c2goaXRlbSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RfeWFtbF9tYXAobm9kZSkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLmRlZmVyKCgpID0+IHtcbiAgICAgICAgICB2YXIga2V5LCByZWYsIHJlc3VsdHMsIHZhbHVlO1xuICAgICAgICAgIHJlZiA9IHRoaXMuY29uc3RydWN0X21hcHBpbmcobm9kZSk7XG4gICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChkYXRhW2tleV0gPSB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdF95YW1sX29iamVjdChub2RlLCBrbGFzcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgZGF0YSA9IG5ldyBrbGFzcztcbiAgICAgICAgdGhpcy5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgdmFyIGtleSwgcmVmLCByZXN1bHRzLCB2YWx1ZTtcbiAgICAgICAgICByZWYgPSB0aGlzLmNvbnN0cnVjdF9tYXBwaW5nKG5vZGUsIHRydWUpO1xuICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVmW2tleV07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goZGF0YVtrZXldID0gdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBjb25zdHJ1Y3RfdW5kZWZpbmVkKG5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCBgY291bGQgbm90IGRldGVybWluZSBhIGNvbnN0cnVjdG9yIGZvciB0aGUgdGFnICR7bm9kZS50YWd9YCwgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBCT09MX1ZBTFVFUyA9IHtcbiAgICAgIG9uOiB0cnVlLFxuICAgICAgb2ZmOiBmYWxzZSxcbiAgICAgIHRydWU6IHRydWUsXG4gICAgICBmYWxzZTogZmFsc2UsXG4gICAgICB5ZXM6IHRydWUsXG4gICAgICBubzogZmFsc2VcbiAgICB9O1xuXG4gICAgVElNRVNUQU1QX1JFR0VYID0gL14oWzAtOV1bMC05XVswLTldWzAtOV0pLShbMC05XVswLTldPyktKFswLTldWzAtOV0/KSg/Oig/OltUdF18W1xceDIwXFx0XSspKFswLTldWzAtOV0/KTooWzAtOV1bMC05XSk6KFswLTldWzAtOV0pKD86XFwuKFswLTldKikpPyg/OltcXHgyMFxcdF0qKFp8KFstK10pKFswLTldWzAtOV0/KSg/OjooWzAtOV1bMC05XSkpPykpPyk/JC87IC8vICAxOiB5ZWFyXG4gICAgLy8gIDI6IG1vbnRoXG4gICAgLy8gIDM6IGRheVxuICAgIC8vICA0OiBob3VyXG4gICAgLy8gIDU6IG1pbnV0ZVxuICAgIC8vICA2OiBzZWNvbmRcbiAgICAvLyAgNzogZnJhY3Rpb25cbiAgICAvLyAgOTogdHpfc2lnblxuICAgIC8vIDEwOiB0el9ob3VyXG4gICAgLy8gMTE6IHR6X21pbnV0ZVxuICAgIC8vICA4OiB0elxuXG4gICAgVElNRVNUQU1QX1BBUlRTID0ge1xuICAgICAgeWVhcjogMSxcbiAgICAgIG1vbnRoOiAyLFxuICAgICAgZGF5OiAzLFxuICAgICAgaG91cjogNCxcbiAgICAgIG1pbnV0ZTogNSxcbiAgICAgIHNlY29uZDogNixcbiAgICAgIGZyYWN0aW9uOiA3LFxuICAgICAgdHo6IDgsXG4gICAgICB0el9zaWduOiA5LFxuICAgICAgdHpfaG91cjogMTAsXG4gICAgICB0el9taW51dGU6IDExXG4gICAgfTtcblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfbnVsbCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9ib29sKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6aW50JywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfaW50KTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9mbG9hdCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX2JpbmFyeSk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3RpbWVzdGFtcCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9vbWFwKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9wYWlycyk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3NldCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3N0cik7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3NlcSk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX21hcCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IobnVsbCwgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3VuZGVmaW5lZCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///574\n")},190:function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){eval("(function() {\n  var emitter, representer, resolver, serializer, util;\n\n  util = __webpack_require__(823);\n\n  emitter = __webpack_require__(320);\n\n  serializer = __webpack_require__(472);\n\n  representer = __webpack_require__(832);\n\n  resolver = __webpack_require__(579);\n\n  this.make_dumper = function(Emitter = emitter.Emitter, Serializer = serializer.Serializer, Representer = representer.Representer, Resolver = resolver.Resolver) {\n    var Dumper, components;\n    components = [Emitter, Serializer, Representer, Resolver];\n    return Dumper = (function() {\n      var component;\n\n      class Dumper {\n        constructor(stream, options = {}) {\n          var i, len, ref;\n          components[0].prototype.initialise.call(this, stream, options);\n          ref = components.slice(1);\n          for (i = 0, len = ref.length; i < len; i++) {\n            component = ref[i];\n            component.prototype.initialise.call(this, options);\n          }\n        }\n\n      };\n\n      util.extend(Dumper.prototype, ...((function() {\n        var i, len, results;\n        results = [];\n        for (i = 0, len = components.length; i < len; i++) {\n          component = components[i];\n          results.push(component.prototype);\n        }\n        return results;\n      })()));\n\n      return Dumper;\n\n    }).call(this);\n  };\n\n  this.Dumper = this.make_dumper();\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLEdBQVE7O0FBRXpCLFlBQVksbUJBQU8sQ0FBQyxHQUFXOztBQUUvQixlQUFlLG1CQUFPLENBQUMsR0FBYzs7QUFFckMsZ0JBQWdCLG1CQUFPLENBQUMsR0FBZTs7QUFFdkMsYUFBYSxtQkFBTyxDQUFDLEdBQVk7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwtanMvbGliL2R1bXBlci5qcz9iYzI4Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpIHtcbiAgdmFyIGVtaXR0ZXIsIHJlcHJlc2VudGVyLCByZXNvbHZlciwgc2VyaWFsaXplciwgdXRpbDtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgZW1pdHRlciA9IHJlcXVpcmUoJy4vZW1pdHRlcicpO1xuXG4gIHNlcmlhbGl6ZXIgPSByZXF1aXJlKCcuL3NlcmlhbGl6ZXInKTtcblxuICByZXByZXNlbnRlciA9IHJlcXVpcmUoJy4vcmVwcmVzZW50ZXInKTtcblxuICByZXNvbHZlciA9IHJlcXVpcmUoJy4vcmVzb2x2ZXInKTtcblxuICB0aGlzLm1ha2VfZHVtcGVyID0gZnVuY3Rpb24oRW1pdHRlciA9IGVtaXR0ZXIuRW1pdHRlciwgU2VyaWFsaXplciA9IHNlcmlhbGl6ZXIuU2VyaWFsaXplciwgUmVwcmVzZW50ZXIgPSByZXByZXNlbnRlci5SZXByZXNlbnRlciwgUmVzb2x2ZXIgPSByZXNvbHZlci5SZXNvbHZlcikge1xuICAgIHZhciBEdW1wZXIsIGNvbXBvbmVudHM7XG4gICAgY29tcG9uZW50cyA9IFtFbWl0dGVyLCBTZXJpYWxpemVyLCBSZXByZXNlbnRlciwgUmVzb2x2ZXJdO1xuICAgIHJldHVybiBEdW1wZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tcG9uZW50O1xuXG4gICAgICBjbGFzcyBEdW1wZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihzdHJlYW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgIHZhciBpLCBsZW4sIHJlZjtcbiAgICAgICAgICBjb21wb25lbnRzWzBdLnByb3RvdHlwZS5pbml0aWFsaXNlLmNhbGwodGhpcywgc3RyZWFtLCBvcHRpb25zKTtcbiAgICAgICAgICByZWYgPSBjb21wb25lbnRzLnNsaWNlKDEpO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gcmVmW2ldO1xuICAgICAgICAgICAgY29tcG9uZW50LnByb3RvdHlwZS5pbml0aWFsaXNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH07XG5cbiAgICAgIHV0aWwuZXh0ZW5kKER1bXBlci5wcm90b3R5cGUsIC4uLigoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGNvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSkoKSkpO1xuXG4gICAgICByZXR1cm4gRHVtcGVyO1xuXG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfTtcblxuICB0aGlzLkR1bXBlciA9IHRoaXMubWFrZV9kdW1wZXIoKTtcblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///190\n")},320:function(__unused_webpack_module,exports,__webpack_require__){eval("(function() {\n  var ScalarAnalysis, YAMLError, events, util,\n    hasProp = {}.hasOwnProperty,\n    indexOf = [].indexOf;\n\n  events = __webpack_require__(63);\n\n  util = __webpack_require__(823);\n\n  ({YAMLError} = __webpack_require__(372));\n\n  this.EmitterError = class EmitterError extends YAMLError {};\n\n  /*\n  Emitter expects events obeying the following grammar:\n\n  stream   ::= STREAM-START document* STREAM-END\n  document ::= DOCUMENT-START node DOCUMENT-END\n  node     ::= SCALA | sequence | mapping\n  sequence ::= SEQUENCE-START node* SEQUENCE-END\n  mapping  ::= MAPPING-START (node node)* MAPPING-END\n  */\n  this.Emitter = (function() {\n    var C_WHITESPACE, DEFAULT_TAG_PREFIXES, ESCAPE_REPLACEMENTS, ctor;\n\n    class Emitter {\n      constructor() {\n        return ctor.apply(this, arguments);\n      }\n\n      initialise(stream, options) {\n        var ref;\n        this.stream = stream;\n        // Encoding can be overriden by STREAM-START\n        this.encoding = null;\n        // Emitter is a state machine with a stack of states to handle nested structures.\n        this.states = [];\n        this.state = this.expect_stream_start;\n        // Current event and the event queue\n        this.events = [];\n        this.event = null;\n        // The current indentation level and the stack of previous indents.\n        this.indents = [];\n        this.indent = null;\n        // Flow level.\n        this.flow_level = 0;\n        // Contexts.\n        this.root_context = false;\n        this.sequence_context = false;\n        this.mapping_context = false;\n        this.simple_key_context = false;\n        // Characteristics of the last emitted character:\n        // - current position.\n        // - is it a whitespace?\n        // - is it an indentation character (indentation space, '-', '?', or ':')?\n        this.line = 0;\n        this.column = 0;\n        this.whitespace = true;\n        this.indentation = true;\n        // Whether the document requires an explicit document indicator.\n        this.open_ended = false;\n        // Formatting details\n        ({canonical: this.canonical, allow_unicode: this.allow_unicode} = options);\n        if (this.canonical == null) {\n          this.canonical = false;\n        }\n        if (this.allow_unicode == null) {\n          this.allow_unicode = true;\n        }\n        this.best_indent = 1 < options.indent && options.indent < 10 ? options.indent : 2;\n        this.best_width = options.width > this.indent * 2 ? options.width : 80;\n        this.best_line_break = (ref = options.line_break) === '\\r' || ref === '\\n' || ref === '\\r\\n' ? options.line_break : '\\n';\n        // Tag prefixes.\n        this.tag_prefixes = null;\n        // Prepared anchor and tag\n        this.prepared_anchor = null;\n        this.prepared_tag = null;\n        // Scalar analysis and style.\n        this.analysis = null;\n        return this.style = null;\n      }\n\n      /*\n      Reset the state attributes (to clear self-references)\n      */\n      dispose() {\n        this.states = [];\n        return this.state = null;\n      }\n\n      emit(event) {\n        var results;\n        this.events.push(event);\n        results = [];\n        while (!this.need_more_events()) {\n          this.event = this.events.shift();\n          this.state();\n          results.push(this.event = null);\n        }\n        return results;\n      }\n\n      /*\n      In some cases, we wait for a few next events before emitting.\n      */\n      need_more_events() {\n        var event;\n        if (this.events.length === 0) {\n          return true;\n        }\n        event = this.events[0];\n        if (event instanceof events.DocumentStartEvent) {\n          return this.need_events(1);\n        } else if (event instanceof events.SequenceStartEvent) {\n          return this.need_events(2);\n        } else if (event instanceof events.MappingStartEvent) {\n          return this.need_events(3);\n        } else {\n          return false;\n        }\n      }\n\n      need_events(count) {\n        var event, i, len, level, ref;\n        level = 0;\n        ref = this.events.slice(1);\n        for (i = 0, len = ref.length; i < len; i++) {\n          event = ref[i];\n          if (event instanceof events.DocumentStartEvent || event instanceof events.CollectionStartEvent) {\n            level++;\n          } else if (event instanceof events.DocumentEndEvent || event instanceof events.CollectionEndEvent) {\n            level--;\n          } else if (event instanceof events.StreamEndEvent) {\n            level = -1;\n          }\n          if (level < 0) {\n            return false;\n          }\n        }\n        return this.events.length < count + 1;\n      }\n\n      increase_indent(options = {}) {\n        this.indents.push(this.indent);\n        if (this.indent == null) {\n          return this.indent = options.flow ? this.best_indent : 0;\n        } else if (!options.indentless) {\n          return this.indent += this.best_indent;\n        }\n      }\n\n      // Stream states\n      expect_stream_start() {\n        if (this.event instanceof events.StreamStartEvent) {\n          if (this.event.encoding && !('encoding' in this.stream)) {\n            this.encoding = this.event.encoding;\n          }\n          this.write_stream_start();\n          return this.state = this.expect_first_document_start;\n        } else {\n          return this.error('expected StreamStartEvent, but got', this.event);\n        }\n      }\n\n      expect_nothing() {\n        return this.error('expected nothing, but got', this.event);\n      }\n\n      // Document states\n      expect_first_document_start() {\n        return this.expect_document_start(true);\n      }\n\n      expect_document_start(first = false) {\n        var explicit, handle, i, k, len, prefix, ref;\n        if (this.event instanceof events.DocumentStartEvent) {\n          if ((this.event.version || this.event.tags) && this.open_ended) {\n            this.write_indicator('...', true);\n            this.write_indent();\n          }\n          if (this.event.version) {\n            this.write_version_directive(this.prepare_version(this.event.version));\n          }\n          this.tag_prefixes = util.clone(DEFAULT_TAG_PREFIXES);\n          if (this.event.tags) {\n            ref = ((function() {\n              var ref, results;\n              ref = this.event.tags;\n              results = [];\n              for (k in ref) {\n                if (!hasProp.call(ref, k)) continue;\n                results.push(k);\n              }\n              return results;\n            }).call(this)).sort();\n            for (i = 0, len = ref.length; i < len; i++) {\n              handle = ref[i];\n              prefix = this.event.tags[handle];\n              this.tag_prefixes[prefix] = handle;\n              this.write_tag_directive(this.prepare_tag_handle(handle), this.prepare_tag_prefix(prefix));\n            }\n          }\n          explicit = !first || this.event.explicit || this.canonical || this.event.version || this.event.tags || this.check_empty_document();\n          if (explicit) {\n            this.write_indent();\n            this.write_indicator('---', true);\n            if (this.canonical) {\n              this.write_indent();\n            }\n          }\n          return this.state = this.expect_document_root;\n        } else if (this.event instanceof events.StreamEndEvent) {\n          if (this.open_ended) {\n            this.write_indicator('...', true);\n            this.write_indent();\n          }\n          this.write_stream_end();\n          return this.state = this.expect_nothing;\n        } else {\n          return this.error('expected DocumentStartEvent, but got', this.event);\n        }\n      }\n\n      expect_document_end() {\n        if (this.event instanceof events.DocumentEndEvent) {\n          this.write_indent();\n          if (this.event.explicit) {\n            this.write_indicator('...', true);\n            this.write_indent();\n          }\n          this.flush_stream();\n          return this.state = this.expect_document_start;\n        } else {\n          return this.error('expected DocumentEndEvent, but got', this.event);\n        }\n      }\n\n      expect_document_root() {\n        this.states.push(this.expect_document_end);\n        return this.expect_node({\n          root: true\n        });\n      }\n\n      // Node states\n      expect_node(expect = {}) {\n        this.root_context = !!expect.root;\n        this.sequence_context = !!expect.sequence;\n        this.mapping_context = !!expect.mapping;\n        this.simple_key_context = !!expect.simple_key;\n        if (this.event instanceof events.AliasEvent) {\n          return this.expect_alias();\n        } else if (this.event instanceof events.ScalarEvent || this.event instanceof events.CollectionStartEvent) {\n          this.process_anchor('&');\n          this.process_tag();\n          if (this.event instanceof events.ScalarEvent) {\n            return this.expect_scalar();\n          } else if (this.event instanceof events.SequenceStartEvent) {\n            if (this.flow_level || this.canonical || this.event.flow_style || this.check_empty_sequence()) {\n              return this.expect_flow_sequence();\n            } else {\n              return this.expect_block_sequence();\n            }\n          } else if (this.event instanceof events.MappingStartEvent) {\n            if (this.flow_level || this.canonical || this.event.flow_style || this.check_empty_mapping()) {\n              return this.expect_flow_mapping();\n            } else {\n              return this.expect_block_mapping();\n            }\n          }\n        } else {\n          return this.error('expected NodeEvent, but got', this.event);\n        }\n      }\n\n      expect_alias() {\n        if (!this.event.anchor) {\n          this.error('anchor is not specified for alias');\n        }\n        this.process_anchor('*');\n        return this.state = this.states.pop();\n      }\n\n      expect_scalar() {\n        this.increase_indent({\n          flow: true\n        });\n        this.process_scalar();\n        this.indent = this.indents.pop();\n        return this.state = this.states.pop();\n      }\n\n      // Flow sequence states\n      expect_flow_sequence() {\n        this.write_indicator('[', true, {\n          whitespace: true\n        });\n        this.flow_level++;\n        this.increase_indent({\n          flow: true\n        });\n        return this.state = this.expect_first_flow_sequence_item;\n      }\n\n      expect_first_flow_sequence_item() {\n        if (this.event instanceof events.SequenceEndEvent) {\n          this.indent = this.indents.pop();\n          this.flow_level--;\n          this.write_indicator(']', false);\n          return this.state = this.states.pop();\n        } else {\n          if (this.canonical || this.column > this.best_width) {\n            this.write_indent();\n          }\n          this.states.push(this.expect_flow_sequence_item);\n          return this.expect_node({\n            sequence: true\n          });\n        }\n      }\n\n      expect_flow_sequence_item() {\n        if (this.event instanceof events.SequenceEndEvent) {\n          this.indent = this.indents.pop();\n          this.flow_level--;\n          if (this.canonical) {\n            this.write_indicator(',', false);\n            this.write_indent();\n          }\n          this.write_indicator(']', false);\n          return this.state = this.states.pop();\n        } else {\n          this.write_indicator(',', false);\n          if (this.canonical || this.column > this.best_width) {\n            this.write_indent();\n          }\n          this.states.push(this.expect_flow_sequence_item);\n          return this.expect_node({\n            sequence: true\n          });\n        }\n      }\n\n      // Flow mapping states\n      expect_flow_mapping() {\n        this.write_indicator('{', true, {\n          whitespace: true\n        });\n        this.flow_level++;\n        this.increase_indent({\n          flow: true\n        });\n        return this.state = this.expect_first_flow_mapping_key;\n      }\n\n      expect_first_flow_mapping_key() {\n        if (this.event instanceof events.MappingEndEvent) {\n          this.indent = this.indents.pop();\n          this.flow_level--;\n          this.write_indicator('}', false);\n          return this.state = this.states.pop();\n        } else {\n          if (this.canonical || this.column > this.best_width) {\n            this.write_indent();\n          }\n          if (!this.canonical && this.check_simple_key()) {\n            this.states.push(this.expect_flow_mapping_simple_value);\n            return this.expect_node({\n              mapping: true,\n              simple_key: true\n            });\n          } else {\n            this.write_indicator('?', true);\n            this.states.push(this.expect_flow_mapping_value);\n            return this.expect_node({\n              mapping: true\n            });\n          }\n        }\n      }\n\n      expect_flow_mapping_key() {\n        if (this.event instanceof events.MappingEndEvent) {\n          this.indent = this.indents.pop();\n          this.flow_level--;\n          if (this.canonical) {\n            this.write_indicator(',', false);\n            this.write_indent();\n          }\n          this.write_indicator('}', false);\n          return this.state = this.states.pop();\n        } else {\n          this.write_indicator(',', false);\n          if (this.canonical || this.column > this.best_width) {\n            this.write_indent();\n          }\n          if (!this.canonical && this.check_simple_key()) {\n            this.states.push(this.expect_flow_mapping_simple_value);\n            return this.expect_node({\n              mapping: true,\n              simple_key: true\n            });\n          } else {\n            this.write_indicator('?', true);\n            this.states.push(this.expect_flow_mapping_value);\n            return this.expect_node({\n              mapping: true\n            });\n          }\n        }\n      }\n\n      expect_flow_mapping_simple_value() {\n        this.write_indicator(':', false);\n        this.states.push(this.expect_flow_mapping_key);\n        return this.expect_node({\n          mapping: true\n        });\n      }\n\n      expect_flow_mapping_value() {\n        if (this.canonical || this.column > this.best_width) {\n          this.write_indent();\n        }\n        this.write_indicator(':', true);\n        this.states.push(this.expect_flow_mapping_key);\n        return this.expect_node({\n          mapping: true\n        });\n      }\n\n      // Block sequence states\n      expect_block_sequence() {\n        var indentless;\n        indentless = this.mapping_context && !this.indentation;\n        this.increase_indent({indentless});\n        return this.state = this.expect_first_block_sequence_item;\n      }\n\n      expect_first_block_sequence_item() {\n        return this.expect_block_sequence_item(true);\n      }\n\n      expect_block_sequence_item(first = false) {\n        if (!first && this.event instanceof events.SequenceEndEvent) {\n          this.indent = this.indents.pop();\n          return this.state = this.states.pop();\n        } else {\n          this.write_indent();\n          this.write_indicator('-', true, {\n            indentation: true\n          });\n          this.states.push(this.expect_block_sequence_item);\n          return this.expect_node({\n            sequence: true\n          });\n        }\n      }\n\n      // Block mapping states\n      expect_block_mapping() {\n        this.increase_indent();\n        return this.state = this.expect_first_block_mapping_key;\n      }\n\n      expect_first_block_mapping_key() {\n        return this.expect_block_mapping_key(true);\n      }\n\n      expect_block_mapping_key(first = false) {\n        if (!first && this.event instanceof events.MappingEndEvent) {\n          this.indent = this.indents.pop();\n          return this.state = this.states.pop();\n        } else {\n          this.write_indent();\n          if (this.check_simple_key()) {\n            this.states.push(this.expect_block_mapping_simple_value);\n            return this.expect_node({\n              mapping: true,\n              simple_key: true\n            });\n          } else {\n            this.write_indicator('?', true, {\n              indentation: true\n            });\n            this.states.push(this.expect_block_mapping_value);\n            return this.expect_node({\n              mapping: true\n            });\n          }\n        }\n      }\n\n      expect_block_mapping_simple_value() {\n        this.write_indicator(':', false);\n        this.states.push(this.expect_block_mapping_key);\n        return this.expect_node({\n          mapping: true\n        });\n      }\n\n      expect_block_mapping_value() {\n        this.write_indent();\n        this.write_indicator(':', true, {\n          indentation: true\n        });\n        this.states.push(this.expect_block_mapping_key);\n        return this.expect_node({\n          mapping: true\n        });\n      }\n\n      // Checkers\n      check_empty_document() {\n        var event;\n        if (!(this.event instanceof events.DocumentStartEvent) || this.events.length === 0) {\n          return false;\n        }\n        event = this.events[0];\n        return event instanceof events.ScalarEvent && (event.anchor == null) && (event.tag == null) && event.implicit && event.value === '';\n      }\n\n      check_empty_sequence() {\n        return this.event instanceof events.SequenceStartEvent && this.events[0] instanceof events.SequenceEndEvent;\n      }\n\n      check_empty_mapping() {\n        return this.event instanceof events.MappingStartEvent && this.events[0] instanceof events.MappingEndEvent;\n      }\n\n      check_simple_key() {\n        var length;\n        length = 0;\n        if (this.event instanceof events.NodeEvent && (this.event.anchor != null)) {\n          if (this.prepared_anchor == null) {\n            this.prepared_anchor = this.prepare_anchor(this.event.anchor);\n          }\n          length += this.prepared_anchor.length;\n        }\n        if ((this.event.tag != null) && (this.event instanceof events.ScalarEvent || this.event instanceof events.CollectionStartEvent)) {\n          if (this.prepared_tag == null) {\n            this.prepared_tag = this.prepare_tag(this.event.tag);\n          }\n          length += this.prepared_tag.length;\n        }\n        if (this.event instanceof events.ScalarEvent) {\n          if (this.analysis == null) {\n            this.analysis = this.analyze_scalar(this.event.value);\n          }\n          length += this.analysis.scalar.length;\n        }\n        return length < 128 && (this.event instanceof events.AliasEvent || (this.event instanceof events.ScalarEvent && !this.analysis.empty && !this.analysis.multiline) || this.check_empty_sequence() || this.check_empty_mapping());\n      }\n\n      // Anchor, Tag and Scalar processors\n      process_anchor(indicator) {\n        if (this.event.anchor == null) {\n          this.prepared_anchor = null;\n          return;\n        }\n        if (this.prepared_anchor == null) {\n          this.prepared_anchor = this.prepare_anchor(this.event.anchor);\n        }\n        if (this.prepared_anchor) {\n          this.write_indicator(`${indicator}${this.prepared_anchor}`, true);\n        }\n        return this.prepared_anchor = null;\n      }\n\n      process_tag() {\n        var tag;\n        tag = this.event.tag;\n        if (this.event instanceof events.ScalarEvent) {\n          if (this.style == null) {\n            this.style = this.choose_scalar_style();\n          }\n          if ((!this.canonical || (tag == null)) && ((this.style === '' && this.event.implicit[0]) || (this.style !== '' && this.event.implicit[1]))) {\n            this.prepared_tag = null;\n            return;\n          }\n          if (this.event.implicit[0] && (tag == null)) {\n            tag = '!';\n            this.prepared_tag = null;\n          }\n        } else if ((!this.canonical || (tag == null)) && this.event.implicit) {\n          this.prepared_tag = null;\n          return;\n        }\n        if (tag == null) {\n          this.error('tag is not specified');\n        }\n        if (this.prepared_tag == null) {\n          this.prepared_tag = this.prepare_tag(tag);\n        }\n        this.write_indicator(this.prepared_tag, true);\n        return this.prepared_tag = null;\n      }\n\n      process_scalar() {\n        var split;\n        if (this.analysis == null) {\n          this.analysis = this.analyze_scalar(this.event.value);\n        }\n        if (this.style == null) {\n          this.style = this.choose_scalar_style();\n        }\n        split = !this.simple_key_context;\n        switch (this.style) {\n          case '\"':\n            this.write_double_quoted(this.analysis.scalar, split);\n            break;\n          case \"'\":\n            this.write_single_quoted(this.analysis.scalar, split);\n            break;\n          case '>':\n            this.write_folded(this.analysis.scalar);\n            break;\n          case '|':\n            this.write_literal(this.analysis.scalar);\n            break;\n          default:\n            this.write_plain(this.analysis.scalar, split);\n        }\n        this.analysis = null;\n        return this.style = null;\n      }\n\n      choose_scalar_style() {\n        var ref;\n        if (this.analysis == null) {\n          this.analysis = this.analyze_scalar(this.event.value);\n        }\n        if (this.event.style === '\"' || this.canonical) {\n          return '\"';\n        }\n        if (!this.event.style && this.event.implicit[0] && !(this.simple_key_context && (this.analysis.empty || this.analysis.multiline)) && ((this.flow_level && this.analysis.allow_flow_plain) || (!this.flow_level && this.analysis.allow_block_plain))) {\n          return '';\n        }\n        if (this.event.style && (ref = this.event.style, indexOf.call('|>', ref) >= 0) && !this.flow_level && !this.simple_key_context && this.analysis.allow_block) {\n          return this.event.style;\n        }\n        if ((!this.event.style || this.event.style === \"'\") && this.analysis.allow_single_quoted && !(this.simple_key_context && this.analysis.multiline)) {\n          return \"'\";\n        }\n        return '\"';\n      }\n\n      // Analyzers\n      prepare_version([major, minor]) {\n        var version;\n        version = `${major}.${minor}`;\n        if (major === 1) {\n          return version;\n        } else {\n          return this.error('unsupported YAML version', version);\n        }\n      }\n\n      prepare_tag_handle(handle) {\n        var char, i, len, ref;\n        if (!handle) {\n          this.error('tag handle must not be empty');\n        }\n        if (handle[0] !== '!' || handle.slice(-1) !== '!') {\n          this.error(\"tag handle must start and end with '!':\", handle);\n        }\n        ref = handle.slice(1, -1);\n        for (i = 0, len = ref.length; i < len; i++) {\n          char = ref[i];\n          if (!(('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || indexOf.call('-_', char) >= 0)) {\n            this.error(`invalid character '${char}' in the tag handle:`, handle);\n          }\n        }\n        return handle;\n      }\n\n      prepare_tag_prefix(prefix) {\n        var char, chunks, end, start;\n        if (!prefix) {\n          this.error('tag prefix must not be empty');\n        }\n        chunks = [];\n        start = 0;\n        end = +(prefix[0] === '!');\n        while (end < prefix.length) {\n          char = prefix[end];\n          if (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || indexOf.call('-;/?!:@&=+$,_.~*\\'()[]', char) >= 0) {\n            end++;\n          } else {\n            if (start < end) {\n              chunks.push(prefix.slice(start, end));\n            }\n            start = end = end + 1;\n            chunks.push(char);\n          }\n        }\n        if (start < end) {\n          chunks.push(prefix.slice(start, end));\n        }\n        return chunks.join('');\n      }\n\n      prepare_tag(tag) {\n        var char, chunks, end, handle, i, k, len, prefix, ref, start, suffix, suffix_text;\n        if (!tag) {\n          this.error('tag must not be empty');\n        }\n        if (tag === '!') {\n          return tag;\n        }\n        handle = null;\n        suffix = tag;\n        ref = ((function() {\n          var ref, results;\n          ref = this.tag_prefixes;\n          results = [];\n          for (k in ref) {\n            if (!hasProp.call(ref, k)) continue;\n            results.push(k);\n          }\n          return results;\n        }).call(this)).sort();\n        for (i = 0, len = ref.length; i < len; i++) {\n          prefix = ref[i];\n          if (tag.indexOf(prefix) === 0 && (prefix === '!' || prefix.length < tag.length)) {\n            handle = this.tag_prefixes[prefix];\n            suffix = tag.slice(prefix.length);\n          }\n        }\n        chunks = [];\n        start = end = 0;\n        while (end < suffix.length) {\n          char = suffix[end];\n          if (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || indexOf.call('-;/?!:@&=+$,_.~*\\'()[]', char) >= 0 || (char === '!' && handle !== '!')) {\n            end++;\n          } else {\n            if (start < end) {\n              chunks.push(suffix.slice(start, end));\n            }\n            start = end = end + 1;\n            chunks.push(char);\n          }\n        }\n        if (start < end) {\n          chunks.push(suffix.slice(start, end));\n        }\n        suffix_text = chunks.join('');\n        if (handle) {\n          return `${handle}${suffix_text}`;\n        } else {\n          return `!<${suffix_text}>`;\n        }\n      }\n\n      prepare_anchor(anchor) {\n        var char, i, len;\n        if (!anchor) {\n          this.error('anchor must not be empty');\n        }\n        for (i = 0, len = anchor.length; i < len; i++) {\n          char = anchor[i];\n          if (!(('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || indexOf.call('-_', char) >= 0)) {\n            this.error(`invalid character '${char}' in the anchor:`, anchor);\n          }\n        }\n        return anchor;\n      }\n\n      analyze_scalar(scalar) {\n        var allow_block, allow_block_plain, allow_double_quoted, allow_flow_plain, allow_single_quoted, block_indicators, break_space, char, flow_indicators, followed_by_whitespace, i, index, leading_break, leading_space, len, line_breaks, preceded_by_whitespace, previous_break, previous_space, ref, ref1, space_break, special_characters, trailing_break, trailing_space, unicode_characters;\n        // Empty scalar is a special case.\n        if (!scalar) {\n          new ScalarAnalysis(scalar, true, false, false, true, true, true, false);\n        }\n        // Indicators and special characters.\n        block_indicators = false;\n        flow_indicators = false;\n        line_breaks = false;\n        special_characters = false;\n        unicode_characters = false;\n        // Important whitespace combinations\n        leading_space = false;\n        leading_break = false;\n        trailing_space = false;\n        trailing_break = false;\n        break_space = false;\n        space_break = false;\n        // Check document indicators.\n        if (scalar.indexOf('---') === 0 || scalar.indexOf('...') === 0) {\n          block_indicators = true;\n          flow_indicators = true;\n        }\n        // First character or preceded by a whitespace.\n        preceded_by_whitespace = true;\n        // Last character or followed by a whitespace.\n        followed_by_whitespace = scalar.length === 1 || (ref = scalar[1], indexOf.call('\\0 \\t\\r\\n\\x85\\u2028\\u2029', ref) >= 0);\n        // The previous character is a space.\n        previous_space = false;\n        // The previous character is a break\n        previous_break = false;\n        index = 0;\n        for (index = i = 0, len = scalar.length; i < len; index = ++i) {\n          char = scalar[index];\n          // Check for indicators.\n          if (index === 0) {\n            // Leading indicators are special characters.\n            if (indexOf.call('#,[]{}&*!|>\\'\"%@`', char) >= 0 || (char === '-' && followed_by_whitespace)) {\n              flow_indicators = true;\n              block_indicators = true;\n            } else if (indexOf.call('?:', char) >= 0) {\n              flow_indicators = true;\n              if (followed_by_whitespace) {\n                block_indicators = true;\n              }\n            }\n          } else {\n            // Some indicators cannot appear within a scalar as well.\n            if (indexOf.call(',?[]{}', char) >= 0) {\n              flow_indicators = true;\n            } else if (char === ':') {\n              flow_indicators = true;\n              if (followed_by_whitespace) {\n                block_indicators = true;\n              }\n            } else if (char === '#' && preceded_by_whitespace) {\n              flow_indicators = true;\n              block_indicators = true;\n            }\n          }\n          // Check for line breaks, special, and unicode characters.\n          if (indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0) {\n            line_breaks = true;\n          }\n          if (!(char === '\\n' || ('\\x20' <= char && char <= '\\x7e'))) {\n            if (char !== '\\uFEFF' && (char === '\\x85' || ('\\xA0' <= char && char <= '\\uD7FF') || ('\\uE000' <= char && char <= '\\uFFFD'))) {\n              unicode_characters = true;\n              if (!this.allow_unicode) {\n                special_characters = true;\n              }\n            } else {\n              special_characters = true;\n            }\n          }\n          // Detect important whitespace combinations.\n          if (char === ' ') {\n            if (index === 0) {\n              leading_space = true;\n            }\n            if (index === scalar.length - 1) {\n              trailing_space = true;\n            }\n            if (previous_break) {\n              break_space = true;\n            }\n            previous_break = false;\n            previous_space = true;\n          } else if (indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0) {\n            if (index === 0) {\n              leading_break = true;\n            }\n            if (index === scalar.length - 1) {\n              trailing_break = true;\n            }\n            if (previous_space) {\n              space_break = true;\n            }\n            previous_break = true;\n            previous_space = false;\n          } else {\n            previous_break = false;\n            previous_space = false;\n          }\n          // Prepare for the next character.\n          preceded_by_whitespace = indexOf.call(C_WHITESPACE, char) >= 0;\n          followed_by_whitespace = index + 2 >= scalar.length || (ref1 = scalar[index + 2], indexOf.call(C_WHITESPACE, ref1) >= 0);\n        }\n        // Let's decide what styles are allowed.\n        allow_flow_plain = true;\n        allow_block_plain = true;\n        allow_single_quoted = true;\n        allow_double_quoted = true;\n        allow_block = true;\n        // Leading and trailing whitespaces are bad for plain scalars.\n        if (leading_space || leading_break || trailing_space || trailing_break) {\n          allow_flow_plain = allow_block_plain = false;\n        }\n        // We do not permit trailing spaces for block scalars.\n        if (trailing_space) {\n          allow_block = false;\n        }\n        // Spaces at the beginning of a new line are only acceptable for block scalars.\n        if (break_space) {\n          allow_flow_plain = allow_block_plain = allow_single_quoted = false;\n        }\n        // Spaces followed by breaks, as well as special character are only allowed for double quoted\n        // scalars.\n        if (space_break || special_characters) {\n          allow_flow_plain = allow_block_plain = allow_single_quoted = allow_block = false;\n        }\n        // Although the plain scalar writer supports breaks, we never emit multiline plain scalars.\n        if (line_breaks) {\n          allow_flow_plain = allow_block_plain = false;\n        }\n        // Flow indicators are forbidden for flow plain scalars.\n        if (flow_indicators) {\n          allow_flow_plain = false;\n        }\n        // Block indicators are forbidden for block plain scalars.\n        if (block_indicators) {\n          allow_block_plain = false;\n        }\n        return new ScalarAnalysis(scalar, false, line_breaks, allow_flow_plain, allow_block_plain, allow_single_quoted, allow_double_quoted, allow_block);\n      }\n\n      // Writers\n      /*\n      Write BOM if needed.\n      */\n      write_stream_start() {\n        if (this.encoding && this.encoding.indexOf('utf-16') === 0) {\n          return this.stream.write('\\uFEFF', this.encoding);\n        }\n      }\n\n      write_stream_end() {\n        return this.flush_stream();\n      }\n\n      write_indicator(indicator, need_whitespace, options = {}) {\n        var data;\n        data = this.whitespace || !need_whitespace ? indicator : ' ' + indicator;\n        this.whitespace = !!options.whitespace;\n        this.indentation && (this.indentation = !!options.indentation);\n        this.column += data.length;\n        this.open_ended = false;\n        return this.stream.write(data, this.encoding);\n      }\n\n      write_indent() {\n        var data, indent, ref;\n        indent = (ref = this.indent) != null ? ref : 0;\n        if (!this.indentation || this.column > indent || (this.column === indent && !this.whitespace)) {\n          this.write_line_break();\n        }\n        if (this.column < indent) {\n          this.whitespace = true;\n          data = new Array(indent - this.column + 1).join(' ');\n          this.column = indent;\n          return this.stream.write(data, this.encoding);\n        }\n      }\n\n      write_line_break(data) {\n        this.whitespace = true;\n        this.indentation = true;\n        this.line += 1;\n        this.column = 0;\n        return this.stream.write(data != null ? data : this.best_line_break, this.encoding);\n      }\n\n      write_version_directive(version_text) {\n        this.stream.write(`%YAML ${version_text}`, this.encoding);\n        return this.write_line_break();\n      }\n\n      write_tag_directive(handle_text, prefix_text) {\n        this.stream.write(`%TAG ${handle_text} ${prefix_text}`, this.encoding);\n        return this.write_line_break();\n      }\n\n      write_single_quoted(text, split = true) {\n        var br, breaks, char, data, end, i, len, ref, spaces, start;\n        this.write_indicator(\"'\", true);\n        spaces = false;\n        breaks = false;\n        start = end = 0;\n        while (end <= text.length) {\n          char = text[end];\n          if (spaces) {\n            if ((char == null) || char !== ' ') {\n              if (start + 1 === end && this.column > this.best_width && split && start !== 0 && end !== text.length) {\n                this.write_indent();\n              } else {\n                data = text.slice(start, end);\n                this.column += data.length;\n                this.stream.write(data, this.encoding);\n              }\n              start = end;\n            }\n          } else if (breaks) {\n            if ((char == null) || indexOf.call('\\n\\x85\\u2028\\u2029', char) < 0) {\n              if (text[start] === '\\n') {\n                this.write_line_break();\n              }\n              ref = text.slice(start, end);\n              for (i = 0, len = ref.length; i < len; i++) {\n                br = ref[i];\n                if (br === '\\n') {\n                  this.write_line_break();\n                } else {\n                  this.write_line_break(br);\n                }\n              }\n              this.write_indent();\n              start = end;\n            }\n          } else if (((char == null) || indexOf.call(' \\n\\x85\\u2028\\u2029', char) >= 0 || char === \"'\") && start < end) {\n            data = text.slice(start, end);\n            this.column += data.length;\n            this.stream.write(data, this.encoding);\n            start = end;\n          }\n          if (char === \"'\") {\n            this.column += 2;\n            this.stream.write(\"''\", this.encoding);\n            start = end + 1;\n          }\n          if (char != null) {\n            spaces = char === ' ';\n            breaks = indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0;\n          }\n          end++;\n        }\n        return this.write_indicator(\"'\", false);\n      }\n\n      write_double_quoted(text, split = true) {\n        var char, data, end, start;\n        this.write_indicator('\"', true);\n        start = end = 0;\n        while (end <= text.length) {\n          char = text[end];\n          if ((char == null) || indexOf.call('\"\\\\\\x85\\u2028\\u2029\\uFEFF', char) >= 0 || !(('\\x20' <= char && char <= '\\x7E') || (this.allow_unicode && (('\\xA0' <= char && char <= '\\uD7FF') || ('\\uE000' <= char && char <= '\\uFFFD'))))) {\n            if (start < end) {\n              data = text.slice(start, end);\n              this.column += data.length;\n              this.stream.write(data, this.encoding);\n              start = end;\n            }\n            if (char != null) {\n              data = char in ESCAPE_REPLACEMENTS ? '\\\\' + ESCAPE_REPLACEMENTS[char] : char <= '\\xFF' ? `\\\\x${util.pad_left(util.to_hex(char), '0', 2)}` : char <= '\\uFFFF' ? `\\\\u${util.pad_left(util.to_hex(char), '0', 4)}` : `\\\\U${util.pad_left(util.to_hex(char), '0', 16)}`;\n              this.column += data.length;\n              this.stream.write(data, this.encoding);\n              start = end + 1;\n            }\n          }\n          if (split && (0 < end && end < text.length - 1) && (char === ' ' || start >= end) && this.column + (end - start) > this.best_width) {\n            data = `${text.slice(start, end)}\\\\`;\n            if (start < end) {\n              start = end;\n            }\n            this.column += data.length;\n            this.stream.write(data, this.encoding);\n            this.write_indent();\n            this.whitespace = false;\n            this.indentation = false;\n            if (text[start] === ' ') {\n              data = '\\\\';\n              this.column += data.length;\n              this.stream.write(data, this.encoding);\n            }\n          }\n          end++;\n        }\n        return this.write_indicator('\"', false);\n      }\n\n      write_folded(text) {\n        var br, breaks, char, data, end, hints, i, leading_space, len, ref, results, spaces, start;\n        hints = this.determine_block_hints(text);\n        this.write_indicator(`>${hints}`, true);\n        if (hints.slice(-1) === '+') {\n          this.open_ended = true;\n        }\n        this.write_line_break();\n        leading_space = true;\n        breaks = true;\n        spaces = false;\n        start = end = 0;\n        results = [];\n        while (end <= text.length) {\n          char = text[end];\n          if (breaks) {\n            if ((char == null) || indexOf.call('\\n\\x85\\u2028\\u2029', char) < 0) {\n              if (!leading_space && (char != null) && char !== ' ' && text[start] === '\\n') {\n                this.write_line_break();\n              }\n              leading_space = char === ' ';\n              ref = text.slice(start, end);\n              for (i = 0, len = ref.length; i < len; i++) {\n                br = ref[i];\n                if (br === '\\n') {\n                  this.write_line_break();\n                } else {\n                  this.write_line_break(br);\n                }\n              }\n              if (char != null) {\n                this.write_indent();\n              }\n              start = end;\n            }\n          } else if (spaces) {\n            if (char !== ' ') {\n              if (start + 1 === end && this.column > this.best_width) {\n                this.write_indent();\n              } else {\n                data = text.slice(start, end);\n                this.column += data.length;\n                this.stream.write(data, this.encoding);\n              }\n              start = end;\n            }\n          } else if ((char == null) || indexOf.call(' \\n\\x85\\u2028\\u2029', char) >= 0) {\n            data = text.slice(start, end);\n            this.column += data.length;\n            this.stream.write(data, this.encoding);\n            if (char == null) {\n              this.write_line_break();\n            }\n            start = end;\n          }\n          if (char != null) {\n            breaks = indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0;\n            spaces = char === ' ';\n          }\n          results.push(end++);\n        }\n        return results;\n      }\n\n      write_literal(text) {\n        var br, breaks, char, data, end, hints, i, len, ref, results, start;\n        hints = this.determine_block_hints(text);\n        this.write_indicator(`|${hints}`, true);\n        if (hints.slice(-1) === '+') {\n          this.open_ended = true;\n        }\n        this.write_line_break();\n        breaks = true;\n        start = end = 0;\n        results = [];\n        while (end <= text.length) {\n          char = text[end];\n          if (breaks) {\n            if ((char == null) || indexOf.call('\\n\\x85\\u2028\\u2029', char) < 0) {\n              ref = text.slice(start, end);\n              for (i = 0, len = ref.length; i < len; i++) {\n                br = ref[i];\n                if (br === '\\n') {\n                  this.write_line_break();\n                } else {\n                  this.write_line_break(br);\n                }\n              }\n              if (char != null) {\n                this.write_indent();\n              }\n              start = end;\n            }\n          } else {\n            if ((char == null) || indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0) {\n              data = text.slice(start, end);\n              this.stream.write(data, this.encoding);\n              if (char == null) {\n                this.write_line_break();\n              }\n              start = end;\n            }\n          }\n          if (char != null) {\n            breaks = indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0;\n          }\n          results.push(end++);\n        }\n        return results;\n      }\n\n      write_plain(text, split = true) {\n        var br, breaks, char, data, end, i, len, ref, results, spaces, start;\n        if (!text) {\n          return;\n        }\n        if (this.root_context) {\n          this.open_ended = true;\n        }\n        if (!this.whitespace) {\n          data = ' ';\n          this.column += data.length;\n          this.stream.write(data, this.encoding);\n        }\n        this.whitespace = false;\n        this.indentation = false;\n        spaces = false;\n        breaks = false;\n        start = end = 0;\n        results = [];\n        while (end <= text.length) {\n          char = text[end];\n          if (spaces) {\n            if (char !== ' ') {\n              if (start + 1 === end && this.column > this.best_width && split) {\n                this.write_indent();\n                this.whitespace = false;\n                this.indentation = false;\n              } else {\n                data = text.slice(start, end);\n                this.column += data.length;\n                this.stream.write(data, this.encoding);\n              }\n              start = end;\n            }\n          } else if (breaks) {\n            if (indexOf.call('\\n\\x85\\u2028\\u2029', char) < 0) {\n              if (text[start] === '\\n') {\n                this.write_line_break();\n              }\n              ref = text.slice(start, end);\n              for (i = 0, len = ref.length; i < len; i++) {\n                br = ref[i];\n                if (br === '\\n') {\n                  this.write_line_break();\n                } else {\n                  this.write_line_break(br);\n                }\n              }\n              this.write_indent();\n              this.whitespace = false;\n              this.indentation = false;\n              start = end;\n            }\n          } else {\n            if ((char == null) || indexOf.call(' \\n\\x85\\u2028\\u2029', char) >= 0) {\n              data = text.slice(start, end);\n              this.column += data.length;\n              this.stream.write(data, this.encoding);\n              start = end;\n            }\n          }\n          if (char != null) {\n            spaces = char === ' ';\n            breaks = indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0;\n          }\n          results.push(end++);\n        }\n        return results;\n      }\n\n      determine_block_hints(text) {\n        var first, hints, i, last, penultimate;\n        hints = '';\n        first = text[0], i = text.length - 2, penultimate = text[i++], last = text[i++];\n        if (indexOf.call(' \\n\\x85\\u2028\\u2029', first) >= 0) {\n          hints += this.best_indent;\n        }\n        if (indexOf.call('\\n\\x85\\u2028\\u2029', last) < 0) {\n          hints += '-';\n        } else if (text.length === 1 || indexOf.call('\\n\\x85\\u2028\\u2029', penultimate) >= 0) {\n          hints += '+';\n        }\n        return hints;\n      }\n\n      flush_stream() {\n        var base;\n        return typeof (base = this.stream).flush === \"function\" ? base.flush() : void 0;\n      }\n\n      /*\n      Helper for common error pattern.\n      */\n      error(message, context) {\n        var ref, ref1;\n        if (context) {\n          context = (ref = context != null ? (ref1 = context.constructor) != null ? ref1.name : void 0 : void 0) != null ? ref : util.inspect(context);\n        }\n        throw new exports.EmitterError(`${message}${(context ? ` ${context}` : '')}`);\n      }\n\n    };\n\n    C_WHITESPACE = '\\0 \\t\\r\\n\\x85\\u2028\\u2029';\n\n    DEFAULT_TAG_PREFIXES = {\n      '!': '!',\n      'tag:yaml.org,2002:': '!!'\n    };\n\n    ESCAPE_REPLACEMENTS = {\n      '\\0': '0',\n      '\\x07': 'a',\n      '\\x08': 'b',\n      '\\x09': 't',\n      '\\x0A': 'n',\n      '\\x0B': 'v',\n      '\\x0C': 'f',\n      '\\x0D': 'r',\n      '\\x1B': 'e',\n      '\"': '\"',\n      '\\\\': '\\\\',\n      '\\x85': 'N',\n      '\\xA0': '_',\n      '\\u2028': 'L',\n      '\\u2029': 'P'\n    };\n\n    ctor = Emitter.prototype.initialise;\n\n    return Emitter;\n\n  }).call(this);\n\n  ScalarAnalysis = class ScalarAnalysis {\n    constructor(scalar1, empty, multiline, allow_flow_plain1, allow_block_plain1, allow_single_quoted1, allow_double_quoted1, allow_block1) {\n      this.scalar = scalar1;\n      this.empty = empty;\n      this.multiline = multiline;\n      this.allow_flow_plain = allow_flow_plain1;\n      this.allow_block_plain = allow_block_plain1;\n      this.allow_single_quoted = allow_single_quoted1;\n      this.allow_double_quoted = allow_double_quoted1;\n      this.allow_block = allow_block1;\n    }\n\n  };\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLEVBQVU7O0FBRTdCLFNBQVMsbUJBQU8sQ0FBQyxHQUFROztBQUV6QixJQUFJLFdBQVcsRUFBRSxtQkFBTyxDQUFDLEdBQVU7O0FBRW5DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4REFBOEQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVSxFQUFFLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTSxHQUFHLE1BQU07QUFDcEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThIO0FBQzlIO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxFQUFFLFlBQVk7QUFDekMsVUFBVTtBQUNWLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsYUFBYSxFQUFFLFlBQVk7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLHlDQUF5Qyw2QkFBNkIseUNBQXlDLFVBQVUsMENBQTBDO0FBQ2hSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVEsRUFBRSxlQUFlLFFBQVEsUUFBUTtBQUNuRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwtanMvbGliL2VtaXR0ZXIuanM/YmU0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIHZhciBTY2FsYXJBbmFseXNpcywgWUFNTEVycm9yLCBldmVudHMsIHV0aWwsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gICh7WUFNTEVycm9yfSA9IHJlcXVpcmUoJy4vZXJyb3JzJykpO1xuXG4gIHRoaXMuRW1pdHRlckVycm9yID0gY2xhc3MgRW1pdHRlckVycm9yIGV4dGVuZHMgWUFNTEVycm9yIHt9O1xuXG4gIC8qXG4gIEVtaXR0ZXIgZXhwZWN0cyBldmVudHMgb2JleWluZyB0aGUgZm9sbG93aW5nIGdyYW1tYXI6XG5cbiAgc3RyZWFtICAgOjo9IFNUUkVBTS1TVEFSVCBkb2N1bWVudCogU1RSRUFNLUVORFxuICBkb2N1bWVudCA6Oj0gRE9DVU1FTlQtU1RBUlQgbm9kZSBET0NVTUVOVC1FTkRcbiAgbm9kZSAgICAgOjo9IFNDQUxBIHwgc2VxdWVuY2UgfCBtYXBwaW5nXG4gIHNlcXVlbmNlIDo6PSBTRVFVRU5DRS1TVEFSVCBub2RlKiBTRVFVRU5DRS1FTkRcbiAgbWFwcGluZyAgOjo9IE1BUFBJTkctU1RBUlQgKG5vZGUgbm9kZSkqIE1BUFBJTkctRU5EXG4gICovXG4gIHRoaXMuRW1pdHRlciA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgQ19XSElURVNQQUNFLCBERUZBVUxUX1RBR19QUkVGSVhFUywgRVNDQVBFX1JFUExBQ0VNRU5UUywgY3RvcjtcblxuICAgIGNsYXNzIEVtaXR0ZXIge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpc2Uoc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAvLyBFbmNvZGluZyBjYW4gYmUgb3ZlcnJpZGVuIGJ5IFNUUkVBTS1TVEFSVFxuICAgICAgICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgICAgICAgLy8gRW1pdHRlciBpcyBhIHN0YXRlIG1hY2hpbmUgd2l0aCBhIHN0YWNrIG9mIHN0YXRlcyB0byBoYW5kbGUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICAgIHRoaXMuc3RhdGVzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmV4cGVjdF9zdHJlYW1fc3RhcnQ7XG4gICAgICAgIC8vIEN1cnJlbnQgZXZlbnQgYW5kIHRoZSBldmVudCBxdWV1ZVxuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50ID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIHRoZSBzdGFjayBvZiBwcmV2aW91cyBpbmRlbnRzLlxuICAgICAgICB0aGlzLmluZGVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSBudWxsO1xuICAgICAgICAvLyBGbG93IGxldmVsLlxuICAgICAgICB0aGlzLmZsb3dfbGV2ZWwgPSAwO1xuICAgICAgICAvLyBDb250ZXh0cy5cbiAgICAgICAgdGhpcy5yb290X2NvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZV9jb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFwcGluZ19jb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2ltcGxlX2tleV9jb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIC8vIENoYXJhY3RlcmlzdGljcyBvZiB0aGUgbGFzdCBlbWl0dGVkIGNoYXJhY3RlcjpcbiAgICAgICAgLy8gLSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAvLyAtIGlzIGl0IGEgd2hpdGVzcGFjZT9cbiAgICAgICAgLy8gLSBpcyBpdCBhbiBpbmRlbnRhdGlvbiBjaGFyYWN0ZXIgKGluZGVudGF0aW9uIHNwYWNlLCAnLScsICc/Jywgb3IgJzonKT9cbiAgICAgICAgdGhpcy5saW5lID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLndoaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgICB0aGlzLmluZGVudGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgLy8gV2hldGhlciB0aGUgZG9jdW1lbnQgcmVxdWlyZXMgYW4gZXhwbGljaXQgZG9jdW1lbnQgaW5kaWNhdG9yLlxuICAgICAgICB0aGlzLm9wZW5fZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gRm9ybWF0dGluZyBkZXRhaWxzXG4gICAgICAgICh7Y2Fub25pY2FsOiB0aGlzLmNhbm9uaWNhbCwgYWxsb3dfdW5pY29kZTogdGhpcy5hbGxvd191bmljb2RlfSA9IG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5jYW5vbmljYWwgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY2Fub25pY2FsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWxsb3dfdW5pY29kZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5hbGxvd191bmljb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlc3RfaW5kZW50ID0gMSA8IG9wdGlvbnMuaW5kZW50ICYmIG9wdGlvbnMuaW5kZW50IDwgMTAgPyBvcHRpb25zLmluZGVudCA6IDI7XG4gICAgICAgIHRoaXMuYmVzdF93aWR0aCA9IG9wdGlvbnMud2lkdGggPiB0aGlzLmluZGVudCAqIDIgPyBvcHRpb25zLndpZHRoIDogODA7XG4gICAgICAgIHRoaXMuYmVzdF9saW5lX2JyZWFrID0gKHJlZiA9IG9wdGlvbnMubGluZV9icmVhaykgPT09ICdcXHInIHx8IHJlZiA9PT0gJ1xcbicgfHwgcmVmID09PSAnXFxyXFxuJyA/IG9wdGlvbnMubGluZV9icmVhayA6ICdcXG4nO1xuICAgICAgICAvLyBUYWcgcHJlZml4ZXMuXG4gICAgICAgIHRoaXMudGFnX3ByZWZpeGVzID0gbnVsbDtcbiAgICAgICAgLy8gUHJlcGFyZWQgYW5jaG9yIGFuZCB0YWdcbiAgICAgICAgdGhpcy5wcmVwYXJlZF9hbmNob3IgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXBhcmVkX3RhZyA9IG51bGw7XG4gICAgICAgIC8vIFNjYWxhciBhbmFseXNpcyBhbmQgc3R5bGUuXG4gICAgICAgIHRoaXMuYW5hbHlzaXMgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBSZXNldCB0aGUgc3RhdGUgYXR0cmlidXRlcyAodG8gY2xlYXIgc2VsZi1yZWZlcmVuY2VzKVxuICAgICAgKi9cbiAgICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZW1pdChldmVudCkge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgdGhpcy5ldmVudHMucHVzaChldmVudCk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLm5lZWRfbW9yZV9ldmVudHMoKSkge1xuICAgICAgICAgIHRoaXMuZXZlbnQgPSB0aGlzLmV2ZW50cy5zaGlmdCgpO1xuICAgICAgICAgIHRoaXMuc3RhdGUoKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5ldmVudCA9IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgSW4gc29tZSBjYXNlcywgd2Ugd2FpdCBmb3IgYSBmZXcgbmV4dCBldmVudHMgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAgKi9cbiAgICAgIG5lZWRfbW9yZV9ldmVudHMoKSB7XG4gICAgICAgIHZhciBldmVudDtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50ID0gdGhpcy5ldmVudHNbMF07XG4gICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5Eb2N1bWVudFN0YXJ0RXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWVkX2V2ZW50cygxKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5TZXF1ZW5jZVN0YXJ0RXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWVkX2V2ZW50cygyKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5NYXBwaW5nU3RhcnRFdmVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5lZWRfZXZlbnRzKDMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZWVkX2V2ZW50cyhjb3VudCkge1xuICAgICAgICB2YXIgZXZlbnQsIGksIGxlbiwgbGV2ZWwsIHJlZjtcbiAgICAgICAgbGV2ZWwgPSAwO1xuICAgICAgICByZWYgPSB0aGlzLmV2ZW50cy5zbGljZSgxKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZXZlbnQgPSByZWZbaV07XG4gICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgZXZlbnRzLkRvY3VtZW50U3RhcnRFdmVudCB8fCBldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5Db2xsZWN0aW9uU3RhcnRFdmVudCkge1xuICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgZXZlbnRzLkRvY3VtZW50RW5kRXZlbnQgfHwgZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuQ29sbGVjdGlvbkVuZEV2ZW50KSB7XG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuU3RyZWFtRW5kRXZlbnQpIHtcbiAgICAgICAgICAgIGxldmVsID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLmxlbmd0aCA8IGNvdW50ICsgMTtcbiAgICAgIH1cblxuICAgICAgaW5jcmVhc2VfaW5kZW50KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmluZGVudHMucHVzaCh0aGlzLmluZGVudCk7XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZW50ID0gb3B0aW9ucy5mbG93ID8gdGhpcy5iZXN0X2luZGVudCA6IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuaW5kZW50bGVzcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmluZGVudCArPSB0aGlzLmJlc3RfaW5kZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFN0cmVhbSBzdGF0ZXNcbiAgICAgIGV4cGVjdF9zdHJlYW1fc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50IGluc3RhbmNlb2YgZXZlbnRzLlN0cmVhbVN0YXJ0RXZlbnQpIHtcbiAgICAgICAgICBpZiAodGhpcy5ldmVudC5lbmNvZGluZyAmJiAhKCdlbmNvZGluZycgaW4gdGhpcy5zdHJlYW0pKSB7XG4gICAgICAgICAgICB0aGlzLmVuY29kaW5nID0gdGhpcy5ldmVudC5lbmNvZGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy53cml0ZV9zdHJlYW1fc3RhcnQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9IHRoaXMuZXhwZWN0X2ZpcnN0X2RvY3VtZW50X3N0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdleHBlY3RlZCBTdHJlYW1TdGFydEV2ZW50LCBidXQgZ290JywgdGhpcy5ldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXhwZWN0X25vdGhpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdleHBlY3RlZCBub3RoaW5nLCBidXQgZ290JywgdGhpcy5ldmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERvY3VtZW50IHN0YXRlc1xuICAgICAgZXhwZWN0X2ZpcnN0X2RvY3VtZW50X3N0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBlY3RfZG9jdW1lbnRfc3RhcnQodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdF9kb2N1bWVudF9zdGFydChmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIHZhciBleHBsaWNpdCwgaGFuZGxlLCBpLCBrLCBsZW4sIHByZWZpeCwgcmVmO1xuICAgICAgICBpZiAodGhpcy5ldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5Eb2N1bWVudFN0YXJ0RXZlbnQpIHtcbiAgICAgICAgICBpZiAoKHRoaXMuZXZlbnQudmVyc2lvbiB8fCB0aGlzLmV2ZW50LnRhZ3MpICYmIHRoaXMub3Blbl9lbmRlZCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRpY2F0b3IoJy4uLicsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZXZlbnQudmVyc2lvbikge1xuICAgICAgICAgICAgdGhpcy53cml0ZV92ZXJzaW9uX2RpcmVjdGl2ZSh0aGlzLnByZXBhcmVfdmVyc2lvbih0aGlzLmV2ZW50LnZlcnNpb24pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50YWdfcHJlZml4ZXMgPSB1dGlsLmNsb25lKERFRkFVTFRfVEFHX1BSRUZJWEVTKTtcbiAgICAgICAgICBpZiAodGhpcy5ldmVudC50YWdzKSB7XG4gICAgICAgICAgICByZWYgPSAoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICByZWYgPSB0aGlzLmV2ZW50LnRhZ3M7XG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChrIGluIHJlZikge1xuICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwgaykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcykpLnNvcnQoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICBoYW5kbGUgPSByZWZbaV07XG4gICAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuZXZlbnQudGFnc1toYW5kbGVdO1xuICAgICAgICAgICAgICB0aGlzLnRhZ19wcmVmaXhlc1twcmVmaXhdID0gaGFuZGxlO1xuICAgICAgICAgICAgICB0aGlzLndyaXRlX3RhZ19kaXJlY3RpdmUodGhpcy5wcmVwYXJlX3RhZ19oYW5kbGUoaGFuZGxlKSwgdGhpcy5wcmVwYXJlX3RhZ19wcmVmaXgocHJlZml4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cGxpY2l0ID0gIWZpcnN0IHx8IHRoaXMuZXZlbnQuZXhwbGljaXQgfHwgdGhpcy5jYW5vbmljYWwgfHwgdGhpcy5ldmVudC52ZXJzaW9uIHx8IHRoaXMuZXZlbnQudGFncyB8fCB0aGlzLmNoZWNrX2VtcHR5X2RvY3VtZW50KCk7XG4gICAgICAgICAgaWYgKGV4cGxpY2l0KSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlX2luZGVudCgpO1xuICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRpY2F0b3IoJy0tLScsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2Fub25pY2FsKSB7XG4gICAgICAgICAgICAgIHRoaXMud3JpdGVfaW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gdGhpcy5leHBlY3RfZG9jdW1lbnRfcm9vdDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmV2ZW50IGluc3RhbmNlb2YgZXZlbnRzLlN0cmVhbUVuZEV2ZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMub3Blbl9lbmRlZCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRpY2F0b3IoJy4uLicsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy53cml0ZV9zdHJlYW1fZW5kKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPSB0aGlzLmV4cGVjdF9ub3RoaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdleHBlY3RlZCBEb2N1bWVudFN0YXJ0RXZlbnQsIGJ1dCBnb3QnLCB0aGlzLmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3RfZG9jdW1lbnRfZW5kKCkge1xuICAgICAgICBpZiAodGhpcy5ldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5Eb2N1bWVudEVuZEV2ZW50KSB7XG4gICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgICBpZiAodGhpcy5ldmVudC5leHBsaWNpdCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRpY2F0b3IoJy4uLicsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mbHVzaF9zdHJlYW0oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9IHRoaXMuZXhwZWN0X2RvY3VtZW50X3N0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdleHBlY3RlZCBEb2N1bWVudEVuZEV2ZW50LCBidXQgZ290JywgdGhpcy5ldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXhwZWN0X2RvY3VtZW50X3Jvb3QoKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2godGhpcy5leHBlY3RfZG9jdW1lbnRfZW5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0X25vZGUoe1xuICAgICAgICAgIHJvb3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vZGUgc3RhdGVzXG4gICAgICBleHBlY3Rfbm9kZShleHBlY3QgPSB7fSkge1xuICAgICAgICB0aGlzLnJvb3RfY29udGV4dCA9ICEhZXhwZWN0LnJvb3Q7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VfY29udGV4dCA9ICEhZXhwZWN0LnNlcXVlbmNlO1xuICAgICAgICB0aGlzLm1hcHBpbmdfY29udGV4dCA9ICEhZXhwZWN0Lm1hcHBpbmc7XG4gICAgICAgIHRoaXMuc2ltcGxlX2tleV9jb250ZXh0ID0gISFleHBlY3Quc2ltcGxlX2tleTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuQWxpYXNFdmVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4cGVjdF9hbGlhcygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuU2NhbGFyRXZlbnQgfHwgdGhpcy5ldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5Db2xsZWN0aW9uU3RhcnRFdmVudCkge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc19hbmNob3IoJyYnKTtcbiAgICAgICAgICB0aGlzLnByb2Nlc3NfdGFnKCk7XG4gICAgICAgICAgaWYgKHRoaXMuZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuU2NhbGFyRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGVjdF9zY2FsYXIoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuU2VxdWVuY2VTdGFydEV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mbG93X2xldmVsIHx8IHRoaXMuY2Fub25pY2FsIHx8IHRoaXMuZXZlbnQuZmxvd19zdHlsZSB8fCB0aGlzLmNoZWNrX2VtcHR5X3NlcXVlbmNlKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0X2Zsb3dfc2VxdWVuY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGVjdF9ibG9ja19zZXF1ZW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5NYXBwaW5nU3RhcnRFdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCB8fCB0aGlzLmNhbm9uaWNhbCB8fCB0aGlzLmV2ZW50LmZsb3dfc3R5bGUgfHwgdGhpcy5jaGVja19lbXB0eV9tYXBwaW5nKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0X2Zsb3dfbWFwcGluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0X2Jsb2NrX21hcHBpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ2V4cGVjdGVkIE5vZGVFdmVudCwgYnV0IGdvdCcsIHRoaXMuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdF9hbGlhcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50LmFuY2hvcikge1xuICAgICAgICAgIHRoaXMuZXJyb3IoJ2FuY2hvciBpcyBub3Qgc3BlY2lmaWVkIGZvciBhbGlhcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc19hbmNob3IoJyonKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0X3NjYWxhcigpIHtcbiAgICAgICAgdGhpcy5pbmNyZWFzZV9pbmRlbnQoe1xuICAgICAgICAgIGZsb3c6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvY2Vzc19zY2FsYXIoKTtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSB0aGlzLmluZGVudHMucG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZsb3cgc2VxdWVuY2Ugc3RhdGVzXG4gICAgICBleHBlY3RfZmxvd19zZXF1ZW5jZSgpIHtcbiAgICAgICAgdGhpcy53cml0ZV9pbmRpY2F0b3IoJ1snLCB0cnVlLCB7XG4gICAgICAgICAgd2hpdGVzcGFjZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mbG93X2xldmVsKys7XG4gICAgICAgIHRoaXMuaW5jcmVhc2VfaW5kZW50KHtcbiAgICAgICAgICBmbG93OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9IHRoaXMuZXhwZWN0X2ZpcnN0X2Zsb3dfc2VxdWVuY2VfaXRlbTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0X2ZpcnN0X2Zsb3dfc2VxdWVuY2VfaXRlbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuU2VxdWVuY2VFbmRFdmVudCkge1xuICAgICAgICAgIHRoaXMuaW5kZW50ID0gdGhpcy5pbmRlbnRzLnBvcCgpO1xuICAgICAgICAgIHRoaXMuZmxvd19sZXZlbC0tO1xuICAgICAgICAgIHRoaXMud3JpdGVfaW5kaWNhdG9yKCddJywgZmFsc2UpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2Fub25pY2FsIHx8IHRoaXMuY29sdW1uID4gdGhpcy5iZXN0X3dpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlX2luZGVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHRoaXMuZXhwZWN0X2Zsb3dfc2VxdWVuY2VfaXRlbSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0X25vZGUoe1xuICAgICAgICAgICAgc2VxdWVuY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3RfZmxvd19zZXF1ZW5jZV9pdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5ldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5TZXF1ZW5jZUVuZEV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5pbmRlbnQgPSB0aGlzLmluZGVudHMucG9wKCk7XG4gICAgICAgICAgdGhpcy5mbG93X2xldmVsLS07XG4gICAgICAgICAgaWYgKHRoaXMuY2Fub25pY2FsKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlX2luZGljYXRvcignLCcsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVfaW5kZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud3JpdGVfaW5kaWNhdG9yKCddJywgZmFsc2UpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy53cml0ZV9pbmRpY2F0b3IoJywnLCBmYWxzZSk7XG4gICAgICAgICAgaWYgKHRoaXMuY2Fub25pY2FsIHx8IHRoaXMuY29sdW1uID4gdGhpcy5iZXN0X3dpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlX2luZGVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHRoaXMuZXhwZWN0X2Zsb3dfc2VxdWVuY2VfaXRlbSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0X25vZGUoe1xuICAgICAgICAgICAgc2VxdWVuY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGbG93IG1hcHBpbmcgc3RhdGVzXG4gICAgICBleHBlY3RfZmxvd19tYXBwaW5nKCkge1xuICAgICAgICB0aGlzLndyaXRlX2luZGljYXRvcigneycsIHRydWUsIHtcbiAgICAgICAgICB3aGl0ZXNwYWNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZsb3dfbGV2ZWwrKztcbiAgICAgICAgdGhpcy5pbmNyZWFzZV9pbmRlbnQoe1xuICAgICAgICAgIGZsb3c6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gdGhpcy5leHBlY3RfZmlyc3RfZmxvd19tYXBwaW5nX2tleTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0X2ZpcnN0X2Zsb3dfbWFwcGluZ19rZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50IGluc3RhbmNlb2YgZXZlbnRzLk1hcHBpbmdFbmRFdmVudCkge1xuICAgICAgICAgIHRoaXMuaW5kZW50ID0gdGhpcy5pbmRlbnRzLnBvcCgpO1xuICAgICAgICAgIHRoaXMuZmxvd19sZXZlbC0tO1xuICAgICAgICAgIHRoaXMud3JpdGVfaW5kaWNhdG9yKCd9JywgZmFsc2UpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2Fub25pY2FsIHx8IHRoaXMuY29sdW1uID4gdGhpcy5iZXN0X3dpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlX2luZGVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuY2Fub25pY2FsICYmIHRoaXMuY2hlY2tfc2ltcGxlX2tleSgpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHRoaXMuZXhwZWN0X2Zsb3dfbWFwcGluZ19zaW1wbGVfdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0X25vZGUoe1xuICAgICAgICAgICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgICAgICAgICBzaW1wbGVfa2V5OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRpY2F0b3IoJz8nLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2godGhpcy5leHBlY3RfZmxvd19tYXBwaW5nX3ZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGVjdF9ub2RlKHtcbiAgICAgICAgICAgICAgbWFwcGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdF9mbG93X21hcHBpbmdfa2V5KCkge1xuICAgICAgICBpZiAodGhpcy5ldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5NYXBwaW5nRW5kRXZlbnQpIHtcbiAgICAgICAgICB0aGlzLmluZGVudCA9IHRoaXMuaW5kZW50cy5wb3AoKTtcbiAgICAgICAgICB0aGlzLmZsb3dfbGV2ZWwtLTtcbiAgICAgICAgICBpZiAodGhpcy5jYW5vbmljYWwpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVfaW5kaWNhdG9yKCcsJywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy53cml0ZV9pbmRpY2F0b3IoJ30nLCBmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndyaXRlX2luZGljYXRvcignLCcsIGZhbHNlKTtcbiAgICAgICAgICBpZiAodGhpcy5jYW5vbmljYWwgfHwgdGhpcy5jb2x1bW4gPiB0aGlzLmJlc3Rfd2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVfaW5kZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jYW5vbmljYWwgJiYgdGhpcy5jaGVja19zaW1wbGVfa2V5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2godGhpcy5leHBlY3RfZmxvd19tYXBwaW5nX3NpbXBsZV92YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBlY3Rfbm9kZSh7XG4gICAgICAgICAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICAgICAgICAgIHNpbXBsZV9rZXk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlX2luZGljYXRvcignPycsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCh0aGlzLmV4cGVjdF9mbG93X21hcHBpbmdfdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0X25vZGUoe1xuICAgICAgICAgICAgICBtYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXhwZWN0X2Zsb3dfbWFwcGluZ19zaW1wbGVfdmFsdWUoKSB7XG4gICAgICAgIHRoaXMud3JpdGVfaW5kaWNhdG9yKCc6JywgZmFsc2UpO1xuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHRoaXMuZXhwZWN0X2Zsb3dfbWFwcGluZ19rZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHBlY3Rfbm9kZSh7XG4gICAgICAgICAgbWFwcGluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0X2Zsb3dfbWFwcGluZ192YWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2Fub25pY2FsIHx8IHRoaXMuY29sdW1uID4gdGhpcy5iZXN0X3dpZHRoKSB7XG4gICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlX2luZGljYXRvcignOicsIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHRoaXMuZXhwZWN0X2Zsb3dfbWFwcGluZ19rZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHBlY3Rfbm9kZSh7XG4gICAgICAgICAgbWFwcGluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQmxvY2sgc2VxdWVuY2Ugc3RhdGVzXG4gICAgICBleHBlY3RfYmxvY2tfc2VxdWVuY2UoKSB7XG4gICAgICAgIHZhciBpbmRlbnRsZXNzO1xuICAgICAgICBpbmRlbnRsZXNzID0gdGhpcy5tYXBwaW5nX2NvbnRleHQgJiYgIXRoaXMuaW5kZW50YXRpb247XG4gICAgICAgIHRoaXMuaW5jcmVhc2VfaW5kZW50KHtpbmRlbnRsZXNzfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gdGhpcy5leHBlY3RfZmlyc3RfYmxvY2tfc2VxdWVuY2VfaXRlbTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0X2ZpcnN0X2Jsb2NrX3NlcXVlbmNlX2l0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGVjdF9ibG9ja19zZXF1ZW5jZV9pdGVtKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBleHBlY3RfYmxvY2tfc2VxdWVuY2VfaXRlbShmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghZmlyc3QgJiYgdGhpcy5ldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5TZXF1ZW5jZUVuZEV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5pbmRlbnQgPSB0aGlzLmluZGVudHMucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndyaXRlX2luZGVudCgpO1xuICAgICAgICAgIHRoaXMud3JpdGVfaW5kaWNhdG9yKCctJywgdHJ1ZSwge1xuICAgICAgICAgICAgaW5kZW50YXRpb246IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHRoaXMuZXhwZWN0X2Jsb2NrX3NlcXVlbmNlX2l0ZW0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4cGVjdF9ub2RlKHtcbiAgICAgICAgICAgIHNlcXVlbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQmxvY2sgbWFwcGluZyBzdGF0ZXNcbiAgICAgIGV4cGVjdF9ibG9ja19tYXBwaW5nKCkge1xuICAgICAgICB0aGlzLmluY3JlYXNlX2luZGVudCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9IHRoaXMuZXhwZWN0X2ZpcnN0X2Jsb2NrX21hcHBpbmdfa2V5O1xuICAgICAgfVxuXG4gICAgICBleHBlY3RfZmlyc3RfYmxvY2tfbWFwcGluZ19rZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGVjdF9ibG9ja19tYXBwaW5nX2tleSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0X2Jsb2NrX21hcHBpbmdfa2V5KGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFmaXJzdCAmJiB0aGlzLmV2ZW50IGluc3RhbmNlb2YgZXZlbnRzLk1hcHBpbmdFbmRFdmVudCkge1xuICAgICAgICAgIHRoaXMuaW5kZW50ID0gdGhpcy5pbmRlbnRzLnBvcCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja19zaW1wbGVfa2V5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2godGhpcy5leHBlY3RfYmxvY2tfbWFwcGluZ19zaW1wbGVfdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0X25vZGUoe1xuICAgICAgICAgICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgICAgICAgICBzaW1wbGVfa2V5OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRpY2F0b3IoJz8nLCB0cnVlLCB7XG4gICAgICAgICAgICAgIGluZGVudGF0aW9uOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2godGhpcy5leHBlY3RfYmxvY2tfbWFwcGluZ192YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBlY3Rfbm9kZSh7XG4gICAgICAgICAgICAgIG1hcHBpbmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3RfYmxvY2tfbWFwcGluZ19zaW1wbGVfdmFsdWUoKSB7XG4gICAgICAgIHRoaXMud3JpdGVfaW5kaWNhdG9yKCc6JywgZmFsc2UpO1xuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHRoaXMuZXhwZWN0X2Jsb2NrX21hcHBpbmdfa2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0X25vZGUoe1xuICAgICAgICAgIG1hcHBpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdF9ibG9ja19tYXBwaW5nX3ZhbHVlKCkge1xuICAgICAgICB0aGlzLndyaXRlX2luZGVudCgpO1xuICAgICAgICB0aGlzLndyaXRlX2luZGljYXRvcignOicsIHRydWUsIHtcbiAgICAgICAgICBpbmRlbnRhdGlvbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCh0aGlzLmV4cGVjdF9ibG9ja19tYXBwaW5nX2tleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGVjdF9ub2RlKHtcbiAgICAgICAgICBtYXBwaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVja2Vyc1xuICAgICAgY2hlY2tfZW1wdHlfZG9jdW1lbnQoKSB7XG4gICAgICAgIHZhciBldmVudDtcbiAgICAgICAgaWYgKCEodGhpcy5ldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5Eb2N1bWVudFN0YXJ0RXZlbnQpIHx8IHRoaXMuZXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudCA9IHRoaXMuZXZlbnRzWzBdO1xuICAgICAgICByZXR1cm4gZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuU2NhbGFyRXZlbnQgJiYgKGV2ZW50LmFuY2hvciA9PSBudWxsKSAmJiAoZXZlbnQudGFnID09IG51bGwpICYmIGV2ZW50LmltcGxpY2l0ICYmIGV2ZW50LnZhbHVlID09PSAnJztcbiAgICAgIH1cblxuICAgICAgY2hlY2tfZW1wdHlfc2VxdWVuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50IGluc3RhbmNlb2YgZXZlbnRzLlNlcXVlbmNlU3RhcnRFdmVudCAmJiB0aGlzLmV2ZW50c1swXSBpbnN0YW5jZW9mIGV2ZW50cy5TZXF1ZW5jZUVuZEV2ZW50O1xuICAgICAgfVxuXG4gICAgICBjaGVja19lbXB0eV9tYXBwaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudCBpbnN0YW5jZW9mIGV2ZW50cy5NYXBwaW5nU3RhcnRFdmVudCAmJiB0aGlzLmV2ZW50c1swXSBpbnN0YW5jZW9mIGV2ZW50cy5NYXBwaW5nRW5kRXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrX3NpbXBsZV9rZXkoKSB7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50IGluc3RhbmNlb2YgZXZlbnRzLk5vZGVFdmVudCAmJiAodGhpcy5ldmVudC5hbmNob3IgIT0gbnVsbCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5wcmVwYXJlZF9hbmNob3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlZF9hbmNob3IgPSB0aGlzLnByZXBhcmVfYW5jaG9yKHRoaXMuZXZlbnQuYW5jaG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoICs9IHRoaXMucHJlcGFyZWRfYW5jaG9yLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuZXZlbnQudGFnICE9IG51bGwpICYmICh0aGlzLmV2ZW50IGluc3RhbmNlb2YgZXZlbnRzLlNjYWxhckV2ZW50IHx8IHRoaXMuZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuQ29sbGVjdGlvblN0YXJ0RXZlbnQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJlcGFyZWRfdGFnID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZWRfdGFnID0gdGhpcy5wcmVwYXJlX3RhZyh0aGlzLmV2ZW50LnRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCArPSB0aGlzLnByZXBhcmVkX3RhZy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuU2NhbGFyRXZlbnQpIHtcbiAgICAgICAgICBpZiAodGhpcy5hbmFseXNpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFuYWx5c2lzID0gdGhpcy5hbmFseXplX3NjYWxhcih0aGlzLmV2ZW50LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoICs9IHRoaXMuYW5hbHlzaXMuc2NhbGFyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoIDwgMTI4ICYmICh0aGlzLmV2ZW50IGluc3RhbmNlb2YgZXZlbnRzLkFsaWFzRXZlbnQgfHwgKHRoaXMuZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuU2NhbGFyRXZlbnQgJiYgIXRoaXMuYW5hbHlzaXMuZW1wdHkgJiYgIXRoaXMuYW5hbHlzaXMubXVsdGlsaW5lKSB8fCB0aGlzLmNoZWNrX2VtcHR5X3NlcXVlbmNlKCkgfHwgdGhpcy5jaGVja19lbXB0eV9tYXBwaW5nKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBBbmNob3IsIFRhZyBhbmQgU2NhbGFyIHByb2Nlc3NvcnNcbiAgICAgIHByb2Nlc3NfYW5jaG9yKGluZGljYXRvcikge1xuICAgICAgICBpZiAodGhpcy5ldmVudC5hbmNob3IgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucHJlcGFyZWRfYW5jaG9yID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJlcGFyZWRfYW5jaG9yID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnByZXBhcmVkX2FuY2hvciA9IHRoaXMucHJlcGFyZV9hbmNob3IodGhpcy5ldmVudC5hbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXBhcmVkX2FuY2hvcikge1xuICAgICAgICAgIHRoaXMud3JpdGVfaW5kaWNhdG9yKGAke2luZGljYXRvcn0ke3RoaXMucHJlcGFyZWRfYW5jaG9yfWAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByZXBhcmVkX2FuY2hvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3NfdGFnKCkge1xuICAgICAgICB2YXIgdGFnO1xuICAgICAgICB0YWcgPSB0aGlzLmV2ZW50LnRhZztcbiAgICAgICAgaWYgKHRoaXMuZXZlbnQgaW5zdGFuY2VvZiBldmVudHMuU2NhbGFyRXZlbnQpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5jaG9vc2Vfc2NhbGFyX3N0eWxlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoIXRoaXMuY2Fub25pY2FsIHx8ICh0YWcgPT0gbnVsbCkpICYmICgodGhpcy5zdHlsZSA9PT0gJycgJiYgdGhpcy5ldmVudC5pbXBsaWNpdFswXSkgfHwgKHRoaXMuc3R5bGUgIT09ICcnICYmIHRoaXMuZXZlbnQuaW1wbGljaXRbMV0pKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlZF90YWcgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5ldmVudC5pbXBsaWNpdFswXSAmJiAodGFnID09IG51bGwpKSB7XG4gICAgICAgICAgICB0YWcgPSAnISc7XG4gICAgICAgICAgICB0aGlzLnByZXBhcmVkX3RhZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCghdGhpcy5jYW5vbmljYWwgfHwgKHRhZyA9PSBudWxsKSkgJiYgdGhpcy5ldmVudC5pbXBsaWNpdCkge1xuICAgICAgICAgIHRoaXMucHJlcGFyZWRfdGFnID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcigndGFnIGlzIG5vdCBzcGVjaWZpZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmVwYXJlZF90YWcgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucHJlcGFyZWRfdGFnID0gdGhpcy5wcmVwYXJlX3RhZyh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVfaW5kaWNhdG9yKHRoaXMucHJlcGFyZWRfdGFnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZWRfdGFnID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzc19zY2FsYXIoKSB7XG4gICAgICAgIHZhciBzcGxpdDtcbiAgICAgICAgaWYgKHRoaXMuYW5hbHlzaXMgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuYW5hbHlzaXMgPSB0aGlzLmFuYWx5emVfc2NhbGFyKHRoaXMuZXZlbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0eWxlID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5jaG9vc2Vfc2NhbGFyX3N0eWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3BsaXQgPSAhdGhpcy5zaW1wbGVfa2V5X2NvbnRleHQ7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdHlsZSkge1xuICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHRoaXMud3JpdGVfZG91YmxlX3F1b3RlZCh0aGlzLmFuYWx5c2lzLnNjYWxhciwgc3BsaXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHRoaXMud3JpdGVfc2luZ2xlX3F1b3RlZCh0aGlzLmFuYWx5c2lzLnNjYWxhciwgc3BsaXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICB0aGlzLndyaXRlX2ZvbGRlZCh0aGlzLmFuYWx5c2lzLnNjYWxhcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICAgIHRoaXMud3JpdGVfbGl0ZXJhbCh0aGlzLmFuYWx5c2lzLnNjYWxhcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy53cml0ZV9wbGFpbih0aGlzLmFuYWx5c2lzLnNjYWxhciwgc3BsaXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5hbHlzaXMgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNob29zZV9zY2FsYXJfc3R5bGUoKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGlmICh0aGlzLmFuYWx5c2lzID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmFuYWx5c2lzID0gdGhpcy5hbmFseXplX3NjYWxhcih0aGlzLmV2ZW50LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ldmVudC5zdHlsZSA9PT0gJ1wiJyB8fCB0aGlzLmNhbm9uaWNhbCkge1xuICAgICAgICAgIHJldHVybiAnXCInO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ldmVudC5zdHlsZSAmJiB0aGlzLmV2ZW50LmltcGxpY2l0WzBdICYmICEodGhpcy5zaW1wbGVfa2V5X2NvbnRleHQgJiYgKHRoaXMuYW5hbHlzaXMuZW1wdHkgfHwgdGhpcy5hbmFseXNpcy5tdWx0aWxpbmUpKSAmJiAoKHRoaXMuZmxvd19sZXZlbCAmJiB0aGlzLmFuYWx5c2lzLmFsbG93X2Zsb3dfcGxhaW4pIHx8ICghdGhpcy5mbG93X2xldmVsICYmIHRoaXMuYW5hbHlzaXMuYWxsb3dfYmxvY2tfcGxhaW4pKSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ldmVudC5zdHlsZSAmJiAocmVmID0gdGhpcy5ldmVudC5zdHlsZSwgaW5kZXhPZi5jYWxsKCd8PicsIHJlZikgPj0gMCkgJiYgIXRoaXMuZmxvd19sZXZlbCAmJiAhdGhpcy5zaW1wbGVfa2V5X2NvbnRleHQgJiYgdGhpcy5hbmFseXNpcy5hbGxvd19ibG9jaykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50LnN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXRoaXMuZXZlbnQuc3R5bGUgfHwgdGhpcy5ldmVudC5zdHlsZSA9PT0gXCInXCIpICYmIHRoaXMuYW5hbHlzaXMuYWxsb3dfc2luZ2xlX3F1b3RlZCAmJiAhKHRoaXMuc2ltcGxlX2tleV9jb250ZXh0ICYmIHRoaXMuYW5hbHlzaXMubXVsdGlsaW5lKSkge1xuICAgICAgICAgIHJldHVybiBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1wiJztcbiAgICAgIH1cblxuICAgICAgLy8gQW5hbHl6ZXJzXG4gICAgICBwcmVwYXJlX3ZlcnNpb24oW21ham9yLCBtaW5vcl0pIHtcbiAgICAgICAgdmFyIHZlcnNpb247XG4gICAgICAgIHZlcnNpb24gPSBgJHttYWpvcn0uJHttaW5vcn1gO1xuICAgICAgICBpZiAobWFqb3IgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcigndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uJywgdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJlcGFyZV90YWdfaGFuZGxlKGhhbmRsZSkge1xuICAgICAgICB2YXIgY2hhciwgaSwgbGVuLCByZWY7XG4gICAgICAgIGlmICghaGFuZGxlKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcigndGFnIGhhbmRsZSBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVbMF0gIT09ICchJyB8fCBoYW5kbGUuc2xpY2UoLTEpICE9PSAnIScpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKFwidGFnIGhhbmRsZSBtdXN0IHN0YXJ0IGFuZCBlbmQgd2l0aCAnISc6XCIsIGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gaGFuZGxlLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hhciA9IHJlZltpXTtcbiAgICAgICAgICBpZiAoISgoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnOScpIHx8ICgnQScgPD0gY2hhciAmJiBjaGFyIDw9ICdaJykgfHwgKCdhJyA8PSBjaGFyICYmIGNoYXIgPD0gJ3onKSB8fCBpbmRleE9mLmNhbGwoJy1fJywgY2hhcikgPj0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoYGludmFsaWQgY2hhcmFjdGVyICcke2NoYXJ9JyBpbiB0aGUgdGFnIGhhbmRsZTpgLCBoYW5kbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgfVxuXG4gICAgICBwcmVwYXJlX3RhZ19wcmVmaXgocHJlZml4KSB7XG4gICAgICAgIHZhciBjaGFyLCBjaHVua3MsIGVuZCwgc3RhcnQ7XG4gICAgICAgIGlmICghcHJlZml4KSB7XG4gICAgICAgICAgdGhpcy5lcnJvcigndGFnIHByZWZpeCBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9ICsocHJlZml4WzBdID09PSAnIScpO1xuICAgICAgICB3aGlsZSAoZW5kIDwgcHJlZml4Lmxlbmd0aCkge1xuICAgICAgICAgIGNoYXIgPSBwcmVmaXhbZW5kXTtcbiAgICAgICAgICBpZiAoKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknKSB8fCAoJ0EnIDw9IGNoYXIgJiYgY2hhciA8PSAnWicpIHx8ICgnYScgPD0gY2hhciAmJiBjaGFyIDw9ICd6JykgfHwgaW5kZXhPZi5jYWxsKCctOy8/ITpAJj0rJCxfLn4qXFwnKClbXScsIGNoYXIpID49IDApIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2gocHJlZml4LnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kID0gZW5kICsgMTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICBjaHVua3MucHVzaChwcmVmaXguc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVua3Muam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIHByZXBhcmVfdGFnKHRhZykge1xuICAgICAgICB2YXIgY2hhciwgY2h1bmtzLCBlbmQsIGhhbmRsZSwgaSwgaywgbGVuLCBwcmVmaXgsIHJlZiwgc3RhcnQsIHN1ZmZpeCwgc3VmZml4X3RleHQ7XG4gICAgICAgIGlmICghdGFnKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcigndGFnIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gJyEnKSB7XG4gICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGUgPSBudWxsO1xuICAgICAgICBzdWZmaXggPSB0YWc7XG4gICAgICAgIHJlZiA9ICgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICByZWYgPSB0aGlzLnRhZ19wcmVmaXhlcztcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChrIGluIHJlZikge1xuICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrKSkgY29udGludWU7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpKS5zb3J0KCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHByZWZpeCA9IHJlZltpXTtcbiAgICAgICAgICBpZiAodGFnLmluZGV4T2YocHJlZml4KSA9PT0gMCAmJiAocHJlZml4ID09PSAnIScgfHwgcHJlZml4Lmxlbmd0aCA8IHRhZy5sZW5ndGgpKSB7XG4gICAgICAgICAgICBoYW5kbGUgPSB0aGlzLnRhZ19wcmVmaXhlc1twcmVmaXhdO1xuICAgICAgICAgICAgc3VmZml4ID0gdGFnLnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaHVua3MgPSBbXTtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAwO1xuICAgICAgICB3aGlsZSAoZW5kIDwgc3VmZml4Lmxlbmd0aCkge1xuICAgICAgICAgIGNoYXIgPSBzdWZmaXhbZW5kXTtcbiAgICAgICAgICBpZiAoKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknKSB8fCAoJ0EnIDw9IGNoYXIgJiYgY2hhciA8PSAnWicpIHx8ICgnYScgPD0gY2hhciAmJiBjaGFyIDw9ICd6JykgfHwgaW5kZXhPZi5jYWxsKCctOy8/ITpAJj0rJCxfLn4qXFwnKClbXScsIGNoYXIpID49IDAgfHwgKGNoYXIgPT09ICchJyAmJiBoYW5kbGUgIT09ICchJykpIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2goc3VmZml4LnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kID0gZW5kICsgMTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICBjaHVua3MucHVzaChzdWZmaXguc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHN1ZmZpeF90ZXh0ID0gY2h1bmtzLmpvaW4oJycpO1xuICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2hhbmRsZX0ke3N1ZmZpeF90ZXh0fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGAhPCR7c3VmZml4X3RleHR9PmA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJlcGFyZV9hbmNob3IoYW5jaG9yKSB7XG4gICAgICAgIHZhciBjaGFyLCBpLCBsZW47XG4gICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcignYW5jaG9yIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYW5jaG9yLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hhciA9IGFuY2hvcltpXTtcbiAgICAgICAgICBpZiAoISgoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnOScpIHx8ICgnQScgPD0gY2hhciAmJiBjaGFyIDw9ICdaJykgfHwgKCdhJyA8PSBjaGFyICYmIGNoYXIgPD0gJ3onKSB8fCBpbmRleE9mLmNhbGwoJy1fJywgY2hhcikgPj0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoYGludmFsaWQgY2hhcmFjdGVyICcke2NoYXJ9JyBpbiB0aGUgYW5jaG9yOmAsIGFuY2hvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmNob3I7XG4gICAgICB9XG5cbiAgICAgIGFuYWx5emVfc2NhbGFyKHNjYWxhcikge1xuICAgICAgICB2YXIgYWxsb3dfYmxvY2ssIGFsbG93X2Jsb2NrX3BsYWluLCBhbGxvd19kb3VibGVfcXVvdGVkLCBhbGxvd19mbG93X3BsYWluLCBhbGxvd19zaW5nbGVfcXVvdGVkLCBibG9ja19pbmRpY2F0b3JzLCBicmVha19zcGFjZSwgY2hhciwgZmxvd19pbmRpY2F0b3JzLCBmb2xsb3dlZF9ieV93aGl0ZXNwYWNlLCBpLCBpbmRleCwgbGVhZGluZ19icmVhaywgbGVhZGluZ19zcGFjZSwgbGVuLCBsaW5lX2JyZWFrcywgcHJlY2VkZWRfYnlfd2hpdGVzcGFjZSwgcHJldmlvdXNfYnJlYWssIHByZXZpb3VzX3NwYWNlLCByZWYsIHJlZjEsIHNwYWNlX2JyZWFrLCBzcGVjaWFsX2NoYXJhY3RlcnMsIHRyYWlsaW5nX2JyZWFrLCB0cmFpbGluZ19zcGFjZSwgdW5pY29kZV9jaGFyYWN0ZXJzO1xuICAgICAgICAvLyBFbXB0eSBzY2FsYXIgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgICAgIGlmICghc2NhbGFyKSB7XG4gICAgICAgICAgbmV3IFNjYWxhckFuYWx5c2lzKHNjYWxhciwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCB0cnVlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5kaWNhdG9ycyBhbmQgc3BlY2lhbCBjaGFyYWN0ZXJzLlxuICAgICAgICBibG9ja19pbmRpY2F0b3JzID0gZmFsc2U7XG4gICAgICAgIGZsb3dfaW5kaWNhdG9ycyA9IGZhbHNlO1xuICAgICAgICBsaW5lX2JyZWFrcyA9IGZhbHNlO1xuICAgICAgICBzcGVjaWFsX2NoYXJhY3RlcnMgPSBmYWxzZTtcbiAgICAgICAgdW5pY29kZV9jaGFyYWN0ZXJzID0gZmFsc2U7XG4gICAgICAgIC8vIEltcG9ydGFudCB3aGl0ZXNwYWNlIGNvbWJpbmF0aW9uc1xuICAgICAgICBsZWFkaW5nX3NwYWNlID0gZmFsc2U7XG4gICAgICAgIGxlYWRpbmdfYnJlYWsgPSBmYWxzZTtcbiAgICAgICAgdHJhaWxpbmdfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgdHJhaWxpbmdfYnJlYWsgPSBmYWxzZTtcbiAgICAgICAgYnJlYWtfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgc3BhY2VfYnJlYWsgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2hlY2sgZG9jdW1lbnQgaW5kaWNhdG9ycy5cbiAgICAgICAgaWYgKHNjYWxhci5pbmRleE9mKCctLS0nKSA9PT0gMCB8fCBzY2FsYXIuaW5kZXhPZignLi4uJykgPT09IDApIHtcbiAgICAgICAgICBibG9ja19pbmRpY2F0b3JzID0gdHJ1ZTtcbiAgICAgICAgICBmbG93X2luZGljYXRvcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0IGNoYXJhY3RlciBvciBwcmVjZWRlZCBieSBhIHdoaXRlc3BhY2UuXG4gICAgICAgIHByZWNlZGVkX2J5X3doaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgICAvLyBMYXN0IGNoYXJhY3RlciBvciBmb2xsb3dlZCBieSBhIHdoaXRlc3BhY2UuXG4gICAgICAgIGZvbGxvd2VkX2J5X3doaXRlc3BhY2UgPSBzY2FsYXIubGVuZ3RoID09PSAxIHx8IChyZWYgPSBzY2FsYXJbMV0sIGluZGV4T2YuY2FsbCgnXFwwIFxcdFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLCByZWYpID49IDApO1xuICAgICAgICAvLyBUaGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzIGEgc3BhY2UuXG4gICAgICAgIHByZXZpb3VzX3NwYWNlID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXMgYSBicmVha1xuICAgICAgICBwcmV2aW91c19icmVhayA9IGZhbHNlO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGZvciAoaW5kZXggPSBpID0gMCwgbGVuID0gc2NhbGFyLmxlbmd0aDsgaSA8IGxlbjsgaW5kZXggPSArK2kpIHtcbiAgICAgICAgICBjaGFyID0gc2NhbGFyW2luZGV4XTtcbiAgICAgICAgICAvLyBDaGVjayBmb3IgaW5kaWNhdG9ycy5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIC8vIExlYWRpbmcgaW5kaWNhdG9ycyBhcmUgc3BlY2lhbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgaWYgKGluZGV4T2YuY2FsbCgnIyxbXXt9JiohfD5cXCdcIiVAYCcsIGNoYXIpID49IDAgfHwgKGNoYXIgPT09ICctJyAmJiBmb2xsb3dlZF9ieV93aGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICBmbG93X2luZGljYXRvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICBibG9ja19pbmRpY2F0b3JzID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXhPZi5jYWxsKCc/OicsIGNoYXIpID49IDApIHtcbiAgICAgICAgICAgICAgZmxvd19pbmRpY2F0b3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGZvbGxvd2VkX2J5X3doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBibG9ja19pbmRpY2F0b3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTb21lIGluZGljYXRvcnMgY2Fubm90IGFwcGVhciB3aXRoaW4gYSBzY2FsYXIgYXMgd2VsbC5cbiAgICAgICAgICAgIGlmIChpbmRleE9mLmNhbGwoJyw/W117fScsIGNoYXIpID49IDApIHtcbiAgICAgICAgICAgICAgZmxvd19pbmRpY2F0b3JzID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJzonKSB7XG4gICAgICAgICAgICAgIGZsb3dfaW5kaWNhdG9ycyA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChmb2xsb3dlZF9ieV93aGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tfaW5kaWNhdG9ycyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJyMnICYmIHByZWNlZGVkX2J5X3doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgZmxvd19pbmRpY2F0b3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYmxvY2tfaW5kaWNhdG9ycyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENoZWNrIGZvciBsaW5lIGJyZWFrcywgc3BlY2lhbCwgYW5kIHVuaWNvZGUgY2hhcmFjdGVycy5cbiAgICAgICAgICBpZiAoaW5kZXhPZi5jYWxsKCdcXG5cXHg4NVxcdTIwMjhcXHUyMDI5JywgY2hhcikgPj0gMCkge1xuICAgICAgICAgICAgbGluZV9icmVha3MgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShjaGFyID09PSAnXFxuJyB8fCAoJ1xceDIwJyA8PSBjaGFyICYmIGNoYXIgPD0gJ1xceDdlJykpKSB7XG4gICAgICAgICAgICBpZiAoY2hhciAhPT0gJ1xcdUZFRkYnICYmIChjaGFyID09PSAnXFx4ODUnIHx8ICgnXFx4QTAnIDw9IGNoYXIgJiYgY2hhciA8PSAnXFx1RDdGRicpIHx8ICgnXFx1RTAwMCcgPD0gY2hhciAmJiBjaGFyIDw9ICdcXHVGRkZEJykpKSB7XG4gICAgICAgICAgICAgIHVuaWNvZGVfY2hhcmFjdGVycyA9IHRydWU7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd191bmljb2RlKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbF9jaGFyYWN0ZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3BlY2lhbF9jaGFyYWN0ZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRGV0ZWN0IGltcG9ydGFudCB3aGl0ZXNwYWNlIGNvbWJpbmF0aW9ucy5cbiAgICAgICAgICBpZiAoY2hhciA9PT0gJyAnKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgbGVhZGluZ19zcGFjZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHNjYWxhci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIHRyYWlsaW5nX3NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91c19icmVhaykge1xuICAgICAgICAgICAgICBicmVha19zcGFjZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91c19icmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgcHJldmlvdXNfc3BhY2UgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXhPZi5jYWxsKCdcXG5cXHg4NVxcdTIwMjhcXHUyMDI5JywgY2hhcikgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgIGxlYWRpbmdfYnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBzY2FsYXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICB0cmFpbGluZ19icmVhayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldmlvdXNfc3BhY2UpIHtcbiAgICAgICAgICAgICAgc3BhY2VfYnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXNfYnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgcHJldmlvdXNfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNfYnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgIHByZXZpb3VzX3NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFByZXBhcmUgZm9yIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgICAgICBwcmVjZWRlZF9ieV93aGl0ZXNwYWNlID0gaW5kZXhPZi5jYWxsKENfV0hJVEVTUEFDRSwgY2hhcikgPj0gMDtcbiAgICAgICAgICBmb2xsb3dlZF9ieV93aGl0ZXNwYWNlID0gaW5kZXggKyAyID49IHNjYWxhci5sZW5ndGggfHwgKHJlZjEgPSBzY2FsYXJbaW5kZXggKyAyXSwgaW5kZXhPZi5jYWxsKENfV0hJVEVTUEFDRSwgcmVmMSkgPj0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGV0J3MgZGVjaWRlIHdoYXQgc3R5bGVzIGFyZSBhbGxvd2VkLlxuICAgICAgICBhbGxvd19mbG93X3BsYWluID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dfYmxvY2tfcGxhaW4gPSB0cnVlO1xuICAgICAgICBhbGxvd19zaW5nbGVfcXVvdGVkID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dfZG91YmxlX3F1b3RlZCA9IHRydWU7XG4gICAgICAgIGFsbG93X2Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgLy8gTGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZXMgYXJlIGJhZCBmb3IgcGxhaW4gc2NhbGFycy5cbiAgICAgICAgaWYgKGxlYWRpbmdfc3BhY2UgfHwgbGVhZGluZ19icmVhayB8fCB0cmFpbGluZ19zcGFjZSB8fCB0cmFpbGluZ19icmVhaykge1xuICAgICAgICAgIGFsbG93X2Zsb3dfcGxhaW4gPSBhbGxvd19ibG9ja19wbGFpbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvIG5vdCBwZXJtaXQgdHJhaWxpbmcgc3BhY2VzIGZvciBibG9jayBzY2FsYXJzLlxuICAgICAgICBpZiAodHJhaWxpbmdfc3BhY2UpIHtcbiAgICAgICAgICBhbGxvd19ibG9jayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwYWNlcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbmV3IGxpbmUgYXJlIG9ubHkgYWNjZXB0YWJsZSBmb3IgYmxvY2sgc2NhbGFycy5cbiAgICAgICAgaWYgKGJyZWFrX3NwYWNlKSB7XG4gICAgICAgICAgYWxsb3dfZmxvd19wbGFpbiA9IGFsbG93X2Jsb2NrX3BsYWluID0gYWxsb3dfc2luZ2xlX3F1b3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwYWNlcyBmb2xsb3dlZCBieSBicmVha3MsIGFzIHdlbGwgYXMgc3BlY2lhbCBjaGFyYWN0ZXIgYXJlIG9ubHkgYWxsb3dlZCBmb3IgZG91YmxlIHF1b3RlZFxuICAgICAgICAvLyBzY2FsYXJzLlxuICAgICAgICBpZiAoc3BhY2VfYnJlYWsgfHwgc3BlY2lhbF9jaGFyYWN0ZXJzKSB7XG4gICAgICAgICAgYWxsb3dfZmxvd19wbGFpbiA9IGFsbG93X2Jsb2NrX3BsYWluID0gYWxsb3dfc2luZ2xlX3F1b3RlZCA9IGFsbG93X2Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWx0aG91Z2ggdGhlIHBsYWluIHNjYWxhciB3cml0ZXIgc3VwcG9ydHMgYnJlYWtzLCB3ZSBuZXZlciBlbWl0IG11bHRpbGluZSBwbGFpbiBzY2FsYXJzLlxuICAgICAgICBpZiAobGluZV9icmVha3MpIHtcbiAgICAgICAgICBhbGxvd19mbG93X3BsYWluID0gYWxsb3dfYmxvY2tfcGxhaW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbG93IGluZGljYXRvcnMgYXJlIGZvcmJpZGRlbiBmb3IgZmxvdyBwbGFpbiBzY2FsYXJzLlxuICAgICAgICBpZiAoZmxvd19pbmRpY2F0b3JzKSB7XG4gICAgICAgICAgYWxsb3dfZmxvd19wbGFpbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJsb2NrIGluZGljYXRvcnMgYXJlIGZvcmJpZGRlbiBmb3IgYmxvY2sgcGxhaW4gc2NhbGFycy5cbiAgICAgICAgaWYgKGJsb2NrX2luZGljYXRvcnMpIHtcbiAgICAgICAgICBhbGxvd19ibG9ja19wbGFpbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2NhbGFyQW5hbHlzaXMoc2NhbGFyLCBmYWxzZSwgbGluZV9icmVha3MsIGFsbG93X2Zsb3dfcGxhaW4sIGFsbG93X2Jsb2NrX3BsYWluLCBhbGxvd19zaW5nbGVfcXVvdGVkLCBhbGxvd19kb3VibGVfcXVvdGVkLCBhbGxvd19ibG9jayk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdyaXRlcnNcbiAgICAgIC8qXG4gICAgICBXcml0ZSBCT00gaWYgbmVlZGVkLlxuICAgICAgKi9cbiAgICAgIHdyaXRlX3N0cmVhbV9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5jb2RpbmcgJiYgdGhpcy5lbmNvZGluZy5pbmRleE9mKCd1dGYtMTYnKSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSgnXFx1RkVGRicsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdyaXRlX3N0cmVhbV9lbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsdXNoX3N0cmVhbSgpO1xuICAgICAgfVxuXG4gICAgICB3cml0ZV9pbmRpY2F0b3IoaW5kaWNhdG9yLCBuZWVkX3doaXRlc3BhY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgZGF0YSA9IHRoaXMud2hpdGVzcGFjZSB8fCAhbmVlZF93aGl0ZXNwYWNlID8gaW5kaWNhdG9yIDogJyAnICsgaW5kaWNhdG9yO1xuICAgICAgICB0aGlzLndoaXRlc3BhY2UgPSAhIW9wdGlvbnMud2hpdGVzcGFjZTtcbiAgICAgICAgdGhpcy5pbmRlbnRhdGlvbiAmJiAodGhpcy5pbmRlbnRhdGlvbiA9ICEhb3B0aW9ucy5pbmRlbnRhdGlvbik7XG4gICAgICAgIHRoaXMuY29sdW1uICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLm9wZW5fZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKGRhdGEsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgfVxuXG4gICAgICB3cml0ZV9pbmRlbnQoKSB7XG4gICAgICAgIHZhciBkYXRhLCBpbmRlbnQsIHJlZjtcbiAgICAgICAgaW5kZW50ID0gKHJlZiA9IHRoaXMuaW5kZW50KSAhPSBudWxsID8gcmVmIDogMDtcbiAgICAgICAgaWYgKCF0aGlzLmluZGVudGF0aW9uIHx8IHRoaXMuY29sdW1uID4gaW5kZW50IHx8ICh0aGlzLmNvbHVtbiA9PT0gaW5kZW50ICYmICF0aGlzLndoaXRlc3BhY2UpKSB7XG4gICAgICAgICAgdGhpcy53cml0ZV9saW5lX2JyZWFrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uIDwgaW5kZW50KSB7XG4gICAgICAgICAgdGhpcy53aGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICBkYXRhID0gbmV3IEFycmF5KGluZGVudCAtIHRoaXMuY29sdW1uICsgMSkuam9pbignICcpO1xuICAgICAgICAgIHRoaXMuY29sdW1uID0gaW5kZW50O1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShkYXRhLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3cml0ZV9saW5lX2JyZWFrKGRhdGEpIHtcbiAgICAgICAgdGhpcy53aGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmRlbnRhdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMubGluZSArPSAxO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShkYXRhICE9IG51bGwgPyBkYXRhIDogdGhpcy5iZXN0X2xpbmVfYnJlYWssIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgfVxuXG4gICAgICB3cml0ZV92ZXJzaW9uX2RpcmVjdGl2ZSh2ZXJzaW9uX3RleHQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoYCVZQU1MICR7dmVyc2lvbl90ZXh0fWAsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZV9saW5lX2JyZWFrKCk7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlX3RhZ19kaXJlY3RpdmUoaGFuZGxlX3RleHQsIHByZWZpeF90ZXh0KSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKGAlVEFHICR7aGFuZGxlX3RleHR9ICR7cHJlZml4X3RleHR9YCwgdGhpcy5lbmNvZGluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlX2xpbmVfYnJlYWsoKTtcbiAgICAgIH1cblxuICAgICAgd3JpdGVfc2luZ2xlX3F1b3RlZCh0ZXh0LCBzcGxpdCA9IHRydWUpIHtcbiAgICAgICAgdmFyIGJyLCBicmVha3MsIGNoYXIsIGRhdGEsIGVuZCwgaSwgbGVuLCByZWYsIHNwYWNlcywgc3RhcnQ7XG4gICAgICAgIHRoaXMud3JpdGVfaW5kaWNhdG9yKFwiJ1wiLCB0cnVlKTtcbiAgICAgICAgc3BhY2VzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrcyA9IGZhbHNlO1xuICAgICAgICBzdGFydCA9IGVuZCA9IDA7XG4gICAgICAgIHdoaWxlIChlbmQgPD0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICBjaGFyID0gdGV4dFtlbmRdO1xuICAgICAgICAgIGlmIChzcGFjZXMpIHtcbiAgICAgICAgICAgIGlmICgoY2hhciA9PSBudWxsKSB8fCBjaGFyICE9PSAnICcpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgMSA9PT0gZW5kICYmIHRoaXMuY29sdW1uID4gdGhpcy5iZXN0X3dpZHRoICYmIHNwbGl0ICYmIHN0YXJ0ICE9PSAwICYmIGVuZCAhPT0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlX2luZGVudCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKGRhdGEsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYnJlYWtzKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXIgPT0gbnVsbCkgfHwgaW5kZXhPZi5jYWxsKCdcXG5cXHg4NVxcdTIwMjhcXHUyMDI5JywgY2hhcikgPCAwKSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0W3N0YXJ0XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlX2xpbmVfYnJlYWsoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWYgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiciA9IHJlZltpXTtcbiAgICAgICAgICAgICAgICBpZiAoYnIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLndyaXRlX2xpbmVfYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZV9saW5lX2JyZWFrKGJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICgoKGNoYXIgPT0gbnVsbCkgfHwgaW5kZXhPZi5jYWxsKCcgXFxuXFx4ODVcXHUyMDI4XFx1MjAyOScsIGNoYXIpID49IDAgfHwgY2hhciA9PT0gXCInXCIpICYmIHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICBkYXRhID0gdGV4dC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoZGF0YSwgdGhpcy5lbmNvZGluZyk7XG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbiArPSAyO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoXCInJ1wiLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3BhY2VzID0gY2hhciA9PT0gJyAnO1xuICAgICAgICAgICAgYnJlYWtzID0gaW5kZXhPZi5jYWxsKCdcXG5cXHg4NVxcdTIwMjhcXHUyMDI5JywgY2hhcikgPj0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVfaW5kaWNhdG9yKFwiJ1wiLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlX2RvdWJsZV9xdW90ZWQodGV4dCwgc3BsaXQgPSB0cnVlKSB7XG4gICAgICAgIHZhciBjaGFyLCBkYXRhLCBlbmQsIHN0YXJ0O1xuICAgICAgICB0aGlzLndyaXRlX2luZGljYXRvcignXCInLCB0cnVlKTtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAwO1xuICAgICAgICB3aGlsZSAoZW5kIDw9IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgY2hhciA9IHRleHRbZW5kXTtcbiAgICAgICAgICBpZiAoKGNoYXIgPT0gbnVsbCkgfHwgaW5kZXhPZi5jYWxsKCdcIlxcXFxcXHg4NVxcdTIwMjhcXHUyMDI5XFx1RkVGRicsIGNoYXIpID49IDAgfHwgISgoJ1xceDIwJyA8PSBjaGFyICYmIGNoYXIgPD0gJ1xceDdFJykgfHwgKHRoaXMuYWxsb3dfdW5pY29kZSAmJiAoKCdcXHhBMCcgPD0gY2hhciAmJiBjaGFyIDw9ICdcXHVEN0ZGJykgfHwgKCdcXHVFMDAwJyA8PSBjaGFyICYmIGNoYXIgPD0gJ1xcdUZGRkQnKSkpKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoZGF0YSwgdGhpcy5lbmNvZGluZyk7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBkYXRhID0gY2hhciBpbiBFU0NBUEVfUkVQTEFDRU1FTlRTID8gJ1xcXFwnICsgRVNDQVBFX1JFUExBQ0VNRU5UU1tjaGFyXSA6IGNoYXIgPD0gJ1xceEZGJyA/IGBcXFxceCR7dXRpbC5wYWRfbGVmdCh1dGlsLnRvX2hleChjaGFyKSwgJzAnLCAyKX1gIDogY2hhciA8PSAnXFx1RkZGRicgPyBgXFxcXHUke3V0aWwucGFkX2xlZnQodXRpbC50b19oZXgoY2hhciksICcwJywgNCl9YCA6IGBcXFxcVSR7dXRpbC5wYWRfbGVmdCh1dGlsLnRvX2hleChjaGFyKSwgJzAnLCAxNil9YDtcbiAgICAgICAgICAgICAgdGhpcy5jb2x1bW4gKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKGRhdGEsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICAgICAgICBzdGFydCA9IGVuZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcGxpdCAmJiAoMCA8IGVuZCAmJiBlbmQgPCB0ZXh0Lmxlbmd0aCAtIDEpICYmIChjaGFyID09PSAnICcgfHwgc3RhcnQgPj0gZW5kKSAmJiB0aGlzLmNvbHVtbiArIChlbmQgLSBzdGFydCkgPiB0aGlzLmJlc3Rfd2lkdGgpIHtcbiAgICAgICAgICAgIGRhdGEgPSBgJHt0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpfVxcXFxgO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2x1bW4gKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS53cml0ZShkYXRhLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVfaW5kZW50KCk7XG4gICAgICAgICAgICB0aGlzLndoaXRlc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0ZXh0W3N0YXJ0XSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSAnXFxcXCc7XG4gICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICB0aGlzLnN0cmVhbS53cml0ZShkYXRhLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVfaW5kaWNhdG9yKCdcIicsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgd3JpdGVfZm9sZGVkKHRleHQpIHtcbiAgICAgICAgdmFyIGJyLCBicmVha3MsIGNoYXIsIGRhdGEsIGVuZCwgaGludHMsIGksIGxlYWRpbmdfc3BhY2UsIGxlbiwgcmVmLCByZXN1bHRzLCBzcGFjZXMsIHN0YXJ0O1xuICAgICAgICBoaW50cyA9IHRoaXMuZGV0ZXJtaW5lX2Jsb2NrX2hpbnRzKHRleHQpO1xuICAgICAgICB0aGlzLndyaXRlX2luZGljYXRvcihgPiR7aGludHN9YCwgdHJ1ZSk7XG4gICAgICAgIGlmIChoaW50cy5zbGljZSgtMSkgPT09ICcrJykge1xuICAgICAgICAgIHRoaXMub3Blbl9lbmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZV9saW5lX2JyZWFrKCk7XG4gICAgICAgIGxlYWRpbmdfc3BhY2UgPSB0cnVlO1xuICAgICAgICBicmVha3MgPSB0cnVlO1xuICAgICAgICBzcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAwO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIHdoaWxlIChlbmQgPD0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICBjaGFyID0gdGV4dFtlbmRdO1xuICAgICAgICAgIGlmIChicmVha3MpIHtcbiAgICAgICAgICAgIGlmICgoY2hhciA9PSBudWxsKSB8fCBpbmRleE9mLmNhbGwoJ1xcblxceDg1XFx1MjAyOFxcdTIwMjknLCBjaGFyKSA8IDApIHtcbiAgICAgICAgICAgICAgaWYgKCFsZWFkaW5nX3NwYWNlICYmIChjaGFyICE9IG51bGwpICYmIGNoYXIgIT09ICcgJyAmJiB0ZXh0W3N0YXJ0XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlX2xpbmVfYnJlYWsoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZWFkaW5nX3NwYWNlID0gY2hhciA9PT0gJyAnO1xuICAgICAgICAgICAgICByZWYgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiciA9IHJlZltpXTtcbiAgICAgICAgICAgICAgICBpZiAoYnIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLndyaXRlX2xpbmVfYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZV9saW5lX2JyZWFrKGJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNoYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVfaW5kZW50KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGFjZXMpIHtcbiAgICAgICAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgMSA9PT0gZW5kICYmIHRoaXMuY29sdW1uID4gdGhpcy5iZXN0X3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGV4dC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS53cml0ZShkYXRhLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKChjaGFyID09IG51bGwpIHx8IGluZGV4T2YuY2FsbCgnIFxcblxceDg1XFx1MjAyOFxcdTIwMjknLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgICBkYXRhID0gdGV4dC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoZGF0YSwgdGhpcy5lbmNvZGluZyk7XG4gICAgICAgICAgICBpZiAoY2hhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMud3JpdGVfbGluZV9icmVhaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrcyA9IGluZGV4T2YuY2FsbCgnXFxuXFx4ODVcXHUyMDI4XFx1MjAyOScsIGNoYXIpID49IDA7XG4gICAgICAgICAgICBzcGFjZXMgPSBjaGFyID09PSAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMucHVzaChlbmQrKyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlX2xpdGVyYWwodGV4dCkge1xuICAgICAgICB2YXIgYnIsIGJyZWFrcywgY2hhciwgZGF0YSwgZW5kLCBoaW50cywgaSwgbGVuLCByZWYsIHJlc3VsdHMsIHN0YXJ0O1xuICAgICAgICBoaW50cyA9IHRoaXMuZGV0ZXJtaW5lX2Jsb2NrX2hpbnRzKHRleHQpO1xuICAgICAgICB0aGlzLndyaXRlX2luZGljYXRvcihgfCR7aGludHN9YCwgdHJ1ZSk7XG4gICAgICAgIGlmIChoaW50cy5zbGljZSgtMSkgPT09ICcrJykge1xuICAgICAgICAgIHRoaXMub3Blbl9lbmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZV9saW5lX2JyZWFrKCk7XG4gICAgICAgIGJyZWFrcyA9IHRydWU7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gMDtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICB3aGlsZSAoZW5kIDw9IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgY2hhciA9IHRleHRbZW5kXTtcbiAgICAgICAgICBpZiAoYnJlYWtzKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXIgPT0gbnVsbCkgfHwgaW5kZXhPZi5jYWxsKCdcXG5cXHg4NVxcdTIwMjhcXHUyMDI5JywgY2hhcikgPCAwKSB7XG4gICAgICAgICAgICAgIHJlZiA9IHRleHQuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGJyID0gcmVmW2ldO1xuICAgICAgICAgICAgICAgIGlmIChiciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVfbGluZV9icmVhaygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLndyaXRlX2xpbmVfYnJlYWsoYnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2hhciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjaGFyID09IG51bGwpIHx8IGluZGV4T2YuY2FsbCgnXFxuXFx4ODVcXHUyMDI4XFx1MjAyOScsIGNoYXIpID49IDApIHtcbiAgICAgICAgICAgICAgZGF0YSA9IHRleHQuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKGRhdGEsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICAgICAgICBpZiAoY2hhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZV9saW5lX2JyZWFrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrcyA9IGluZGV4T2YuY2FsbCgnXFxuXFx4ODVcXHUyMDI4XFx1MjAyOScsIGNoYXIpID49IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMucHVzaChlbmQrKyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlX3BsYWluKHRleHQsIHNwbGl0ID0gdHJ1ZSkge1xuICAgICAgICB2YXIgYnIsIGJyZWFrcywgY2hhciwgZGF0YSwgZW5kLCBpLCBsZW4sIHJlZiwgcmVzdWx0cywgc3BhY2VzLCBzdGFydDtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvb3RfY29udGV4dCkge1xuICAgICAgICAgIHRoaXMub3Blbl9lbmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLndoaXRlc3BhY2UpIHtcbiAgICAgICAgICBkYXRhID0gJyAnO1xuICAgICAgICAgIHRoaXMuY29sdW1uICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKGRhdGEsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZGVudGF0aW9uID0gZmFsc2U7XG4gICAgICAgIHNwYWNlcyA9IGZhbHNlO1xuICAgICAgICBicmVha3MgPSBmYWxzZTtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAwO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIHdoaWxlIChlbmQgPD0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICBjaGFyID0gdGV4dFtlbmRdO1xuICAgICAgICAgIGlmIChzcGFjZXMpIHtcbiAgICAgICAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgMSA9PT0gZW5kICYmIHRoaXMuY29sdW1uID4gdGhpcy5iZXN0X3dpZHRoICYmIHNwbGl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZV9pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLndoaXRlc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRleHQuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4gKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoZGF0YSwgdGhpcy5lbmNvZGluZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChicmVha3MpIHtcbiAgICAgICAgICAgIGlmIChpbmRleE9mLmNhbGwoJ1xcblxceDg1XFx1MjAyOFxcdTIwMjknLCBjaGFyKSA8IDApIHtcbiAgICAgICAgICAgICAgaWYgKHRleHRbc3RhcnRdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVfbGluZV9icmVhaygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlZiA9IHRleHQuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGJyID0gcmVmW2ldO1xuICAgICAgICAgICAgICAgIGlmIChiciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVfbGluZV9icmVhaygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLndyaXRlX2xpbmVfYnJlYWsoYnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLndyaXRlX2luZGVudCgpO1xuICAgICAgICAgICAgICB0aGlzLndoaXRlc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5pbmRlbnRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjaGFyID09IG51bGwpIHx8IGluZGV4T2YuY2FsbCgnIFxcblxceDg1XFx1MjAyOFxcdTIwMjknLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoZGF0YSwgdGhpcy5lbmNvZGluZyk7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciAhPSBudWxsKSB7XG4gICAgICAgICAgICBzcGFjZXMgPSBjaGFyID09PSAnICc7XG4gICAgICAgICAgICBicmVha3MgPSBpbmRleE9mLmNhbGwoJ1xcblxceDg1XFx1MjAyOFxcdTIwMjknLCBjaGFyKSA+PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHRzLnB1c2goZW5kKyspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfVxuXG4gICAgICBkZXRlcm1pbmVfYmxvY2tfaGludHModGV4dCkge1xuICAgICAgICB2YXIgZmlyc3QsIGhpbnRzLCBpLCBsYXN0LCBwZW51bHRpbWF0ZTtcbiAgICAgICAgaGludHMgPSAnJztcbiAgICAgICAgZmlyc3QgPSB0ZXh0WzBdLCBpID0gdGV4dC5sZW5ndGggLSAyLCBwZW51bHRpbWF0ZSA9IHRleHRbaSsrXSwgbGFzdCA9IHRleHRbaSsrXTtcbiAgICAgICAgaWYgKGluZGV4T2YuY2FsbCgnIFxcblxceDg1XFx1MjAyOFxcdTIwMjknLCBmaXJzdCkgPj0gMCkge1xuICAgICAgICAgIGhpbnRzICs9IHRoaXMuYmVzdF9pbmRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4T2YuY2FsbCgnXFxuXFx4ODVcXHUyMDI4XFx1MjAyOScsIGxhc3QpIDwgMCkge1xuICAgICAgICAgIGhpbnRzICs9ICctJztcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMSB8fCBpbmRleE9mLmNhbGwoJ1xcblxceDg1XFx1MjAyOFxcdTIwMjknLCBwZW51bHRpbWF0ZSkgPj0gMCkge1xuICAgICAgICAgIGhpbnRzICs9ICcrJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGludHM7XG4gICAgICB9XG5cbiAgICAgIGZsdXNoX3N0cmVhbSgpIHtcbiAgICAgICAgdmFyIGJhc2U7XG4gICAgICAgIHJldHVybiB0eXBlb2YgKGJhc2UgPSB0aGlzLnN0cmVhbSkuZmx1c2ggPT09IFwiZnVuY3Rpb25cIiA/IGJhc2UuZmx1c2goKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIEhlbHBlciBmb3IgY29tbW9uIGVycm9yIHBhdHRlcm4uXG4gICAgICAqL1xuICAgICAgZXJyb3IobWVzc2FnZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVmLCByZWYxO1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGNvbnRleHQgPSAocmVmID0gY29udGV4dCAhPSBudWxsID8gKHJlZjEgPSBjb250ZXh0LmNvbnN0cnVjdG9yKSAhPSBudWxsID8gcmVmMS5uYW1lIDogdm9pZCAwIDogdm9pZCAwKSAhPSBudWxsID8gcmVmIDogdXRpbC5pbnNwZWN0KGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkVtaXR0ZXJFcnJvcihgJHttZXNzYWdlfSR7KGNvbnRleHQgPyBgICR7Y29udGV4dH1gIDogJycpfWApO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIENfV0hJVEVTUEFDRSA9ICdcXDAgXFx0XFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOSc7XG5cbiAgICBERUZBVUxUX1RBR19QUkVGSVhFUyA9IHtcbiAgICAgICchJzogJyEnLFxuICAgICAgJ3RhZzp5YW1sLm9yZywyMDAyOic6ICchISdcbiAgICB9O1xuXG4gICAgRVNDQVBFX1JFUExBQ0VNRU5UUyA9IHtcbiAgICAgICdcXDAnOiAnMCcsXG4gICAgICAnXFx4MDcnOiAnYScsXG4gICAgICAnXFx4MDgnOiAnYicsXG4gICAgICAnXFx4MDknOiAndCcsXG4gICAgICAnXFx4MEEnOiAnbicsXG4gICAgICAnXFx4MEInOiAndicsXG4gICAgICAnXFx4MEMnOiAnZicsXG4gICAgICAnXFx4MEQnOiAncicsXG4gICAgICAnXFx4MUInOiAnZScsXG4gICAgICAnXCInOiAnXCInLFxuICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAnXFx4ODUnOiAnTicsXG4gICAgICAnXFx4QTAnOiAnXycsXG4gICAgICAnXFx1MjAyOCc6ICdMJyxcbiAgICAgICdcXHUyMDI5JzogJ1AnXG4gICAgfTtcblxuICAgIGN0b3IgPSBFbWl0dGVyLnByb3RvdHlwZS5pbml0aWFsaXNlO1xuXG4gICAgcmV0dXJuIEVtaXR0ZXI7XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICBTY2FsYXJBbmFseXNpcyA9IGNsYXNzIFNjYWxhckFuYWx5c2lzIHtcbiAgICBjb25zdHJ1Y3RvcihzY2FsYXIxLCBlbXB0eSwgbXVsdGlsaW5lLCBhbGxvd19mbG93X3BsYWluMSwgYWxsb3dfYmxvY2tfcGxhaW4xLCBhbGxvd19zaW5nbGVfcXVvdGVkMSwgYWxsb3dfZG91YmxlX3F1b3RlZDEsIGFsbG93X2Jsb2NrMSkge1xuICAgICAgdGhpcy5zY2FsYXIgPSBzY2FsYXIxO1xuICAgICAgdGhpcy5lbXB0eSA9IGVtcHR5O1xuICAgICAgdGhpcy5tdWx0aWxpbmUgPSBtdWx0aWxpbmU7XG4gICAgICB0aGlzLmFsbG93X2Zsb3dfcGxhaW4gPSBhbGxvd19mbG93X3BsYWluMTtcbiAgICAgIHRoaXMuYWxsb3dfYmxvY2tfcGxhaW4gPSBhbGxvd19ibG9ja19wbGFpbjE7XG4gICAgICB0aGlzLmFsbG93X3NpbmdsZV9xdW90ZWQgPSBhbGxvd19zaW5nbGVfcXVvdGVkMTtcbiAgICAgIHRoaXMuYWxsb3dfZG91YmxlX3F1b3RlZCA9IGFsbG93X2RvdWJsZV9xdW90ZWQxO1xuICAgICAgdGhpcy5hbGxvd19ibG9jayA9IGFsbG93X2Jsb2NrMTtcbiAgICB9XG5cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///320\n")},372:function(){eval("(function() {\n  var indexOf = [].indexOf;\n\n  this.Mark = class Mark {\n    constructor(line, column, buffer, pointer) {\n      this.line = line;\n      this.column = column;\n      this.buffer = buffer;\n      this.pointer = pointer;\n    }\n\n    get_snippet(indent = 4, max_length = 75) {\n      var break_chars, end, head, ref, ref1, start, tail;\n      if (this.buffer == null) {\n        return null;\n      }\n      break_chars = '\\x00\\r\\n\\x85\\u2028\\u2029';\n      head = '';\n      start = this.pointer;\n      while (start > 0 && (ref = this.buffer[start - 1], indexOf.call(break_chars, ref) < 0)) {\n        start--;\n        if (this.pointer - start > max_length / 2 - 1) {\n          head = ' ... ';\n          start += 5;\n          break;\n        }\n      }\n      tail = '';\n      end = this.pointer;\n      while (end < this.buffer.length && (ref1 = this.buffer[end], indexOf.call(break_chars, ref1) < 0)) {\n        end++;\n        if (end - this.pointer > max_length / 2 - 1) {\n          tail = ' ... ';\n          end -= 5;\n          break;\n        }\n      }\n      return `${(new Array(indent)).join(' ')}${head}${this.buffer.slice(start, end)}${tail}\\n${(new Array(indent + this.pointer - start + head.length)).join(' ')}^`;\n    }\n\n    toString() {\n      var snippet, where;\n      snippet = this.get_snippet();\n      where = `  on line ${this.line + 1}, column ${this.column + 1}`;\n      if (snippet) {\n        return where;\n      } else {\n        return `${where}:\\n${snippet}`;\n      }\n    }\n\n  };\n\n  this.YAMLError = class YAMLError extends Error {\n    constructor(message) {\n      super(message);\n      // Hack to get the stack on the error somehow\n      Object.defineProperty(this, 'stack', {\n        get: function() {\n          return this.toString() + '\\n' + (new Error).stack.split('\\n').slice(1).join('\\n');\n        }\n      });\n    }\n\n    toString() {\n      return this.message;\n    }\n\n  };\n\n  this.MarkedYAMLError = class MarkedYAMLError extends this.YAMLError {\n    constructor(context, context_mark, problem, problem_mark, note) {\n      super();\n      this.context = context;\n      this.context_mark = context_mark;\n      this.problem = problem;\n      this.problem_mark = problem_mark;\n      this.note = note;\n    }\n\n    toString() {\n      var lines;\n      lines = [];\n      if (this.context != null) {\n        lines.push(this.context);\n      }\n      if ((this.context_mark != null) && ((this.problem == null) || (this.problem_mark == null) || this.context_mark.line !== this.problem_mark.line || this.context_mark.column !== this.problem_mark.column)) {\n        lines.push(this.context_mark.toString());\n      }\n      if (this.problem != null) {\n        lines.push(this.problem);\n      }\n      if (this.problem_mark != null) {\n        lines.push(this.problem_mark.toString());\n      }\n      if (this.note != null) {\n        lines.push(this.note);\n      }\n      return lines.join('\\n');\n    }\n\n  };\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEIsRUFBRSxLQUFLLEVBQUUsOEJBQThCLEVBQUUsS0FBSyxJQUFJLG1FQUFtRTtBQUNuSzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYyxXQUFXLGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtCQUFrQixNQUFNLEtBQUssUUFBUTtBQUNyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMveWFtbC1qcy9saWIvZXJyb3JzLmpzPzUwMmEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkge1xuICB2YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbiAgdGhpcy5NYXJrID0gY2xhc3MgTWFyayB7XG4gICAgY29uc3RydWN0b3IobGluZSwgY29sdW1uLCBidWZmZXIsIHBvaW50ZXIpIHtcbiAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgdGhpcy5wb2ludGVyID0gcG9pbnRlcjtcbiAgICB9XG5cbiAgICBnZXRfc25pcHBldChpbmRlbnQgPSA0LCBtYXhfbGVuZ3RoID0gNzUpIHtcbiAgICAgIHZhciBicmVha19jaGFycywgZW5kLCBoZWFkLCByZWYsIHJlZjEsIHN0YXJ0LCB0YWlsO1xuICAgICAgaWYgKHRoaXMuYnVmZmVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBicmVha19jaGFycyA9ICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknO1xuICAgICAgaGVhZCA9ICcnO1xuICAgICAgc3RhcnQgPSB0aGlzLnBvaW50ZXI7XG4gICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIChyZWYgPSB0aGlzLmJ1ZmZlcltzdGFydCAtIDFdLCBpbmRleE9mLmNhbGwoYnJlYWtfY2hhcnMsIHJlZikgPCAwKSkge1xuICAgICAgICBzdGFydC0tO1xuICAgICAgICBpZiAodGhpcy5wb2ludGVyIC0gc3RhcnQgPiBtYXhfbGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgICBoZWFkID0gJyAuLi4gJztcbiAgICAgICAgICBzdGFydCArPSA1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0YWlsID0gJyc7XG4gICAgICBlbmQgPSB0aGlzLnBvaW50ZXI7XG4gICAgICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmIChyZWYxID0gdGhpcy5idWZmZXJbZW5kXSwgaW5kZXhPZi5jYWxsKGJyZWFrX2NoYXJzLCByZWYxKSA8IDApKSB7XG4gICAgICAgIGVuZCsrO1xuICAgICAgICBpZiAoZW5kIC0gdGhpcy5wb2ludGVyID4gbWF4X2xlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICAgICAgZW5kIC09IDU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHsobmV3IEFycmF5KGluZGVudCkpLmpvaW4oJyAnKX0ke2hlYWR9JHt0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKX0ke3RhaWx9XFxuJHsobmV3IEFycmF5KGluZGVudCArIHRoaXMucG9pbnRlciAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpKS5qb2luKCcgJyl9XmA7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgc25pcHBldCwgd2hlcmU7XG4gICAgICBzbmlwcGV0ID0gdGhpcy5nZXRfc25pcHBldCgpO1xuICAgICAgd2hlcmUgPSBgICBvbiBsaW5lICR7dGhpcy5saW5lICsgMX0sIGNvbHVtbiAke3RoaXMuY29sdW1uICsgMX1gO1xuICAgICAgaWYgKHNuaXBwZXQpIHtcbiAgICAgICAgcmV0dXJuIHdoZXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke3doZXJlfTpcXG4ke3NuaXBwZXR9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLllBTUxFcnJvciA9IGNsYXNzIFlBTUxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIC8vIEhhY2sgdG8gZ2V0IHRoZSBzdGFjayBvbiB0aGUgZXJyb3Igc29tZWhvd1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpICsgJ1xcbicgKyAobmV3IEVycm9yKS5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLk1hcmtlZFlBTUxFcnJvciA9IGNsYXNzIE1hcmtlZFlBTUxFcnJvciBleHRlbmRzIHRoaXMuWUFNTEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjb250ZXh0X21hcmssIHByb2JsZW0sIHByb2JsZW1fbWFyaywgbm90ZSkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLmNvbnRleHRfbWFyayA9IGNvbnRleHRfbWFyaztcbiAgICAgIHRoaXMucHJvYmxlbSA9IHByb2JsZW07XG4gICAgICB0aGlzLnByb2JsZW1fbWFyayA9IHByb2JsZW1fbWFyaztcbiAgICAgIHRoaXMubm90ZSA9IG5vdGU7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgbGluZXM7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgaWYgKHRoaXMuY29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIGxpbmVzLnB1c2godGhpcy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmICgodGhpcy5jb250ZXh0X21hcmsgIT0gbnVsbCkgJiYgKCh0aGlzLnByb2JsZW0gPT0gbnVsbCkgfHwgKHRoaXMucHJvYmxlbV9tYXJrID09IG51bGwpIHx8IHRoaXMuY29udGV4dF9tYXJrLmxpbmUgIT09IHRoaXMucHJvYmxlbV9tYXJrLmxpbmUgfHwgdGhpcy5jb250ZXh0X21hcmsuY29sdW1uICE9PSB0aGlzLnByb2JsZW1fbWFyay5jb2x1bW4pKSB7XG4gICAgICAgIGxpbmVzLnB1c2godGhpcy5jb250ZXh0X21hcmsudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9ibGVtICE9IG51bGwpIHtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLnByb2JsZW0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvYmxlbV9tYXJrICE9IG51bGwpIHtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLnByb2JsZW1fbWFyay50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5vdGUgIT0gbnVsbCkge1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMubm90ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfVxuXG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///372\n")},63:function(){eval("(function() {\n  this.Event = class Event {\n    constructor(start_mark1, end_mark1) {\n      this.start_mark = start_mark1;\n      this.end_mark = end_mark1;\n    }\n\n  };\n\n  this.NodeEvent = class NodeEvent extends this.Event {\n    constructor(anchor1, start_mark, end_mark) {\n      super(start_mark, end_mark);\n      this.anchor = anchor1;\n    }\n\n  };\n\n  this.CollectionStartEvent = class CollectionStartEvent extends this.NodeEvent {\n    constructor(anchor, tag, implicit, start_mark, end_mark, flow_style) {\n      super(anchor, start_mark, end_mark);\n      this.tag = tag;\n      this.implicit = implicit;\n      this.flow_style = flow_style;\n    }\n\n  };\n\n  this.CollectionEndEvent = class CollectionEndEvent extends this.Event {};\n\n  this.StreamStartEvent = class StreamStartEvent extends this.Event {\n    constructor(start_mark, end_mark, encoding) {\n      super(start_mark, end_mark);\n      this.encoding = encoding;\n    }\n\n  };\n\n  this.StreamEndEvent = class StreamEndEvent extends this.Event {};\n\n  this.DocumentStartEvent = class DocumentStartEvent extends this.Event {\n    constructor(start_mark, end_mark, explicit, version, tags) {\n      super(start_mark, end_mark);\n      this.explicit = explicit;\n      this.version = version;\n      this.tags = tags;\n    }\n\n  };\n\n  this.DocumentEndEvent = class DocumentEndEvent extends this.Event {\n    constructor(start_mark, end_mark, explicit) {\n      super(start_mark, end_mark);\n      this.explicit = explicit;\n    }\n\n  };\n\n  this.AliasEvent = class AliasEvent extends this.NodeEvent {};\n\n  this.ScalarEvent = class ScalarEvent extends this.NodeEvent {\n    constructor(anchor, tag, implicit, value, start_mark, end_mark, style) {\n      super(anchor, start_mark, end_mark);\n      this.tag = tag;\n      this.implicit = implicit;\n      this.value = value;\n      this.style = style;\n    }\n\n  };\n\n  this.SequenceStartEvent = class SequenceStartEvent extends this.CollectionStartEvent {};\n\n  this.SequenceEndEvent = class SequenceEndEvent extends this.CollectionEndEvent {};\n\n  this.MappingStartEvent = class MappingStartEvent extends this.CollectionStartEvent {};\n\n  this.MappingEndEvent = class MappingEndEvent extends this.CollectionEndEvent {};\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy95YW1sLWpzL2xpYi9ldmVudHMuanM/MTNmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIHRoaXMuRXZlbnQgPSBjbGFzcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnRfbWFyazEsIGVuZF9tYXJrMSkge1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyazE7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcmsxO1xuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuTm9kZUV2ZW50ID0gY2xhc3MgTm9kZUV2ZW50IGV4dGVuZHMgdGhpcy5FdmVudCB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yMSwgc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgIHN1cGVyKHN0YXJ0X21hcmssIGVuZF9tYXJrKTtcbiAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yMTtcbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLkNvbGxlY3Rpb25TdGFydEV2ZW50ID0gY2xhc3MgQ29sbGVjdGlvblN0YXJ0RXZlbnQgZXh0ZW5kcyB0aGlzLk5vZGVFdmVudCB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCBzdGFydF9tYXJrLCBlbmRfbWFyaywgZmxvd19zdHlsZSkge1xuICAgICAgc3VwZXIoYW5jaG9yLCBzdGFydF9tYXJrLCBlbmRfbWFyayk7XG4gICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgIHRoaXMuaW1wbGljaXQgPSBpbXBsaWNpdDtcbiAgICAgIHRoaXMuZmxvd19zdHlsZSA9IGZsb3dfc3R5bGU7XG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5Db2xsZWN0aW9uRW5kRXZlbnQgPSBjbGFzcyBDb2xsZWN0aW9uRW5kRXZlbnQgZXh0ZW5kcyB0aGlzLkV2ZW50IHt9O1xuXG4gIHRoaXMuU3RyZWFtU3RhcnRFdmVudCA9IGNsYXNzIFN0cmVhbVN0YXJ0RXZlbnQgZXh0ZW5kcyB0aGlzLkV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydF9tYXJrLCBlbmRfbWFyaywgZW5jb2RpbmcpIHtcbiAgICAgIHN1cGVyKHN0YXJ0X21hcmssIGVuZF9tYXJrKTtcbiAgICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLlN0cmVhbUVuZEV2ZW50ID0gY2xhc3MgU3RyZWFtRW5kRXZlbnQgZXh0ZW5kcyB0aGlzLkV2ZW50IHt9O1xuXG4gIHRoaXMuRG9jdW1lbnRTdGFydEV2ZW50ID0gY2xhc3MgRG9jdW1lbnRTdGFydEV2ZW50IGV4dGVuZHMgdGhpcy5FdmVudCB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnRfbWFyaywgZW5kX21hcmssIGV4cGxpY2l0LCB2ZXJzaW9uLCB0YWdzKSB7XG4gICAgICBzdXBlcihzdGFydF9tYXJrLCBlbmRfbWFyayk7XG4gICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XG4gICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLkRvY3VtZW50RW5kRXZlbnQgPSBjbGFzcyBEb2N1bWVudEVuZEV2ZW50IGV4dGVuZHMgdGhpcy5FdmVudCB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnRfbWFyaywgZW5kX21hcmssIGV4cGxpY2l0KSB7XG4gICAgICBzdXBlcihzdGFydF9tYXJrLCBlbmRfbWFyayk7XG4gICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5BbGlhc0V2ZW50ID0gY2xhc3MgQWxpYXNFdmVudCBleHRlbmRzIHRoaXMuTm9kZUV2ZW50IHt9O1xuXG4gIHRoaXMuU2NhbGFyRXZlbnQgPSBjbGFzcyBTY2FsYXJFdmVudCBleHRlbmRzIHRoaXMuTm9kZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhbmNob3IsIHRhZywgaW1wbGljaXQsIHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgc3R5bGUpIHtcbiAgICAgIHN1cGVyKGFuY2hvciwgc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICB0aGlzLmltcGxpY2l0ID0gaW1wbGljaXQ7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5TZXF1ZW5jZVN0YXJ0RXZlbnQgPSBjbGFzcyBTZXF1ZW5jZVN0YXJ0RXZlbnQgZXh0ZW5kcyB0aGlzLkNvbGxlY3Rpb25TdGFydEV2ZW50IHt9O1xuXG4gIHRoaXMuU2VxdWVuY2VFbmRFdmVudCA9IGNsYXNzIFNlcXVlbmNlRW5kRXZlbnQgZXh0ZW5kcyB0aGlzLkNvbGxlY3Rpb25FbmRFdmVudCB7fTtcblxuICB0aGlzLk1hcHBpbmdTdGFydEV2ZW50ID0gY2xhc3MgTWFwcGluZ1N0YXJ0RXZlbnQgZXh0ZW5kcyB0aGlzLkNvbGxlY3Rpb25TdGFydEV2ZW50IHt9O1xuXG4gIHRoaXMuTWFwcGluZ0VuZEV2ZW50ID0gY2xhc3MgTWFwcGluZ0VuZEV2ZW50IGV4dGVuZHMgdGhpcy5Db2xsZWN0aW9uRW5kRXZlbnQge307XG5cbn0pLmNhbGwodGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///63\n")},696:function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){eval("(function() {\n  var composer, constructor, parser, reader, resolver, scanner, util;\n\n  util = __webpack_require__(823);\n\n  reader = __webpack_require__(26);\n\n  scanner = __webpack_require__(265);\n\n  parser = __webpack_require__(806);\n\n  composer = __webpack_require__(391);\n\n  resolver = __webpack_require__(579);\n\n  constructor = __webpack_require__(574);\n\n  this.make_loader = function(Reader = reader.Reader, Scanner = scanner.Scanner, Parser = parser.Parser, Composer = composer.Composer, Resolver = resolver.Resolver, Constructor = constructor.Constructor) {\n    var Loader, components;\n    components = [Reader, Scanner, Parser, Composer, Resolver, Constructor];\n    return Loader = (function() {\n      var component;\n\n      class Loader {\n        constructor(stream) {\n          var i, len, ref;\n          components[0].prototype.initialise.call(this, stream);\n          ref = components.slice(1);\n          for (i = 0, len = ref.length; i < len; i++) {\n            component = ref[i];\n            component.prototype.initialise.call(this);\n          }\n        }\n\n      };\n\n      util.extend(Loader.prototype, ...((function() {\n        var i, len, results;\n        results = [];\n        for (i = 0, len = components.length; i < len; i++) {\n          component = components[i];\n          results.push(component.prototype);\n        }\n        return results;\n      })()));\n\n      return Loader;\n\n    }).call(this);\n  };\n\n  this.Loader = this.make_loader();\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLEdBQVE7O0FBRXpCLFdBQVcsbUJBQU8sQ0FBQyxFQUFVOztBQUU3QixZQUFZLG1CQUFPLENBQUMsR0FBVzs7QUFFL0IsV0FBVyxtQkFBTyxDQUFDLEdBQVU7O0FBRTdCLGFBQWEsbUJBQU8sQ0FBQyxHQUFZOztBQUVqQyxhQUFhLG1CQUFPLENBQUMsR0FBWTs7QUFFakMsZ0JBQWdCLG1CQUFPLENBQUMsR0FBZTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwtanMvbGliL2xvYWRlci5qcz85OWFiIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpIHtcbiAgdmFyIGNvbXBvc2VyLCBjb25zdHJ1Y3RvciwgcGFyc2VyLCByZWFkZXIsIHJlc29sdmVyLCBzY2FubmVyLCB1dGlsO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICByZWFkZXIgPSByZXF1aXJlKCcuL3JlYWRlcicpO1xuXG4gIHNjYW5uZXIgPSByZXF1aXJlKCcuL3NjYW5uZXInKTtcblxuICBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuXG4gIGNvbXBvc2VyID0gcmVxdWlyZSgnLi9jb21wb3NlcicpO1xuXG4gIHJlc29sdmVyID0gcmVxdWlyZSgnLi9yZXNvbHZlcicpO1xuXG4gIGNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3RvcicpO1xuXG4gIHRoaXMubWFrZV9sb2FkZXIgPSBmdW5jdGlvbihSZWFkZXIgPSByZWFkZXIuUmVhZGVyLCBTY2FubmVyID0gc2Nhbm5lci5TY2FubmVyLCBQYXJzZXIgPSBwYXJzZXIuUGFyc2VyLCBDb21wb3NlciA9IGNvbXBvc2VyLkNvbXBvc2VyLCBSZXNvbHZlciA9IHJlc29sdmVyLlJlc29sdmVyLCBDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yLkNvbnN0cnVjdG9yKSB7XG4gICAgdmFyIExvYWRlciwgY29tcG9uZW50cztcbiAgICBjb21wb25lbnRzID0gW1JlYWRlciwgU2Nhbm5lciwgUGFyc2VyLCBDb21wb3NlciwgUmVzb2x2ZXIsIENvbnN0cnVjdG9yXTtcbiAgICByZXR1cm4gTG9hZGVyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbXBvbmVudDtcblxuICAgICAgY2xhc3MgTG9hZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIGksIGxlbiwgcmVmO1xuICAgICAgICAgIGNvbXBvbmVudHNbMF0ucHJvdG90eXBlLmluaXRpYWxpc2UuY2FsbCh0aGlzLCBzdHJlYW0pO1xuICAgICAgICAgIHJlZiA9IGNvbXBvbmVudHMuc2xpY2UoMSk7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSByZWZbaV07XG4gICAgICAgICAgICBjb21wb25lbnQucHJvdG90eXBlLmluaXRpYWxpc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfTtcblxuICAgICAgdXRpbC5leHRlbmQoTG9hZGVyLnByb3RvdHlwZSwgLi4uKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICByZXN1bHRzLnB1c2goY29tcG9uZW50LnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KSgpKSk7XG5cbiAgICAgIHJldHVybiBMb2FkZXI7XG5cbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHRoaXMuTG9hZGVyID0gdGhpcy5tYWtlX2xvYWRlcigpO1xuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///696\n")},914:function(){eval("(function() {\n  var unique_id;\n\n  unique_id = 0;\n\n  this.Node = class Node {\n    constructor(tag1, value1, start_mark1, end_mark1) {\n      this.tag = tag1;\n      this.value = value1;\n      this.start_mark = start_mark1;\n      this.end_mark = end_mark1;\n      this.unique_id = `node_${unique_id++}`;\n    }\n\n  };\n\n  this.ScalarNode = (function() {\n    class ScalarNode extends this.Node {\n      constructor(tag, value, start_mark, end_mark, style) {\n        super(tag, value, start_mark, end_mark);\n        this.style = style;\n      }\n\n    };\n\n    ScalarNode.prototype.id = 'scalar';\n\n    return ScalarNode;\n\n  }).call(this);\n\n  this.CollectionNode = class CollectionNode extends this.Node {\n    constructor(tag, value, start_mark, end_mark, flow_style) {\n      super(tag, value, start_mark, end_mark);\n      this.flow_style = flow_style;\n    }\n\n  };\n\n  this.SequenceNode = (function() {\n    class SequenceNode extends this.CollectionNode {};\n\n    SequenceNode.prototype.id = 'sequence';\n\n    return SequenceNode;\n\n  }).call(this);\n\n  this.MappingNode = (function() {\n    class MappingNode extends this.CollectionNode {};\n\n    MappingNode.prototype.id = 'mapping';\n\n    return MappingNode;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMveWFtbC1qcy9saWIvbm9kZXMuanM/MzIxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIHZhciB1bmlxdWVfaWQ7XG5cbiAgdW5pcXVlX2lkID0gMDtcblxuICB0aGlzLk5vZGUgPSBjbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcxLCB2YWx1ZTEsIHN0YXJ0X21hcmsxLCBlbmRfbWFyazEpIHtcbiAgICAgIHRoaXMudGFnID0gdGFnMTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTE7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrMTtcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyazE7XG4gICAgICB0aGlzLnVuaXF1ZV9pZCA9IGBub2RlXyR7dW5pcXVlX2lkKyt9YDtcbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLlNjYWxhck5vZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgU2NhbGFyTm9kZSBleHRlbmRzIHRoaXMuTm9kZSB7XG4gICAgICBjb25zdHJ1Y3Rvcih0YWcsIHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgc3R5bGUpIHtcbiAgICAgICAgc3VwZXIodGFnLCB2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2NhbGFyTm9kZS5wcm90b3R5cGUuaWQgPSAnc2NhbGFyJztcblxuICAgIHJldHVybiBTY2FsYXJOb2RlO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5Db2xsZWN0aW9uTm9kZSA9IGNsYXNzIENvbGxlY3Rpb25Ob2RlIGV4dGVuZHMgdGhpcy5Ob2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgZmxvd19zdHlsZSkge1xuICAgICAgc3VwZXIodGFnLCB2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgICAgdGhpcy5mbG93X3N0eWxlID0gZmxvd19zdHlsZTtcbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLlNlcXVlbmNlTm9kZSA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBTZXF1ZW5jZU5vZGUgZXh0ZW5kcyB0aGlzLkNvbGxlY3Rpb25Ob2RlIHt9O1xuXG4gICAgU2VxdWVuY2VOb2RlLnByb3RvdHlwZS5pZCA9ICdzZXF1ZW5jZSc7XG5cbiAgICByZXR1cm4gU2VxdWVuY2VOb2RlO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5NYXBwaW5nTm9kZSA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBNYXBwaW5nTm9kZSBleHRlbmRzIHRoaXMuQ29sbGVjdGlvbk5vZGUge307XG5cbiAgICBNYXBwaW5nTm9kZS5wcm90b3R5cGUuaWQgPSAnbWFwcGluZyc7XG5cbiAgICByZXR1cm4gTWFwcGluZ05vZGU7XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///914\n")},806:function(__unused_webpack_module,exports,__webpack_require__){eval("(function() {\n  var MarkedYAMLError, events, tokens,\n    hasProp = {}.hasOwnProperty;\n\n  events = __webpack_require__(63);\n\n  ({MarkedYAMLError} = __webpack_require__(372));\n\n  tokens = __webpack_require__(902);\n\n  this.ParserError = class ParserError extends MarkedYAMLError {};\n\n  this.Parser = (function() {\n    var DEFAULT_TAGS, ctor;\n\n    class Parser {\n      constructor() {\n        return ctor.apply(this, arguments);\n      }\n\n      initialise() {\n        this.current_event = null;\n        this.yaml_version = null;\n        this.tag_handles = {};\n        this.states = [];\n        this.marks = [];\n        return this.state = 'parse_stream_start';\n      }\n\n      /*\n      Reset the state attributes.\n      */\n      dispose() {\n        this.states = [];\n        return this.state = null;\n      }\n\n      /*\n      Check the type of the next event.\n      */\n      check_event(...choices) {\n        var choice, i, len;\n        if (this.current_event === null) {\n          if (this.state != null) {\n            this.current_event = this[this.state]();\n          }\n        }\n        if (this.current_event !== null) {\n          if (choices.length === 0) {\n            return true;\n          }\n          for (i = 0, len = choices.length; i < len; i++) {\n            choice = choices[i];\n            if (this.current_event instanceof choice) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n\n      /*\n      Get the next event.\n      */\n      peek_event() {\n        if (this.current_event === null && (this.state != null)) {\n          this.current_event = this[this.state]();\n        }\n        return this.current_event;\n      }\n\n      /*\n      Get the event and proceed further.\n      */\n      get_event() {\n        var event;\n        if (this.current_event === null && (this.state != null)) {\n          this.current_event = this[this.state]();\n        }\n        event = this.current_event;\n        this.current_event = null;\n        return event;\n      }\n\n      // stream ::= STREAM-START implicit_document? explicit_document* STREAM-END\n      // implicit_document ::= block_node DOCUMENT-END*\n      // explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*\n      /*\n      Parse the stream start.\n      */\n      parse_stream_start() {\n        var event, token;\n        token = this.get_token();\n        event = new events.StreamStartEvent(token.start_mark, token.end_mark);\n        // Prepare the next state,\n        this.state = 'parse_implicit_document_start';\n        return event;\n      }\n\n      /*\n      Parse an implicit document.\n      */\n      parse_implicit_document_start() {\n        var end_mark, event, start_mark, token;\n        if (!this.check_token(tokens.DirectiveToken, tokens.DocumentStartToken, tokens.StreamEndToken)) {\n          this.tag_handles = DEFAULT_TAGS;\n          token = this.peek_token();\n          start_mark = end_mark = token.start_mark;\n          event = new events.DocumentStartEvent(start_mark, end_mark, false);\n          // Prepare the next state\n          this.states.push('parse_document_end');\n          this.state = 'parse_block_node';\n          return event;\n        } else {\n          return this.parse_document_start();\n        }\n      }\n\n      /*\n      Parse an explicit document.\n      */\n      parse_document_start() {\n        var end_mark, event, start_mark, tags, token, version;\n        while (this.check_token(tokens.DocumentEndToken)) {\n          // Parse any extra document end indicators\n          this.get_token();\n        }\n        if (!this.check_token(tokens.StreamEndToken)) {\n          start_mark = this.peek_token().start_mark;\n          [version, tags] = this.process_directives();\n          if (!this.check_token(tokens.DocumentStartToken)) {\n            throw new exports.ParserError(`expected '<document start>', but found ${(this.peek_token().id)}`, this.peek_token().start_mark);\n          }\n          token = this.get_token();\n          end_mark = token.end_mark;\n          event = new events.DocumentStartEvent(start_mark, end_mark, true, version, tags);\n          this.states.push('parse_document_end');\n          this.state = 'parse_document_content';\n        } else {\n          // Parse the end of the stream.\n          token = this.get_token();\n          event = new events.StreamEndEvent(token.start_mark, token.end_mark);\n          if (this.states.length !== 0) {\n            throw new Error('assertion error, states should be empty');\n          }\n          if (this.marks.length !== 0) {\n            throw new Error('assertion error, marks should be empty');\n          }\n          this.state = null;\n        }\n        return event;\n      }\n\n      /*\n      Parse the document end.\n      */\n      parse_document_end() {\n        var end_mark, event, explicit, start_mark, token;\n        token = this.peek_token();\n        start_mark = end_mark = token.start_mark;\n        explicit = false;\n        if (this.check_token(tokens.DocumentEndToken)) {\n          token = this.get_token();\n          end_mark = token.end_mark;\n          explicit = true;\n        }\n        event = new events.DocumentEndEvent(start_mark, end_mark, explicit);\n        // Prepare next state.\n        this.state = 'parse_document_start';\n        return event;\n      }\n\n      parse_document_content() {\n        var event;\n        if (this.check_token(tokens.DirectiveToken, tokens.DocumentStartToken, tokens.DocumentEndToken, tokens.StreamEndToken)) {\n          event = this.process_empty_scalar(this.peek_token().start_mark);\n          this.state = this.states.pop();\n          return event;\n        } else {\n          return this.parse_block_node();\n        }\n      }\n\n      process_directives() {\n        var handle, major, minor, prefix, ref, tag_handles_copy, token, value;\n        this.yaml_version = null;\n        this.tag_handles = {};\n        while (this.check_token(tokens.DirectiveToken)) {\n          token = this.get_token();\n          if (token.name === 'YAML') {\n            if (this.yaml_version !== null) {\n              throw new exports.ParserError(null, null, 'found duplicate YAML directive', token.start_mark);\n            }\n            [major, minor] = token.value;\n            if (major !== 1) {\n              throw new exports.ParserError(null, null, 'found incompatible YAML document (version 1.* is required)', token.start_mark);\n            }\n            this.yaml_version = token.value;\n          } else if (token.name === 'TAG') {\n            [handle, prefix] = token.value;\n            if (handle in this.tag_handles) {\n              throw new exports.ParserError(null, null, `duplicate tag handle ${handle}`, token.start_mark);\n            }\n            this.tag_handles[handle] = prefix;\n          }\n        }\n        tag_handles_copy = null;\n        ref = this.tag_handles;\n        for (handle in ref) {\n          if (!hasProp.call(ref, handle)) continue;\n          prefix = ref[handle];\n          if (tag_handles_copy == null) {\n            tag_handles_copy = {};\n          }\n          tag_handles_copy[handle] = prefix;\n        }\n        value = [this.yaml_version, tag_handles_copy];\n        for (handle in DEFAULT_TAGS) {\n          if (!hasProp.call(DEFAULT_TAGS, handle)) continue;\n          prefix = DEFAULT_TAGS[handle];\n          if (!(prefix in this.tag_handles)) {\n            this.tag_handles[handle] = prefix;\n          }\n        }\n        return value;\n      }\n\n      // block_node_or_indentless_sequence ::= ALIAS\n      //   | properties (block_content | indentless_sequence)?\n      //   | block_content\n      //   | indentless_block_sequence\n      // block_node ::= ALIAS\n      //   | properties block_content?\n      //   | block_content\n      // flow_node ::= ALIAS\n      //   | properties flow_content?\n      //   | flow_content\n      // properties ::= TAG ANCHOR? | ANCHOR TAG?\n      // block_content ::= block_collection | flow_collection | SCALAR\n      // flow_content ::= flow_collection | SCALAR\n      // block_collection ::= block_sequence | block_mapping\n      // flow_collection ::= flow_sequence | flow_mapping\n      parse_block_node() {\n        return this.parse_node(true);\n      }\n\n      parse_flow_node() {\n        return this.parse_node();\n      }\n\n      parse_block_node_or_indentless_sequence() {\n        return this.parse_node(true, true);\n      }\n\n      parse_node(block = false, indentless_sequence = false) {\n        var anchor, end_mark, event, handle, implicit, node, start_mark, suffix, tag, tag_mark, token;\n        if (this.check_token(tokens.AliasToken)) {\n          token = this.get_token();\n          event = new events.AliasEvent(token.value, token.start_mark, token.end_mark);\n          this.state = this.states.pop();\n        } else {\n          anchor = null;\n          tag = null;\n          start_mark = end_mark = tag_mark = null;\n          if (this.check_token(tokens.AnchorToken)) {\n            token = this.get_token();\n            start_mark = token.start_mark;\n            end_mark = token.end_mark;\n            anchor = token.value;\n            if (this.check_token(tokens.TagToken)) {\n              token = this.get_token();\n              tag_mark = token.start_mark;\n              end_mark = token.end_mark;\n              tag = token.value;\n            }\n          } else if (this.check_token(tokens.TagToken)) {\n            token = this.get_token();\n            start_mark = tag_mark = token.start_mark;\n            end_mark = token.end_mark;\n            tag = token.value;\n            if (this.check_token(tokens.AnchorToken)) {\n              token = this.get_token();\n              end_mark = token.end_mark;\n              anchor = token.value;\n            }\n          }\n          if (tag !== null) {\n            [handle, suffix] = tag;\n            if (handle !== null) {\n              if (!(handle in this.tag_handles)) {\n                throw new exports.ParserError('while parsing a node', start_mark, `found undefined tag handle ${handle}`, tag_mark);\n              }\n              tag = this.tag_handles[handle] + suffix;\n            } else {\n              tag = suffix;\n            }\n          }\n          if (start_mark === null) {\n            start_mark = end_mark = this.peek_token().start_mark;\n          }\n          event = null;\n          implicit = tag === null || tag === '!';\n          if (indentless_sequence && this.check_token(tokens.BlockEntryToken)) {\n            end_mark = this.peek_token().end_mark;\n            event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark);\n            this.state = 'parse_indentless_sequence_entry';\n          } else {\n            if (this.check_token(tokens.ScalarToken)) {\n              token = this.get_token();\n              end_mark = token.end_mark;\n              if ((token.plain && tag === null) || tag === '!') {\n                implicit = [true, false];\n              } else if (tag === null) {\n                implicit = [false, true];\n              } else {\n                implicit = [false, false];\n              }\n              event = new events.ScalarEvent(anchor, tag, implicit, token.value, start_mark, end_mark, token.style);\n              this.state = this.states.pop();\n            } else if (this.check_token(tokens.FlowSequenceStartToken)) {\n              end_mark = this.peek_token().end_mark;\n              event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark, true);\n              this.state = 'parse_flow_sequence_first_entry';\n            } else if (this.check_token(tokens.FlowMappingStartToken)) {\n              end_mark = this.peek_token().end_mark;\n              event = new events.MappingStartEvent(anchor, tag, implicit, start_mark, end_mark, true);\n              this.state = 'parse_flow_mapping_first_key';\n            } else if (block && this.check_token(tokens.BlockSequenceStartToken)) {\n              end_mark = this.peek_token().end_mark;\n              event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark, false);\n              this.state = 'parse_block_sequence_first_entry';\n            } else if (block && this.check_token(tokens.BlockMappingStartToken)) {\n              end_mark = this.peek_token().end_mark;\n              event = new events.MappingStartEvent(anchor, tag, implicit, start_mark, end_mark, false);\n              this.state = 'parse_block_mapping_first_key';\n            } else if (anchor !== null || tag !== null) {\n              // Empty scalars are allowed even if a tag or an anchor is specified.\n              event = new events.ScalarEvent(anchor, tag, [implicit, false], '', start_mark, end_mark);\n              this.state = this.states.pop();\n            } else {\n              if (block) {\n                node = 'block';\n              } else {\n                node = 'flow';\n              }\n              token = this.peek_token();\n              throw new exports.ParserError(`while parsing a ${node} node`, start_mark, `expected the node content, but found ${token.id}`, token.start_mark);\n            }\n          }\n        }\n        return event;\n      }\n\n      // block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)*\n      //   BLOCK-END\n      parse_block_sequence_first_entry() {\n        var token;\n        token = this.get_token();\n        this.marks.push(token.start_mark);\n        return this.parse_block_sequence_entry();\n      }\n\n      parse_block_sequence_entry() {\n        var event, token;\n        if (this.check_token(tokens.BlockEntryToken)) {\n          token = this.get_token();\n          if (!this.check_token(tokens.BlockEntryToken, tokens.BlockEndToken)) {\n            this.states.push('parse_block_sequence_entry');\n            return this.parse_block_node();\n          } else {\n            this.state = 'parse_block_sequence_entry';\n            return this.process_empty_scalar(token.end_mark);\n          }\n        }\n        if (!this.check_token(tokens.BlockEndToken)) {\n          token = this.peek_token();\n          throw new exports.ParserError('while parsing a block collection', this.marks.slice(-1)[0], `expected <block end>, but found ${token.id}`, token.start_mark);\n        }\n        token = this.get_token();\n        event = new events.SequenceEndEvent(token.start_mark, token.end_mark);\n        this.state = this.states.pop();\n        this.marks.pop();\n        return event;\n      }\n\n      // indentless_sequence ::= (BLOCK-ENTRY block_node?)+\n      parse_indentless_sequence_entry() {\n        var event, token;\n        if (this.check_token(tokens.BlockEntryToken)) {\n          token = this.get_token();\n          if (!this.check_token(tokens.BlockEntryToken, tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {\n            this.states.push('parse_indentless_sequence_entry');\n            return this.parse_block_node();\n          } else {\n            this.state = 'parse_indentless_sequence_entry';\n            return this.process_empty_scalar(token.end_mark);\n          }\n        }\n        token = this.peek_token();\n        event = new events.SequenceEndEvent(token.start_mark, token.start_mark);\n        this.state = this.states.pop();\n        return event;\n      }\n\n      // block_mapping ::= BLOCK-MAPPING-START\n      //   ((KEY block_node_or_indentless_sequence?)?\n      //   (VALUE block_node_or_indentless_sequence?)?)* BLOCK-END\n      parse_block_mapping_first_key() {\n        var token;\n        token = this.get_token();\n        this.marks.push(token.start_mark);\n        return this.parse_block_mapping_key();\n      }\n\n      parse_block_mapping_key() {\n        var event, token;\n        if (this.check_token(tokens.KeyToken)) {\n          token = this.get_token();\n          if (!this.check_token(tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {\n            this.states.push('parse_block_mapping_value');\n            return this.parse_block_node_or_indentless_sequence();\n          } else {\n            this.state = 'parse_block_mapping_value';\n            return this.process_empty_scalar(token.end_mark);\n          }\n        }\n        if (!this.check_token(tokens.BlockEndToken)) {\n          token = this.peek_token();\n          throw new exports.ParserError('while parsing a block mapping', this.marks.slice(-1)[0], `expected <block end>, but found ${token.id}`, token.start_mark);\n        }\n        token = this.get_token();\n        event = new events.MappingEndEvent(token.start_mark, token.end_mark);\n        this.state = this.states.pop();\n        this.marks.pop();\n        return event;\n      }\n\n      parse_block_mapping_value() {\n        var token;\n        if (this.check_token(tokens.ValueToken)) {\n          token = this.get_token();\n          if (!this.check_token(tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {\n            this.states.push('parse_block_mapping_key');\n            return this.parse_block_node_or_indentless_sequence();\n          } else {\n            this.state = 'parse_block_mapping_key';\n            return this.process_empty_scalar(token.end_mark);\n          }\n        } else {\n          this.state = 'parse_block_mapping_key';\n          token = this.peek_token();\n          return this.process_empty_scalar(token.start_mark);\n        }\n      }\n\n      // flow_sequence ::= FLOW-SEQUENCE-START\n      //   (flow_sequence_entry FLOW-ENTRY)* flow_sequence_entry? FLOW-SEQUENCE-END\n      // flow_sequence_entry ::= flow_node | KEY flow_node? (VALUE flow_node?)?\n\n      // Note that while production rules for both flow_sequence_entry and\n      // flow_mapping_entry are equal, their interpretations are different.  For\n      // `flow_sequence_entry`, the part `KEY flow_node? (VALUE flow_node?)?`\n      // generate an inline mapping (set syntax).\n      parse_flow_sequence_first_entry() {\n        var token;\n        token = this.get_token();\n        this.marks.push(token.start_mark);\n        return this.parse_flow_sequence_entry(true);\n      }\n\n      parse_flow_sequence_entry(first = false) {\n        var event, token;\n        if (!this.check_token(tokens.FlowSequenceEndToken)) {\n          if (!first) {\n            if (this.check_token(tokens.FlowEntryToken)) {\n              this.get_token();\n            } else {\n              token = this.peek_token();\n              throw new exports.ParserError('while parsing a flow sequence', this.marks.slice(-1)[0], `expected ',' or ']', but got ${token.id}`, token.start_mark);\n            }\n          }\n          if (this.check_token(tokens.KeyToken)) {\n            token = this.peek_token();\n            event = new events.MappingStartEvent(null, null, true, token.start_mark, token.end_mark, true);\n            this.state = 'parse_flow_sequence_entry_mapping_key';\n            return event;\n          } else if (!this.check_token(tokens.FlowSequenceEndToken)) {\n            this.states.push('parse_flow_sequence_entry');\n            return this.parse_flow_node();\n          }\n        }\n        token = this.get_token();\n        event = new events.SequenceEndEvent(token.start_mark, token.end_mark);\n        this.state = this.states.pop();\n        this.marks.pop();\n        return event;\n      }\n\n      parse_flow_sequence_entry_mapping_key() {\n        var token;\n        token = this.get_token();\n        if (!this.check_token(tokens.ValueToken, tokens.FlowEntryToken, tokens.FlowSequenceEndToken)) {\n          this.states.push('parse_flow_sequence_entry_mapping_value');\n          return this.parse_flow_node();\n        } else {\n          this.state = 'parse_flow_sequence_entry_mapping_value';\n          return this.process_empty_scalar(token.end_mark);\n        }\n      }\n\n      parse_flow_sequence_entry_mapping_value() {\n        var token;\n        if (this.check_token(tokens.ValueToken)) {\n          token = this.get_token();\n          if (!this.check_token(tokens.FlowEntryToken, tokens.FlowSequenceEndToken)) {\n            this.states.push('parse_flow_sequence_entry_mapping_end');\n            return this.parse_flow_node();\n          } else {\n            this.state = 'parse_flow_sequence_entry_mapping_end';\n            return this.process_empty_scalar(token.end_mark);\n          }\n        } else {\n          this.state = 'parse_flow_sequence_entry_mapping_end';\n          token = this.peek_token();\n          return this.process_empty_scalar(token.start_mark);\n        }\n      }\n\n      parse_flow_sequence_entry_mapping_end() {\n        var token;\n        this.state = 'parse_flow_sequence_entry';\n        token = this.peek_token();\n        return new events.MappingEndEvent(token.start_mark, token.start_mark);\n      }\n\n      // flow_mapping ::= FLOW-MAPPING-START (flow_mapping_entry FLOW-ENTRY)*\n      //   flow_mapping_entry? FLOW-MAPPING-END\n      // flow_mapping_entry ::= flow_node | KEY flow_node? (VALUE flow_node?)?\n      parse_flow_mapping_first_key() {\n        var token;\n        token = this.get_token();\n        this.marks.push(token.start_mark);\n        return this.parse_flow_mapping_key(true);\n      }\n\n      parse_flow_mapping_key(first = false) {\n        var event, token;\n        if (!this.check_token(tokens.FlowMappingEndToken)) {\n          if (!first) {\n            if (this.check_token(tokens.FlowEntryToken)) {\n              this.get_token();\n            } else {\n              token = this.peek_token();\n              throw new exports.ParserError('while parsing a flow mapping', this.marks.slice(-1)[0], `expected ',' or '}', but got ${token.id}`, token.start_mark);\n            }\n          }\n          if (this.check_token(tokens.KeyToken)) {\n            token = this.get_token();\n            if (!this.check_token(tokens.ValueToken, tokens.FlowEntryToken, tokens.FlowMappingEndToken)) {\n              this.states.push('parse_flow_mapping_value');\n              return this.parse_flow_node();\n            } else {\n              this.state = 'parse_flow_mapping_value';\n              return this.process_empty_scalar(token.end_mark);\n            }\n          } else if (!this.check_token(tokens.FlowMappingEndToken)) {\n            this.states.push('parse_flow_mapping_empty_value');\n            return this.parse_flow_node();\n          }\n        }\n        token = this.get_token();\n        event = new events.MappingEndEvent(token.start_mark, token.end_mark);\n        this.state = this.states.pop();\n        this.marks.pop();\n        return event;\n      }\n\n      parse_flow_mapping_value() {\n        var token;\n        if (this.check_token(tokens.ValueToken)) {\n          token = this.get_token();\n          if (!this.check_token(tokens.FlowEntryToken, tokens.FlowMappingEndToken)) {\n            this.states.push('parse_flow_mapping_key');\n            return this.parse_flow_node();\n          } else {\n            this.state = 'parse_flow_mapping_key';\n            return this.process_empty_scalar(token.end_mark);\n          }\n        } else {\n          this.state = 'parse_flow_mapping_key';\n          token = this.peek_token();\n          return this.process_empty_scalar(token.start_mark);\n        }\n      }\n\n      parse_flow_mapping_empty_value() {\n        this.state = 'parse_flow_mapping_key';\n        return this.process_empty_scalar(this.peek_token().start_mark);\n      }\n\n      process_empty_scalar(mark) {\n        return new events.ScalarEvent(null, null, [true, false], '', mark, mark);\n      }\n\n    };\n\n    DEFAULT_TAGS = {\n      '!': '!',\n      '!!': 'tag:yaml.org,2002:'\n    };\n\n    ctor = Parser.prototype.initialise;\n\n    return Parser;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLFdBQVcsbUJBQU8sQ0FBQyxFQUFVOztBQUU3QixJQUFJLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsR0FBVTs7QUFFekMsV0FBVyxtQkFBTyxDQUFDLEdBQVU7O0FBRTdCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsdUJBQXVCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILE9BQU87QUFDdkg7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE1BQU0sMkRBQTJELFNBQVM7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSxTQUFTO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSUFBcUksU0FBUztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esc0lBQXNJLFNBQVM7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esd0hBQXdILGFBQWEsU0FBUztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy95YW1sLWpzL2xpYi9wYXJzZXIuanM/YWMwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIGV2ZW50cywgdG9rZW5zLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBldmVudHMgPSByZXF1aXJlKCcuL2V2ZW50cycpO1xuXG4gICh7TWFya2VkWUFNTEVycm9yfSA9IHJlcXVpcmUoJy4vZXJyb3JzJykpO1xuXG4gIHRva2VucyA9IHJlcXVpcmUoJy4vdG9rZW5zJyk7XG5cbiAgdGhpcy5QYXJzZXJFcnJvciA9IGNsYXNzIFBhcnNlckVycm9yIGV4dGVuZHMgTWFya2VkWUFNTEVycm9yIHt9O1xuXG4gIHRoaXMuUGFyc2VyID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBERUZBVUxUX1RBR1MsIGN0b3I7XG5cbiAgICBjbGFzcyBQYXJzZXIge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudF9ldmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMueWFtbF92ZXJzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWdfaGFuZGxlcyA9IHt9O1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLm1hcmtzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gJ3BhcnNlX3N0cmVhbV9zdGFydCc7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBSZXNldCB0aGUgc3RhdGUgYXR0cmlidXRlcy5cbiAgICAgICovXG4gICAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBDaGVjayB0aGUgdHlwZSBvZiB0aGUgbmV4dCBldmVudC5cbiAgICAgICovXG4gICAgICBjaGVja19ldmVudCguLi5jaG9pY2VzKSB7XG4gICAgICAgIHZhciBjaG9pY2UsIGksIGxlbjtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudF9ldmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9ldmVudCA9IHRoaXNbdGhpcy5zdGF0ZV0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudF9ldmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChjaG9pY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNob2ljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNob2ljZSA9IGNob2ljZXNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50X2V2ZW50IGluc3RhbmNlb2YgY2hvaWNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBHZXQgdGhlIG5leHQgZXZlbnQuXG4gICAgICAqL1xuICAgICAgcGVla19ldmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudF9ldmVudCA9PT0gbnVsbCAmJiAodGhpcy5zdGF0ZSAhPSBudWxsKSkge1xuICAgICAgICAgIHRoaXMuY3VycmVudF9ldmVudCA9IHRoaXNbdGhpcy5zdGF0ZV0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50X2V2ZW50O1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgR2V0IHRoZSBldmVudCBhbmQgcHJvY2VlZCBmdXJ0aGVyLlxuICAgICAgKi9cbiAgICAgIGdldF9ldmVudCgpIHtcbiAgICAgICAgdmFyIGV2ZW50O1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50X2V2ZW50ID09PSBudWxsICYmICh0aGlzLnN0YXRlICE9IG51bGwpKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50X2V2ZW50ID0gdGhpc1t0aGlzLnN0YXRlXSgpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50ID0gdGhpcy5jdXJyZW50X2V2ZW50O1xuICAgICAgICB0aGlzLmN1cnJlbnRfZXZlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0cmVhbSA6Oj0gU1RSRUFNLVNUQVJUIGltcGxpY2l0X2RvY3VtZW50PyBleHBsaWNpdF9kb2N1bWVudCogU1RSRUFNLUVORFxuICAgICAgLy8gaW1wbGljaXRfZG9jdW1lbnQgOjo9IGJsb2NrX25vZGUgRE9DVU1FTlQtRU5EKlxuICAgICAgLy8gZXhwbGljaXRfZG9jdW1lbnQgOjo9IERJUkVDVElWRSogRE9DVU1FTlQtU1RBUlQgYmxvY2tfbm9kZT8gRE9DVU1FTlQtRU5EKlxuICAgICAgLypcbiAgICAgIFBhcnNlIHRoZSBzdHJlYW0gc3RhcnQuXG4gICAgICAqL1xuICAgICAgcGFyc2Vfc3RyZWFtX3N0YXJ0KCkge1xuICAgICAgICB2YXIgZXZlbnQsIHRva2VuO1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TdHJlYW1TdGFydEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgbmV4dCBzdGF0ZSxcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9pbXBsaWNpdF9kb2N1bWVudF9zdGFydCc7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFBhcnNlIGFuIGltcGxpY2l0IGRvY3VtZW50LlxuICAgICAgKi9cbiAgICAgIHBhcnNlX2ltcGxpY2l0X2RvY3VtZW50X3N0YXJ0KCkge1xuICAgICAgICB2YXIgZW5kX21hcmssIGV2ZW50LCBzdGFydF9tYXJrLCB0b2tlbjtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5EaXJlY3RpdmVUb2tlbiwgdG9rZW5zLkRvY3VtZW50U3RhcnRUb2tlbiwgdG9rZW5zLlN0cmVhbUVuZFRva2VuKSkge1xuICAgICAgICAgIHRoaXMudGFnX2hhbmRsZXMgPSBERUZBVUxUX1RBR1M7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgICBzdGFydF9tYXJrID0gZW5kX21hcmsgPSB0b2tlbi5zdGFydF9tYXJrO1xuICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5Eb2N1bWVudFN0YXJ0RXZlbnQoc3RhcnRfbWFyaywgZW5kX21hcmssIGZhbHNlKTtcbiAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBuZXh0IHN0YXRlXG4gICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZG9jdW1lbnRfZW5kJyk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9ibG9ja19ub2RlJztcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZG9jdW1lbnRfc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgUGFyc2UgYW4gZXhwbGljaXQgZG9jdW1lbnQuXG4gICAgICAqL1xuICAgICAgcGFyc2VfZG9jdW1lbnRfc3RhcnQoKSB7XG4gICAgICAgIHZhciBlbmRfbWFyaywgZXZlbnQsIHN0YXJ0X21hcmssIHRhZ3MsIHRva2VuLCB2ZXJzaW9uO1xuICAgICAgICB3aGlsZSAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRG9jdW1lbnRFbmRUb2tlbikpIHtcbiAgICAgICAgICAvLyBQYXJzZSBhbnkgZXh0cmEgZG9jdW1lbnQgZW5kIGluZGljYXRvcnNcbiAgICAgICAgICB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuU3RyZWFtRW5kVG9rZW4pKSB7XG4gICAgICAgICAgc3RhcnRfbWFyayA9IHRoaXMucGVla190b2tlbigpLnN0YXJ0X21hcms7XG4gICAgICAgICAgW3ZlcnNpb24sIHRhZ3NdID0gdGhpcy5wcm9jZXNzX2RpcmVjdGl2ZXMoKTtcbiAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkRvY3VtZW50U3RhcnRUb2tlbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKGBleHBlY3RlZCAnPGRvY3VtZW50IHN0YXJ0PicsIGJ1dCBmb3VuZCAkeyh0aGlzLnBlZWtfdG9rZW4oKS5pZCl9YCwgdGhpcy5wZWVrX3Rva2VuKCkuc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5Eb2N1bWVudFN0YXJ0RXZlbnQoc3RhcnRfbWFyaywgZW5kX21hcmssIHRydWUsIHZlcnNpb24sIHRhZ3MpO1xuICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2RvY3VtZW50X2VuZCcpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZG9jdW1lbnRfY29udGVudCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFyc2UgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICBldmVudCA9IG5ldyBldmVudHMuU3RyZWFtRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmspO1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzZXJ0aW9uIGVycm9yLCBzdGF0ZXMgc2hvdWxkIGJlIGVtcHR5Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm1hcmtzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NlcnRpb24gZXJyb3IsIG1hcmtzIHNob3VsZCBiZSBlbXB0eScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBQYXJzZSB0aGUgZG9jdW1lbnQgZW5kLlxuICAgICAgKi9cbiAgICAgIHBhcnNlX2RvY3VtZW50X2VuZCgpIHtcbiAgICAgICAgdmFyIGVuZF9tYXJrLCBldmVudCwgZXhwbGljaXQsIHN0YXJ0X21hcmssIHRva2VuO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICBzdGFydF9tYXJrID0gZW5kX21hcmsgPSB0b2tlbi5zdGFydF9tYXJrO1xuICAgICAgICBleHBsaWNpdCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRG9jdW1lbnRFbmRUb2tlbikpIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgZW5kX21hcmsgPSB0b2tlbi5lbmRfbWFyaztcbiAgICAgICAgICBleHBsaWNpdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLkRvY3VtZW50RW5kRXZlbnQoc3RhcnRfbWFyaywgZW5kX21hcmssIGV4cGxpY2l0KTtcbiAgICAgICAgLy8gUHJlcGFyZSBuZXh0IHN0YXRlLlxuICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2RvY3VtZW50X3N0YXJ0JztcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuXG4gICAgICBwYXJzZV9kb2N1bWVudF9jb250ZW50KCkge1xuICAgICAgICB2YXIgZXZlbnQ7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5EaXJlY3RpdmVUb2tlbiwgdG9rZW5zLkRvY3VtZW50U3RhcnRUb2tlbiwgdG9rZW5zLkRvY3VtZW50RW5kVG9rZW4sIHRva2Vucy5TdHJlYW1FbmRUb2tlbikpIHtcbiAgICAgICAgICBldmVudCA9IHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodGhpcy5wZWVrX3Rva2VuKCkuc3RhcnRfbWFyayk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9ibG9ja19ub2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvY2Vzc19kaXJlY3RpdmVzKCkge1xuICAgICAgICB2YXIgaGFuZGxlLCBtYWpvciwgbWlub3IsIHByZWZpeCwgcmVmLCB0YWdfaGFuZGxlc19jb3B5LCB0b2tlbiwgdmFsdWU7XG4gICAgICAgIHRoaXMueWFtbF92ZXJzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWdfaGFuZGxlcyA9IHt9O1xuICAgICAgICB3aGlsZSAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRGlyZWN0aXZlVG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIGlmICh0b2tlbi5uYW1lID09PSAnWUFNTCcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnlhbWxfdmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcihudWxsLCBudWxsLCAnZm91bmQgZHVwbGljYXRlIFlBTUwgZGlyZWN0aXZlJywgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbbWFqb3IsIG1pbm9yXSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgaWYgKG1ham9yICE9PSAxKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKG51bGwsIG51bGwsICdmb3VuZCBpbmNvbXBhdGlibGUgWUFNTCBkb2N1bWVudCAodmVyc2lvbiAxLiogaXMgcmVxdWlyZWQpJywgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnlhbWxfdmVyc2lvbiA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4ubmFtZSA9PT0gJ1RBRycpIHtcbiAgICAgICAgICAgIFtoYW5kbGUsIHByZWZpeF0gPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgaW4gdGhpcy50YWdfaGFuZGxlcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcihudWxsLCBudWxsLCBgZHVwbGljYXRlIHRhZyBoYW5kbGUgJHtoYW5kbGV9YCwgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRhZ19oYW5kbGVzW2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhZ19oYW5kbGVzX2NvcHkgPSBudWxsO1xuICAgICAgICByZWYgPSB0aGlzLnRhZ19oYW5kbGVzO1xuICAgICAgICBmb3IgKGhhbmRsZSBpbiByZWYpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGhhbmRsZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIHByZWZpeCA9IHJlZltoYW5kbGVdO1xuICAgICAgICAgIGlmICh0YWdfaGFuZGxlc19jb3B5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRhZ19oYW5kbGVzX2NvcHkgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFnX2hhbmRsZXNfY29weVtoYW5kbGVdID0gcHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gW3RoaXMueWFtbF92ZXJzaW9uLCB0YWdfaGFuZGxlc19jb3B5XTtcbiAgICAgICAgZm9yIChoYW5kbGUgaW4gREVGQVVMVF9UQUdTKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwoREVGQVVMVF9UQUdTLCBoYW5kbGUpKSBjb250aW51ZTtcbiAgICAgICAgICBwcmVmaXggPSBERUZBVUxUX1RBR1NbaGFuZGxlXTtcbiAgICAgICAgICBpZiAoIShwcmVmaXggaW4gdGhpcy50YWdfaGFuZGxlcykpIHtcbiAgICAgICAgICAgIHRoaXMudGFnX2hhbmRsZXNbaGFuZGxlXSA9IHByZWZpeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBibG9ja19ub2RlX29yX2luZGVudGxlc3Nfc2VxdWVuY2UgOjo9IEFMSUFTXG4gICAgICAvLyAgIHwgcHJvcGVydGllcyAoYmxvY2tfY29udGVudCB8IGluZGVudGxlc3Nfc2VxdWVuY2UpP1xuICAgICAgLy8gICB8IGJsb2NrX2NvbnRlbnRcbiAgICAgIC8vICAgfCBpbmRlbnRsZXNzX2Jsb2NrX3NlcXVlbmNlXG4gICAgICAvLyBibG9ja19ub2RlIDo6PSBBTElBU1xuICAgICAgLy8gICB8IHByb3BlcnRpZXMgYmxvY2tfY29udGVudD9cbiAgICAgIC8vICAgfCBibG9ja19jb250ZW50XG4gICAgICAvLyBmbG93X25vZGUgOjo9IEFMSUFTXG4gICAgICAvLyAgIHwgcHJvcGVydGllcyBmbG93X2NvbnRlbnQ/XG4gICAgICAvLyAgIHwgZmxvd19jb250ZW50XG4gICAgICAvLyBwcm9wZXJ0aWVzIDo6PSBUQUcgQU5DSE9SPyB8IEFOQ0hPUiBUQUc/XG4gICAgICAvLyBibG9ja19jb250ZW50IDo6PSBibG9ja19jb2xsZWN0aW9uIHwgZmxvd19jb2xsZWN0aW9uIHwgU0NBTEFSXG4gICAgICAvLyBmbG93X2NvbnRlbnQgOjo9IGZsb3dfY29sbGVjdGlvbiB8IFNDQUxBUlxuICAgICAgLy8gYmxvY2tfY29sbGVjdGlvbiA6Oj0gYmxvY2tfc2VxdWVuY2UgfCBibG9ja19tYXBwaW5nXG4gICAgICAvLyBmbG93X2NvbGxlY3Rpb24gOjo9IGZsb3dfc2VxdWVuY2UgfCBmbG93X21hcHBpbmdcbiAgICAgIHBhcnNlX2Jsb2NrX25vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlX25vZGUodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlX2Zsb3dfbm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2Vfbm9kZSgpO1xuICAgICAgfVxuXG4gICAgICBwYXJzZV9ibG9ja19ub2RlX29yX2luZGVudGxlc3Nfc2VxdWVuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlX25vZGUodHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlX25vZGUoYmxvY2sgPSBmYWxzZSwgaW5kZW50bGVzc19zZXF1ZW5jZSA9IGZhbHNlKSB7XG4gICAgICAgIHZhciBhbmNob3IsIGVuZF9tYXJrLCBldmVudCwgaGFuZGxlLCBpbXBsaWNpdCwgbm9kZSwgc3RhcnRfbWFyaywgc3VmZml4LCB0YWcsIHRhZ19tYXJrLCB0b2tlbjtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkFsaWFzVG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5BbGlhc0V2ZW50KHRva2VuLnZhbHVlLCB0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuY2hvciA9IG51bGw7XG4gICAgICAgICAgdGFnID0gbnVsbDtcbiAgICAgICAgICBzdGFydF9tYXJrID0gZW5kX21hcmsgPSB0YWdfbWFyayA9IG51bGw7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkFuY2hvclRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgICAgc3RhcnRfbWFyayA9IHRva2VuLnN0YXJ0X21hcms7XG4gICAgICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICAgICAgYW5jaG9yID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuVGFnVG9rZW4pKSB7XG4gICAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICAgICAgdGFnX21hcmsgPSB0b2tlbi5zdGFydF9tYXJrO1xuICAgICAgICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICAgICAgICB0YWcgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlRhZ1Rva2VuKSkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgICAgc3RhcnRfbWFyayA9IHRhZ19tYXJrID0gdG9rZW4uc3RhcnRfbWFyaztcbiAgICAgICAgICAgIGVuZF9tYXJrID0gdG9rZW4uZW5kX21hcms7XG4gICAgICAgICAgICB0YWcgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5BbmNob3JUb2tlbikpIHtcbiAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICAgICAgICBhbmNob3IgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgW2hhbmRsZSwgc3VmZml4XSA9IHRhZztcbiAgICAgICAgICAgIGlmIChoYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaGFuZGxlIGluIHRoaXMudGFnX2hhbmRsZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IoJ3doaWxlIHBhcnNpbmcgYSBub2RlJywgc3RhcnRfbWFyaywgYGZvdW5kIHVuZGVmaW5lZCB0YWcgaGFuZGxlICR7aGFuZGxlfWAsIHRhZ19tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YWcgPSB0aGlzLnRhZ19oYW5kbGVzW2hhbmRsZV0gKyBzdWZmaXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YWcgPSBzdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydF9tYXJrID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydF9tYXJrID0gZW5kX21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5zdGFydF9tYXJrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudCA9IG51bGw7XG4gICAgICAgICAgaW1wbGljaXQgPSB0YWcgPT09IG51bGwgfHwgdGFnID09PSAnISc7XG4gICAgICAgICAgaWYgKGluZGVudGxlc3Nfc2VxdWVuY2UgJiYgdGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tFbnRyeVRva2VuKSkge1xuICAgICAgICAgICAgZW5kX21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5lbmRfbWFyaztcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TZXF1ZW5jZVN0YXJ0RXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCBzdGFydF9tYXJrLCBlbmRfbWFyayk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2luZGVudGxlc3Nfc2VxdWVuY2VfZW50cnknO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuU2NhbGFyVG9rZW4pKSB7XG4gICAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICAgICAgZW5kX21hcmsgPSB0b2tlbi5lbmRfbWFyaztcbiAgICAgICAgICAgICAgaWYgKCh0b2tlbi5wbGFpbiAmJiB0YWcgPT09IG51bGwpIHx8IHRhZyA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgaW1wbGljaXQgPSBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltcGxpY2l0ID0gW2ZhbHNlLCB0cnVlXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbXBsaWNpdCA9IFtmYWxzZSwgZmFsc2VdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TY2FsYXJFdmVudChhbmNob3IsIHRhZywgaW1wbGljaXQsIHRva2VuLnZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgdG9rZW4uc3R5bGUpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dTZXF1ZW5jZVN0YXJ0VG9rZW4pKSB7XG4gICAgICAgICAgICAgIGVuZF9tYXJrID0gdGhpcy5wZWVrX3Rva2VuKCkuZW5kX21hcms7XG4gICAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TZXF1ZW5jZVN0YXJ0RXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCBzdGFydF9tYXJrLCBlbmRfbWFyaywgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19zZXF1ZW5jZV9maXJzdF9lbnRyeSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dNYXBwaW5nU3RhcnRUb2tlbikpIHtcbiAgICAgICAgICAgICAgZW5kX21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5lbmRfbWFyaztcbiAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLk1hcHBpbmdTdGFydEV2ZW50KGFuY2hvciwgdGFnLCBpbXBsaWNpdCwgc3RhcnRfbWFyaywgZW5kX21hcmssIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfbWFwcGluZ19maXJzdF9rZXknO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jayAmJiB0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja1NlcXVlbmNlU3RhcnRUb2tlbikpIHtcbiAgICAgICAgICAgICAgZW5kX21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5lbmRfbWFyaztcbiAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNlcXVlbmNlU3RhcnRFdmVudChhbmNob3IsIHRhZywgaW1wbGljaXQsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfYmxvY2tfc2VxdWVuY2VfZmlyc3RfZW50cnknO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jayAmJiB0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja01hcHBpbmdTdGFydFRva2VuKSkge1xuICAgICAgICAgICAgICBlbmRfbWFyayA9IHRoaXMucGVla190b2tlbigpLmVuZF9tYXJrO1xuICAgICAgICAgICAgICBldmVudCA9IG5ldyBldmVudHMuTWFwcGluZ1N0YXJ0RXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCBzdGFydF9tYXJrLCBlbmRfbWFyaywgZmFsc2UpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Jsb2NrX21hcHBpbmdfZmlyc3Rfa2V5JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yICE9PSBudWxsIHx8IHRhZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBFbXB0eSBzY2FsYXJzIGFyZSBhbGxvd2VkIGV2ZW4gaWYgYSB0YWcgb3IgYW4gYW5jaG9yIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNjYWxhckV2ZW50KGFuY2hvciwgdGFnLCBbaW1wbGljaXQsIGZhbHNlXSwgJycsIHN0YXJ0X21hcmssIGVuZF9tYXJrKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9ICdibG9jayc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9ICdmbG93JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcihgd2hpbGUgcGFyc2luZyBhICR7bm9kZX0gbm9kZWAsIHN0YXJ0X21hcmssIGBleHBlY3RlZCB0aGUgbm9kZSBjb250ZW50LCBidXQgZm91bmQgJHt0b2tlbi5pZH1gLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBibG9ja19zZXF1ZW5jZSA6Oj0gQkxPQ0stU0VRVUVOQ0UtU1RBUlQgKEJMT0NLLUVOVFJZIGJsb2NrX25vZGU/KSpcbiAgICAgIC8vICAgQkxPQ0stRU5EXG4gICAgICBwYXJzZV9ibG9ja19zZXF1ZW5jZV9maXJzdF9lbnRyeSgpIHtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIHRoaXMubWFya3MucHVzaCh0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfYmxvY2tfc2VxdWVuY2VfZW50cnkoKTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VfYmxvY2tfc2VxdWVuY2VfZW50cnkoKSB7XG4gICAgICAgIHZhciBldmVudCwgdG9rZW47XG4gICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja0VudHJ5VG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tFbnRyeVRva2VuLCB0b2tlbnMuQmxvY2tFbmRUb2tlbikpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Jsb2NrX3NlcXVlbmNlX2VudHJ5Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9ibG9ja19ub2RlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfYmxvY2tfc2VxdWVuY2VfZW50cnknO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcignd2hpbGUgcGFyc2luZyBhIGJsb2NrIGNvbGxlY3Rpb24nLCB0aGlzLm1hcmtzLnNsaWNlKC0xKVswXSwgYGV4cGVjdGVkIDxibG9jayBlbmQ+LCBidXQgZm91bmQgJHt0b2tlbi5pZH1gLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TZXF1ZW5jZUVuZEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgICB0aGlzLm1hcmtzLnBvcCgpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGluZGVudGxlc3Nfc2VxdWVuY2UgOjo9IChCTE9DSy1FTlRSWSBibG9ja19ub2RlPykrXG4gICAgICBwYXJzZV9pbmRlbnRsZXNzX3NlcXVlbmNlX2VudHJ5KCkge1xuICAgICAgICB2YXIgZXZlbnQsIHRva2VuO1xuICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tFbnRyeVRva2VuKSkge1xuICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrRW50cnlUb2tlbiwgdG9rZW5zLktleVRva2VuLCB0b2tlbnMuVmFsdWVUb2tlbiwgdG9rZW5zLkJsb2NrRW5kVG9rZW4pKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9pbmRlbnRsZXNzX3NlcXVlbmNlX2VudHJ5Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9ibG9ja19ub2RlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfaW5kZW50bGVzc19zZXF1ZW5jZV9lbnRyeSc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TZXF1ZW5jZUVuZEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cblxuICAgICAgLy8gYmxvY2tfbWFwcGluZyA6Oj0gQkxPQ0stTUFQUElORy1TVEFSVFxuICAgICAgLy8gICAoKEtFWSBibG9ja19ub2RlX29yX2luZGVudGxlc3Nfc2VxdWVuY2U/KT9cbiAgICAgIC8vICAgKFZBTFVFIGJsb2NrX25vZGVfb3JfaW5kZW50bGVzc19zZXF1ZW5jZT8pPykqIEJMT0NLLUVORFxuICAgICAgcGFyc2VfYmxvY2tfbWFwcGluZ19maXJzdF9rZXkoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICB0aGlzLm1hcmtzLnB1c2godG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Jsb2NrX21hcHBpbmdfa2V5KCk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlX2Jsb2NrX21hcHBpbmdfa2V5KCkge1xuICAgICAgICB2YXIgZXZlbnQsIHRva2VuO1xuICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuS2V5VG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuS2V5VG9rZW4sIHRva2Vucy5WYWx1ZVRva2VuLCB0b2tlbnMuQmxvY2tFbmRUb2tlbikpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Jsb2NrX21hcHBpbmdfdmFsdWUnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Jsb2NrX25vZGVfb3JfaW5kZW50bGVzc19zZXF1ZW5jZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Jsb2NrX21hcHBpbmdfdmFsdWUnO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcignd2hpbGUgcGFyc2luZyBhIGJsb2NrIG1hcHBpbmcnLCB0aGlzLm1hcmtzLnNsaWNlKC0xKVswXSwgYGV4cGVjdGVkIDxibG9jayBlbmQ+LCBidXQgZm91bmQgJHt0b2tlbi5pZH1gLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5NYXBwaW5nRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmspO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIHRoaXMubWFya3MucG9wKCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cblxuICAgICAgcGFyc2VfYmxvY2tfbWFwcGluZ192YWx1ZSgpIHtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuVmFsdWVUb2tlbikpIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5LZXlUb2tlbiwgdG9rZW5zLlZhbHVlVG9rZW4sIHRva2Vucy5CbG9ja0VuZFRva2VuKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfYmxvY2tfbWFwcGluZ19rZXknKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Jsb2NrX25vZGVfb3JfaW5kZW50bGVzc19zZXF1ZW5jZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Jsb2NrX21hcHBpbmdfa2V5JztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9ibG9ja19tYXBwaW5nX2tleSc7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmbG93X3NlcXVlbmNlIDo6PSBGTE9XLVNFUVVFTkNFLVNUQVJUXG4gICAgICAvLyAgIChmbG93X3NlcXVlbmNlX2VudHJ5IEZMT1ctRU5UUlkpKiBmbG93X3NlcXVlbmNlX2VudHJ5PyBGTE9XLVNFUVVFTkNFLUVORFxuICAgICAgLy8gZmxvd19zZXF1ZW5jZV9lbnRyeSA6Oj0gZmxvd19ub2RlIHwgS0VZIGZsb3dfbm9kZT8gKFZBTFVFIGZsb3dfbm9kZT8pP1xuXG4gICAgICAvLyBOb3RlIHRoYXQgd2hpbGUgcHJvZHVjdGlvbiBydWxlcyBmb3IgYm90aCBmbG93X3NlcXVlbmNlX2VudHJ5IGFuZFxuICAgICAgLy8gZmxvd19tYXBwaW5nX2VudHJ5IGFyZSBlcXVhbCwgdGhlaXIgaW50ZXJwcmV0YXRpb25zIGFyZSBkaWZmZXJlbnQuICBGb3JcbiAgICAgIC8vIGBmbG93X3NlcXVlbmNlX2VudHJ5YCwgdGhlIHBhcnQgYEtFWSBmbG93X25vZGU/IChWQUxVRSBmbG93X25vZGU/KT9gXG4gICAgICAvLyBnZW5lcmF0ZSBhbiBpbmxpbmUgbWFwcGluZyAoc2V0IHN5bnRheCkuXG4gICAgICBwYXJzZV9mbG93X3NlcXVlbmNlX2ZpcnN0X2VudHJ5KCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgdGhpcy5tYXJrcy5wdXNoKHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5KHRydWUpO1xuICAgICAgfVxuXG4gICAgICBwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5KGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGV2ZW50LCB0b2tlbjtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93U2VxdWVuY2VFbmRUb2tlbikpIHtcbiAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd0VudHJ5VG9rZW4pKSB7XG4gICAgICAgICAgICAgIHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcignd2hpbGUgcGFyc2luZyBhIGZsb3cgc2VxdWVuY2UnLCB0aGlzLm1hcmtzLnNsaWNlKC0xKVswXSwgYGV4cGVjdGVkICcsJyBvciAnXScsIGJ1dCBnb3QgJHt0b2tlbi5pZH1gLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLktleVRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5NYXBwaW5nU3RhcnRFdmVudChudWxsLCBudWxsLCB0cnVlLCB0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyaywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ19rZXknO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dTZXF1ZW5jZUVuZFRva2VuKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19ub2RlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNlcXVlbmNlRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmspO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIHRoaXMubWFya3MucG9wKCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cblxuICAgICAgcGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX2tleSgpIHtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuVmFsdWVUb2tlbiwgdG9rZW5zLkZsb3dFbnRyeVRva2VuLCB0b2tlbnMuRmxvd1NlcXVlbmNlRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX3ZhbHVlJyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19ub2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfdmFsdWUnO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfdmFsdWUoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlZhbHVlVG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd0VudHJ5VG9rZW4sIHRva2Vucy5GbG93U2VxdWVuY2VFbmRUb2tlbikpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ19lbmQnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Zsb3dfbm9kZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ19lbmQnO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ19lbmQnO1xuICAgICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX2VuZCgpIHtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnknO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICByZXR1cm4gbmV3IGV2ZW50cy5NYXBwaW5nRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICB9XG5cbiAgICAgIC8vIGZsb3dfbWFwcGluZyA6Oj0gRkxPVy1NQVBQSU5HLVNUQVJUIChmbG93X21hcHBpbmdfZW50cnkgRkxPVy1FTlRSWSkqXG4gICAgICAvLyAgIGZsb3dfbWFwcGluZ19lbnRyeT8gRkxPVy1NQVBQSU5HLUVORFxuICAgICAgLy8gZmxvd19tYXBwaW5nX2VudHJ5IDo6PSBmbG93X25vZGUgfCBLRVkgZmxvd19ub2RlPyAoVkFMVUUgZmxvd19ub2RlPyk/XG4gICAgICBwYXJzZV9mbG93X21hcHBpbmdfZmlyc3Rfa2V5KCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgdGhpcy5tYXJrcy5wdXNoKHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9mbG93X21hcHBpbmdfa2V5KHRydWUpO1xuICAgICAgfVxuXG4gICAgICBwYXJzZV9mbG93X21hcHBpbmdfa2V5KGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGV2ZW50LCB0b2tlbjtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93TWFwcGluZ0VuZFRva2VuKSkge1xuICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93RW50cnlUb2tlbikpIHtcbiAgICAgICAgICAgICAgdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKCd3aGlsZSBwYXJzaW5nIGEgZmxvdyBtYXBwaW5nJywgdGhpcy5tYXJrcy5zbGljZSgtMSlbMF0sIGBleHBlY3RlZCAnLCcgb3IgJ30nLCBidXQgZ290ICR7dG9rZW4uaWR9YCwgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5LZXlUb2tlbikpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuVmFsdWVUb2tlbiwgdG9rZW5zLkZsb3dFbnRyeVRva2VuLCB0b2tlbnMuRmxvd01hcHBpbmdFbmRUb2tlbikpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZmxvd19tYXBwaW5nX3ZhbHVlJyk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Zsb3dfbm9kZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X21hcHBpbmdfdmFsdWUnO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd01hcHBpbmdFbmRUb2tlbikpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Zsb3dfbWFwcGluZ19lbXB0eV92YWx1ZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19ub2RlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLk1hcHBpbmdFbmRFdmVudCh0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgdGhpcy5tYXJrcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuXG4gICAgICBwYXJzZV9mbG93X21hcHBpbmdfdmFsdWUoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlZhbHVlVG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd0VudHJ5VG9rZW4sIHRva2Vucy5GbG93TWFwcGluZ0VuZFRva2VuKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZmxvd19tYXBwaW5nX2tleScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19ub2RlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19tYXBwaW5nX2tleSc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19tYXBwaW5nX2tleSc7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXJzZV9mbG93X21hcHBpbmdfZW1wdHlfdmFsdWUoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19tYXBwaW5nX2tleSc7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRoaXMucGVla190b2tlbigpLnN0YXJ0X21hcmspO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzX2VtcHR5X3NjYWxhcihtYXJrKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXZlbnRzLlNjYWxhckV2ZW50KG51bGwsIG51bGwsIFt0cnVlLCBmYWxzZV0sICcnLCBtYXJrLCBtYXJrKTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBERUZBVUxUX1RBR1MgPSB7XG4gICAgICAnISc6ICchJyxcbiAgICAgICchISc6ICd0YWc6eWFtbC5vcmcsMjAwMjonXG4gICAgfTtcblxuICAgIGN0b3IgPSBQYXJzZXIucHJvdG90eXBlLmluaXRpYWxpc2U7XG5cbiAgICByZXR1cm4gUGFyc2VyO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///806\n")},26:function(__unused_webpack_module,exports,__webpack_require__){eval("(function() {\n  var Mark, YAMLError,\n    indexOf = [].indexOf;\n\n  ({Mark, YAMLError} = __webpack_require__(372));\n\n  this.ReaderError = class ReaderError extends YAMLError {\n    constructor(position1, character1, reason) {\n      super();\n      this.position = position1;\n      this.character = character1;\n      this.reason = reason;\n    }\n\n    toString() {\n      return `unacceptable character #${this.character.charCodeAt(0).toString(16)}: ${this.reason}\\n  position ${this.position}`;\n    }\n\n  };\n\n  /*\n  Reader:\n    checks if characters are within the allowed range\n    add '\\x00' to the end\n  */\n  this.Reader = (function() {\n    var NON_PRINTABLE, ctor;\n\n    class Reader {\n      constructor() {\n        return ctor.apply(this, arguments);\n      }\n\n      initialise(string) {\n        this.string = string;\n        this.line = 0;\n        this.column = 0;\n        this.index = 0;\n        this.check_printable();\n        return this.string += '\\x00';\n      }\n\n      peek(index = 0) {\n        return this.string[this.index + index];\n      }\n\n      prefix(length = 1) {\n        return this.string.slice(this.index, this.index + length);\n      }\n\n      forward(length = 1) {\n        var char, results;\n        results = [];\n        while (length) {\n          char = this.string[this.index];\n          this.index++;\n          if (indexOf.call('\\n\\x85\\u2082\\u2029', char) >= 0 || (char === '\\r' && this.string[this.index] !== '\\n')) {\n            this.line++;\n            this.column = 0;\n          } else {\n            this.column++;\n          }\n          results.push(length--);\n        }\n        return results;\n      }\n\n      get_mark() {\n        return new Mark(this.line, this.column, this.string, this.index);\n      }\n\n      check_printable() {\n        var character, match, position;\n        match = NON_PRINTABLE.exec(this.string);\n        if (match) {\n          character = match[0];\n          position = (this.string.length - this.index) + match.index;\n          throw new exports.ReaderError(position, character, 'special characters are not allowed');\n        }\n      }\n\n    };\n\n    NON_PRINTABLE = /[^\\x09\\x0A\\x0D\\x20-\\x7E\\x85\\xA0-\\uFFFD]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/; // Invalid single characters\n    // Missing or invalid low surrogate\n    // Missing or invalid high surrogate\n\n    ctor = Reader.prototype.initialise;\n\n    return Reader;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxHQUFVOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QywwQ0FBMEMsSUFBSSxZQUFZLGVBQWUsY0FBYztBQUMvSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdJQUF3STtBQUN4STtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy95YW1sLWpzL2xpYi9yZWFkZXIuanM/YzM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrLCBZQU1MRXJyb3IsXG4gICAgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbiAgKHtNYXJrLCBZQU1MRXJyb3J9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKSk7XG5cbiAgdGhpcy5SZWFkZXJFcnJvciA9IGNsYXNzIFJlYWRlckVycm9yIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjEsIGNoYXJhY3RlcjEsIHJlYXNvbikge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjE7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IGNoYXJhY3RlcjE7XG4gICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgdW5hY2NlcHRhYmxlIGNoYXJhY3RlciAjJHt0aGlzLmNoYXJhY3Rlci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KX06ICR7dGhpcy5yZWFzb259XFxuICBwb3NpdGlvbiAke3RoaXMucG9zaXRpb259YDtcbiAgICB9XG5cbiAgfTtcblxuICAvKlxuICBSZWFkZXI6XG4gICAgY2hlY2tzIGlmIGNoYXJhY3RlcnMgYXJlIHdpdGhpbiB0aGUgYWxsb3dlZCByYW5nZVxuICAgIGFkZCAnXFx4MDAnIHRvIHRoZSBlbmRcbiAgKi9cbiAgdGhpcy5SZWFkZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIE5PTl9QUklOVEFCTEUsIGN0b3I7XG5cbiAgICBjbGFzcyBSZWFkZXIge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpc2Uoc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLmxpbmUgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmNoZWNrX3ByaW50YWJsZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcgKz0gJ1xceDAwJztcbiAgICAgIH1cblxuICAgICAgcGVlayhpbmRleCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nW3RoaXMuaW5kZXggKyBpbmRleF07XG4gICAgICB9XG5cbiAgICAgIHByZWZpeChsZW5ndGggPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLmluZGV4LCB0aGlzLmluZGV4ICsgbGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgZm9yd2FyZChsZW5ndGggPSAxKSB7XG4gICAgICAgIHZhciBjaGFyLCByZXN1bHRzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIHdoaWxlIChsZW5ndGgpIHtcbiAgICAgICAgICBjaGFyID0gdGhpcy5zdHJpbmdbdGhpcy5pbmRleF07XG4gICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgIGlmIChpbmRleE9mLmNhbGwoJ1xcblxceDg1XFx1MjA4MlxcdTIwMjknLCBjaGFyKSA+PSAwIHx8IChjaGFyID09PSAnXFxyJyAmJiB0aGlzLnN0cmluZ1t0aGlzLmluZGV4XSAhPT0gJ1xcbicpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmUrKztcbiAgICAgICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4rKztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGxlbmd0aC0tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH1cblxuICAgICAgZ2V0X21hcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFyayh0aGlzLmxpbmUsIHRoaXMuY29sdW1uLCB0aGlzLnN0cmluZywgdGhpcy5pbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrX3ByaW50YWJsZSgpIHtcbiAgICAgICAgdmFyIGNoYXJhY3RlciwgbWF0Y2gsIHBvc2l0aW9uO1xuICAgICAgICBtYXRjaCA9IE5PTl9QUklOVEFCTEUuZXhlYyh0aGlzLnN0cmluZyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNoYXJhY3RlciA9IG1hdGNoWzBdO1xuICAgICAgICAgIHBvc2l0aW9uID0gKHRoaXMuc3RyaW5nLmxlbmd0aCAtIHRoaXMuaW5kZXgpICsgbWF0Y2guaW5kZXg7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUmVhZGVyRXJyb3IocG9zaXRpb24sIGNoYXJhY3RlciwgJ3NwZWNpYWwgY2hhcmFjdGVycyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIE5PTl9QUklOVEFCTEUgPSAvW15cXHgwOVxceDBBXFx4MERcXHgyMC1cXHg3RVxceDg1XFx4QTAtXFx1RkZGRF18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vOyAvLyBJbnZhbGlkIHNpbmdsZSBjaGFyYWN0ZXJzXG4gICAgLy8gTWlzc2luZyBvciBpbnZhbGlkIGxvdyBzdXJyb2dhdGVcbiAgICAvLyBNaXNzaW5nIG9yIGludmFsaWQgaGlnaCBzdXJyb2dhdGVcblxuICAgIGN0b3IgPSBSZWFkZXIucHJvdG90eXBlLmluaXRpYWxpc2U7XG5cbiAgICByZXR1cm4gUmVhZGVyO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n")},832:function(__unused_webpack_module,exports,__webpack_require__){eval("(function() {\n  var YAMLError, nodes,\n    hasProp = {}.hasOwnProperty;\n\n  nodes = __webpack_require__(914);\n\n  ({YAMLError} = __webpack_require__(372));\n\n  this.RepresenterError = class RepresenterError extends YAMLError {};\n\n  this.BaseRepresenter = (function() {\n    var ctor;\n\n    class BaseRepresenter {\n      constructor() {\n        return ctor.apply(this, arguments);\n      }\n\n      static add_representer(data_type, handler) {\n        if (!this.prototype.hasOwnProperty('yaml_representers_types')) {\n          this.prototype.yaml_representers_types = [].concat(this.prototype.yaml_representers_types);\n        }\n        if (!this.prototype.hasOwnProperty('yaml_representers_handlers')) {\n          this.prototype.yaml_representers_handlers = [].concat(this.prototype.yaml_representers_handlers);\n        }\n        this.prototype.yaml_representers_types.push(data_type);\n        return this.prototype.yaml_representers_handlers.push(handler);\n      }\n\n      static add_multi_representer(data_type, handler) {\n        if (!this.prototype.hasOwnProperty('yaml_multi_representers_types')) {\n          this.prototype.yaml_multi_representers_types = [].concat(this.prototype.yaml_multi_representers_types);\n        }\n        if (!this.prototype.hasOwnProperty('yaml_multi_representers_handlers')) {\n          this.prototype.yaml_multi_representers_handlers = [].concat(this.prototype.yaml_multi_representers_handlers);\n        }\n        this.prototype.yaml_multi_representers_types.push(data_type);\n        return this.prototype.yaml_multi_representers_handlers.push(handler);\n      }\n\n      initialise({\n          default_style: default_style,\n          default_flow_style: default_flow_style\n        } = {}) {\n        this.default_style = default_style;\n        this.default_flow_style = default_flow_style;\n        this.represented_objects = {};\n        this.object_keeper = [];\n        return this.alias_key = null;\n      }\n\n      represent(data) {\n        var node;\n        node = this.represent_data(data);\n        this.serialize(node);\n        this.represented_objects = {};\n        this.object_keeper = [];\n        return this.alias_key = null;\n      }\n\n      represent_data(data) {\n        var data_type, i, j, len, ref, representer, type;\n        if (this.ignore_aliases(data)) {\n          this.alias_key = null;\n        } else if ((i = this.object_keeper.indexOf(data)) !== -1) {\n          this.alias_key = i;\n          if (this.alias_key in this.represented_objects) {\n            return this.represented_objects[this.alias_key];\n          }\n        } else {\n          this.alias_key = this.object_keeper.length;\n          this.object_keeper.push(data);\n        }\n        // Bit fiddly: we look into our non-multi representers using the JS type if `data` is not an\n        // object, otherwise we use the object's constructor.  For multi-representers we just use\n        // instanceof.  A representer for `undefined` can be called for any type.\n        representer = null;\n        data_type = data === null ? 'null' : typeof data;\n        if (data_type === 'object') {\n          data_type = data.constructor;\n        }\n        if ((i = this.yaml_representers_types.lastIndexOf(data_type)) !== -1) {\n          representer = this.yaml_representers_handlers[i];\n        }\n        if (representer == null) {\n          ref = this.yaml_multi_representers_types;\n          for (i = j = 0, len = ref.length; j < len; i = ++j) {\n            type = ref[i];\n            if (!(data instanceof type)) {\n              continue;\n            }\n            representer = this.yaml_multi_representers_handlers[i];\n            break;\n          }\n        }\n        if (representer == null) {\n          if ((i = this.yaml_multi_representers_types.lastIndexOf(void 0)) !== -1) {\n            representer = this.yaml_multi_representers_handlers[i];\n          } else if ((i = this.yaml_representers_types.lastIndexOf(void 0)) !== -1) {\n            representer = this.yaml_representers_handlers[i];\n          }\n        }\n        if (representer != null) {\n          return representer.call(this, data);\n        } else {\n          return new nodes.ScalarNode(null, `${data}`);\n        }\n      }\n\n      represent_scalar(tag, value, style = this.default_style) {\n        var node;\n        node = new nodes.ScalarNode(tag, value, null, null, style);\n        if (this.alias_key != null) {\n          this.represented_objects[this.alias_key] = node;\n        }\n        return node;\n      }\n\n      represent_sequence(tag, sequence, flow_style) {\n        var best_style, item, j, len, node, node_item, ref, value;\n        value = [];\n        node = new nodes.SequenceNode(tag, value, null, null, flow_style);\n        if (this.alias_key != null) {\n          this.represented_objects[this.alias_key] = node;\n        }\n        best_style = true;\n        for (j = 0, len = sequence.length; j < len; j++) {\n          item = sequence[j];\n          node_item = this.represent_data(item);\n          if (!(node_item instanceof nodes.ScalarNode || node_item.style)) {\n            best_style = false;\n          }\n          value.push(node_item);\n        }\n        if (flow_style == null) {\n          node.flow_style = (ref = this.default_flow_style) != null ? ref : best_style;\n        }\n        return node;\n      }\n\n      represent_mapping(tag, mapping, flow_style) {\n        var best_style, item_key, item_value, node, node_key, node_value, ref, value;\n        value = [];\n        node = new nodes.MappingNode(tag, value, flow_style);\n        if (this.alias_key) {\n          this.represented_objects[this.alias_key] = node;\n        }\n        best_style = true;\n        for (item_key in mapping) {\n          if (!hasProp.call(mapping, item_key)) continue;\n          item_value = mapping[item_key];\n          node_key = this.represent_data(item_key);\n          node_value = this.represent_data(item_value);\n          if (!(node_key instanceof nodes.ScalarNode || node_key.style)) {\n            best_style = false;\n          }\n          if (!(node_value instanceof nodes.ScalarNode || node_value.style)) {\n            best_style = false;\n          }\n          value.push([node_key, node_value]);\n        }\n        if (!flow_style) {\n          node.flow_style = (ref = this.default_flow_style) != null ? ref : best_style;\n        }\n        return node;\n      }\n\n      ignore_aliases(data) {\n        return false;\n      }\n\n    };\n\n    BaseRepresenter.prototype.yaml_representers_types = [];\n\n    BaseRepresenter.prototype.yaml_representers_handlers = [];\n\n    BaseRepresenter.prototype.yaml_multi_representers_types = [];\n\n    BaseRepresenter.prototype.yaml_multi_representers_handlers = [];\n\n    ctor = BaseRepresenter.prototype.initialise;\n\n    return BaseRepresenter;\n\n  }).call(this);\n\n  this.Representer = class Representer extends this.BaseRepresenter {\n    represent_boolean(data) {\n      return this.represent_scalar('tag:yaml.org,2002:bool', (data ? 'true' : 'false'));\n    }\n\n    represent_null(data) {\n      return this.represent_scalar('tag:yaml.org,2002:null', 'null');\n    }\n\n    represent_number(data) {\n      var tag, value;\n      tag = `tag:yaml.org,2002:${(data % 1 === 0 ? 'int' : 'float')}`;\n      value = data !== data ? '.nan' : data === 2e308 ? '.inf' : data === -2e308 ? '-.inf' : data.toString();\n      return this.represent_scalar(tag, value);\n    }\n\n    represent_string(data) {\n      return this.represent_scalar('tag:yaml.org,2002:str', data);\n    }\n\n    represent_array(data) {\n      return this.represent_sequence('tag:yaml.org,2002:seq', data);\n    }\n\n    represent_date(data) {\n      return this.represent_scalar('tag:yaml.org,2002:timestamp', data.toISOString());\n    }\n\n    represent_object(data) {\n      return this.represent_mapping('tag:yaml.org,2002:map', data);\n    }\n\n    represent_undefined(data) {\n      throw new exports.RepresenterError(`cannot represent an onbject: ${data}`);\n    }\n\n    ignore_aliases(data) {\n      var ref;\n      if (data == null) {\n        return true;\n      }\n      if ((ref = typeof data) === 'boolean' || ref === 'number' || ref === 'string') {\n        return true;\n      }\n      return false;\n    }\n\n  };\n\n  this.Representer.add_representer('boolean', this.Representer.prototype.represent_boolean);\n\n  this.Representer.add_representer('null', this.Representer.prototype.represent_null);\n\n  this.Representer.add_representer('number', this.Representer.prototype.represent_number);\n\n  this.Representer.add_representer('string', this.Representer.prototype.represent_string);\n\n  this.Representer.add_representer(Array, this.Representer.prototype.represent_array);\n\n  this.Representer.add_representer(Date, this.Representer.prototype.represent_date);\n\n  this.Representer.add_representer(Object, this.Representer.prototype.represent_object);\n\n  this.Representer.add_representer(null, this.Representer.prototype.represent_undefined);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLFVBQVUsbUJBQU8sQ0FBQyxHQUFTOztBQUUzQixJQUFJLFdBQVcsRUFBRSxtQkFBTyxDQUFDLEdBQVU7O0FBRW5DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxtQ0FBbUM7QUFDcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxLQUFLO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMveWFtbC1qcy9saWIvcmVwcmVzZW50ZXIuanM/Y2VjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIHZhciBZQU1MRXJyb3IsIG5vZGVzLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICAoe1lBTUxFcnJvcn0gPSByZXF1aXJlKCcuL2Vycm9ycycpKTtcblxuICB0aGlzLlJlcHJlc2VudGVyRXJyb3IgPSBjbGFzcyBSZXByZXNlbnRlckVycm9yIGV4dGVuZHMgWUFNTEVycm9yIHt9O1xuXG4gIHRoaXMuQmFzZVJlcHJlc2VudGVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdG9yO1xuXG4gICAgY2xhc3MgQmFzZVJlcHJlc2VudGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICByZXR1cm4gY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgYWRkX3JlcHJlc2VudGVyKGRhdGFfdHlwZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoIXRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KCd5YW1sX3JlcHJlc2VudGVyc190eXBlcycpKSB7XG4gICAgICAgICAgdGhpcy5wcm90b3R5cGUueWFtbF9yZXByZXNlbnRlcnNfdHlwZXMgPSBbXS5jb25jYXQodGhpcy5wcm90b3R5cGUueWFtbF9yZXByZXNlbnRlcnNfdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3lhbWxfcmVwcmVzZW50ZXJzX2hhbmRsZXJzJykpIHtcbiAgICAgICAgICB0aGlzLnByb3RvdHlwZS55YW1sX3JlcHJlc2VudGVyc19oYW5kbGVycyA9IFtdLmNvbmNhdCh0aGlzLnByb3RvdHlwZS55YW1sX3JlcHJlc2VudGVyc19oYW5kbGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm90b3R5cGUueWFtbF9yZXByZXNlbnRlcnNfdHlwZXMucHVzaChkYXRhX3R5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUueWFtbF9yZXByZXNlbnRlcnNfaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGFkZF9tdWx0aV9yZXByZXNlbnRlcihkYXRhX3R5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgneWFtbF9tdWx0aV9yZXByZXNlbnRlcnNfdHlwZXMnKSkge1xuICAgICAgICAgIHRoaXMucHJvdG90eXBlLnlhbWxfbXVsdGlfcmVwcmVzZW50ZXJzX3R5cGVzID0gW10uY29uY2F0KHRoaXMucHJvdG90eXBlLnlhbWxfbXVsdGlfcmVwcmVzZW50ZXJzX3R5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KCd5YW1sX211bHRpX3JlcHJlc2VudGVyc19oYW5kbGVycycpKSB7XG4gICAgICAgICAgdGhpcy5wcm90b3R5cGUueWFtbF9tdWx0aV9yZXByZXNlbnRlcnNfaGFuZGxlcnMgPSBbXS5jb25jYXQodGhpcy5wcm90b3R5cGUueWFtbF9tdWx0aV9yZXByZXNlbnRlcnNfaGFuZGxlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvdG90eXBlLnlhbWxfbXVsdGlfcmVwcmVzZW50ZXJzX3R5cGVzLnB1c2goZGF0YV90eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlLnlhbWxfbXVsdGlfcmVwcmVzZW50ZXJzX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpc2Uoe1xuICAgICAgICAgIGRlZmF1bHRfc3R5bGU6IGRlZmF1bHRfc3R5bGUsXG4gICAgICAgICAgZGVmYXVsdF9mbG93X3N0eWxlOiBkZWZhdWx0X2Zsb3dfc3R5bGVcbiAgICAgICAgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdF9zdHlsZSA9IGRlZmF1bHRfc3R5bGU7XG4gICAgICAgIHRoaXMuZGVmYXVsdF9mbG93X3N0eWxlID0gZGVmYXVsdF9mbG93X3N0eWxlO1xuICAgICAgICB0aGlzLnJlcHJlc2VudGVkX29iamVjdHMgPSB7fTtcbiAgICAgICAgdGhpcy5vYmplY3Rfa2VlcGVyID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLmFsaWFzX2tleSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJlcHJlc2VudChkYXRhKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBub2RlID0gdGhpcy5yZXByZXNlbnRfZGF0YShkYXRhKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUobm9kZSk7XG4gICAgICAgIHRoaXMucmVwcmVzZW50ZWRfb2JqZWN0cyA9IHt9O1xuICAgICAgICB0aGlzLm9iamVjdF9rZWVwZXIgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpYXNfa2V5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmVwcmVzZW50X2RhdGEoZGF0YSkge1xuICAgICAgICB2YXIgZGF0YV90eXBlLCBpLCBqLCBsZW4sIHJlZiwgcmVwcmVzZW50ZXIsIHR5cGU7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZV9hbGlhc2VzKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5hbGlhc19rZXkgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKChpID0gdGhpcy5vYmplY3Rfa2VlcGVyLmluZGV4T2YoZGF0YSkpICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuYWxpYXNfa2V5ID0gaTtcbiAgICAgICAgICBpZiAodGhpcy5hbGlhc19rZXkgaW4gdGhpcy5yZXByZXNlbnRlZF9vYmplY3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXByZXNlbnRlZF9vYmplY3RzW3RoaXMuYWxpYXNfa2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hbGlhc19rZXkgPSB0aGlzLm9iamVjdF9rZWVwZXIubGVuZ3RoO1xuICAgICAgICAgIHRoaXMub2JqZWN0X2tlZXBlci5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJpdCBmaWRkbHk6IHdlIGxvb2sgaW50byBvdXIgbm9uLW11bHRpIHJlcHJlc2VudGVycyB1c2luZyB0aGUgSlMgdHlwZSBpZiBgZGF0YWAgaXMgbm90IGFuXG4gICAgICAgIC8vIG9iamVjdCwgb3RoZXJ3aXNlIHdlIHVzZSB0aGUgb2JqZWN0J3MgY29uc3RydWN0b3IuICBGb3IgbXVsdGktcmVwcmVzZW50ZXJzIHdlIGp1c3QgdXNlXG4gICAgICAgIC8vIGluc3RhbmNlb2YuICBBIHJlcHJlc2VudGVyIGZvciBgdW5kZWZpbmVkYCBjYW4gYmUgY2FsbGVkIGZvciBhbnkgdHlwZS5cbiAgICAgICAgcmVwcmVzZW50ZXIgPSBudWxsO1xuICAgICAgICBkYXRhX3R5cGUgPSBkYXRhID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGRhdGE7XG4gICAgICAgIGlmIChkYXRhX3R5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZGF0YV90eXBlID0gZGF0YS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGkgPSB0aGlzLnlhbWxfcmVwcmVzZW50ZXJzX3R5cGVzLmxhc3RJbmRleE9mKGRhdGFfdHlwZSkpICE9PSAtMSkge1xuICAgICAgICAgIHJlcHJlc2VudGVyID0gdGhpcy55YW1sX3JlcHJlc2VudGVyc19oYW5kbGVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwcmVzZW50ZXIgPT0gbnVsbCkge1xuICAgICAgICAgIHJlZiA9IHRoaXMueWFtbF9tdWx0aV9yZXByZXNlbnRlcnNfdHlwZXM7XG4gICAgICAgICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGkgPSArK2opIHtcbiAgICAgICAgICAgIHR5cGUgPSByZWZbaV07XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXByZXNlbnRlciA9IHRoaXMueWFtbF9tdWx0aV9yZXByZXNlbnRlcnNfaGFuZGxlcnNbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcHJlc2VudGVyID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoKGkgPSB0aGlzLnlhbWxfbXVsdGlfcmVwcmVzZW50ZXJzX3R5cGVzLmxhc3RJbmRleE9mKHZvaWQgMCkpICE9PSAtMSkge1xuICAgICAgICAgICAgcmVwcmVzZW50ZXIgPSB0aGlzLnlhbWxfbXVsdGlfcmVwcmVzZW50ZXJzX2hhbmRsZXJzW2ldO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGkgPSB0aGlzLnlhbWxfcmVwcmVzZW50ZXJzX3R5cGVzLmxhc3RJbmRleE9mKHZvaWQgMCkpICE9PSAtMSkge1xuICAgICAgICAgICAgcmVwcmVzZW50ZXIgPSB0aGlzLnlhbWxfcmVwcmVzZW50ZXJzX2hhbmRsZXJzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwcmVzZW50ZXIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZXByZXNlbnRlci5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgbm9kZXMuU2NhbGFyTm9kZShudWxsLCBgJHtkYXRhfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlcHJlc2VudF9zY2FsYXIodGFnLCB2YWx1ZSwgc3R5bGUgPSB0aGlzLmRlZmF1bHRfc3R5bGUpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSh0YWcsIHZhbHVlLCBudWxsLCBudWxsLCBzdHlsZSk7XG4gICAgICAgIGlmICh0aGlzLmFsaWFzX2tleSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZXByZXNlbnRlZF9vYmplY3RzW3RoaXMuYWxpYXNfa2V5XSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHJlcHJlc2VudF9zZXF1ZW5jZSh0YWcsIHNlcXVlbmNlLCBmbG93X3N0eWxlKSB7XG4gICAgICAgIHZhciBiZXN0X3N0eWxlLCBpdGVtLCBqLCBsZW4sIG5vZGUsIG5vZGVfaXRlbSwgcmVmLCB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5TZXF1ZW5jZU5vZGUodGFnLCB2YWx1ZSwgbnVsbCwgbnVsbCwgZmxvd19zdHlsZSk7XG4gICAgICAgIGlmICh0aGlzLmFsaWFzX2tleSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZXByZXNlbnRlZF9vYmplY3RzW3RoaXMuYWxpYXNfa2V5XSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgYmVzdF9zdHlsZSA9IHRydWU7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHNlcXVlbmNlLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlcXVlbmNlW2pdO1xuICAgICAgICAgIG5vZGVfaXRlbSA9IHRoaXMucmVwcmVzZW50X2RhdGEoaXRlbSk7XG4gICAgICAgICAgaWYgKCEobm9kZV9pdGVtIGluc3RhbmNlb2Ygbm9kZXMuU2NhbGFyTm9kZSB8fCBub2RlX2l0ZW0uc3R5bGUpKSB7XG4gICAgICAgICAgICBiZXN0X3N0eWxlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlLnB1c2gobm9kZV9pdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxvd19zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZS5mbG93X3N0eWxlID0gKHJlZiA9IHRoaXMuZGVmYXVsdF9mbG93X3N0eWxlKSAhPSBudWxsID8gcmVmIDogYmVzdF9zdHlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgcmVwcmVzZW50X21hcHBpbmcodGFnLCBtYXBwaW5nLCBmbG93X3N0eWxlKSB7XG4gICAgICAgIHZhciBiZXN0X3N0eWxlLCBpdGVtX2tleSwgaXRlbV92YWx1ZSwgbm9kZSwgbm9kZV9rZXksIG5vZGVfdmFsdWUsIHJlZiwgdmFsdWU7XG4gICAgICAgIHZhbHVlID0gW107XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTWFwcGluZ05vZGUodGFnLCB2YWx1ZSwgZmxvd19zdHlsZSk7XG4gICAgICAgIGlmICh0aGlzLmFsaWFzX2tleSkge1xuICAgICAgICAgIHRoaXMucmVwcmVzZW50ZWRfb2JqZWN0c1t0aGlzLmFsaWFzX2tleV0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGJlc3Rfc3R5bGUgPSB0cnVlO1xuICAgICAgICBmb3IgKGl0ZW1fa2V5IGluIG1hcHBpbmcpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChtYXBwaW5nLCBpdGVtX2tleSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGl0ZW1fdmFsdWUgPSBtYXBwaW5nW2l0ZW1fa2V5XTtcbiAgICAgICAgICBub2RlX2tleSA9IHRoaXMucmVwcmVzZW50X2RhdGEoaXRlbV9rZXkpO1xuICAgICAgICAgIG5vZGVfdmFsdWUgPSB0aGlzLnJlcHJlc2VudF9kYXRhKGl0ZW1fdmFsdWUpO1xuICAgICAgICAgIGlmICghKG5vZGVfa2V5IGluc3RhbmNlb2Ygbm9kZXMuU2NhbGFyTm9kZSB8fCBub2RlX2tleS5zdHlsZSkpIHtcbiAgICAgICAgICAgIGJlc3Rfc3R5bGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEobm9kZV92YWx1ZSBpbnN0YW5jZW9mIG5vZGVzLlNjYWxhck5vZGUgfHwgbm9kZV92YWx1ZS5zdHlsZSkpIHtcbiAgICAgICAgICAgIGJlc3Rfc3R5bGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUucHVzaChbbm9kZV9rZXksIG5vZGVfdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsb3dfc3R5bGUpIHtcbiAgICAgICAgICBub2RlLmZsb3dfc3R5bGUgPSAocmVmID0gdGhpcy5kZWZhdWx0X2Zsb3dfc3R5bGUpICE9IG51bGwgPyByZWYgOiBiZXN0X3N0eWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBpZ25vcmVfYWxpYXNlcyhkYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBCYXNlUmVwcmVzZW50ZXIucHJvdG90eXBlLnlhbWxfcmVwcmVzZW50ZXJzX3R5cGVzID0gW107XG5cbiAgICBCYXNlUmVwcmVzZW50ZXIucHJvdG90eXBlLnlhbWxfcmVwcmVzZW50ZXJzX2hhbmRsZXJzID0gW107XG5cbiAgICBCYXNlUmVwcmVzZW50ZXIucHJvdG90eXBlLnlhbWxfbXVsdGlfcmVwcmVzZW50ZXJzX3R5cGVzID0gW107XG5cbiAgICBCYXNlUmVwcmVzZW50ZXIucHJvdG90eXBlLnlhbWxfbXVsdGlfcmVwcmVzZW50ZXJzX2hhbmRsZXJzID0gW107XG5cbiAgICBjdG9yID0gQmFzZVJlcHJlc2VudGVyLnByb3RvdHlwZS5pbml0aWFsaXNlO1xuXG4gICAgcmV0dXJuIEJhc2VSZXByZXNlbnRlcjtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuUmVwcmVzZW50ZXIgPSBjbGFzcyBSZXByZXNlbnRlciBleHRlbmRzIHRoaXMuQmFzZVJlcHJlc2VudGVyIHtcbiAgICByZXByZXNlbnRfYm9vbGVhbihkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXByZXNlbnRfc2NhbGFyKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywgKGRhdGEgPyAndHJ1ZScgOiAnZmFsc2UnKSk7XG4gICAgfVxuXG4gICAgcmVwcmVzZW50X251bGwoZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwcmVzZW50X3NjYWxhcigndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsICdudWxsJyk7XG4gICAgfVxuXG4gICAgcmVwcmVzZW50X251bWJlcihkYXRhKSB7XG4gICAgICB2YXIgdGFnLCB2YWx1ZTtcbiAgICAgIHRhZyA9IGB0YWc6eWFtbC5vcmcsMjAwMjokeyhkYXRhICUgMSA9PT0gMCA/ICdpbnQnIDogJ2Zsb2F0Jyl9YDtcbiAgICAgIHZhbHVlID0gZGF0YSAhPT0gZGF0YSA/ICcubmFuJyA6IGRhdGEgPT09IDJlMzA4ID8gJy5pbmYnIDogZGF0YSA9PT0gLTJlMzA4ID8gJy0uaW5mJyA6IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlcHJlc2VudF9zY2FsYXIodGFnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmVwcmVzZW50X3N0cmluZyhkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXByZXNlbnRfc2NhbGFyKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXByZXNlbnRfYXJyYXkoZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwcmVzZW50X3NlcXVlbmNlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXByZXNlbnRfZGF0ZShkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXByZXNlbnRfc2NhbGFyKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCBkYXRhLnRvSVNPU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHJlcHJlc2VudF9vYmplY3QoZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwcmVzZW50X21hcHBpbmcoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIGRhdGEpO1xuICAgIH1cblxuICAgIHJlcHJlc2VudF91bmRlZmluZWQoZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUmVwcmVzZW50ZXJFcnJvcihgY2Fubm90IHJlcHJlc2VudCBhbiBvbmJqZWN0OiAke2RhdGF9YCk7XG4gICAgfVxuXG4gICAgaWdub3JlX2FsaWFzZXMoZGF0YSkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoKHJlZiA9IHR5cGVvZiBkYXRhKSA9PT0gJ2Jvb2xlYW4nIHx8IHJlZiA9PT0gJ251bWJlcicgfHwgcmVmID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLlJlcHJlc2VudGVyLmFkZF9yZXByZXNlbnRlcignYm9vbGVhbicsIHRoaXMuUmVwcmVzZW50ZXIucHJvdG90eXBlLnJlcHJlc2VudF9ib29sZWFuKTtcblxuICB0aGlzLlJlcHJlc2VudGVyLmFkZF9yZXByZXNlbnRlcignbnVsbCcsIHRoaXMuUmVwcmVzZW50ZXIucHJvdG90eXBlLnJlcHJlc2VudF9udWxsKTtcblxuICB0aGlzLlJlcHJlc2VudGVyLmFkZF9yZXByZXNlbnRlcignbnVtYmVyJywgdGhpcy5SZXByZXNlbnRlci5wcm90b3R5cGUucmVwcmVzZW50X251bWJlcik7XG5cbiAgdGhpcy5SZXByZXNlbnRlci5hZGRfcmVwcmVzZW50ZXIoJ3N0cmluZycsIHRoaXMuUmVwcmVzZW50ZXIucHJvdG90eXBlLnJlcHJlc2VudF9zdHJpbmcpO1xuXG4gIHRoaXMuUmVwcmVzZW50ZXIuYWRkX3JlcHJlc2VudGVyKEFycmF5LCB0aGlzLlJlcHJlc2VudGVyLnByb3RvdHlwZS5yZXByZXNlbnRfYXJyYXkpO1xuXG4gIHRoaXMuUmVwcmVzZW50ZXIuYWRkX3JlcHJlc2VudGVyKERhdGUsIHRoaXMuUmVwcmVzZW50ZXIucHJvdG90eXBlLnJlcHJlc2VudF9kYXRlKTtcblxuICB0aGlzLlJlcHJlc2VudGVyLmFkZF9yZXByZXNlbnRlcihPYmplY3QsIHRoaXMuUmVwcmVzZW50ZXIucHJvdG90eXBlLnJlcHJlc2VudF9vYmplY3QpO1xuXG4gIHRoaXMuUmVwcmVzZW50ZXIuYWRkX3JlcHJlc2VudGVyKG51bGwsIHRoaXMuUmVwcmVzZW50ZXIucHJvdG90eXBlLnJlcHJlc2VudF91bmRlZmluZWQpO1xuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///832\n")},579:function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){eval("(function() {\n  var YAMLError, nodes, util,\n    indexOf = [].indexOf;\n\n  nodes = __webpack_require__(914);\n\n  util = __webpack_require__(823);\n\n  ({YAMLError} = __webpack_require__(372));\n\n  this.ResolverError = class ResolverError extends YAMLError {};\n\n  this.BaseResolver = (function() {\n    var DEFAULT_MAPPING_TAG, DEFAULT_SCALAR_TAG, DEFAULT_SEQUENCE_TAG, ctor;\n\n    class BaseResolver {\n      constructor() {\n        return ctor.apply(this, arguments);\n      }\n\n      static add_implicit_resolver(tag, regexp, first = [null]) {\n        var base, char, i, len, results;\n        if (!this.prototype.hasOwnProperty('yaml_implicit_resolvers')) {\n          this.prototype.yaml_implicit_resolvers = util.extend({}, this.prototype.yaml_implicit_resolvers);\n        }\n        results = [];\n        for (i = 0, len = first.length; i < len; i++) {\n          char = first[i];\n          results.push(((base = this.prototype.yaml_implicit_resolvers)[char] != null ? base[char] : base[char] = []).push([tag, regexp]));\n        }\n        return results;\n      }\n\n      initialise() {\n        this.resolver_exact_paths = [];\n        return this.resolver_prefix_paths = [];\n      }\n\n      descend_resolver(current_node, current_index) {\n        var depth, exact_paths, i, j, kind, len, len1, path, prefix_paths, ref, ref1;\n        if (util.is_empty(this.yaml_path_resolvers)) {\n          return;\n        }\n        exact_paths = {};\n        prefix_paths = [];\n        if (current_node) {\n          depth = this.resolver_prefix_paths.length;\n          ref = this.resolver_prefix_paths.slice(-1)[0];\n          for (i = 0, len = ref.length; i < len; i++) {\n            [path, kind] = ref[i];\n            if (this.check_resolver_prefix(depth, path, kind, current_node, current_index)) {\n              if (path.length > depth) {\n                prefix_paths.push([path, kind]);\n              } else {\n                exact_paths[kind] = this.yaml_path_resolvers[path][kind];\n              }\n            }\n          }\n        } else {\n          ref1 = this.yaml_path_resolvers;\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            [path, kind] = ref1[j];\n            if (!path) {\n              exact_paths[kind] = this.yaml_path_resolvers[path][kind];\n            } else {\n              prefix_paths.push([path, kind]);\n            }\n          }\n        }\n        this.resolver_exact_paths.push(exact_paths);\n        return this.resolver_prefix_paths.push(prefix_paths);\n      }\n\n      ascend_resolver() {\n        if (util.is_empty(this.yaml_path_resolvers)) {\n          return;\n        }\n        this.resolver_exact_paths.pop();\n        return this.resolver_prefix_paths.pop();\n      }\n\n      check_resolver_prefix(depth, path, kind, current_node, current_index) {\n        var index_check, node_check;\n        [node_check, index_check] = path[depth - 1];\n        if (typeof node_check === 'string') {\n          if (current_node.tag !== node_check) {\n            return;\n          }\n        } else if (node_check !== null) {\n          if (!(current_node instanceof node_check)) {\n            return;\n          }\n        }\n        if (index_check === true && current_index !== null) {\n          return;\n        }\n        if ((index_check === false || index_check === null) && current_index === null) {\n          return;\n        }\n        if (typeof index_check === 'string') {\n          if (!(current_index instanceof nodes.ScalarNode) && index_check === current_index.value) {\n            return;\n          }\n        } else if (typeof index_check === 'number') {\n          if (index_check !== current_index) {\n            return;\n          }\n        }\n        return true;\n      }\n\n      resolve(kind, value, implicit) {\n        var empty, exact_paths, i, k, len, ref, ref1, ref2, regexp, resolvers, tag;\n        if (kind === nodes.ScalarNode && implicit[0]) {\n          if (value === '') {\n            resolvers = (ref = this.yaml_implicit_resolvers['']) != null ? ref : [];\n          } else {\n            resolvers = (ref1 = this.yaml_implicit_resolvers[value[0]]) != null ? ref1 : [];\n          }\n          resolvers = resolvers.concat((ref2 = this.yaml_implicit_resolvers[null]) != null ? ref2 : []);\n          for (i = 0, len = resolvers.length; i < len; i++) {\n            [tag, regexp] = resolvers[i];\n            if (value.match(regexp)) {\n              return tag;\n            }\n          }\n          implicit = implicit[1];\n        }\n        empty = true;\n        for (k in this.yaml_path_resolvers) {\n          if ({}[k] == null) {\n            empty = false;\n          }\n        }\n        if (!empty) {\n          exact_paths = this.resolver_exact_paths.slice(-1)[0];\n          if (indexOf.call(exact_paths, kind) >= 0) {\n            return exact_paths[kind];\n          }\n          if (indexOf.call(exact_paths, null) >= 0) {\n            return exact_paths[null];\n          }\n        }\n        if (kind === nodes.ScalarNode) {\n          return DEFAULT_SCALAR_TAG;\n        }\n        if (kind === nodes.SequenceNode) {\n          return DEFAULT_SEQUENCE_TAG;\n        }\n        if (kind === nodes.MappingNode) {\n          return DEFAULT_MAPPING_TAG;\n        }\n      }\n\n    };\n\n    DEFAULT_SCALAR_TAG = 'tag:yaml.org,2002:str';\n\n    DEFAULT_SEQUENCE_TAG = 'tag:yaml.org,2002:seq';\n\n    DEFAULT_MAPPING_TAG = 'tag:yaml.org,2002:map';\n\n    BaseResolver.prototype.yaml_implicit_resolvers = {};\n\n    BaseResolver.prototype.yaml_path_resolvers = {};\n\n    ctor = BaseResolver.prototype.initialise;\n\n    return BaseResolver;\n\n  }).call(this);\n\n  this.Resolver = class Resolver extends this.BaseResolver {};\n\n  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:bool', /^(?:yes|Yes|YES|true|True|TRUE|on|On|ON|no|No|NO|false|False|FALSE|off|Off|OFF)$/, 'yYnNtTfFoO');\n\n  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:float', /^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?|\\.[0-9_]+(?:[eE][-+][0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$/, '-+0123456789.');\n\n  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:int', /^(?:[-+]?0b[01_]+|[-+]?0[0-7_]+|[-+]?(?:0|[1-9][0-9_]*)|[-+]?0x[0-9a-fA-F_]+|[-+]?0o[0-7_]+|[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$/, '-+0123456789');\n\n  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:merge', /^(?:<<)$/, '<');\n\n  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:null', /^(?:~|null|Null|NULL|)$/, ['~', 'n', 'N', '']);\n\n  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:timestamp', /^(?:[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]|[0-9][0-9][0-9][0-9]-[0-9][0-9]?-[0-9][0-9]?(?:[Tt]|[\\x20\\t]+)[0-9][0-9]?:[0-9][0-9]:[0-9][0-9](?:\\.[0-9]*)?(?:[\\x20\\t]*(?:Z|[-+][0-9][0-9]?(?::[0-9][0-9])?))?)$/, '0123456789');\n\n  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:value', /^(?:=)$/, '=');\n\n  // The following resolver is only for documentation purposes.  It cannot work\n  // because plain scalars cannot start with '!', '&' or '*'.\n  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:yaml', /^(?:!|&|\\*)$/, '!&*');\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG1CQUFPLENBQUMsR0FBUzs7QUFFM0IsU0FBUyxtQkFBTyxDQUFDLEdBQVE7O0FBRXpCLElBQUksV0FBVyxFQUFFLG1CQUFPLENBQUMsR0FBVTs7QUFFbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwtanMvbGliL3Jlc29sdmVyLmpzP2ZiZWMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkge1xuICB2YXIgWUFNTEVycm9yLCBub2RlcywgdXRpbCxcbiAgICBpbmRleE9mID0gW10uaW5kZXhPZjtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgKHtZQU1MRXJyb3J9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKSk7XG5cbiAgdGhpcy5SZXNvbHZlckVycm9yID0gY2xhc3MgUmVzb2x2ZXJFcnJvciBleHRlbmRzIFlBTUxFcnJvciB7fTtcblxuICB0aGlzLkJhc2VSZXNvbHZlciA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgREVGQVVMVF9NQVBQSU5HX1RBRywgREVGQVVMVF9TQ0FMQVJfVEFHLCBERUZBVUxUX1NFUVVFTkNFX1RBRywgY3RvcjtcblxuICAgIGNsYXNzIEJhc2VSZXNvbHZlciB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGFkZF9pbXBsaWNpdF9yZXNvbHZlcih0YWcsIHJlZ2V4cCwgZmlyc3QgPSBbbnVsbF0pIHtcbiAgICAgICAgdmFyIGJhc2UsIGNoYXIsIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgaWYgKCF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgneWFtbF9pbXBsaWNpdF9yZXNvbHZlcnMnKSkge1xuICAgICAgICAgIHRoaXMucHJvdG90eXBlLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzID0gdXRpbC5leHRlbmQoe30sIHRoaXMucHJvdG90eXBlLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGZpcnN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hhciA9IGZpcnN0W2ldO1xuICAgICAgICAgIHJlc3VsdHMucHVzaCgoKGJhc2UgPSB0aGlzLnByb3RvdHlwZS55YW1sX2ltcGxpY2l0X3Jlc29sdmVycylbY2hhcl0gIT0gbnVsbCA/IGJhc2VbY2hhcl0gOiBiYXNlW2NoYXJdID0gW10pLnB1c2goW3RhZywgcmVnZXhwXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICB0aGlzLnJlc29sdmVyX2V4YWN0X3BhdGhzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVyX3ByZWZpeF9wYXRocyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBkZXNjZW5kX3Jlc29sdmVyKGN1cnJlbnRfbm9kZSwgY3VycmVudF9pbmRleCkge1xuICAgICAgICB2YXIgZGVwdGgsIGV4YWN0X3BhdGhzLCBpLCBqLCBraW5kLCBsZW4sIGxlbjEsIHBhdGgsIHByZWZpeF9wYXRocywgcmVmLCByZWYxO1xuICAgICAgICBpZiAodXRpbC5pc19lbXB0eSh0aGlzLnlhbWxfcGF0aF9yZXNvbHZlcnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV4YWN0X3BhdGhzID0ge307XG4gICAgICAgIHByZWZpeF9wYXRocyA9IFtdO1xuICAgICAgICBpZiAoY3VycmVudF9ub2RlKSB7XG4gICAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVyX3ByZWZpeF9wYXRocy5sZW5ndGg7XG4gICAgICAgICAgcmVmID0gdGhpcy5yZXNvbHZlcl9wcmVmaXhfcGF0aHMuc2xpY2UoLTEpWzBdO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgW3BhdGgsIGtpbmRdID0gcmVmW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tfcmVzb2x2ZXJfcHJlZml4KGRlcHRoLCBwYXRoLCBraW5kLCBjdXJyZW50X25vZGUsIGN1cnJlbnRfaW5kZXgpKSB7XG4gICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4X3BhdGhzLnB1c2goW3BhdGgsIGtpbmRdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGFjdF9wYXRoc1traW5kXSA9IHRoaXMueWFtbF9wYXRoX3Jlc29sdmVyc1twYXRoXVtraW5kXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWYxID0gdGhpcy55YW1sX3BhdGhfcmVzb2x2ZXJzO1xuICAgICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgW3BhdGgsIGtpbmRdID0gcmVmMVtqXTtcbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICBleGFjdF9wYXRoc1traW5kXSA9IHRoaXMueWFtbF9wYXRoX3Jlc29sdmVyc1twYXRoXVtraW5kXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByZWZpeF9wYXRocy5wdXNoKFtwYXRoLCBraW5kXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb2x2ZXJfZXhhY3RfcGF0aHMucHVzaChleGFjdF9wYXRocyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVyX3ByZWZpeF9wYXRocy5wdXNoKHByZWZpeF9wYXRocyk7XG4gICAgICB9XG5cbiAgICAgIGFzY2VuZF9yZXNvbHZlcigpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNfZW1wdHkodGhpcy55YW1sX3BhdGhfcmVzb2x2ZXJzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVyX2V4YWN0X3BhdGhzLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlcl9wcmVmaXhfcGF0aHMucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrX3Jlc29sdmVyX3ByZWZpeChkZXB0aCwgcGF0aCwga2luZCwgY3VycmVudF9ub2RlLCBjdXJyZW50X2luZGV4KSB7XG4gICAgICAgIHZhciBpbmRleF9jaGVjaywgbm9kZV9jaGVjaztcbiAgICAgICAgW25vZGVfY2hlY2ssIGluZGV4X2NoZWNrXSA9IHBhdGhbZGVwdGggLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlX2NoZWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChjdXJyZW50X25vZGUudGFnICE9PSBub2RlX2NoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVfY2hlY2sgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIShjdXJyZW50X25vZGUgaW5zdGFuY2VvZiBub2RlX2NoZWNrKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXhfY2hlY2sgPT09IHRydWUgJiYgY3VycmVudF9pbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGluZGV4X2NoZWNrID09PSBmYWxzZSB8fCBpbmRleF9jaGVjayA9PT0gbnVsbCkgJiYgY3VycmVudF9pbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGluZGV4X2NoZWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICghKGN1cnJlbnRfaW5kZXggaW5zdGFuY2VvZiBub2Rlcy5TY2FsYXJOb2RlKSAmJiBpbmRleF9jaGVjayA9PT0gY3VycmVudF9pbmRleC52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5kZXhfY2hlY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgaWYgKGluZGV4X2NoZWNrICE9PSBjdXJyZW50X2luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGtpbmQsIHZhbHVlLCBpbXBsaWNpdCkge1xuICAgICAgICB2YXIgZW1wdHksIGV4YWN0X3BhdGhzLCBpLCBrLCBsZW4sIHJlZiwgcmVmMSwgcmVmMiwgcmVnZXhwLCByZXNvbHZlcnMsIHRhZztcbiAgICAgICAgaWYgKGtpbmQgPT09IG5vZGVzLlNjYWxhck5vZGUgJiYgaW1wbGljaXRbMF0pIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXNvbHZlcnMgPSAocmVmID0gdGhpcy55YW1sX2ltcGxpY2l0X3Jlc29sdmVyc1snJ10pICE9IG51bGwgPyByZWYgOiBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZXJzID0gKHJlZjEgPSB0aGlzLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzW3ZhbHVlWzBdXSkgIT0gbnVsbCA/IHJlZjEgOiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZXJzID0gcmVzb2x2ZXJzLmNvbmNhdCgocmVmMiA9IHRoaXMueWFtbF9pbXBsaWNpdF9yZXNvbHZlcnNbbnVsbF0pICE9IG51bGwgPyByZWYyIDogW10pO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlc29sdmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgW3RhZywgcmVnZXhwXSA9IHJlc29sdmVyc1tpXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaChyZWdleHApKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGltcGxpY2l0ID0gaW1wbGljaXRbMV07XG4gICAgICAgIH1cbiAgICAgICAgZW1wdHkgPSB0cnVlO1xuICAgICAgICBmb3IgKGsgaW4gdGhpcy55YW1sX3BhdGhfcmVzb2x2ZXJzKSB7XG4gICAgICAgICAgaWYgKHt9W2tdID09IG51bGwpIHtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZW1wdHkpIHtcbiAgICAgICAgICBleGFjdF9wYXRocyA9IHRoaXMucmVzb2x2ZXJfZXhhY3RfcGF0aHMuc2xpY2UoLTEpWzBdO1xuICAgICAgICAgIGlmIChpbmRleE9mLmNhbGwoZXhhY3RfcGF0aHMsIGtpbmQpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBleGFjdF9wYXRoc1traW5kXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4T2YuY2FsbChleGFjdF9wYXRocywgbnVsbCkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4YWN0X3BhdGhzW251bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2luZCA9PT0gbm9kZXMuU2NhbGFyTm9kZSkge1xuICAgICAgICAgIHJldHVybiBERUZBVUxUX1NDQUxBUl9UQUc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtpbmQgPT09IG5vZGVzLlNlcXVlbmNlTm9kZSkge1xuICAgICAgICAgIHJldHVybiBERUZBVUxUX1NFUVVFTkNFX1RBRztcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2luZCA9PT0gbm9kZXMuTWFwcGluZ05vZGUpIHtcbiAgICAgICAgICByZXR1cm4gREVGQVVMVF9NQVBQSU5HX1RBRztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIERFRkFVTFRfU0NBTEFSX1RBRyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInO1xuXG4gICAgREVGQVVMVF9TRVFVRU5DRV9UQUcgPSAndGFnOnlhbWwub3JnLDIwMDI6c2VxJztcblxuICAgIERFRkFVTFRfTUFQUElOR19UQUcgPSAndGFnOnlhbWwub3JnLDIwMDI6bWFwJztcblxuICAgIEJhc2VSZXNvbHZlci5wcm90b3R5cGUueWFtbF9pbXBsaWNpdF9yZXNvbHZlcnMgPSB7fTtcblxuICAgIEJhc2VSZXNvbHZlci5wcm90b3R5cGUueWFtbF9wYXRoX3Jlc29sdmVycyA9IHt9O1xuXG4gICAgY3RvciA9IEJhc2VSZXNvbHZlci5wcm90b3R5cGUuaW5pdGlhbGlzZTtcblxuICAgIHJldHVybiBCYXNlUmVzb2x2ZXI7XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICB0aGlzLlJlc29sdmVyID0gY2xhc3MgUmVzb2x2ZXIgZXh0ZW5kcyB0aGlzLkJhc2VSZXNvbHZlciB7fTtcblxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIC9eKD86eWVzfFllc3xZRVN8dHJ1ZXxUcnVlfFRSVUV8b258T258T058bm98Tm98Tk98ZmFsc2V8RmFsc2V8RkFMU0V8b2ZmfE9mZnxPRkYpJC8sICd5WW5OdFRmRm9PJyk7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JywgL14oPzpbLStdPyg/OlswLTldWzAtOV9dKilcXC5bMC05X10qKD86W2VFXVstK11bMC05XSspP3xcXC5bMC05X10rKD86W2VFXVstK11bMC05XSspP3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFwuWzAtOV9dKnxbLStdP1xcLig/OmluZnxJbmZ8SU5GKXxcXC4oPzpuYW58TmFOfE5BTikpJC8sICctKzAxMjM0NTY3ODkuJyk7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIC9eKD86Wy0rXT8wYlswMV9dK3xbLStdPzBbMC03X10rfFstK10/KD86MHxbMS05XVswLTlfXSopfFstK10/MHhbMC05YS1mQS1GX10rfFstK10/MG9bMC03X10rfFstK10/WzEtOV1bMC05X10qKD86OlswLTVdP1swLTldKSspJC8sICctKzAxMjM0NTY3ODknKTtcblxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLCAvXig/Ojw8KSQvLCAnPCcpO1xuXG4gIHRoaXMuUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywgL14oPzp+fG51bGx8TnVsbHxOVUxMfCkkLywgWyd+JywgJ24nLCAnTicsICcnXSk7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIC9eKD86WzAtOV1bMC05XVswLTldWzAtOV0tWzAtOV1bMC05XS1bMC05XVswLTldfFswLTldWzAtOV1bMC05XVswLTldLVswLTldWzAtOV0/LVswLTldWzAtOV0/KD86W1R0XXxbXFx4MjBcXHRdKylbMC05XVswLTldPzpbMC05XVswLTldOlswLTldWzAtOV0oPzpcXC5bMC05XSopPyg/OltcXHgyMFxcdF0qKD86WnxbLStdWzAtOV1bMC05XT8oPzo6WzAtOV1bMC05XSk/KSk/KSQvLCAnMDEyMzQ1Njc4OScpO1xuXG4gIHRoaXMuUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyKCd0YWc6eWFtbC5vcmcsMjAwMjp2YWx1ZScsIC9eKD86PSkkLywgJz0nKTtcblxuICAvLyBUaGUgZm9sbG93aW5nIHJlc29sdmVyIGlzIG9ubHkgZm9yIGRvY3VtZW50YXRpb24gcHVycG9zZXMuICBJdCBjYW5ub3Qgd29ya1xuICAvLyBiZWNhdXNlIHBsYWluIHNjYWxhcnMgY2Fubm90IHN0YXJ0IHdpdGggJyEnLCAnJicgb3IgJyonLlxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6eWFtbCcsIC9eKD86IXwmfFxcKikkLywgJyEmKicpO1xuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///579\n")},265:function(__unused_webpack_module,exports,__webpack_require__){eval("(function() {\n  var MarkedYAMLError, SimpleKey, tokens, util,\n    hasProp = {}.hasOwnProperty,\n    indexOf = [].indexOf;\n\n  ({MarkedYAMLError} = __webpack_require__(372));\n\n  tokens = __webpack_require__(902);\n\n  util = __webpack_require__(823);\n\n  /*\n  The Scanner throws these.\n  */\n  this.ScannerError = class ScannerError extends MarkedYAMLError {};\n\n  /*\n  Represents a possible simple key.\n  */\n  SimpleKey = class SimpleKey {\n    constructor(token_number1, required1, index, line, column1, mark1) {\n      this.token_number = token_number1;\n      this.required = required1;\n      this.index = index;\n      this.line = line;\n      this.column = column1;\n      this.mark = mark1;\n    }\n\n  };\n\n  /*\n  The Scanner class deals with converting a YAML stream into a token stream.\n  */\n  this.Scanner = (function() {\n    var C_LB, C_NUMBERS, C_WS, ESCAPE_CODES, ESCAPE_REPLACEMENTS, ctor;\n\n    class Scanner {\n      constructor() {\n        return ctor.apply(this, arguments);\n      }\n\n      /*\n      Initialise the Scanner\n      */\n      initialise() {\n        // Have we reached the end of the stream?\n        this.done = false;\n        // How many unclosed '{' or '[' have been seen. '0' implies block context.\n        this.flow_level = 0;\n        // List of processed tokens not yet emitted.\n        this.tokens = [];\n        // Add the STREAM-START token.\n        this.fetch_stream_start();\n        // Number of tokens emitted through the `get_token` method.\n        this.tokens_taken = 0;\n        // Current indentation level. '-1' means no indentation has been seen.\n        this.indent = -1;\n        // Previous indentation levels.\n        this.indents = [];\n        // Simple Key Treatment\n        //   A simple key is a key that is not denoted by the '?' indicator, e.g.\n        //     block simple key: value\n        //     ? not a simple key\n        //     : { flow simple key: value }\n        //   We emit the KEY token before all keys, so when we find a potential\n        //   simple key, we try to locate the corresponding ':' indicator.  Simple\n        //   keys should be limited to a single line and 1024 characters.\n\n        // Can a simple key start at the current position?  A simple key may\n        // start\n        //   at the beginning of the line, not counting indentation spaces\n        //     (block context)\n        //   after '{', '[', ',' (flow context)\n        //   after '?', ':', '-' (block context)\n        // In the block context, this flag also signifies if a block collection\n        // may start at the current position.\n        this.allow_simple_key = true;\n        // Keep track of possible simple keys.  This is an object.  The key is\n        // `flow_level`; there can be no more than one possible simple key for\n        // each level.  The value is a SimpleKey object. A simple key may start\n        // with ALIAS, ANCHOR, TAG, SCALAR (flow), '[' or '{' tokens.\n        return this.possible_simple_keys = {};\n      }\n\n      // API methods.\n      /*\n      Check if the next token is one of the given types.\n      */\n      check_token(...choices) {\n        var choice, i, len;\n        while (this.need_more_tokens()) {\n          this.fetch_more_tokens();\n        }\n        if (this.tokens.length !== 0) {\n          if (choices.length === 0) {\n            return true;\n          }\n          for (i = 0, len = choices.length; i < len; i++) {\n            choice = choices[i];\n            if (this.tokens[0] instanceof choice) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n\n      /*\n      Return the next token, but do not delete it from the queue.\n      */\n      peek_token() {\n        while (this.need_more_tokens()) {\n          this.fetch_more_tokens();\n        }\n        if (this.tokens.length !== 0) {\n          return this.tokens[0];\n        }\n      }\n\n      /*\n      Return the next token, and remove it from the queue.\n      */\n      get_token() {\n        while (this.need_more_tokens()) {\n          this.fetch_more_tokens();\n        }\n        if (this.tokens.length !== 0) {\n          this.tokens_taken++;\n          return this.tokens.shift();\n        }\n      }\n\n      // Non-API methods.\n      need_more_tokens() {\n        if (this.done) {\n          return false;\n        }\n        if (this.tokens.length === 0) {\n          return true;\n        }\n        // The current token may be a potential simple key, so we need to look\n        // further.\n        this.stale_possible_simple_keys();\n        if (this.next_possible_simple_key() === this.tokens_taken) {\n          return true;\n        }\n        return false;\n      }\n\n      fetch_more_tokens() {\n        var char;\n        // Eat whitespace and comments until we reach the next token.\n        this.scan_to_next_token();\n        // Remove obsolete possible simple keys\n        this.stale_possible_simple_keys();\n        // Compare the current indentation and column. It may add some tokens and\n        // decrease the current indentation level.\n        this.unwind_indent(this.column);\n        // Peek the next character.\n        char = this.peek();\n        if (char === '\\x00') {\n          // Is it the end of stream?\n          return this.fetch_stream_end();\n        }\n        if (char === '%' && this.check_directive()) {\n          // Is it a directive?\n          return this.fetch_directive();\n        }\n        if (char === '-' && this.check_document_start()) {\n          // Is it the document start?\n          return this.fetch_document_start();\n        }\n        if (char === '.' && this.check_document_end()) {\n          // Is it the document end?\n          return this.fetch_document_end();\n        }\n        if (char === '[') {\n          // TODO: support for BOM within a stream.\n\n          // Is it the flow sequence start indicator?\n          return this.fetch_flow_sequence_start();\n        }\n        if (char === '{') {\n          // Is it the flow mapping start indicator?\n          return this.fetch_flow_mapping_start();\n        }\n        if (char === ']') {\n          // Is it the flow sequence end indicator?\n          return this.fetch_flow_sequence_end();\n        }\n        if (char === '}') {\n          // Is it the flow mapping end indicator?\n          return this.fetch_flow_mapping_end();\n        }\n        if (char === ',') {\n          // Is it the flow entry indicator?\n          return this.fetch_flow_entry();\n        }\n        if (char === '-' && this.check_block_entry()) {\n          // Is it the block entry indicator?\n          return this.fetch_block_entry();\n        }\n        if (char === '?' && this.check_key()) {\n          // Is it the key indicator?\n          return this.fetch_key();\n        }\n        if (char === ':' && this.check_value()) {\n          // Is it the value indicator?\n          return this.fetch_value();\n        }\n        if (char === '*') {\n          // Is it an alias?\n          return this.fetch_alias();\n        }\n        if (char === '&') {\n          // Is it an anchor?\n          return this.fetch_anchor();\n        }\n        if (char === '!') {\n          // Is it a tag?\n          return this.fetch_tag();\n        }\n        if (char === '|' && this.flow_level === 0) {\n          // Is it a literal scalar?\n          return this.fetch_literal();\n        }\n        if (char === '>' && this.flow_level === 0) {\n          // Is it a folded scalar?\n          return this.fetch_folded();\n        }\n        if (char === '\\'') {\n          // Is it a single quoted scalar?\n          return this.fetch_single();\n        }\n        if (char === '\"') {\n          // Is it a double quoted scalar?\n          return this.fetch_double();\n        }\n        if (this.check_plain()) {\n          // It must be a plain scalar then.\n          return this.fetch_plain();\n        }\n        // No? It's an error.\n        throw new exports.ScannerError('while scanning for the next token', null, `found character ${char} that cannot start any token`, this.get_mark());\n      }\n\n      // Simple keys treatment.\n      /*\n      Return the number of the nearest possible simple key.\n      */\n      next_possible_simple_key() {\n        var key, level, min_token_number, ref;\n        min_token_number = null;\n        ref = this.possible_simple_keys;\n        for (level in ref) {\n          if (!hasProp.call(ref, level)) continue;\n          key = ref[level];\n          if (min_token_number === null || key.token_number < min_token_number) {\n            min_token_number = key.token_number;\n          }\n        }\n        return min_token_number;\n      }\n\n      /*\n      Remove entries that are no longer possible simple keys.  According to the\n      YAML spec, simple keys:\n      should be limited to a single line\n      should be no longer than 1024 characters\n      Disabling this procedure will allow simple keys of any length and height\n      (may cause problems if indentation is broken though).\n      */\n      stale_possible_simple_keys() {\n        var key, level, ref, results;\n        ref = this.possible_simple_keys;\n        results = [];\n        for (level in ref) {\n          if (!hasProp.call(ref, level)) continue;\n          key = ref[level];\n          if (key.line === this.line && this.index - key.index <= 1024) {\n            continue;\n          }\n          if (!key.required) {\n            results.push(delete this.possible_simple_keys[level]);\n          } else {\n            throw new exports.ScannerError('while scanning a simple key', key.mark, 'could not find expected \\':\\'', this.get_mark());\n          }\n        }\n        return results;\n      }\n\n      /*\n      The next token may start a simple key.  We check if it's possible and save\n      its position.  This function is called for ALIAS, ANCHOR, TAG,\n      SCALAR (flow),'[' and '{'.\n      */\n      save_possible_simple_key() {\n        var required, token_number;\n        // Check if a simple key is required at the current position.\n        required = this.flow_level === 0 && this.indent === this.column;\n        if (required && !this.allow_simple_key) {\n          // A simple key is required only if it is the first token in the current\n          // line.  Therefore it is always allowed.\n          throw new Error('logic failure');\n        }\n        // If simple keys aren't allowed here we're done.\n        if (!this.allow_simple_key) {\n          return;\n        }\n        // The next token might be a simple key.  Let's save its number and\n        // position.\n        this.remove_possible_simple_key();\n        token_number = this.tokens_taken + this.tokens.length;\n        return this.possible_simple_keys[this.flow_level] = new SimpleKey(token_number, required, this.index, this.line, this.column, this.get_mark());\n      }\n\n      /*\n      Remove the saved possible simple key at the current flow level.\n      */\n      remove_possible_simple_key() {\n        var key;\n        if (!(key = this.possible_simple_keys[this.flow_level])) {\n          return;\n        }\n        if (!key.required) {\n          return delete this.possible_simple_keys[this.flow_level];\n        } else {\n          throw new exports.ScannerError('while scanning a simple key', key.mark, 'could not find expected \\':\\'', this.get_mark());\n        }\n      }\n\n      // Indentation functions\n      /*\n      In flow context, tokens should respect indentation.\n      Actually the condition should be `self.indent >= column` according to\n      the spec. But this condition will prohibit intuitively correct\n      constructions such as\n        key : {\n        }\n      */\n      unwind_indent(column) {\n        var mark, results;\n        // In the flow context, indentation is ignored.  We make the scanner less\n        // restrictive than the specification requires.\n        if (this.flow_level !== 0) {\n          return;\n        }\n        results = [];\n        // In block context we may need to issue the BLOCK-END tokens.\n        while (this.indent > column) {\n          mark = this.get_mark();\n          this.indent = this.indents.pop();\n          results.push(this.tokens.push(new tokens.BlockEndToken(mark, mark)));\n        }\n        return results;\n      }\n\n      /*\n      Check if we need to increase indentation.\n      */\n      add_indent(column) {\n        if (!(column > this.indent)) {\n          return false;\n        }\n        this.indents.push(this.indent);\n        this.indent = column;\n        return true;\n      }\n\n      // Fetchers.\n      fetch_stream_start() {\n        var mark;\n        mark = this.get_mark();\n        return this.tokens.push(new tokens.StreamStartToken(mark, mark, this.encoding));\n      }\n\n      fetch_stream_end() {\n        var mark;\n        // Set the current indentation to -1.\n        this.unwind_indent(-1);\n        // Reset simple keys.\n        this.remove_possible_simple_key();\n        this.allow_possible_simple_key = false;\n        this.possible_simple_keys = {};\n        mark = this.get_mark();\n        this.tokens.push(new tokens.StreamEndToken(mark, mark));\n        // The stream is finished.\n        return this.done = true;\n      }\n\n      fetch_directive() {\n        // Set the current indentation to -1.\n        this.unwind_indent(-1);\n        // Reset simple keys.\n        this.remove_possible_simple_key();\n        this.allow_simple_key = false;\n        // Scan and add DIRECTIVE\n        return this.tokens.push(this.scan_directive());\n      }\n\n      fetch_document_start() {\n        return this.fetch_document_indicator(tokens.DocumentStartToken);\n      }\n\n      fetch_document_end() {\n        return this.fetch_document_indicator(tokens.DocumentEndToken);\n      }\n\n      fetch_document_indicator(TokenClass) {\n        var start_mark;\n        // Set the current indentation to -1.\n        this.unwind_indent(-1);\n        // Reset simple keys.  Note that there would not be a block collection\n        // after '---'.\n        this.remove_possible_simple_key();\n        this.allow_simple_key = false;\n        // Add DOCUMENT-START or DOCUMENT-END.\n        start_mark = this.get_mark();\n        this.forward(3);\n        return this.tokens.push(new TokenClass(start_mark, this.get_mark()));\n      }\n\n      fetch_flow_sequence_start() {\n        return this.fetch_flow_collection_start(tokens.FlowSequenceStartToken);\n      }\n\n      fetch_flow_mapping_start() {\n        return this.fetch_flow_collection_start(tokens.FlowMappingStartToken);\n      }\n\n      fetch_flow_collection_start(TokenClass) {\n        var start_mark;\n        // '[' and '{' may start a simple key.\n        this.save_possible_simple_key();\n        // Increase flow level.\n        this.flow_level++;\n        // Simple keys are allowed after '[' and '{'\n        this.allow_simple_key = true;\n        // Add FLOW-SEQUENCE-START or FLOW-MAPPING-START.\n        start_mark = this.get_mark();\n        this.forward();\n        return this.tokens.push(new TokenClass(start_mark, this.get_mark()));\n      }\n\n      fetch_flow_sequence_end() {\n        return this.fetch_flow_collection_end(tokens.FlowSequenceEndToken);\n      }\n\n      fetch_flow_mapping_end() {\n        return this.fetch_flow_collection_end(tokens.FlowMappingEndToken);\n      }\n\n      fetch_flow_collection_end(TokenClass) {\n        var start_mark;\n        // Reset possible simple key on the current level.\n        this.remove_possible_simple_key();\n        // Decrease the flow level\n        this.flow_level--;\n        // No simple keys after ']' or '}'\n        this.allow_simple_key = false;\n        // Add FLOW-SEQUENCE-END or FLOW-MAPPING-END.\n        start_mark = this.get_mark();\n        this.forward();\n        return this.tokens.push(new TokenClass(start_mark, this.get_mark()));\n      }\n\n      fetch_flow_entry() {\n        var start_mark;\n        // Simple keys are allowed after ','.\n        this.allow_simple_key = true;\n        // Reset possible simple key on the current level.\n        this.remove_possible_simple_key();\n        // Add FLOW-ENTRY\n        start_mark = this.get_mark();\n        this.forward();\n        return this.tokens.push(new tokens.FlowEntryToken(start_mark, this.get_mark()));\n      }\n\n      fetch_block_entry() {\n        var mark, start_mark;\n        // Block context needs additional checks\n        if (this.flow_level === 0) {\n          // Are we allowed to start a new entry?\n          if (!this.allow_simple_key) {\n            throw new exports.ScannerError(null, null, 'sequence entries are not allowed here', this.get_mark());\n          }\n          // We may need to add BLOCK-SEQUENCE-START\n          if (this.add_indent(this.column)) {\n            mark = this.get_mark();\n            this.tokens.push(new tokens.BlockSequenceStartToken(mark, mark));\n          }\n        }\n        // It's an error for the block entry to occur in the flow context but we\n        // let the parser detect this.\n\n        // Simple keys are allowed after '-'\n        this.allow_simple_key = true;\n        // Reset possible simple key on the current level.\n        this.remove_possible_simple_key();\n        // Add BLOCK-ENTRY\n        start_mark = this.get_mark();\n        this.forward();\n        return this.tokens.push(new tokens.BlockEntryToken(start_mark, this.get_mark()));\n      }\n\n      fetch_key() {\n        var mark, start_mark;\n        // Block context needs additional checks.\n        if (this.flow_level === 0) {\n          // Are we allowed to start a key?\n          if (!this.allow_simple_key) {\n            throw new exports.ScannerError(null, null, 'mapping keys are not allowed here', this.get_mark());\n          }\n          // We may need to add BLOCK-MAPPING-START.\n          if (this.add_indent(this.column)) {\n            mark = this.get_mark();\n            this.tokens.push(new tokens.BlockMappingStartToken(mark, mark));\n          }\n        }\n        // Simple keys are allowed after '?' in the flow context.\n        this.allow_simple_key = !this.flow_level;\n        // Reset possible simple key on the current level.\n        this.remove_possible_simple_key();\n        // Add KEY.\n        start_mark = this.get_mark();\n        this.forward();\n        return this.tokens.push(new tokens.KeyToken(start_mark, this.get_mark()));\n      }\n\n      fetch_value() {\n        var key, mark, start_mark;\n        // Do we determine a simple key?\n        if (key = this.possible_simple_keys[this.flow_level]) {\n          // Add KEY.\n          delete this.possible_simple_keys[this.flow_level];\n          this.tokens.splice(key.token_number - this.tokens_taken, 0, new tokens.KeyToken(key.mark, key.mark));\n          // If this key starts a new block mapping we need to add\n          // BLOCK-MAPPING-START.\n          if (this.flow_level === 0) {\n            if (this.add_indent(key.column)) {\n              this.tokens.splice(key.token_number - this.tokens_taken, 0, new tokens.BlockMappingStartToken(key.mark, key.mark));\n            }\n          }\n          // There cannot be two simple keys one after the other.\n          this.allow_simple_key = false;\n        } else {\n          // Block context needs additional checks.\n          // TODO: do we really need them?  Parser will catch them anyway.\n          // It must be part of a complex key.\n          if (this.flow_level === 0) {\n            // We are allowed to start a complex value if and only if we can start\n            // a simple key.\n            if (!this.allow_simple_key) {\n              throw new exports.ScannerError(null, null, 'mapping values are not allowed here', this.get_mark());\n            }\n            // If this value starts a new block mapping we need to add\n            // BLOCK-MAPPING-START.  It will be detected as an error later by the\n            // parser.\n            if (this.add_indent(this.column)) {\n              mark = this.get_mark();\n              this.tokens.push(new tokens.BlockMappingStartToken(mark, mark));\n            }\n          }\n          // Simple keys are allowed after ':' in the block context.\n          this.allow_simple_key = !this.flow_level;\n          // Reset possible simple key on the current level.\n          this.remove_possible_simple_key();\n        }\n        // Add VALUE.\n        start_mark = this.get_mark();\n        this.forward();\n        return this.tokens.push(new tokens.ValueToken(start_mark, this.get_mark()));\n      }\n\n      fetch_alias() {\n        // ALIAS could be a simple key.\n        this.save_possible_simple_key();\n        // No simple keys after ALIAS.\n        this.allow_simple_key = false;\n        // Scan and add ALIAS.\n        return this.tokens.push(this.scan_anchor(tokens.AliasToken));\n      }\n\n      fetch_anchor() {\n        // ANCHOR could start a simple key.\n        this.save_possible_simple_key();\n        // No simple keys allowed after ANCHOR.\n        this.allow_simple_key = false;\n        // Scan and add ANCHOR.\n        return this.tokens.push(this.scan_anchor(tokens.AnchorToken));\n      }\n\n      fetch_tag() {\n        // TAG could start a simple key\n        this.save_possible_simple_key();\n        // No simple keys after TAG.\n        this.allow_simple_key = false;\n        // Scan and add TAG.\n        return this.tokens.push(this.scan_tag());\n      }\n\n      fetch_literal() {\n        return this.fetch_block_scalar('|');\n      }\n\n      fetch_folded() {\n        return this.fetch_block_scalar('>');\n      }\n\n      fetch_block_scalar(style) {\n        // A simple key may follow a block sclar.\n        this.allow_simple_key = true;\n        // Reset possible simple key on the current level.\n        this.remove_possible_simple_key();\n        // Scan and add SCALAR.\n        return this.tokens.push(this.scan_block_scalar(style));\n      }\n\n      fetch_single() {\n        return this.fetch_flow_scalar('\\'');\n      }\n\n      fetch_double() {\n        return this.fetch_flow_scalar('\"');\n      }\n\n      fetch_flow_scalar(style) {\n        // A flow scalar could be a simple key.\n        this.save_possible_simple_key();\n        // No simple keys after flow scalars.\n        this.allow_simple_key = false;\n        // Scan and add SCALAR.\n        return this.tokens.push(this.scan_flow_scalar(style));\n      }\n\n      fetch_plain() {\n        // A plain scalar could be a simple key.\n        this.save_possible_simple_key();\n        // No simple keys after plain scalars.  But note that `scan_plain` will\n        // change this flag if the scan is finished at the beginning of the line.\n        this.allow_simple_key = false;\n        // Scan and add SCALAR.  May change `allow_simple_key`.\n        return this.tokens.push(this.scan_plain());\n      }\n\n      // Checkers.\n      /*\n      DIRECTIVE: ^ '%'\n      */\n      check_directive() {\n        if (this.column === 0) {\n          // The % indicator has already been checked.\n          return true;\n        }\n        return false;\n      }\n\n      /*\n      DOCUMENT-START: ^ '---' (' '|'\\n')\n      */\n      check_document_start() {\n        var ref;\n        if (this.column === 0 && this.prefix(3) === '---' && (ref = this.peek(3), indexOf.call(C_LB + C_WS + '\\x00', ref) >= 0)) {\n          return true;\n        }\n        return false;\n      }\n\n      /*\n      DOCUMENT-END: ^ '...' (' '|'\\n')\n      */\n      check_document_end() {\n        var ref;\n        if (this.column === 0 && this.prefix(3) === '...' && (ref = this.peek(3), indexOf.call(C_LB + C_WS + '\\x00', ref) >= 0)) {\n          return true;\n        }\n        return false;\n      }\n\n      /*\n      BLOCK-ENTRY: '-' (' '|'\\n')\n      */\n      check_block_entry() {\n        var ref;\n        return ref = this.peek(1), indexOf.call(C_LB + C_WS + '\\x00', ref) >= 0;\n      }\n\n      /*\n      KEY (flow context):  '?'\n      KEY (block context): '?' (' '|'\\n')\n      */\n      check_key() {\n        var ref;\n        if (this.flow_level !== 0) {\n          // KEY (flow context)\n          return true;\n        }\n        // KEY (block context)\n        return ref = this.peek(1), indexOf.call(C_LB + C_WS + '\\x00', ref) >= 0;\n      }\n\n      /*\n      VALUE (flow context):  ':'\n      VALUE (block context): ':' (' '|'\\n')\n      */\n      check_value() {\n        var ref;\n        if (this.flow_level !== 0) {\n          // VALUE (flow context)\n          return true;\n        }\n        // VALUE (block context)\n        return ref = this.peek(1), indexOf.call(C_LB + C_WS + '\\x00', ref) >= 0;\n      }\n\n      /*\n      A plain scalar may start with any non-space character except:\n      '-', '?', ':', ',', '[', ']', '{', '}',\n      '#', '&', '*', '!', '|', '>', '\\'', '\"',\n      '%', '@', '`'.\n\n      It may also start with\n      '-', '?', ':'\n      if it is followed by a non-space character.\n\n      Note that we limit the last rule to the block context (except the '-'\n      character) because we want the flow context to be space independent.\n      */\n      check_plain() {\n        var char, ref;\n        char = this.peek();\n        return indexOf.call(C_LB + C_WS + '\\x00-?:,[]{}#&*!|>\\'\"%@`', char) < 0 || ((ref = this.peek(1), indexOf.call(C_LB + C_WS + '\\x00', ref) < 0) && (char === '-' || (this.flow_level === 0 && indexOf.call('?:', char) >= 0)));\n      }\n\n      // Scanners.\n      /*\n      We ignore spaces, line breaks and comments.\n      If we find a line break in the block context, we set the flag\n      `allow_simple_key` on.\n      The byte order mark is stripped if it's the first character in the stream.\n      We do not yet support BOM inside the stream as the specification requires.\n      Any such mark will be considered as a part of the document.\n\n      TODO: We need to make tab handling rules more sane.  A good rule is\n      Tabs cannot precede tokens BLOCK-SEQUENCE-START, BLOCK-MAPPING-START,\n      BLOCK-END, KEY (block context), VALUE (block context), BLOCK-ENTRY\n      So the tab checking code is\n      @allow_simple_key = off if <TAB>\n      We also need to add the check for `allow_simple_key is on` to\n      `unwind_indent` before issuing BLOCK-END.  Scanners for block, flow and\n      plain scalars need to be modified.\n      */\n      scan_to_next_token() {\n        var found, ref, results;\n        if (this.index === 0 && this.peek() === '\\uFEFF') {\n          this.forward();\n        }\n        found = false;\n        results = [];\n        while (!found) {\n          while (this.peek() === ' ') {\n            this.forward();\n          }\n          if (this.peek() === '#') {\n            while (ref = this.peek(), indexOf.call(C_LB + '\\x00', ref) < 0) {\n              this.forward();\n            }\n          }\n          if (this.scan_line_break()) {\n            if (this.flow_level === 0) {\n              results.push(this.allow_simple_key = true);\n            } else {\n              results.push(void 0);\n            }\n          } else {\n            results.push(found = true);\n          }\n        }\n        return results;\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_directive() {\n        var end_mark, name, ref, start_mark, value;\n        start_mark = this.get_mark();\n        this.forward();\n        name = this.scan_directive_name(start_mark);\n        value = null;\n        if (name === 'YAML') {\n          value = this.scan_yaml_directive_value(start_mark);\n          end_mark = this.get_mark();\n        } else if (name === 'TAG') {\n          value = this.scan_tag_directive_value(start_mark);\n          end_mark = this.get_mark();\n        } else {\n          end_mark = this.get_mark();\n          while (ref = this.peek(), indexOf.call(C_LB + '\\x00', ref) < 0) {\n            this.forward();\n          }\n        }\n        this.scan_directive_ignored_line(start_mark);\n        return new tokens.DirectiveToken(name, value, start_mark, end_mark);\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_directive_name(start_mark) {\n        var char, length, value;\n        length = 0;\n        char = this.peek(length);\n        while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || indexOf.call('-_', char) >= 0) {\n          length++;\n          char = this.peek(length);\n        }\n        if (length === 0) {\n          throw new exports.ScannerError('while scanning a directive', start_mark, `expected alphanumeric or numeric character but found ${char}`, this.get_mark());\n        }\n        value = this.prefix(length);\n        this.forward(length);\n        char = this.peek();\n        if (indexOf.call(C_LB + '\\x00 ', char) < 0) {\n          throw new exports.ScannerError('while scanning a directive', start_mark, `expected alphanumeric or numeric character but found ${char}`, this.get_mark());\n        }\n        return value;\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_yaml_directive_value(start_mark) {\n        var major, minor, ref;\n        while (this.peek() === ' ') {\n          this.forward();\n        }\n        major = this.scan_yaml_directive_number(start_mark);\n        if (this.peek() !== '.') {\n          throw new exports.ScannerError('while scanning a directive', start_mark, `expected a digit or '.' but found ${this.peek()}`, this.get_mark());\n        }\n        this.forward();\n        minor = this.scan_yaml_directive_number(start_mark);\n        if (ref = this.peek(), indexOf.call(C_LB + '\\x00 ', ref) < 0) {\n          throw new exports.ScannerError('while scanning a directive', start_mark, `expected a digit or ' ' but found ${this.peek()}`, this.get_mark());\n        }\n        return [major, minor];\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_yaml_directive_number(start_mark) {\n        var char, length, ref, value;\n        char = this.peek();\n        if (!(('0' <= char && char <= '9'))) {\n          throw new exports.ScannerError('while scanning a directive', start_mark, `expected a digit but found ${char}`, this.get_mark());\n        }\n        length = 0;\n        while (('0' <= (ref = this.peek(length)) && ref <= '9')) {\n          length++;\n        }\n        value = parseInt(this.prefix(length));\n        this.forward(length);\n        return value;\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_tag_directive_value(start_mark) {\n        var handle, prefix;\n        while (this.peek() === ' ') {\n          this.forward();\n        }\n        handle = this.scan_tag_directive_handle(start_mark);\n        while (this.peek() === ' ') {\n          this.forward();\n        }\n        prefix = this.scan_tag_directive_prefix(start_mark);\n        return [handle, prefix];\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_tag_directive_handle(start_mark) {\n        var char, value;\n        value = this.scan_tag_handle('directive', start_mark);\n        char = this.peek();\n        if (char !== ' ') {\n          throw new exports.ScannerError('while scanning a directive', start_mark, `expected ' ' but found ${char}`, this.get_mark());\n        }\n        return value;\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_tag_directive_prefix(start_mark) {\n        var char, value;\n        value = this.scan_tag_uri('directive', start_mark);\n        char = this.peek();\n        if (indexOf.call(C_LB + '\\x00 ', char) < 0) {\n          throw new exports.ScannerError('while scanning a directive', start_mark, `expected ' ' but found ${char}`, this.get_mark());\n        }\n        return value;\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_directive_ignored_line(start_mark) {\n        var char, ref;\n        while (this.peek() === ' ') {\n          this.forward();\n        }\n        if (this.peek() === '#') {\n          while (ref = this.peek(), indexOf.call(C_LB + '\\x00', ref) < 0) {\n            this.forward();\n          }\n        }\n        char = this.peek();\n        if (indexOf.call(C_LB + '\\x00', char) < 0) {\n          throw new exports.ScannerError('while scanning a directive', start_mark, `expected a comment or a line break but found ${char}`, this.get_mark());\n        }\n        return this.scan_line_break();\n      }\n\n      /*\n      The specification does not restrict characters for anchors and aliases.\n      This may lead to problems, for instance, the document:\n      [ *alias, value ]\n      can be interpteted in two ways, as\n      [ \"value\" ]\n      and\n      [ *alias , \"value\" ]\n      Therefore we restrict aliases to numbers and ASCII letters.\n      */\n      scan_anchor(TokenClass) {\n        var char, indicator, length, name, start_mark, value;\n        start_mark = this.get_mark();\n        indicator = this.peek();\n        if (indicator === '*') {\n          name = 'alias';\n        } else {\n          name = 'anchor';\n        }\n        this.forward();\n        length = 0;\n        char = this.peek(length);\n        while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || indexOf.call('-_', char) >= 0) {\n          length++;\n          char = this.peek(length);\n        }\n        if (length === 0) {\n          throw new exports.ScannerError(`while scanning an ${name}`, start_mark, `expected alphabetic or numeric character but found '${char}'`, this.get_mark());\n        }\n        value = this.prefix(length);\n        this.forward(length);\n        char = this.peek();\n        if (indexOf.call(C_LB + C_WS + '\\x00' + '?:,]}%@`', char) < 0) {\n          throw new exports.ScannerError(`while scanning an ${name}`, start_mark, `expected alphabetic or numeric character but found '${char}'`, this.get_mark());\n        }\n        return new TokenClass(value, start_mark, this.get_mark());\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_tag() {\n        var char, handle, length, start_mark, suffix, use_handle;\n        start_mark = this.get_mark();\n        char = this.peek(1);\n        if (char === '<') {\n          handle = null;\n          this.forward(2);\n          suffix = this.scan_tag_uri('tag', start_mark);\n          if (this.peek() !== '>') {\n            throw new exports.ScannerError('while parsing a tag', start_mark, `expected '>' but found ${this.peek()}`, this.get_mark());\n          }\n          this.forward();\n        } else if (indexOf.call(C_LB + C_WS + '\\x00', char) >= 0) {\n          handle = null;\n          suffix = '!';\n          this.forward();\n        } else {\n          length = 1;\n          use_handle = false;\n          while (indexOf.call(C_LB + '\\x00 ', char) < 0) {\n            if (char === '!') {\n              use_handle = true;\n              break;\n            }\n            length++;\n            char = this.peek(length);\n          }\n          if (use_handle) {\n            handle = this.scan_tag_handle('tag', start_mark);\n          } else {\n            handle = '!';\n            this.forward();\n          }\n          suffix = this.scan_tag_uri('tag', start_mark);\n        }\n        char = this.peek();\n        if (indexOf.call(C_LB + '\\x00 ', char) < 0) {\n          throw new exports.ScannerError('while scanning a tag', start_mark, `expected ' ' but found ${char}`, this.get_mark());\n        }\n        return new tokens.TagToken([handle, suffix], start_mark, this.get_mark());\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_block_scalar(style) {\n        var breaks, chomping, chunks, end_mark, folded, increment, indent, leading_non_space, length, line_break, max_indent, min_indent, ref, ref1, ref2, start_mark;\n        folded = style === '>';\n        chunks = [];\n        start_mark = this.get_mark();\n        // Scan the header.\n        this.forward();\n        [chomping, increment] = this.scan_block_scalar_indicators(start_mark);\n        this.scan_block_scalar_ignored_line(start_mark);\n        // Determine the indentation level and go to the first non-empty line.\n        min_indent = this.indent + 1;\n        if (min_indent < 1) {\n          min_indent = 1;\n        }\n        if (increment == null) {\n          [breaks, max_indent, end_mark] = this.scan_block_scalar_indentation();\n          indent = Math.max(min_indent, max_indent);\n        } else {\n          indent = min_indent + increment - 1;\n          [breaks, end_mark] = this.scan_block_scalar_breaks(indent);\n        }\n        line_break = '';\n        // Scan the inner part of the block scalar.\n        while (this.column === indent && this.peek() !== '\\x00') {\n          chunks = chunks.concat(breaks);\n          leading_non_space = (ref = this.peek(), indexOf.call(' \\t', ref) < 0);\n          length = 0;\n          while (ref1 = this.peek(length), indexOf.call(C_LB + '\\x00', ref1) < 0) {\n            length++;\n          }\n          chunks.push(this.prefix(length));\n          this.forward(length);\n          line_break = this.scan_line_break();\n          [breaks, end_mark] = this.scan_block_scalar_breaks(indent);\n          if (this.column === indent && this.peek() !== '\\x00') {\n            // Unfortunately, folding rules are ambiguous.  This is the folding\n            // according to the specification:\n            if (folded && line_break === '\\n' && leading_non_space && (ref2 = this.peek(), indexOf.call(' \\t', ref2) < 0)) {\n              if (util.is_empty(breaks)) {\n                chunks.push(' ');\n              }\n            } else {\n              chunks.push(line_break);\n            }\n          } else {\n            // This is Clark Evan's interpretation (also in the spec examples):\n            // if folded and line_break is '\\n'\n            //   if not breaks\n            //     if @peek() not in ' \\t'\n            //       chunks.push ' '\n            //     else\n            //       chunks.push line_break\n            // else\n            //   chunks.push line_break\n            break;\n          }\n        }\n        if (chomping !== false) {\n          // Chomp the tail\n          chunks.push(line_break);\n        }\n        if (chomping === true) {\n          chunks = chunks.concat(breaks);\n        }\n        // And we're done.\n        return new tokens.ScalarToken(chunks.join(''), false, start_mark, end_mark, style);\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_block_scalar_indicators(start_mark) {\n        var char, chomping, increment;\n        chomping = null;\n        increment = null;\n        char = this.peek();\n        if (indexOf.call('+-', char) >= 0) {\n          chomping = char === '+';\n          this.forward();\n          char = this.peek();\n          if (indexOf.call(C_NUMBERS, char) >= 0) {\n            increment = parseInt(char);\n            if (increment === 0) {\n              throw new exports.ScannerError('while scanning a block scalar', start_mark, 'expected indentation indicator in the range 1-9 but found 0', this.get_mark());\n            }\n            this.forward();\n          }\n        } else if (indexOf.call(C_NUMBERS, char) >= 0) {\n          increment = parseInt(char);\n          if (increment === 0) {\n            throw new exports.ScannerError('while scanning a block scalar', start_mark, 'expected indentation indicator in the range 1-9 but found 0', this.get_mark());\n          }\n          this.forward();\n          char = this.peek();\n          if (indexOf.call('+-', char) >= 0) {\n            chomping = char === '+';\n            this.forward();\n          }\n        }\n        char = this.peek();\n        if (indexOf.call(C_LB + '\\x00 ', char) < 0) {\n          throw new exports.ScannerError('while scanning a block scalar', start_mark, `expected chomping or indentation indicators, but found ${char}`, this.get_mark());\n        }\n        return [chomping, increment];\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_block_scalar_ignored_line(start_mark) {\n        var char, ref;\n        while (this.peek() === ' ') {\n          this.forward();\n        }\n        if (this.peek() === '#') {\n          while (ref = this.peek(), indexOf.call(C_LB + '\\x00', ref) < 0) {\n            this.forward();\n          }\n        }\n        char = this.peek();\n        if (indexOf.call(C_LB + '\\x00', char) < 0) {\n          throw new exports.ScannerError('while scanning a block scalar', start_mark, `expected a comment or a line break but found ${char}`, this.get_mark());\n        }\n        return this.scan_line_break();\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_block_scalar_indentation() {\n        var chunks, end_mark, max_indent, ref;\n        chunks = [];\n        max_indent = 0;\n        end_mark = this.get_mark();\n        while (ref = this.peek(), indexOf.call(C_LB + ' ', ref) >= 0) {\n          if (this.peek() !== ' ') {\n            chunks.push(this.scan_line_break());\n            end_mark = this.get_mark();\n          } else {\n            this.forward();\n            if (this.column > max_indent) {\n              max_indent = this.column;\n            }\n          }\n        }\n        return [chunks, max_indent, end_mark];\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_block_scalar_breaks(indent) {\n        var chunks, end_mark, ref;\n        chunks = [];\n        end_mark = this.get_mark();\n        while (this.column < indent && this.peek() === ' ') {\n          this.forward();\n        }\n        while (ref = this.peek(), indexOf.call(C_LB, ref) >= 0) {\n          chunks.push(this.scan_line_break());\n          end_mark = this.get_mark();\n          while (this.column < indent && this.peek() === ' ') {\n            this.forward();\n          }\n        }\n        return [chunks, end_mark];\n      }\n\n      /*\n      See the specification for details.\n      Note that we loose indentation rules for quoted scalars. Quoted scalars\n      don't need to adhere indentation because \" and ' clearly mark the beginning\n      and the end of them. Therefore we are less restrictive than the\n      specification requires. We only need to check that document separators are\n      not included in scalars.\n      */\n      scan_flow_scalar(style) {\n        var chunks, double, quote, start_mark;\n        double = style === '\"';\n        chunks = [];\n        start_mark = this.get_mark();\n        quote = this.peek();\n        this.forward();\n        chunks = chunks.concat(this.scan_flow_scalar_non_spaces(double, start_mark));\n        while (this.peek() !== quote) {\n          chunks = chunks.concat(this.scan_flow_scalar_spaces(double, start_mark));\n          chunks = chunks.concat(this.scan_flow_scalar_non_spaces(double, start_mark));\n        }\n        this.forward();\n        return new tokens.ScalarToken(chunks.join(''), false, start_mark, this.get_mark(), style);\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_flow_scalar_non_spaces(double, start_mark) {\n        var char, chunks, code, i, k, length, ref, ref1, ref2;\n        chunks = [];\n        while (true) {\n          length = 0;\n          while (ref = this.peek(length), indexOf.call(C_LB + C_WS + '\\'\"\\\\\\x00', ref) < 0) {\n            length++;\n          }\n          if (length !== 0) {\n            chunks.push(this.prefix(length));\n            this.forward(length);\n          }\n          char = this.peek();\n          if (!double && char === '\\'' && this.peek(1) === '\\'') {\n            chunks.push('\\'');\n            this.forward(2);\n          } else if ((double && char === '\\'') || (!double && indexOf.call('\"\\\\', char) >= 0)) {\n            chunks.push(char);\n            this.forward();\n          } else if (double && char === '\\\\') {\n            this.forward();\n            char = this.peek();\n            if (char in ESCAPE_REPLACEMENTS) {\n              chunks.push(ESCAPE_REPLACEMENTS[char]);\n              this.forward();\n            } else if (char in ESCAPE_CODES) {\n              length = ESCAPE_CODES[char];\n              this.forward();\n              for (k = i = 0, ref1 = length; 0 <= ref1 ? i < ref1 : i > ref1; k = 0 <= ref1 ? ++i : --i) {\n                if (ref2 = this.peek(k), indexOf.call(`${C_NUMBERS}ABCDEFabcdef`, ref2) < 0) {\n                  throw new exports.ScannerError('while scanning a double-quoted scalar', start_mark, `expected escape sequence of ${length} hexadecimal numbers, but found ${this.peek(k)}`, this.get_mark());\n                }\n              }\n              code = parseInt(this.prefix(length), 16);\n              chunks.push(String.fromCharCode(code));\n              this.forward(length);\n            } else if (indexOf.call(C_LB, char) >= 0) {\n              this.scan_line_break();\n              chunks = chunks.concat(this.scan_flow_scalar_breaks(double, start_mark));\n            } else {\n              throw new exports.ScannerError('while scanning a double-quoted scalar', start_mark, `found unknown escape character ${char}`, this.get_mark());\n            }\n          } else {\n            return chunks;\n          }\n        }\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_flow_scalar_spaces(double, start_mark) {\n        var breaks, char, chunks, length, line_break, ref, whitespaces;\n        chunks = [];\n        length = 0;\n        while (ref = this.peek(length), indexOf.call(C_WS, ref) >= 0) {\n          length++;\n        }\n        whitespaces = this.prefix(length);\n        this.forward(length);\n        char = this.peek();\n        if (char === '\\x00') {\n          throw new exports.ScannerError('while scanning a quoted scalar', start_mark, 'found unexpected end of stream', this.get_mark());\n        }\n        if (indexOf.call(C_LB, char) >= 0) {\n          line_break = this.scan_line_break();\n          breaks = this.scan_flow_scalar_breaks(double, start_mark);\n          if (line_break !== '\\n') {\n            chunks.push(line_break);\n          } else if (breaks.length === 0) {\n            chunks.push(' ');\n          }\n          chunks = chunks.concat(breaks);\n        } else {\n          chunks.push(whitespaces);\n        }\n        return chunks;\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_flow_scalar_breaks(double, start_mark) {\n        var chunks, prefix, ref, ref1, ref2;\n        chunks = [];\n        while (true) {\n          // Instead of checking for indentation, we check for document separators.\n          prefix = this.prefix(3);\n          if (prefix === '---' || prefix === '...' && (ref = this.peek(3), indexOf.call(C_LB + C_WS + '\\x00', ref) >= 0)) {\n            throw new exports.ScannerError('while scanning a quoted scalar', start_mark, 'found unexpected document separator', this.get_mark());\n          }\n          while (ref1 = this.peek(), indexOf.call(C_WS, ref1) >= 0) {\n            this.forward();\n          }\n          if (ref2 = this.peek(), indexOf.call(C_LB, ref2) >= 0) {\n            chunks.push(this.scan_line_break());\n          } else {\n            return chunks;\n          }\n        }\n      }\n\n      /*\n      See the specification for details.\n      We add an additional restriction for the flow context:\n        plain scalars in the flow context cannot contain ',', ':' and '?'.\n      We also keep track of the `allow_simple_key` flag here.\n      Indentation rules are loosed for the flow context.\n      */\n      scan_plain() {\n        var char, chunks, end_mark, indent, length, ref, ref1, spaces, start_mark;\n        chunks = [];\n        start_mark = end_mark = this.get_mark();\n        indent = this.indent + 1;\n        // We allow zero indentation for scalars, but then we need to check for\n        // document separators at the beginning of the line.\n        // indent = 1 if indent is 0\n        spaces = [];\n        while (true) {\n          length = 0;\n          if (this.peek() === '#') {\n            break;\n          }\n          while (true) {\n            char = this.peek(length);\n            if (indexOf.call(C_LB + C_WS + '\\x00', char) >= 0 || (this.flow_level === 0 && char === ':' && (ref = this.peek(length + 1), indexOf.call(C_LB + C_WS + '\\x00', ref) >= 0)) || (this.flow_level !== 0 && indexOf.call(',:?[]{}', char) >= 0)) {\n              break;\n            }\n            length++;\n          }\n          // It's not clear what we should do with ':' in the flow context.\n          if (this.flow_level !== 0 && char === ':' && (ref1 = this.peek(length + 1), indexOf.call(C_LB + C_WS + '\\x00,[]{}', ref1) < 0)) {\n            this.forward(length);\n            throw new exports.ScannerError('while scanning a plain scalar', start_mark, 'found unexpected \\':\\'', this.get_mark(), 'Please check http://pyyaml.org/wiki/YAMLColonInFlowContext');\n          }\n          if (length === 0) {\n            break;\n          }\n          this.allow_simple_key = false;\n          chunks = chunks.concat(spaces);\n          chunks.push(this.prefix(length));\n          this.forward(length);\n          end_mark = this.get_mark();\n          spaces = this.scan_plain_spaces(indent, start_mark);\n          if ((spaces == null) || spaces.length === 0 || this.peek() === '#' || (this.flow_level === 0 && this.column < indent)) {\n            break;\n          }\n        }\n        return new tokens.ScalarToken(chunks.join(''), true, start_mark, end_mark);\n      }\n\n      /*\n      See the specification for details.\n      The specification is really confusing about tabs in plain scalars.\n      We just forbid them completely. Do not use tabs in YAML!\n      */\n      scan_plain_spaces(indent, start_mark) {\n        var breaks, char, chunks, length, line_break, prefix, ref, ref1, ref2, ref3, whitespaces;\n        chunks = [];\n        length = 0;\n        while (ref = this.peek(length), indexOf.call(' ', ref) >= 0) {\n          length++;\n        }\n        whitespaces = this.prefix(length);\n        this.forward(length);\n        char = this.peek();\n        if (indexOf.call(C_LB, char) >= 0) {\n          line_break = this.scan_line_break();\n          this.allow_simple_key = true;\n          prefix = this.prefix(3);\n          if (prefix === '---' || prefix === '...' && (ref1 = this.peek(3), indexOf.call(C_LB + C_WS + '\\x00', ref1) >= 0)) {\n            return;\n          }\n          breaks = [];\n          while (ref3 = this.peek(), indexOf.call(C_LB + ' ', ref3) >= 0) {\n            if (this.peek() === ' ') {\n              this.forward();\n            } else {\n              breaks.push(this.scan_line_break());\n              prefix = this.prefix(3);\n              if (prefix === '---' || prefix === '...' && (ref2 = this.peek(3), indexOf.call(C_LB + C_WS + '\\x00', ref2) >= 0)) {\n                return;\n              }\n            }\n          }\n          if (line_break !== '\\n') {\n            chunks.push(line_break);\n          } else if (breaks.length === 0) {\n            chunks.push(' ');\n          }\n          chunks = chunks.concat(breaks);\n        } else if (whitespaces) {\n          chunks.push(whitespaces);\n        }\n        return chunks;\n      }\n\n      /*\n      See the specification for details.\n      For some strange reasons, the specification does not allow '_' in tag\n      handles. I have allowed it anyway.\n      */\n      scan_tag_handle(name, start_mark) {\n        var char, length, value;\n        char = this.peek();\n        if (char !== '!') {\n          throw new exports.ScannerError(`while scanning a ${name}`, start_mark, `expected '!' but found ${char}`, this.get_mark());\n        }\n        length = 1;\n        char = this.peek(length);\n        if (char !== ' ') {\n          while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || indexOf.call('-_', char) >= 0) {\n            length++;\n            char = this.peek(length);\n          }\n          if (char !== '!') {\n            this.forward(length);\n            throw new exports.ScannerError(`while scanning a ${name}`, start_mark, `expected '!' but found ${char}`, this.get_mark());\n          }\n          length++;\n        }\n        value = this.prefix(length);\n        this.forward(length);\n        return value;\n      }\n\n      /*\n      See the specification for details.\n      Note: we do not check if URI is well-formed.\n      */\n      scan_tag_uri(name, start_mark) {\n        var char, chunks, length;\n        chunks = [];\n        length = 0;\n        char = this.peek(length);\n        while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || indexOf.call('-;/?:@&=+$,_.!~*\\'()[]%', char) >= 0) {\n          if (char === '%') {\n            chunks.push(this.prefix(length));\n            this.forward(length);\n            length = 0;\n            chunks.push(this.scan_uri_escapes(name, start_mark));\n          } else {\n            length++;\n          }\n          char = this.peek(length);\n        }\n        if (length !== 0) {\n          chunks.push(this.prefix(length));\n          this.forward(length);\n          length = 0;\n        }\n        if (chunks.length === 0) {\n          throw new exports.ScannerError(`while parsing a ${name}`, start_mark, `expected URI but found ${char}`, this.get_mark());\n        }\n        return chunks.join('');\n      }\n\n      /*\n      See the specification for details.\n      */\n      scan_uri_escapes(name, start_mark) {\n        var bytes, i, k, mark;\n        bytes = [];\n        mark = this.get_mark();\n        while (this.peek() === '%') {\n          this.forward();\n          for (k = i = 0; i <= 2; k = ++i) {\n            throw new exports.ScannerError(`while scanning a ${name}`, start_mark, `expected URI escape sequence of 2 hexadecimal numbers but found ${this.peek(k)}`, this.get_mark());\n          }\n          bytes.push(String.fromCharCode(parseInt(this.prefix(2), 16)));\n          this.forward(2);\n        }\n        return bytes.join('');\n      }\n\n      /*\n      Transforms:\n      '\\r\\n'      :   '\\n'\n      '\\r'        :   '\\n'\n      '\\n'        :   '\\n'\n      '\\x85'      :   '\\n'\n      '\\u2028'    :   '\\u2028'\n      '\\u2029     :   '\\u2029'\n      default     :   ''\n      */\n      scan_line_break() {\n        var char;\n        char = this.peek();\n        if (indexOf.call('\\r\\n\\x85', char) >= 0) {\n          if (this.prefix(2) === '\\r\\n') {\n            this.forward(2);\n          } else {\n            this.forward();\n          }\n          return '\\n';\n        } else if (indexOf.call('\\u2028\\u2029', char) >= 0) {\n          this.forward();\n          return char;\n        }\n        return '';\n      }\n\n    };\n\n    C_LB = '\\r\\n\\x85\\u2028\\u2029';\n\n    C_WS = '\\t ';\n\n    C_NUMBERS = '0123456789';\n\n    ESCAPE_REPLACEMENTS = {\n      '0': '\\x00',\n      'a': '\\x07',\n      'b': '\\x08',\n      't': '\\x09',\n      '\\t': '\\x09',\n      'n': '\\x0A',\n      'v': '\\x0B',\n      'f': '\\x0C',\n      'r': '\\x0D',\n      'e': '\\x1B',\n      ' ': '\\x20',\n      '\"': '\"',\n      '\\\\': '\\\\',\n      'N': '\\x85',\n      '_': '\\xA0',\n      'L': '\\u2028',\n      'P': '\\u2029'\n    };\n\n    ESCAPE_CODES = {\n      'x': 2,\n      'u': 4,\n      'U': 8\n    };\n\n    ctor = Scanner.prototype.initialise;\n\n    return Scanner;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsSUFBSSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLEdBQVU7O0FBRXpDLFdBQVcsbUJBQU8sQ0FBQyxHQUFVOztBQUU3QixTQUFTLG1CQUFPLENBQUMsR0FBUTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxNQUFNO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMklBQTJJLEtBQUs7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJJQUEySSxLQUFLO0FBQ2hKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCxZQUFZO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILFlBQVk7QUFDcEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILEtBQUs7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLEtBQUs7QUFDbEg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsS0FBSztBQUNsSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JLEtBQUs7QUFDeEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELEtBQUssc0VBQXNFLEtBQUs7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsOERBQThELEtBQUssc0VBQXNFLEtBQUs7QUFDOUk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxZQUFZO0FBQ3BIO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxLQUFLO0FBQzVHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdKQUFnSixLQUFLO0FBQ3JKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSUFBc0ksS0FBSztBQUMzSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBaUM7QUFDOUUseURBQXlELFVBQVU7QUFDbkUscUlBQXFJLFFBQVEsaUNBQWlDLGFBQWE7QUFDM0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkLG9JQUFvSSxLQUFLO0FBQ3pJO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsME9BQTBPO0FBQzFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkg7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSyx5Q0FBeUMsS0FBSztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxLQUFLLHlDQUF5QyxLQUFLO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEtBQUsseUNBQXlDLEtBQUs7QUFDL0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDLCtEQUErRCxLQUFLLGtGQUFrRixhQUFhO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy95YW1sLWpzL2xpYi9zY2FubmVyLmpzPzY2MTMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBTaW1wbGVLZXksIHRva2VucywgdXRpbCxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbiAgKHtNYXJrZWRZQU1MRXJyb3J9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKSk7XG5cbiAgdG9rZW5zID0gcmVxdWlyZSgnLi90b2tlbnMnKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLypcbiAgVGhlIFNjYW5uZXIgdGhyb3dzIHRoZXNlLlxuICAqL1xuICB0aGlzLlNjYW5uZXJFcnJvciA9IGNsYXNzIFNjYW5uZXJFcnJvciBleHRlbmRzIE1hcmtlZFlBTUxFcnJvciB7fTtcblxuICAvKlxuICBSZXByZXNlbnRzIGEgcG9zc2libGUgc2ltcGxlIGtleS5cbiAgKi9cbiAgU2ltcGxlS2V5ID0gY2xhc3MgU2ltcGxlS2V5IHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbl9udW1iZXIxLCByZXF1aXJlZDEsIGluZGV4LCBsaW5lLCBjb2x1bW4xLCBtYXJrMSkge1xuICAgICAgdGhpcy50b2tlbl9udW1iZXIgPSB0b2tlbl9udW1iZXIxO1xuICAgICAgdGhpcy5yZXF1aXJlZCA9IHJlcXVpcmVkMTtcbiAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjE7XG4gICAgICB0aGlzLm1hcmsgPSBtYXJrMTtcbiAgICB9XG5cbiAgfTtcblxuICAvKlxuICBUaGUgU2Nhbm5lciBjbGFzcyBkZWFscyB3aXRoIGNvbnZlcnRpbmcgYSBZQU1MIHN0cmVhbSBpbnRvIGEgdG9rZW4gc3RyZWFtLlxuICAqL1xuICB0aGlzLlNjYW5uZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIENfTEIsIENfTlVNQkVSUywgQ19XUywgRVNDQVBFX0NPREVTLCBFU0NBUEVfUkVQTEFDRU1FTlRTLCBjdG9yO1xuXG4gICAgY2xhc3MgU2Nhbm5lciB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIEluaXRpYWxpc2UgdGhlIFNjYW5uZXJcbiAgICAgICovXG4gICAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICAvLyBIYXZlIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc3RyZWFtP1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgLy8gSG93IG1hbnkgdW5jbG9zZWQgJ3snIG9yICdbJyBoYXZlIGJlZW4gc2Vlbi4gJzAnIGltcGxpZXMgYmxvY2sgY29udGV4dC5cbiAgICAgICAgdGhpcy5mbG93X2xldmVsID0gMDtcbiAgICAgICAgLy8gTGlzdCBvZiBwcm9jZXNzZWQgdG9rZW5zIG5vdCB5ZXQgZW1pdHRlZC5cbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgLy8gQWRkIHRoZSBTVFJFQU0tU1RBUlQgdG9rZW4uXG4gICAgICAgIHRoaXMuZmV0Y2hfc3RyZWFtX3N0YXJ0KCk7XG4gICAgICAgIC8vIE51bWJlciBvZiB0b2tlbnMgZW1pdHRlZCB0aHJvdWdoIHRoZSBgZ2V0X3Rva2VuYCBtZXRob2QuXG4gICAgICAgIHRoaXMudG9rZW5zX3Rha2VuID0gMDtcbiAgICAgICAgLy8gQ3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbC4gJy0xJyBtZWFucyBubyBpbmRlbnRhdGlvbiBoYXMgYmVlbiBzZWVuLlxuICAgICAgICB0aGlzLmluZGVudCA9IC0xO1xuICAgICAgICAvLyBQcmV2aW91cyBpbmRlbnRhdGlvbiBsZXZlbHMuXG4gICAgICAgIHRoaXMuaW5kZW50cyA9IFtdO1xuICAgICAgICAvLyBTaW1wbGUgS2V5IFRyZWF0bWVudFxuICAgICAgICAvLyAgIEEgc2ltcGxlIGtleSBpcyBhIGtleSB0aGF0IGlzIG5vdCBkZW5vdGVkIGJ5IHRoZSAnPycgaW5kaWNhdG9yLCBlLmcuXG4gICAgICAgIC8vICAgICBibG9jayBzaW1wbGUga2V5OiB2YWx1ZVxuICAgICAgICAvLyAgICAgPyBub3QgYSBzaW1wbGUga2V5XG4gICAgICAgIC8vICAgICA6IHsgZmxvdyBzaW1wbGUga2V5OiB2YWx1ZSB9XG4gICAgICAgIC8vICAgV2UgZW1pdCB0aGUgS0VZIHRva2VuIGJlZm9yZSBhbGwga2V5cywgc28gd2hlbiB3ZSBmaW5kIGEgcG90ZW50aWFsXG4gICAgICAgIC8vICAgc2ltcGxlIGtleSwgd2UgdHJ5IHRvIGxvY2F0ZSB0aGUgY29ycmVzcG9uZGluZyAnOicgaW5kaWNhdG9yLiAgU2ltcGxlXG4gICAgICAgIC8vICAga2V5cyBzaG91bGQgYmUgbGltaXRlZCB0byBhIHNpbmdsZSBsaW5lIGFuZCAxMDI0IGNoYXJhY3RlcnMuXG5cbiAgICAgICAgLy8gQ2FuIGEgc2ltcGxlIGtleSBzdGFydCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbj8gIEEgc2ltcGxlIGtleSBtYXlcbiAgICAgICAgLy8gc3RhcnRcbiAgICAgICAgLy8gICBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lLCBub3QgY291bnRpbmcgaW5kZW50YXRpb24gc3BhY2VzXG4gICAgICAgIC8vICAgICAoYmxvY2sgY29udGV4dClcbiAgICAgICAgLy8gICBhZnRlciAneycsICdbJywgJywnIChmbG93IGNvbnRleHQpXG4gICAgICAgIC8vICAgYWZ0ZXIgJz8nLCAnOicsICctJyAoYmxvY2sgY29udGV4dClcbiAgICAgICAgLy8gSW4gdGhlIGJsb2NrIGNvbnRleHQsIHRoaXMgZmxhZyBhbHNvIHNpZ25pZmllcyBpZiBhIGJsb2NrIGNvbGxlY3Rpb25cbiAgICAgICAgLy8gbWF5IHN0YXJ0IGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSB0cnVlO1xuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHBvc3NpYmxlIHNpbXBsZSBrZXlzLiAgVGhpcyBpcyBhbiBvYmplY3QuICBUaGUga2V5IGlzXG4gICAgICAgIC8vIGBmbG93X2xldmVsYDsgdGhlcmUgY2FuIGJlIG5vIG1vcmUgdGhhbiBvbmUgcG9zc2libGUgc2ltcGxlIGtleSBmb3JcbiAgICAgICAgLy8gZWFjaCBsZXZlbC4gIFRoZSB2YWx1ZSBpcyBhIFNpbXBsZUtleSBvYmplY3QuIEEgc2ltcGxlIGtleSBtYXkgc3RhcnRcbiAgICAgICAgLy8gd2l0aCBBTElBUywgQU5DSE9SLCBUQUcsIFNDQUxBUiAoZmxvdyksICdbJyBvciAneycgdG9rZW5zLlxuICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5cyA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvLyBBUEkgbWV0aG9kcy5cbiAgICAgIC8qXG4gICAgICBDaGVjayBpZiB0aGUgbmV4dCB0b2tlbiBpcyBvbmUgb2YgdGhlIGdpdmVuIHR5cGVzLlxuICAgICAgKi9cbiAgICAgIGNoZWNrX3Rva2VuKC4uLmNob2ljZXMpIHtcbiAgICAgICAgdmFyIGNob2ljZSwgaSwgbGVuO1xuICAgICAgICB3aGlsZSAodGhpcy5uZWVkX21vcmVfdG9rZW5zKCkpIHtcbiAgICAgICAgICB0aGlzLmZldGNoX21vcmVfdG9rZW5zKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGlmIChjaG9pY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNob2ljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNob2ljZSA9IGNob2ljZXNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbnNbMF0gaW5zdGFuY2VvZiBjaG9pY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFJldHVybiB0aGUgbmV4dCB0b2tlbiwgYnV0IGRvIG5vdCBkZWxldGUgaXQgZnJvbSB0aGUgcXVldWUuXG4gICAgICAqL1xuICAgICAgcGVla190b2tlbigpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubmVlZF9tb3JlX3Rva2VucygpKSB7XG4gICAgICAgICAgdGhpcy5mZXRjaF9tb3JlX3Rva2VucygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRva2Vucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbMF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFJldHVybiB0aGUgbmV4dCB0b2tlbiwgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgICovXG4gICAgICBnZXRfdG9rZW4oKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm5lZWRfbW9yZV90b2tlbnMoKSkge1xuICAgICAgICAgIHRoaXMuZmV0Y2hfbW9yZV90b2tlbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50b2tlbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy50b2tlbnNfdGFrZW4rKztcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBOb24tQVBJIG1ldGhvZHMuXG4gICAgICBuZWVkX21vcmVfdG9rZW5zKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY3VycmVudCB0b2tlbiBtYXkgYmUgYSBwb3RlbnRpYWwgc2ltcGxlIGtleSwgc28gd2UgbmVlZCB0byBsb29rXG4gICAgICAgIC8vIGZ1cnRoZXIuXG4gICAgICAgIHRoaXMuc3RhbGVfcG9zc2libGVfc2ltcGxlX2tleXMoKTtcbiAgICAgICAgaWYgKHRoaXMubmV4dF9wb3NzaWJsZV9zaW1wbGVfa2V5KCkgPT09IHRoaXMudG9rZW5zX3Rha2VuKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9tb3JlX3Rva2VucygpIHtcbiAgICAgICAgdmFyIGNoYXI7XG4gICAgICAgIC8vIEVhdCB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cyB1bnRpbCB3ZSByZWFjaCB0aGUgbmV4dCB0b2tlbi5cbiAgICAgICAgdGhpcy5zY2FuX3RvX25leHRfdG9rZW4oKTtcbiAgICAgICAgLy8gUmVtb3ZlIG9ic29sZXRlIHBvc3NpYmxlIHNpbXBsZSBrZXlzXG4gICAgICAgIHRoaXMuc3RhbGVfcG9zc2libGVfc2ltcGxlX2tleXMoKTtcbiAgICAgICAgLy8gQ29tcGFyZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBhbmQgY29sdW1uLiBJdCBtYXkgYWRkIHNvbWUgdG9rZW5zIGFuZFxuICAgICAgICAvLyBkZWNyZWFzZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbC5cbiAgICAgICAgdGhpcy51bndpbmRfaW5kZW50KHRoaXMuY29sdW1uKTtcbiAgICAgICAgLy8gUGVlayB0aGUgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcXHgwMCcpIHtcbiAgICAgICAgICAvLyBJcyBpdCB0aGUgZW5kIG9mIHN0cmVhbT9cbiAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9zdHJlYW1fZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICclJyAmJiB0aGlzLmNoZWNrX2RpcmVjdGl2ZSgpKSB7XG4gICAgICAgICAgLy8gSXMgaXQgYSBkaXJlY3RpdmU/XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZGlyZWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICctJyAmJiB0aGlzLmNoZWNrX2RvY3VtZW50X3N0YXJ0KCkpIHtcbiAgICAgICAgICAvLyBJcyBpdCB0aGUgZG9jdW1lbnQgc3RhcnQ/XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZG9jdW1lbnRfc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJy4nICYmIHRoaXMuY2hlY2tfZG9jdW1lbnRfZW5kKCkpIHtcbiAgICAgICAgICAvLyBJcyBpdCB0aGUgZG9jdW1lbnQgZW5kP1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoX2RvY3VtZW50X2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSAnWycpIHtcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGZvciBCT00gd2l0aGluIGEgc3RyZWFtLlxuXG4gICAgICAgICAgLy8gSXMgaXQgdGhlIGZsb3cgc2VxdWVuY2Ugc3RhcnQgaW5kaWNhdG9yP1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfc2VxdWVuY2Vfc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ3snKSB7XG4gICAgICAgICAgLy8gSXMgaXQgdGhlIGZsb3cgbWFwcGluZyBzdGFydCBpbmRpY2F0b3I/XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19tYXBwaW5nX3N0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICddJykge1xuICAgICAgICAgIC8vIElzIGl0IHRoZSBmbG93IHNlcXVlbmNlIGVuZCBpbmRpY2F0b3I/XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19zZXF1ZW5jZV9lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ30nKSB7XG4gICAgICAgICAgLy8gSXMgaXQgdGhlIGZsb3cgbWFwcGluZyBlbmQgaW5kaWNhdG9yP1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfbWFwcGluZ19lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJywnKSB7XG4gICAgICAgICAgLy8gSXMgaXQgdGhlIGZsb3cgZW50cnkgaW5kaWNhdG9yP1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfZW50cnkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJy0nICYmIHRoaXMuY2hlY2tfYmxvY2tfZW50cnkoKSkge1xuICAgICAgICAgIC8vIElzIGl0IHRoZSBibG9jayBlbnRyeSBpbmRpY2F0b3I/XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfYmxvY2tfZW50cnkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJz8nICYmIHRoaXMuY2hlY2tfa2V5KCkpIHtcbiAgICAgICAgICAvLyBJcyBpdCB0aGUga2V5IGluZGljYXRvcj9cbiAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9rZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJzonICYmIHRoaXMuY2hlY2tfdmFsdWUoKSkge1xuICAgICAgICAgIC8vIElzIGl0IHRoZSB2YWx1ZSBpbmRpY2F0b3I/XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfdmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJyonKSB7XG4gICAgICAgICAgLy8gSXMgaXQgYW4gYWxpYXM/XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfYWxpYXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJyYnKSB7XG4gICAgICAgICAgLy8gSXMgaXQgYW4gYW5jaG9yP1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoX2FuY2hvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSAnIScpIHtcbiAgICAgICAgICAvLyBJcyBpdCBhIHRhZz9cbiAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF90YWcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ3wnICYmIHRoaXMuZmxvd19sZXZlbCA9PT0gMCkge1xuICAgICAgICAgIC8vIElzIGl0IGEgbGl0ZXJhbCBzY2FsYXI/XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfbGl0ZXJhbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSAnPicgJiYgdGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgICAgLy8gSXMgaXQgYSBmb2xkZWQgc2NhbGFyP1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoX2ZvbGRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSAnXFwnJykge1xuICAgICAgICAgIC8vIElzIGl0IGEgc2luZ2xlIHF1b3RlZCBzY2FsYXI/XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfc2luZ2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAvLyBJcyBpdCBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyP1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoX2RvdWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoZWNrX3BsYWluKCkpIHtcbiAgICAgICAgICAvLyBJdCBtdXN0IGJlIGEgcGxhaW4gc2NhbGFyIHRoZW4uXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfcGxhaW4oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObz8gSXQncyBhbiBlcnJvci5cbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBmb3IgdGhlIG5leHQgdG9rZW4nLCBudWxsLCBgZm91bmQgY2hhcmFjdGVyICR7Y2hhcn0gdGhhdCBjYW5ub3Qgc3RhcnQgYW55IHRva2VuYCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2ltcGxlIGtleXMgdHJlYXRtZW50LlxuICAgICAgLypcbiAgICAgIFJldHVybiB0aGUgbnVtYmVyIG9mIHRoZSBuZWFyZXN0IHBvc3NpYmxlIHNpbXBsZSBrZXkuXG4gICAgICAqL1xuICAgICAgbmV4dF9wb3NzaWJsZV9zaW1wbGVfa2V5KCkge1xuICAgICAgICB2YXIga2V5LCBsZXZlbCwgbWluX3Rva2VuX251bWJlciwgcmVmO1xuICAgICAgICBtaW5fdG9rZW5fbnVtYmVyID0gbnVsbDtcbiAgICAgICAgcmVmID0gdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5cztcbiAgICAgICAgZm9yIChsZXZlbCBpbiByZWYpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGxldmVsKSkgY29udGludWU7XG4gICAgICAgICAga2V5ID0gcmVmW2xldmVsXTtcbiAgICAgICAgICBpZiAobWluX3Rva2VuX251bWJlciA9PT0gbnVsbCB8fCBrZXkudG9rZW5fbnVtYmVyIDwgbWluX3Rva2VuX251bWJlcikge1xuICAgICAgICAgICAgbWluX3Rva2VuX251bWJlciA9IGtleS50b2tlbl9udW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW5fdG9rZW5fbnVtYmVyO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgUmVtb3ZlIGVudHJpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHBvc3NpYmxlIHNpbXBsZSBrZXlzLiAgQWNjb3JkaW5nIHRvIHRoZVxuICAgICAgWUFNTCBzcGVjLCBzaW1wbGUga2V5czpcbiAgICAgIHNob3VsZCBiZSBsaW1pdGVkIHRvIGEgc2luZ2xlIGxpbmVcbiAgICAgIHNob3VsZCBiZSBubyBsb25nZXIgdGhhbiAxMDI0IGNoYXJhY3RlcnNcbiAgICAgIERpc2FibGluZyB0aGlzIHByb2NlZHVyZSB3aWxsIGFsbG93IHNpbXBsZSBrZXlzIG9mIGFueSBsZW5ndGggYW5kIGhlaWdodFxuICAgICAgKG1heSBjYXVzZSBwcm9ibGVtcyBpZiBpbmRlbnRhdGlvbiBpcyBicm9rZW4gdGhvdWdoKS5cbiAgICAgICovXG4gICAgICBzdGFsZV9wb3NzaWJsZV9zaW1wbGVfa2V5cygpIHtcbiAgICAgICAgdmFyIGtleSwgbGV2ZWwsIHJlZiwgcmVzdWx0cztcbiAgICAgICAgcmVmID0gdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldmVsIGluIHJlZikge1xuICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwgbGV2ZWwpKSBjb250aW51ZTtcbiAgICAgICAgICBrZXkgPSByZWZbbGV2ZWxdO1xuICAgICAgICAgIGlmIChrZXkubGluZSA9PT0gdGhpcy5saW5lICYmIHRoaXMuaW5kZXggLSBrZXkuaW5kZXggPD0gMTAyNCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha2V5LnJlcXVpcmVkKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goZGVsZXRlIHRoaXMucG9zc2libGVfc2ltcGxlX2tleXNbbGV2ZWxdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHNpbXBsZSBrZXknLCBrZXkubWFyaywgJ2NvdWxkIG5vdCBmaW5kIGV4cGVjdGVkIFxcJzpcXCcnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFRoZSBuZXh0IHRva2VuIG1heSBzdGFydCBhIHNpbXBsZSBrZXkuICBXZSBjaGVjayBpZiBpdCdzIHBvc3NpYmxlIGFuZCBzYXZlXG4gICAgICBpdHMgcG9zaXRpb24uICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgQUxJQVMsIEFOQ0hPUiwgVEFHLFxuICAgICAgU0NBTEFSIChmbG93KSwnWycgYW5kICd7Jy5cbiAgICAgICovXG4gICAgICBzYXZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKSB7XG4gICAgICAgIHZhciByZXF1aXJlZCwgdG9rZW5fbnVtYmVyO1xuICAgICAgICAvLyBDaGVjayBpZiBhIHNpbXBsZSBrZXkgaXMgcmVxdWlyZWQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHJlcXVpcmVkID0gdGhpcy5mbG93X2xldmVsID09PSAwICYmIHRoaXMuaW5kZW50ID09PSB0aGlzLmNvbHVtbjtcbiAgICAgICAgaWYgKHJlcXVpcmVkICYmICF0aGlzLmFsbG93X3NpbXBsZV9rZXkpIHtcbiAgICAgICAgICAvLyBBIHNpbXBsZSBrZXkgaXMgcmVxdWlyZWQgb25seSBpZiBpdCBpcyB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyBsaW5lLiAgVGhlcmVmb3JlIGl0IGlzIGFsd2F5cyBhbGxvd2VkLlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbG9naWMgZmFpbHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHNpbXBsZSBrZXlzIGFyZW4ndCBhbGxvd2VkIGhlcmUgd2UncmUgZG9uZS5cbiAgICAgICAgaWYgKCF0aGlzLmFsbG93X3NpbXBsZV9rZXkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIG5leHQgdG9rZW4gbWlnaHQgYmUgYSBzaW1wbGUga2V5LiAgTGV0J3Mgc2F2ZSBpdHMgbnVtYmVyIGFuZFxuICAgICAgICAvLyBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgICB0b2tlbl9udW1iZXIgPSB0aGlzLnRva2Vuc190YWtlbiArIHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zc2libGVfc2ltcGxlX2tleXNbdGhpcy5mbG93X2xldmVsXSA9IG5ldyBTaW1wbGVLZXkodG9rZW5fbnVtYmVyLCByZXF1aXJlZCwgdGhpcy5pbmRleCwgdGhpcy5saW5lLCB0aGlzLmNvbHVtbiwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFJlbW92ZSB0aGUgc2F2ZWQgcG9zc2libGUgc2ltcGxlIGtleSBhdCB0aGUgY3VycmVudCBmbG93IGxldmVsLlxuICAgICAgKi9cbiAgICAgIHJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBpZiAoIShrZXkgPSB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzW3RoaXMuZmxvd19sZXZlbF0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2V5LnJlcXVpcmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzW3RoaXMuZmxvd19sZXZlbF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHNpbXBsZSBrZXknLCBrZXkubWFyaywgJ2NvdWxkIG5vdCBmaW5kIGV4cGVjdGVkIFxcJzpcXCcnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluZGVudGF0aW9uIGZ1bmN0aW9uc1xuICAgICAgLypcbiAgICAgIEluIGZsb3cgY29udGV4dCwgdG9rZW5zIHNob3VsZCByZXNwZWN0IGluZGVudGF0aW9uLlxuICAgICAgQWN0dWFsbHkgdGhlIGNvbmRpdGlvbiBzaG91bGQgYmUgYHNlbGYuaW5kZW50ID49IGNvbHVtbmAgYWNjb3JkaW5nIHRvXG4gICAgICB0aGUgc3BlYy4gQnV0IHRoaXMgY29uZGl0aW9uIHdpbGwgcHJvaGliaXQgaW50dWl0aXZlbHkgY29ycmVjdFxuICAgICAgY29uc3RydWN0aW9ucyBzdWNoIGFzXG4gICAgICAgIGtleSA6IHtcbiAgICAgICAgfVxuICAgICAgKi9cbiAgICAgIHVud2luZF9pbmRlbnQoY29sdW1uKSB7XG4gICAgICAgIHZhciBtYXJrLCByZXN1bHRzO1xuICAgICAgICAvLyBJbiB0aGUgZmxvdyBjb250ZXh0LCBpbmRlbnRhdGlvbiBpcyBpZ25vcmVkLiAgV2UgbWFrZSB0aGUgc2Nhbm5lciBsZXNzXG4gICAgICAgIC8vIHJlc3RyaWN0aXZlIHRoYW4gdGhlIHNwZWNpZmljYXRpb24gcmVxdWlyZXMuXG4gICAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgIT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAvLyBJbiBibG9jayBjb250ZXh0IHdlIG1heSBuZWVkIHRvIGlzc3VlIHRoZSBCTE9DSy1FTkQgdG9rZW5zLlxuICAgICAgICB3aGlsZSAodGhpcy5pbmRlbnQgPiBjb2x1bW4pIHtcbiAgICAgICAgICBtYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICAgIHRoaXMuaW5kZW50ID0gdGhpcy5pbmRlbnRzLnBvcCgpO1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuQmxvY2tFbmRUb2tlbihtYXJrLCBtYXJrKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgQ2hlY2sgaWYgd2UgbmVlZCB0byBpbmNyZWFzZSBpbmRlbnRhdGlvbi5cbiAgICAgICovXG4gICAgICBhZGRfaW5kZW50KGNvbHVtbikge1xuICAgICAgICBpZiAoIShjb2x1bW4gPiB0aGlzLmluZGVudCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRlbnRzLnB1c2godGhpcy5pbmRlbnQpO1xuICAgICAgICB0aGlzLmluZGVudCA9IGNvbHVtbjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZldGNoZXJzLlxuICAgICAgZmV0Y2hfc3RyZWFtX3N0YXJ0KCkge1xuICAgICAgICB2YXIgbWFyaztcbiAgICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5TdHJlYW1TdGFydFRva2VuKG1hcmssIG1hcmssIHRoaXMuZW5jb2RpbmcpKTtcbiAgICAgIH1cblxuICAgICAgZmV0Y2hfc3RyZWFtX2VuZCgpIHtcbiAgICAgICAgdmFyIG1hcms7XG4gICAgICAgIC8vIFNldCB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiB0byAtMS5cbiAgICAgICAgdGhpcy51bndpbmRfaW5kZW50KC0xKTtcbiAgICAgICAgLy8gUmVzZXQgc2ltcGxlIGtleXMuXG4gICAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgICAgdGhpcy5hbGxvd19wb3NzaWJsZV9zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucG9zc2libGVfc2ltcGxlX2tleXMgPSB7fTtcbiAgICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLlN0cmVhbUVuZFRva2VuKG1hcmssIG1hcmspKTtcbiAgICAgICAgLy8gVGhlIHN0cmVhbSBpcyBmaW5pc2hlZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZldGNoX2RpcmVjdGl2ZSgpIHtcbiAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IGluZGVudGF0aW9uIHRvIC0xLlxuICAgICAgICB0aGlzLnVud2luZF9pbmRlbnQoLTEpO1xuICAgICAgICAvLyBSZXNldCBzaW1wbGUga2V5cy5cbiAgICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgICAgLy8gU2NhbiBhbmQgYWRkIERJUkVDVElWRVxuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaCh0aGlzLnNjYW5fZGlyZWN0aXZlKCkpO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9kb2N1bWVudF9zdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZG9jdW1lbnRfaW5kaWNhdG9yKHRva2Vucy5Eb2N1bWVudFN0YXJ0VG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9kb2N1bWVudF9lbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2RvY3VtZW50X2luZGljYXRvcih0b2tlbnMuRG9jdW1lbnRFbmRUb2tlbik7XG4gICAgICB9XG5cbiAgICAgIGZldGNoX2RvY3VtZW50X2luZGljYXRvcihUb2tlbkNsYXNzKSB7XG4gICAgICAgIHZhciBzdGFydF9tYXJrO1xuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gdG8gLTEuXG4gICAgICAgIHRoaXMudW53aW5kX2luZGVudCgtMSk7XG4gICAgICAgIC8vIFJlc2V0IHNpbXBsZSBrZXlzLiAgTm90ZSB0aGF0IHRoZXJlIHdvdWxkIG5vdCBiZSBhIGJsb2NrIGNvbGxlY3Rpb25cbiAgICAgICAgLy8gYWZ0ZXIgJy0tLScuXG4gICAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICAgIC8vIEFkZCBET0NVTUVOVC1TVEFSVCBvciBET0NVTUVOVC1FTkQuXG4gICAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2gobmV3IFRva2VuQ2xhc3Moc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKSk7XG4gICAgICB9XG5cbiAgICAgIGZldGNoX2Zsb3dfc2VxdWVuY2Vfc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfY29sbGVjdGlvbl9zdGFydCh0b2tlbnMuRmxvd1NlcXVlbmNlU3RhcnRUb2tlbik7XG4gICAgICB9XG5cbiAgICAgIGZldGNoX2Zsb3dfbWFwcGluZ19zdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19jb2xsZWN0aW9uX3N0YXJ0KHRva2Vucy5GbG93TWFwcGluZ1N0YXJ0VG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9mbG93X2NvbGxlY3Rpb25fc3RhcnQoVG9rZW5DbGFzcykge1xuICAgICAgICB2YXIgc3RhcnRfbWFyaztcbiAgICAgICAgLy8gJ1snIGFuZCAneycgbWF5IHN0YXJ0IGEgc2ltcGxlIGtleS5cbiAgICAgICAgdGhpcy5zYXZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgZmxvdyBsZXZlbC5cbiAgICAgICAgdGhpcy5mbG93X2xldmVsKys7XG4gICAgICAgIC8vIFNpbXBsZSBrZXlzIGFyZSBhbGxvd2VkIGFmdGVyICdbJyBhbmQgJ3snXG4gICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IHRydWU7XG4gICAgICAgIC8vIEFkZCBGTE9XLVNFUVVFTkNFLVNUQVJUIG9yIEZMT1ctTUFQUElORy1TVEFSVC5cbiAgICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyBUb2tlbkNsYXNzKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9mbG93X3NlcXVlbmNlX2VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19jb2xsZWN0aW9uX2VuZCh0b2tlbnMuRmxvd1NlcXVlbmNlRW5kVG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9mbG93X21hcHBpbmdfZW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X2NvbGxlY3Rpb25fZW5kKHRva2Vucy5GbG93TWFwcGluZ0VuZFRva2VuKTtcbiAgICAgIH1cblxuICAgICAgZmV0Y2hfZmxvd19jb2xsZWN0aW9uX2VuZChUb2tlbkNsYXNzKSB7XG4gICAgICAgIHZhciBzdGFydF9tYXJrO1xuICAgICAgICAvLyBSZXNldCBwb3NzaWJsZSBzaW1wbGUga2V5IG9uIHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICAgIC8vIERlY3JlYXNlIHRoZSBmbG93IGxldmVsXG4gICAgICAgIHRoaXMuZmxvd19sZXZlbC0tO1xuICAgICAgICAvLyBObyBzaW1wbGUga2V5cyBhZnRlciAnXScgb3IgJ30nXG4gICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgICAvLyBBZGQgRkxPVy1TRVFVRU5DRS1FTkQgb3IgRkxPVy1NQVBQSU5HLUVORC5cbiAgICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyBUb2tlbkNsYXNzKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9mbG93X2VudHJ5KCkge1xuICAgICAgICB2YXIgc3RhcnRfbWFyaztcbiAgICAgICAgLy8gU2ltcGxlIGtleXMgYXJlIGFsbG93ZWQgYWZ0ZXIgJywnLlxuICAgICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSB0cnVlO1xuICAgICAgICAvLyBSZXNldCBwb3NzaWJsZSBzaW1wbGUga2V5IG9uIHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICAgIC8vIEFkZCBGTE9XLUVOVFJZXG4gICAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLkZsb3dFbnRyeVRva2VuKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9ibG9ja19lbnRyeSgpIHtcbiAgICAgICAgdmFyIG1hcmssIHN0YXJ0X21hcms7XG4gICAgICAgIC8vIEJsb2NrIGNvbnRleHQgbmVlZHMgYWRkaXRpb25hbCBjaGVja3NcbiAgICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCA9PT0gMCkge1xuICAgICAgICAgIC8vIEFyZSB3ZSBhbGxvd2VkIHRvIHN0YXJ0IGEgbmV3IGVudHJ5P1xuICAgICAgICAgIGlmICghdGhpcy5hbGxvd19zaW1wbGVfa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IobnVsbCwgbnVsbCwgJ3NlcXVlbmNlIGVudHJpZXMgYXJlIG5vdCBhbGxvd2VkIGhlcmUnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXZSBtYXkgbmVlZCB0byBhZGQgQkxPQ0stU0VRVUVOQ0UtU1RBUlRcbiAgICAgICAgICBpZiAodGhpcy5hZGRfaW5kZW50KHRoaXMuY29sdW1uKSkge1xuICAgICAgICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5CbG9ja1NlcXVlbmNlU3RhcnRUb2tlbihtYXJrLCBtYXJrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEl0J3MgYW4gZXJyb3IgZm9yIHRoZSBibG9jayBlbnRyeSB0byBvY2N1ciBpbiB0aGUgZmxvdyBjb250ZXh0IGJ1dCB3ZVxuICAgICAgICAvLyBsZXQgdGhlIHBhcnNlciBkZXRlY3QgdGhpcy5cblxuICAgICAgICAvLyBTaW1wbGUga2V5cyBhcmUgYWxsb3dlZCBhZnRlciAnLSdcbiAgICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gdHJ1ZTtcbiAgICAgICAgLy8gUmVzZXQgcG9zc2libGUgc2ltcGxlIGtleSBvbiB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgICAvLyBBZGQgQkxPQ0stRU5UUllcbiAgICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuQmxvY2tFbnRyeVRva2VuKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9rZXkoKSB7XG4gICAgICAgIHZhciBtYXJrLCBzdGFydF9tYXJrO1xuICAgICAgICAvLyBCbG9jayBjb250ZXh0IG5lZWRzIGFkZGl0aW9uYWwgY2hlY2tzLlxuICAgICAgICBpZiAodGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgICAgLy8gQXJlIHdlIGFsbG93ZWQgdG8gc3RhcnQgYSBrZXk/XG4gICAgICAgICAgaWYgKCF0aGlzLmFsbG93X3NpbXBsZV9rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihudWxsLCBudWxsLCAnbWFwcGluZyBrZXlzIGFyZSBub3QgYWxsb3dlZCBoZXJlJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gV2UgbWF5IG5lZWQgdG8gYWRkIEJMT0NLLU1BUFBJTkctU1RBUlQuXG4gICAgICAgICAgaWYgKHRoaXMuYWRkX2luZGVudCh0aGlzLmNvbHVtbikpIHtcbiAgICAgICAgICAgIG1hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuQmxvY2tNYXBwaW5nU3RhcnRUb2tlbihtYXJrLCBtYXJrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNpbXBsZSBrZXlzIGFyZSBhbGxvd2VkIGFmdGVyICc/JyBpbiB0aGUgZmxvdyBjb250ZXh0LlxuICAgICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSAhdGhpcy5mbG93X2xldmVsO1xuICAgICAgICAvLyBSZXNldCBwb3NzaWJsZSBzaW1wbGUga2V5IG9uIHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICAgIC8vIEFkZCBLRVkuXG4gICAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLktleVRva2VuKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF92YWx1ZSgpIHtcbiAgICAgICAgdmFyIGtleSwgbWFyaywgc3RhcnRfbWFyaztcbiAgICAgICAgLy8gRG8gd2UgZGV0ZXJtaW5lIGEgc2ltcGxlIGtleT9cbiAgICAgICAgaWYgKGtleSA9IHRoaXMucG9zc2libGVfc2ltcGxlX2tleXNbdGhpcy5mbG93X2xldmVsXSkge1xuICAgICAgICAgIC8vIEFkZCBLRVkuXG4gICAgICAgICAgZGVsZXRlIHRoaXMucG9zc2libGVfc2ltcGxlX2tleXNbdGhpcy5mbG93X2xldmVsXTtcbiAgICAgICAgICB0aGlzLnRva2Vucy5zcGxpY2Uoa2V5LnRva2VuX251bWJlciAtIHRoaXMudG9rZW5zX3Rha2VuLCAwLCBuZXcgdG9rZW5zLktleVRva2VuKGtleS5tYXJrLCBrZXkubWFyaykpO1xuICAgICAgICAgIC8vIElmIHRoaXMga2V5IHN0YXJ0cyBhIG5ldyBibG9jayBtYXBwaW5nIHdlIG5lZWQgdG8gYWRkXG4gICAgICAgICAgLy8gQkxPQ0stTUFQUElORy1TVEFSVC5cbiAgICAgICAgICBpZiAodGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRfaW5kZW50KGtleS5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgIHRoaXMudG9rZW5zLnNwbGljZShrZXkudG9rZW5fbnVtYmVyIC0gdGhpcy50b2tlbnNfdGFrZW4sIDAsIG5ldyB0b2tlbnMuQmxvY2tNYXBwaW5nU3RhcnRUb2tlbihrZXkubWFyaywga2V5Lm1hcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlcmUgY2Fubm90IGJlIHR3byBzaW1wbGUga2V5cyBvbmUgYWZ0ZXIgdGhlIG90aGVyLlxuICAgICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEJsb2NrIGNvbnRleHQgbmVlZHMgYWRkaXRpb25hbCBjaGVja3MuXG4gICAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgdGhlbT8gIFBhcnNlciB3aWxsIGNhdGNoIHRoZW0gYW55d2F5LlxuICAgICAgICAgIC8vIEl0IG11c3QgYmUgcGFydCBvZiBhIGNvbXBsZXgga2V5LlxuICAgICAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBhbGxvd2VkIHRvIHN0YXJ0IGEgY29tcGxleCB2YWx1ZSBpZiBhbmQgb25seSBpZiB3ZSBjYW4gc3RhcnRcbiAgICAgICAgICAgIC8vIGEgc2ltcGxlIGtleS5cbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd19zaW1wbGVfa2V5KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihudWxsLCBudWxsLCAnbWFwcGluZyB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkIGhlcmUnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhpcyB2YWx1ZSBzdGFydHMgYSBuZXcgYmxvY2sgbWFwcGluZyB3ZSBuZWVkIHRvIGFkZFxuICAgICAgICAgICAgLy8gQkxPQ0stTUFQUElORy1TVEFSVC4gIEl0IHdpbGwgYmUgZGV0ZWN0ZWQgYXMgYW4gZXJyb3IgbGF0ZXIgYnkgdGhlXG4gICAgICAgICAgICAvLyBwYXJzZXIuXG4gICAgICAgICAgICBpZiAodGhpcy5hZGRfaW5kZW50KHRoaXMuY29sdW1uKSkge1xuICAgICAgICAgICAgICBtYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuQmxvY2tNYXBwaW5nU3RhcnRUb2tlbihtYXJrLCBtYXJrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNpbXBsZSBrZXlzIGFyZSBhbGxvd2VkIGFmdGVyICc6JyBpbiB0aGUgYmxvY2sgY29udGV4dC5cbiAgICAgICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSAhdGhpcy5mbG93X2xldmVsO1xuICAgICAgICAgIC8vIFJlc2V0IHBvc3NpYmxlIHNpbXBsZSBrZXkgb24gdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBWQUxVRS5cbiAgICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuVmFsdWVUb2tlbihzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCkpKTtcbiAgICAgIH1cblxuICAgICAgZmV0Y2hfYWxpYXMoKSB7XG4gICAgICAgIC8vIEFMSUFTIGNvdWxkIGJlIGEgc2ltcGxlIGtleS5cbiAgICAgICAgdGhpcy5zYXZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgICAgLy8gTm8gc2ltcGxlIGtleXMgYWZ0ZXIgQUxJQVMuXG4gICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgICAvLyBTY2FuIGFuZCBhZGQgQUxJQVMuXG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl9hbmNob3IodG9rZW5zLkFsaWFzVG9rZW4pKTtcbiAgICAgIH1cblxuICAgICAgZmV0Y2hfYW5jaG9yKCkge1xuICAgICAgICAvLyBBTkNIT1IgY291bGQgc3RhcnQgYSBzaW1wbGUga2V5LlxuICAgICAgICB0aGlzLnNhdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgICAvLyBObyBzaW1wbGUga2V5cyBhbGxvd2VkIGFmdGVyIEFOQ0hPUi5cbiAgICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICAgIC8vIFNjYW4gYW5kIGFkZCBBTkNIT1IuXG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl9hbmNob3IodG9rZW5zLkFuY2hvclRva2VuKSk7XG4gICAgICB9XG5cbiAgICAgIGZldGNoX3RhZygpIHtcbiAgICAgICAgLy8gVEFHIGNvdWxkIHN0YXJ0IGEgc2ltcGxlIGtleVxuICAgICAgICB0aGlzLnNhdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgICAvLyBObyBzaW1wbGUga2V5cyBhZnRlciBUQUcuXG4gICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgICAvLyBTY2FuIGFuZCBhZGQgVEFHLlxuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaCh0aGlzLnNjYW5fdGFnKCkpO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9saXRlcmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9ibG9ja19zY2FsYXIoJ3wnKTtcbiAgICAgIH1cblxuICAgICAgZmV0Y2hfZm9sZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9ibG9ja19zY2FsYXIoJz4nKTtcbiAgICAgIH1cblxuICAgICAgZmV0Y2hfYmxvY2tfc2NhbGFyKHN0eWxlKSB7XG4gICAgICAgIC8vIEEgc2ltcGxlIGtleSBtYXkgZm9sbG93IGEgYmxvY2sgc2NsYXIuXG4gICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IHRydWU7XG4gICAgICAgIC8vIFJlc2V0IHBvc3NpYmxlIHNpbXBsZSBrZXkgb24gdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgICAgLy8gU2NhbiBhbmQgYWRkIFNDQUxBUi5cbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2godGhpcy5zY2FuX2Jsb2NrX3NjYWxhcihzdHlsZSkpO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9zaW5nbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfc2NhbGFyKCdcXCcnKTtcbiAgICAgIH1cblxuICAgICAgZmV0Y2hfZG91YmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X3NjYWxhcignXCInKTtcbiAgICAgIH1cblxuICAgICAgZmV0Y2hfZmxvd19zY2FsYXIoc3R5bGUpIHtcbiAgICAgICAgLy8gQSBmbG93IHNjYWxhciBjb3VsZCBiZSBhIHNpbXBsZSBrZXkuXG4gICAgICAgIHRoaXMuc2F2ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICAgIC8vIE5vIHNpbXBsZSBrZXlzIGFmdGVyIGZsb3cgc2NhbGFycy5cbiAgICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICAgIC8vIFNjYW4gYW5kIGFkZCBTQ0FMQVIuXG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl9mbG93X3NjYWxhcihzdHlsZSkpO1xuICAgICAgfVxuXG4gICAgICBmZXRjaF9wbGFpbigpIHtcbiAgICAgICAgLy8gQSBwbGFpbiBzY2FsYXIgY291bGQgYmUgYSBzaW1wbGUga2V5LlxuICAgICAgICB0aGlzLnNhdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgICAvLyBObyBzaW1wbGUga2V5cyBhZnRlciBwbGFpbiBzY2FsYXJzLiAgQnV0IG5vdGUgdGhhdCBgc2Nhbl9wbGFpbmAgd2lsbFxuICAgICAgICAvLyBjaGFuZ2UgdGhpcyBmbGFnIGlmIHRoZSBzY2FuIGlzIGZpbmlzaGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmUuXG4gICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgICAvLyBTY2FuIGFuZCBhZGQgU0NBTEFSLiAgTWF5IGNoYW5nZSBgYWxsb3dfc2ltcGxlX2tleWAuXG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl9wbGFpbigpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2tlcnMuXG4gICAgICAvKlxuICAgICAgRElSRUNUSVZFOiBeICclJ1xuICAgICAgKi9cbiAgICAgIGNoZWNrX2RpcmVjdGl2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgLy8gVGhlICUgaW5kaWNhdG9yIGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBET0NVTUVOVC1TVEFSVDogXiAnLS0tJyAoJyAnfCdcXG4nKVxuICAgICAgKi9cbiAgICAgIGNoZWNrX2RvY3VtZW50X3N0YXJ0KCkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4gPT09IDAgJiYgdGhpcy5wcmVmaXgoMykgPT09ICctLS0nICYmIChyZWYgPSB0aGlzLnBlZWsoMyksIGluZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIHJlZikgPj0gMCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBET0NVTUVOVC1FTkQ6IF4gJy4uLicgKCcgJ3wnXFxuJylcbiAgICAgICovXG4gICAgICBjaGVja19kb2N1bWVudF9lbmQoKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbiA9PT0gMCAmJiB0aGlzLnByZWZpeCgzKSA9PT0gJy4uLicgJiYgKHJlZiA9IHRoaXMucGVlaygzKSwgaW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgcmVmKSA+PSAwKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIEJMT0NLLUVOVFJZOiAnLScgKCcgJ3wnXFxuJylcbiAgICAgICovXG4gICAgICBjaGVja19ibG9ja19lbnRyeSgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIHJlZiA9IHRoaXMucGVlaygxKSwgaW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgcmVmKSA+PSAwO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgS0VZIChmbG93IGNvbnRleHQpOiAgJz8nXG4gICAgICBLRVkgKGJsb2NrIGNvbnRleHQpOiAnPycgKCcgJ3wnXFxuJylcbiAgICAgICovXG4gICAgICBjaGVja19rZXkoKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgIT09IDApIHtcbiAgICAgICAgICAvLyBLRVkgKGZsb3cgY29udGV4dClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBLRVkgKGJsb2NrIGNvbnRleHQpXG4gICAgICAgIHJldHVybiByZWYgPSB0aGlzLnBlZWsoMSksIGluZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIHJlZikgPj0gMDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFZBTFVFIChmbG93IGNvbnRleHQpOiAgJzonXG4gICAgICBWQUxVRSAoYmxvY2sgY29udGV4dCk6ICc6JyAoJyAnfCdcXG4nKVxuICAgICAgKi9cbiAgICAgIGNoZWNrX3ZhbHVlKCkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBpZiAodGhpcy5mbG93X2xldmVsICE9PSAwKSB7XG4gICAgICAgICAgLy8gVkFMVUUgKGZsb3cgY29udGV4dClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWQUxVRSAoYmxvY2sgY29udGV4dClcbiAgICAgICAgcmV0dXJuIHJlZiA9IHRoaXMucGVlaygxKSwgaW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgcmVmKSA+PSAwO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgQSBwbGFpbiBzY2FsYXIgbWF5IHN0YXJ0IHdpdGggYW55IG5vbi1zcGFjZSBjaGFyYWN0ZXIgZXhjZXB0OlxuICAgICAgJy0nLCAnPycsICc6JywgJywnLCAnWycsICddJywgJ3snLCAnfScsXG4gICAgICAnIycsICcmJywgJyonLCAnIScsICd8JywgJz4nLCAnXFwnJywgJ1wiJyxcbiAgICAgICclJywgJ0AnLCAnYCcuXG5cbiAgICAgIEl0IG1heSBhbHNvIHN0YXJ0IHdpdGhcbiAgICAgICctJywgJz8nLCAnOidcbiAgICAgIGlmIGl0IGlzIGZvbGxvd2VkIGJ5IGEgbm9uLXNwYWNlIGNoYXJhY3Rlci5cblxuICAgICAgTm90ZSB0aGF0IHdlIGxpbWl0IHRoZSBsYXN0IHJ1bGUgdG8gdGhlIGJsb2NrIGNvbnRleHQgKGV4Y2VwdCB0aGUgJy0nXG4gICAgICBjaGFyYWN0ZXIpIGJlY2F1c2Ugd2Ugd2FudCB0aGUgZmxvdyBjb250ZXh0IHRvIGJlIHNwYWNlIGluZGVwZW5kZW50LlxuICAgICAgKi9cbiAgICAgIGNoZWNrX3BsYWluKCkge1xuICAgICAgICB2YXIgY2hhciwgcmVmO1xuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAtPzosW117fSMmKiF8PlxcJ1wiJUBgJywgY2hhcikgPCAwIHx8ICgocmVmID0gdGhpcy5wZWVrKDEpLCBpbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCByZWYpIDwgMCkgJiYgKGNoYXIgPT09ICctJyB8fCAodGhpcy5mbG93X2xldmVsID09PSAwICYmIGluZGV4T2YuY2FsbCgnPzonLCBjaGFyKSA+PSAwKSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBTY2FubmVycy5cbiAgICAgIC8qXG4gICAgICBXZSBpZ25vcmUgc3BhY2VzLCBsaW5lIGJyZWFrcyBhbmQgY29tbWVudHMuXG4gICAgICBJZiB3ZSBmaW5kIGEgbGluZSBicmVhayBpbiB0aGUgYmxvY2sgY29udGV4dCwgd2Ugc2V0IHRoZSBmbGFnXG4gICAgICBgYWxsb3dfc2ltcGxlX2tleWAgb24uXG4gICAgICBUaGUgYnl0ZSBvcmRlciBtYXJrIGlzIHN0cmlwcGVkIGlmIGl0J3MgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3RyZWFtLlxuICAgICAgV2UgZG8gbm90IHlldCBzdXBwb3J0IEJPTSBpbnNpZGUgdGhlIHN0cmVhbSBhcyB0aGUgc3BlY2lmaWNhdGlvbiByZXF1aXJlcy5cbiAgICAgIEFueSBzdWNoIG1hcmsgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQuXG5cbiAgICAgIFRPRE86IFdlIG5lZWQgdG8gbWFrZSB0YWIgaGFuZGxpbmcgcnVsZXMgbW9yZSBzYW5lLiAgQSBnb29kIHJ1bGUgaXNcbiAgICAgIFRhYnMgY2Fubm90IHByZWNlZGUgdG9rZW5zIEJMT0NLLVNFUVVFTkNFLVNUQVJULCBCTE9DSy1NQVBQSU5HLVNUQVJULFxuICAgICAgQkxPQ0stRU5ELCBLRVkgKGJsb2NrIGNvbnRleHQpLCBWQUxVRSAoYmxvY2sgY29udGV4dCksIEJMT0NLLUVOVFJZXG4gICAgICBTbyB0aGUgdGFiIGNoZWNraW5nIGNvZGUgaXNcbiAgICAgIEBhbGxvd19zaW1wbGVfa2V5ID0gb2ZmIGlmIDxUQUI+XG4gICAgICBXZSBhbHNvIG5lZWQgdG8gYWRkIHRoZSBjaGVjayBmb3IgYGFsbG93X3NpbXBsZV9rZXkgaXMgb25gIHRvXG4gICAgICBgdW53aW5kX2luZGVudGAgYmVmb3JlIGlzc3VpbmcgQkxPQ0stRU5ELiAgU2Nhbm5lcnMgZm9yIGJsb2NrLCBmbG93IGFuZFxuICAgICAgcGxhaW4gc2NhbGFycyBuZWVkIHRvIGJlIG1vZGlmaWVkLlxuICAgICAgKi9cbiAgICAgIHNjYW5fdG9fbmV4dF90b2tlbigpIHtcbiAgICAgICAgdmFyIGZvdW5kLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09PSAwICYmIHRoaXMucGVlaygpID09PSAnXFx1RkVGRicpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIHdoaWxlICghZm91bmQpIHtcbiAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB3aGlsZSAocmVmID0gdGhpcy5wZWVrKCksIGluZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgcmVmKSA8IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnNjYW5fbGluZV9icmVhaygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goZm91bmQgPSB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAqL1xuICAgICAgc2Nhbl9kaXJlY3RpdmUoKSB7XG4gICAgICAgIHZhciBlbmRfbWFyaywgbmFtZSwgcmVmLCBzdGFydF9tYXJrLCB2YWx1ZTtcbiAgICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIG5hbWUgPSB0aGlzLnNjYW5fZGlyZWN0aXZlX25hbWUoc3RhcnRfbWFyayk7XG4gICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdZQU1MJykge1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5zY2FuX3lhbWxfZGlyZWN0aXZlX3ZhbHVlKHN0YXJ0X21hcmspO1xuICAgICAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdUQUcnKSB7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnNjYW5fdGFnX2RpcmVjdGl2ZV92YWx1ZShzdGFydF9tYXJrKTtcbiAgICAgICAgICBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgICB3aGlsZSAocmVmID0gdGhpcy5wZWVrKCksIGluZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgcmVmKSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW5fZGlyZWN0aXZlX2lnbm9yZWRfbGluZShzdGFydF9tYXJrKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0b2tlbnMuRGlyZWN0aXZlVG9rZW4obmFtZSwgdmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgICovXG4gICAgICBzY2FuX2RpcmVjdGl2ZV9uYW1lKHN0YXJ0X21hcmspIHtcbiAgICAgICAgdmFyIGNoYXIsIGxlbmd0aCwgdmFsdWU7XG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKCgnMCcgPD0gY2hhciAmJiBjaGFyIDw9ICc5JykgfHwgKCdBJyA8PSBjaGFyICYmIGNoYXIgPD0gJ1onKSB8fCAoJ2EnIDw9IGNoYXIgJiYgY2hhciA8PSAneicpIHx8IGluZGV4T2YuY2FsbCgnLV8nLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZGlyZWN0aXZlJywgc3RhcnRfbWFyaywgYGV4cGVjdGVkIGFscGhhbnVtZXJpYyBvciBudW1lcmljIGNoYXJhY3RlciBidXQgZm91bmQgJHtjaGFyfWAsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0aGlzLnByZWZpeChsZW5ndGgpO1xuICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoaW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAgJywgY2hhcikgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIGBleHBlY3RlZCBhbHBoYW51bWVyaWMgb3IgbnVtZXJpYyBjaGFyYWN0ZXIgYnV0IGZvdW5kICR7Y2hhcn1gLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgICovXG4gICAgICBzY2FuX3lhbWxfZGlyZWN0aXZlX3ZhbHVlKHN0YXJ0X21hcmspIHtcbiAgICAgICAgdmFyIG1ham9yLCBtaW5vciwgcmVmO1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIG1ham9yID0gdGhpcy5zY2FuX3lhbWxfZGlyZWN0aXZlX251bWJlcihzdGFydF9tYXJrKTtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpICE9PSAnLicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZGlyZWN0aXZlJywgc3RhcnRfbWFyaywgYGV4cGVjdGVkIGEgZGlnaXQgb3IgJy4nIGJ1dCBmb3VuZCAke3RoaXMucGVlaygpfWAsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIG1pbm9yID0gdGhpcy5zY2FuX3lhbWxfZGlyZWN0aXZlX251bWJlcihzdGFydF9tYXJrKTtcbiAgICAgICAgaWYgKHJlZiA9IHRoaXMucGVlaygpLCBpbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCAnLCByZWYpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBgZXhwZWN0ZWQgYSBkaWdpdCBvciAnICcgYnV0IGZvdW5kICR7dGhpcy5wZWVrKCl9YCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21ham9yLCBtaW5vcl07XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAqL1xuICAgICAgc2Nhbl95YW1sX2RpcmVjdGl2ZV9udW1iZXIoc3RhcnRfbWFyaykge1xuICAgICAgICB2YXIgY2hhciwgbGVuZ3RoLCByZWYsIHZhbHVlO1xuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICghKCgnMCcgPD0gY2hhciAmJiBjaGFyIDw9ICc5JykpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIGBleHBlY3RlZCBhIGRpZ2l0IGJ1dCBmb3VuZCAke2NoYXJ9YCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoKCcwJyA8PSAocmVmID0gdGhpcy5wZWVrKGxlbmd0aCkpICYmIHJlZiA8PSAnOScpKSB7XG4gICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBwYXJzZUludCh0aGlzLnByZWZpeChsZW5ndGgpKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgICovXG4gICAgICBzY2FuX3RhZ19kaXJlY3RpdmVfdmFsdWUoc3RhcnRfbWFyaykge1xuICAgICAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlID0gdGhpcy5zY2FuX3RhZ19kaXJlY3RpdmVfaGFuZGxlKHN0YXJ0X21hcmspO1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIHByZWZpeCA9IHRoaXMuc2Nhbl90YWdfZGlyZWN0aXZlX3ByZWZpeChzdGFydF9tYXJrKTtcbiAgICAgICAgcmV0dXJuIFtoYW5kbGUsIHByZWZpeF07XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAqL1xuICAgICAgc2Nhbl90YWdfZGlyZWN0aXZlX2hhbmRsZShzdGFydF9tYXJrKSB7XG4gICAgICAgIHZhciBjaGFyLCB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNjYW5fdGFnX2hhbmRsZSgnZGlyZWN0aXZlJywgc3RhcnRfbWFyayk7XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGNoYXIgIT09ICcgJykge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBgZXhwZWN0ZWQgJyAnIGJ1dCBmb3VuZCAke2NoYXJ9YCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAqL1xuICAgICAgc2Nhbl90YWdfZGlyZWN0aXZlX3ByZWZpeChzdGFydF9tYXJrKSB7XG4gICAgICAgIHZhciBjaGFyLCB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNjYW5fdGFnX3VyaSgnZGlyZWN0aXZlJywgc3RhcnRfbWFyayk7XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGluZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwICcsIGNoYXIpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBgZXhwZWN0ZWQgJyAnIGJ1dCBmb3VuZCAke2NoYXJ9YCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAqL1xuICAgICAgc2Nhbl9kaXJlY3RpdmVfaWdub3JlZF9saW5lKHN0YXJ0X21hcmspIHtcbiAgICAgICAgdmFyIGNoYXIsIHJlZjtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09ICcjJykge1xuICAgICAgICAgIHdoaWxlIChyZWYgPSB0aGlzLnBlZWsoKSwgaW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAnLCByZWYpIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGluZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgY2hhcikgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIGBleHBlY3RlZCBhIGNvbW1lbnQgb3IgYSBsaW5lIGJyZWFrIGJ1dCBmb3VuZCAke2NoYXJ9YCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY2FuX2xpbmVfYnJlYWsoKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFRoZSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHJlc3RyaWN0IGNoYXJhY3RlcnMgZm9yIGFuY2hvcnMgYW5kIGFsaWFzZXMuXG4gICAgICBUaGlzIG1heSBsZWFkIHRvIHByb2JsZW1zLCBmb3IgaW5zdGFuY2UsIHRoZSBkb2N1bWVudDpcbiAgICAgIFsgKmFsaWFzLCB2YWx1ZSBdXG4gICAgICBjYW4gYmUgaW50ZXJwdGV0ZWQgaW4gdHdvIHdheXMsIGFzXG4gICAgICBbIFwidmFsdWVcIiBdXG4gICAgICBhbmRcbiAgICAgIFsgKmFsaWFzICwgXCJ2YWx1ZVwiIF1cbiAgICAgIFRoZXJlZm9yZSB3ZSByZXN0cmljdCBhbGlhc2VzIHRvIG51bWJlcnMgYW5kIEFTQ0lJIGxldHRlcnMuXG4gICAgICAqL1xuICAgICAgc2Nhbl9hbmNob3IoVG9rZW5DbGFzcykge1xuICAgICAgICB2YXIgY2hhciwgaW5kaWNhdG9yLCBsZW5ndGgsIG5hbWUsIHN0YXJ0X21hcmssIHZhbHVlO1xuICAgICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICBpbmRpY2F0b3IgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGluZGljYXRvciA9PT0gJyonKSB7XG4gICAgICAgICAgbmFtZSA9ICdhbGlhcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9ICdhbmNob3InO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICAgIHdoaWxlICgoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnOScpIHx8ICgnQScgPD0gY2hhciAmJiBjaGFyIDw9ICdaJykgfHwgKCdhJyA8PSBjaGFyICYmIGNoYXIgPD0gJ3onKSB8fCBpbmRleE9mLmNhbGwoJy1fJywgY2hhcikgPj0gMCkge1xuICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKGB3aGlsZSBzY2FubmluZyBhbiAke25hbWV9YCwgc3RhcnRfbWFyaywgYGV4cGVjdGVkIGFscGhhYmV0aWMgb3IgbnVtZXJpYyBjaGFyYWN0ZXIgYnV0IGZvdW5kICcke2NoYXJ9J2AsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0aGlzLnByZWZpeChsZW5ndGgpO1xuICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoaW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJyArICc/OixdfSVAYCcsIGNoYXIpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihgd2hpbGUgc2Nhbm5pbmcgYW4gJHtuYW1lfWAsIHN0YXJ0X21hcmssIGBleHBlY3RlZCBhbHBoYWJldGljIG9yIG51bWVyaWMgY2hhcmFjdGVyIGJ1dCBmb3VuZCAnJHtjaGFyfSdgLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5DbGFzcyh2YWx1ZSwgc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgICovXG4gICAgICBzY2FuX3RhZygpIHtcbiAgICAgICAgdmFyIGNoYXIsIGhhbmRsZSwgbGVuZ3RoLCBzdGFydF9tYXJrLCBzdWZmaXgsIHVzZV9oYW5kbGU7XG4gICAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoMSk7XG4gICAgICAgIGlmIChjaGFyID09PSAnPCcpIHtcbiAgICAgICAgICBoYW5kbGUgPSBudWxsO1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgyKTtcbiAgICAgICAgICBzdWZmaXggPSB0aGlzLnNjYW5fdGFnX3VyaSgndGFnJywgc3RhcnRfbWFyayk7XG4gICAgICAgICAgaWYgKHRoaXMucGVlaygpICE9PSAnPicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgcGFyc2luZyBhIHRhZycsIHN0YXJ0X21hcmssIGBleHBlY3RlZCAnPicgYnV0IGZvdW5kICR7dGhpcy5wZWVrKCl9YCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgY2hhcikgPj0gMCkge1xuICAgICAgICAgIGhhbmRsZSA9IG51bGw7XG4gICAgICAgICAgc3VmZml4ID0gJyEnO1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgICAgdXNlX2hhbmRsZSA9IGZhbHNlO1xuICAgICAgICAgIHdoaWxlIChpbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCAnLCBjaGFyKSA8IDApIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnIScpIHtcbiAgICAgICAgICAgICAgdXNlX2hhbmRsZSA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1c2VfaGFuZGxlKSB7XG4gICAgICAgICAgICBoYW5kbGUgPSB0aGlzLnNjYW5fdGFnX2hhbmRsZSgndGFnJywgc3RhcnRfbWFyayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZSA9ICchJztcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWZmaXggPSB0aGlzLnNjYW5fdGFnX3VyaSgndGFnJywgc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoaW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAgJywgY2hhcikgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHRhZycsIHN0YXJ0X21hcmssIGBleHBlY3RlZCAnICcgYnV0IGZvdW5kICR7Y2hhcn1gLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdG9rZW5zLlRhZ1Rva2VuKFtoYW5kbGUsIHN1ZmZpeF0sIHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAqL1xuICAgICAgc2Nhbl9ibG9ja19zY2FsYXIoc3R5bGUpIHtcbiAgICAgICAgdmFyIGJyZWFrcywgY2hvbXBpbmcsIGNodW5rcywgZW5kX21hcmssIGZvbGRlZCwgaW5jcmVtZW50LCBpbmRlbnQsIGxlYWRpbmdfbm9uX3NwYWNlLCBsZW5ndGgsIGxpbmVfYnJlYWssIG1heF9pbmRlbnQsIG1pbl9pbmRlbnQsIHJlZiwgcmVmMSwgcmVmMiwgc3RhcnRfbWFyaztcbiAgICAgICAgZm9sZGVkID0gc3R5bGUgPT09ICc+JztcbiAgICAgICAgY2h1bmtzID0gW107XG4gICAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIC8vIFNjYW4gdGhlIGhlYWRlci5cbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIFtjaG9tcGluZywgaW5jcmVtZW50XSA9IHRoaXMuc2Nhbl9ibG9ja19zY2FsYXJfaW5kaWNhdG9ycyhzdGFydF9tYXJrKTtcbiAgICAgICAgdGhpcy5zY2FuX2Jsb2NrX3NjYWxhcl9pZ25vcmVkX2xpbmUoc3RhcnRfbWFyayk7XG4gICAgICAgIC8vIERldGVybWluZSB0aGUgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGdvIHRvIHRoZSBmaXJzdCBub24tZW1wdHkgbGluZS5cbiAgICAgICAgbWluX2luZGVudCA9IHRoaXMuaW5kZW50ICsgMTtcbiAgICAgICAgaWYgKG1pbl9pbmRlbnQgPCAxKSB7XG4gICAgICAgICAgbWluX2luZGVudCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY3JlbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgW2JyZWFrcywgbWF4X2luZGVudCwgZW5kX21hcmtdID0gdGhpcy5zY2FuX2Jsb2NrX3NjYWxhcl9pbmRlbnRhdGlvbigpO1xuICAgICAgICAgIGluZGVudCA9IE1hdGgubWF4KG1pbl9pbmRlbnQsIG1heF9pbmRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGVudCA9IG1pbl9pbmRlbnQgKyBpbmNyZW1lbnQgLSAxO1xuICAgICAgICAgIFticmVha3MsIGVuZF9tYXJrXSA9IHRoaXMuc2Nhbl9ibG9ja19zY2FsYXJfYnJlYWtzKGluZGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZV9icmVhayA9ICcnO1xuICAgICAgICAvLyBTY2FuIHRoZSBpbm5lciBwYXJ0IG9mIHRoZSBibG9jayBzY2FsYXIuXG4gICAgICAgIHdoaWxlICh0aGlzLmNvbHVtbiA9PT0gaW5kZW50ICYmIHRoaXMucGVlaygpICE9PSAnXFx4MDAnKSB7XG4gICAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdChicmVha3MpO1xuICAgICAgICAgIGxlYWRpbmdfbm9uX3NwYWNlID0gKHJlZiA9IHRoaXMucGVlaygpLCBpbmRleE9mLmNhbGwoJyBcXHQnLCByZWYpIDwgMCk7XG4gICAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgICB3aGlsZSAocmVmMSA9IHRoaXMucGVlayhsZW5ndGgpLCBpbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCcsIHJlZjEpIDwgMCkge1xuICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNodW5rcy5wdXNoKHRoaXMucHJlZml4KGxlbmd0aCkpO1xuICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICAgIGxpbmVfYnJlYWsgPSB0aGlzLnNjYW5fbGluZV9icmVhaygpO1xuICAgICAgICAgIFticmVha3MsIGVuZF9tYXJrXSA9IHRoaXMuc2Nhbl9ibG9ja19zY2FsYXJfYnJlYWtzKGluZGVudCk7XG4gICAgICAgICAgaWYgKHRoaXMuY29sdW1uID09PSBpbmRlbnQgJiYgdGhpcy5wZWVrKCkgIT09ICdcXHgwMCcpIHtcbiAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIGZvbGRpbmcgcnVsZXMgYXJlIGFtYmlndW91cy4gIFRoaXMgaXMgdGhlIGZvbGRpbmdcbiAgICAgICAgICAgIC8vIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbjpcbiAgICAgICAgICAgIGlmIChmb2xkZWQgJiYgbGluZV9icmVhayA9PT0gJ1xcbicgJiYgbGVhZGluZ19ub25fc3BhY2UgJiYgKHJlZjIgPSB0aGlzLnBlZWsoKSwgaW5kZXhPZi5jYWxsKCcgXFx0JywgcmVmMikgPCAwKSkge1xuICAgICAgICAgICAgICBpZiAodXRpbC5pc19lbXB0eShicmVha3MpKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobGluZV9icmVhayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgQ2xhcmsgRXZhbidzIGludGVycHJldGF0aW9uIChhbHNvIGluIHRoZSBzcGVjIGV4YW1wbGVzKTpcbiAgICAgICAgICAgIC8vIGlmIGZvbGRlZCBhbmQgbGluZV9icmVhayBpcyAnXFxuJ1xuICAgICAgICAgICAgLy8gICBpZiBub3QgYnJlYWtzXG4gICAgICAgICAgICAvLyAgICAgaWYgQHBlZWsoKSBub3QgaW4gJyBcXHQnXG4gICAgICAgICAgICAvLyAgICAgICBjaHVua3MucHVzaCAnICdcbiAgICAgICAgICAgIC8vICAgICBlbHNlXG4gICAgICAgICAgICAvLyAgICAgICBjaHVua3MucHVzaCBsaW5lX2JyZWFrXG4gICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAvLyAgIGNodW5rcy5wdXNoIGxpbmVfYnJlYWtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvbXBpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gQ2hvbXAgdGhlIHRhaWxcbiAgICAgICAgICBjaHVua3MucHVzaChsaW5lX2JyZWFrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvbXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KGJyZWFrcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW5kIHdlJ3JlIGRvbmUuXG4gICAgICAgIHJldHVybiBuZXcgdG9rZW5zLlNjYWxhclRva2VuKGNodW5rcy5qb2luKCcnKSwgZmFsc2UsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCBzdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAqL1xuICAgICAgc2Nhbl9ibG9ja19zY2FsYXJfaW5kaWNhdG9ycyhzdGFydF9tYXJrKSB7XG4gICAgICAgIHZhciBjaGFyLCBjaG9tcGluZywgaW5jcmVtZW50O1xuICAgICAgICBjaG9tcGluZyA9IG51bGw7XG4gICAgICAgIGluY3JlbWVudCA9IG51bGw7XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGluZGV4T2YuY2FsbCgnKy0nLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgY2hvbXBpbmcgPSBjaGFyID09PSAnKyc7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICAgIGlmIChpbmRleE9mLmNhbGwoQ19OVU1CRVJTLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgICBpbmNyZW1lbnQgPSBwYXJzZUludChjaGFyKTtcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGJsb2NrIHNjYWxhcicsIHN0YXJ0X21hcmssICdleHBlY3RlZCBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgaW4gdGhlIHJhbmdlIDEtOSBidXQgZm91bmQgMCcsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXhPZi5jYWxsKENfTlVNQkVSUywgY2hhcikgPj0gMCkge1xuICAgICAgICAgIGluY3JlbWVudCA9IHBhcnNlSW50KGNoYXIpO1xuICAgICAgICAgIGlmIChpbmNyZW1lbnQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBibG9jayBzY2FsYXInLCBzdGFydF9tYXJrLCAnZXhwZWN0ZWQgaW5kZW50YXRpb24gaW5kaWNhdG9yIGluIHRoZSByYW5nZSAxLTkgYnV0IGZvdW5kIDAnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgaWYgKGluZGV4T2YuY2FsbCgnKy0nLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgICBjaG9tcGluZyA9IGNoYXIgPT09ICcrJztcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmIChpbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCAnLCBjaGFyKSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgYmxvY2sgc2NhbGFyJywgc3RhcnRfbWFyaywgYGV4cGVjdGVkIGNob21waW5nIG9yIGluZGVudGF0aW9uIGluZGljYXRvcnMsIGJ1dCBmb3VuZCAke2NoYXJ9YCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Nob21waW5nLCBpbmNyZW1lbnRdO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICAgKi9cbiAgICAgIHNjYW5fYmxvY2tfc2NhbGFyX2lnbm9yZWRfbGluZShzdGFydF9tYXJrKSB7XG4gICAgICAgIHZhciBjaGFyLCByZWY7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSAnIycpIHtcbiAgICAgICAgICB3aGlsZSAocmVmID0gdGhpcy5wZWVrKCksIGluZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgcmVmKSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmIChpbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCcsIGNoYXIpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBibG9jayBzY2FsYXInLCBzdGFydF9tYXJrLCBgZXhwZWN0ZWQgYSBjb21tZW50IG9yIGEgbGluZSBicmVhayBidXQgZm91bmQgJHtjaGFyfWAsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbl9saW5lX2JyZWFrKCk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAqL1xuICAgICAgc2Nhbl9ibG9ja19zY2FsYXJfaW5kZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaHVua3MsIGVuZF9tYXJrLCBtYXhfaW5kZW50LCByZWY7XG4gICAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgICBtYXhfaW5kZW50ID0gMDtcbiAgICAgICAgZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIHdoaWxlIChyZWYgPSB0aGlzLnBlZWsoKSwgaW5kZXhPZi5jYWxsKENfTEIgKyAnICcsIHJlZikgPj0gMCkge1xuICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSAhPT0gJyAnKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLnNjYW5fbGluZV9icmVhaygpKTtcbiAgICAgICAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbiA+IG1heF9pbmRlbnQpIHtcbiAgICAgICAgICAgICAgbWF4X2luZGVudCA9IHRoaXMuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2NodW5rcywgbWF4X2luZGVudCwgZW5kX21hcmtdO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICAgKi9cbiAgICAgIHNjYW5fYmxvY2tfc2NhbGFyX2JyZWFrcyhpbmRlbnQpIHtcbiAgICAgICAgdmFyIGNodW5rcywgZW5kX21hcmssIHJlZjtcbiAgICAgICAgY2h1bmtzID0gW107XG4gICAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICB3aGlsZSAodGhpcy5jb2x1bW4gPCBpbmRlbnQgJiYgdGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyZWYgPSB0aGlzLnBlZWsoKSwgaW5kZXhPZi5jYWxsKENfTEIsIHJlZikgPj0gMCkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKHRoaXMuc2Nhbl9saW5lX2JyZWFrKCkpO1xuICAgICAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLmNvbHVtbiA8IGluZGVudCAmJiB0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjaHVua3MsIGVuZF9tYXJrXTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgIE5vdGUgdGhhdCB3ZSBsb29zZSBpbmRlbnRhdGlvbiBydWxlcyBmb3IgcXVvdGVkIHNjYWxhcnMuIFF1b3RlZCBzY2FsYXJzXG4gICAgICBkb24ndCBuZWVkIHRvIGFkaGVyZSBpbmRlbnRhdGlvbiBiZWNhdXNlIFwiIGFuZCAnIGNsZWFybHkgbWFyayB0aGUgYmVnaW5uaW5nXG4gICAgICBhbmQgdGhlIGVuZCBvZiB0aGVtLiBUaGVyZWZvcmUgd2UgYXJlIGxlc3MgcmVzdHJpY3RpdmUgdGhhbiB0aGVcbiAgICAgIHNwZWNpZmljYXRpb24gcmVxdWlyZXMuIFdlIG9ubHkgbmVlZCB0byBjaGVjayB0aGF0IGRvY3VtZW50IHNlcGFyYXRvcnMgYXJlXG4gICAgICBub3QgaW5jbHVkZWQgaW4gc2NhbGFycy5cbiAgICAgICovXG4gICAgICBzY2FuX2Zsb3dfc2NhbGFyKHN0eWxlKSB7XG4gICAgICAgIHZhciBjaHVua3MsIGRvdWJsZSwgcXVvdGUsIHN0YXJ0X21hcms7XG4gICAgICAgIGRvdWJsZSA9IHN0eWxlID09PSAnXCInO1xuICAgICAgICBjaHVua3MgPSBbXTtcbiAgICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgcXVvdGUgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQodGhpcy5zY2FuX2Zsb3dfc2NhbGFyX25vbl9zcGFjZXMoZG91YmxlLCBzdGFydF9tYXJrKSk7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSAhPT0gcXVvdGUpIHtcbiAgICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KHRoaXMuc2Nhbl9mbG93X3NjYWxhcl9zcGFjZXMoZG91YmxlLCBzdGFydF9tYXJrKSk7XG4gICAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdCh0aGlzLnNjYW5fZmxvd19zY2FsYXJfbm9uX3NwYWNlcyhkb3VibGUsIHN0YXJ0X21hcmspKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0b2tlbnMuU2NhbGFyVG9rZW4oY2h1bmtzLmpvaW4oJycpLCBmYWxzZSwgc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpLCBzdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAqL1xuICAgICAgc2Nhbl9mbG93X3NjYWxhcl9ub25fc3BhY2VzKGRvdWJsZSwgc3RhcnRfbWFyaykge1xuICAgICAgICB2YXIgY2hhciwgY2h1bmtzLCBjb2RlLCBpLCBrLCBsZW5ndGgsIHJlZiwgcmVmMSwgcmVmMjtcbiAgICAgICAgY2h1bmtzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgICB3aGlsZSAocmVmID0gdGhpcy5wZWVrKGxlbmd0aCksIGluZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXCdcIlxcXFxcXHgwMCcsIHJlZikgPCAwKSB7XG4gICAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5wcmVmaXgobGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICAgIGlmICghZG91YmxlICYmIGNoYXIgPT09ICdcXCcnICYmIHRoaXMucGVlaygxKSA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCdcXCcnKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKChkb3VibGUgJiYgY2hhciA9PT0gJ1xcJycpIHx8ICghZG91YmxlICYmIGluZGV4T2YuY2FsbCgnXCJcXFxcJywgY2hhcikgPj0gMCkpIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkb3VibGUgJiYgY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgICAgIGlmIChjaGFyIGluIEVTQ0FQRV9SRVBMQUNFTUVOVFMpIHtcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2goRVNDQVBFX1JFUExBQ0VNRU5UU1tjaGFyXSk7XG4gICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyIGluIEVTQ0FQRV9DT0RFUykge1xuICAgICAgICAgICAgICBsZW5ndGggPSBFU0NBUEVfQ09ERVNbY2hhcl07XG4gICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgICAgICBmb3IgKGsgPSBpID0gMCwgcmVmMSA9IGxlbmd0aDsgMCA8PSByZWYxID8gaSA8IHJlZjEgOiBpID4gcmVmMTsgayA9IDAgPD0gcmVmMSA/ICsraSA6IC0taSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWYyID0gdGhpcy5wZWVrKGspLCBpbmRleE9mLmNhbGwoYCR7Q19OVU1CRVJTfUFCQ0RFRmFiY2RlZmAsIHJlZjIpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRvdWJsZS1xdW90ZWQgc2NhbGFyJywgc3RhcnRfbWFyaywgYGV4cGVjdGVkIGVzY2FwZSBzZXF1ZW5jZSBvZiAke2xlbmd0aH0gaGV4YWRlY2ltYWwgbnVtYmVycywgYnV0IGZvdW5kICR7dGhpcy5wZWVrKGspfWAsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvZGUgPSBwYXJzZUludCh0aGlzLnByZWZpeChsZW5ndGgpLCAxNik7XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXhPZi5jYWxsKENfTEIsIGNoYXIpID49IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5zY2FuX2xpbmVfYnJlYWsoKTtcbiAgICAgICAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdCh0aGlzLnNjYW5fZmxvd19zY2FsYXJfYnJlYWtzKGRvdWJsZSwgc3RhcnRfbWFyaykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRvdWJsZS1xdW90ZWQgc2NhbGFyJywgc3RhcnRfbWFyaywgYGZvdW5kIHVua25vd24gZXNjYXBlIGNoYXJhY3RlciAke2NoYXJ9YCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgICovXG4gICAgICBzY2FuX2Zsb3dfc2NhbGFyX3NwYWNlcyhkb3VibGUsIHN0YXJ0X21hcmspIHtcbiAgICAgICAgdmFyIGJyZWFrcywgY2hhciwgY2h1bmtzLCBsZW5ndGgsIGxpbmVfYnJlYWssIHJlZiwgd2hpdGVzcGFjZXM7XG4gICAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAocmVmID0gdGhpcy5wZWVrKGxlbmd0aCksIGluZGV4T2YuY2FsbChDX1dTLCByZWYpID49IDApIHtcbiAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICB3aGl0ZXNwYWNlcyA9IHRoaXMucHJlZml4KGxlbmd0aCk7XG4gICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmIChjaGFyID09PSAnXFx4MDAnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHF1b3RlZCBzY2FsYXInLCBzdGFydF9tYXJrLCAnZm91bmQgdW5leHBlY3RlZCBlbmQgb2Ygc3RyZWFtJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXhPZi5jYWxsKENfTEIsIGNoYXIpID49IDApIHtcbiAgICAgICAgICBsaW5lX2JyZWFrID0gdGhpcy5zY2FuX2xpbmVfYnJlYWsoKTtcbiAgICAgICAgICBicmVha3MgPSB0aGlzLnNjYW5fZmxvd19zY2FsYXJfYnJlYWtzKGRvdWJsZSwgc3RhcnRfbWFyayk7XG4gICAgICAgICAgaWYgKGxpbmVfYnJlYWsgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChsaW5lX2JyZWFrKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJyZWFrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKCcgJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQoYnJlYWtzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVua3MucHVzaCh3aGl0ZXNwYWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgICovXG4gICAgICBzY2FuX2Zsb3dfc2NhbGFyX2JyZWFrcyhkb3VibGUsIHN0YXJ0X21hcmspIHtcbiAgICAgICAgdmFyIGNodW5rcywgcHJlZml4LCByZWYsIHJlZjEsIHJlZjI7XG4gICAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIC8vIEluc3RlYWQgb2YgY2hlY2tpbmcgZm9yIGluZGVudGF0aW9uLCB3ZSBjaGVjayBmb3IgZG9jdW1lbnQgc2VwYXJhdG9ycy5cbiAgICAgICAgICBwcmVmaXggPSB0aGlzLnByZWZpeCgzKTtcbiAgICAgICAgICBpZiAocHJlZml4ID09PSAnLS0tJyB8fCBwcmVmaXggPT09ICcuLi4nICYmIChyZWYgPSB0aGlzLnBlZWsoMyksIGluZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIHJlZikgPj0gMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBxdW90ZWQgc2NhbGFyJywgc3RhcnRfbWFyaywgJ2ZvdW5kIHVuZXhwZWN0ZWQgZG9jdW1lbnQgc2VwYXJhdG9yJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJlZjEgPSB0aGlzLnBlZWsoKSwgaW5kZXhPZi5jYWxsKENfV1MsIHJlZjEpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVmMiA9IHRoaXMucGVlaygpLCBpbmRleE9mLmNhbGwoQ19MQiwgcmVmMikgPj0gMCkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5zY2FuX2xpbmVfYnJlYWsoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICBXZSBhZGQgYW4gYWRkaXRpb25hbCByZXN0cmljdGlvbiBmb3IgdGhlIGZsb3cgY29udGV4dDpcbiAgICAgICAgcGxhaW4gc2NhbGFycyBpbiB0aGUgZmxvdyBjb250ZXh0IGNhbm5vdCBjb250YWluICcsJywgJzonIGFuZCAnPycuXG4gICAgICBXZSBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIGBhbGxvd19zaW1wbGVfa2V5YCBmbGFnIGhlcmUuXG4gICAgICBJbmRlbnRhdGlvbiBydWxlcyBhcmUgbG9vc2VkIGZvciB0aGUgZmxvdyBjb250ZXh0LlxuICAgICAgKi9cbiAgICAgIHNjYW5fcGxhaW4oKSB7XG4gICAgICAgIHZhciBjaGFyLCBjaHVua3MsIGVuZF9tYXJrLCBpbmRlbnQsIGxlbmd0aCwgcmVmLCByZWYxLCBzcGFjZXMsIHN0YXJ0X21hcms7XG4gICAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgICBzdGFydF9tYXJrID0gZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIGluZGVudCA9IHRoaXMuaW5kZW50ICsgMTtcbiAgICAgICAgLy8gV2UgYWxsb3cgemVybyBpbmRlbnRhdGlvbiBmb3Igc2NhbGFycywgYnV0IHRoZW4gd2UgbmVlZCB0byBjaGVjayBmb3JcbiAgICAgICAgLy8gZG9jdW1lbnQgc2VwYXJhdG9ycyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lLlxuICAgICAgICAvLyBpbmRlbnQgPSAxIGlmIGluZGVudCBpcyAwXG4gICAgICAgIHNwYWNlcyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSAnIycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGluZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIGNoYXIpID49IDAgfHwgKHRoaXMuZmxvd19sZXZlbCA9PT0gMCAmJiBjaGFyID09PSAnOicgJiYgKHJlZiA9IHRoaXMucGVlayhsZW5ndGggKyAxKSwgaW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgcmVmKSA+PSAwKSkgfHwgKHRoaXMuZmxvd19sZXZlbCAhPT0gMCAmJiBpbmRleE9mLmNhbGwoJyw6P1tde30nLCBjaGFyKSA+PSAwKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJdCdzIG5vdCBjbGVhciB3aGF0IHdlIHNob3VsZCBkbyB3aXRoICc6JyBpbiB0aGUgZmxvdyBjb250ZXh0LlxuICAgICAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgIT09IDAgJiYgY2hhciA9PT0gJzonICYmIChyZWYxID0gdGhpcy5wZWVrKGxlbmd0aCArIDEpLCBpbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAsW117fScsIHJlZjEpIDwgMCkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHBsYWluIHNjYWxhcicsIHN0YXJ0X21hcmssICdmb3VuZCB1bmV4cGVjdGVkIFxcJzpcXCcnLCB0aGlzLmdldF9tYXJrKCksICdQbGVhc2UgY2hlY2sgaHR0cDovL3B5eWFtbC5vcmcvd2lraS9ZQU1MQ29sb25JbkZsb3dDb250ZXh0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KHNwYWNlcyk7XG4gICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5wcmVmaXgobGVuZ3RoKSk7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgICAgZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgICAgc3BhY2VzID0gdGhpcy5zY2FuX3BsYWluX3NwYWNlcyhpbmRlbnQsIHN0YXJ0X21hcmspO1xuICAgICAgICAgIGlmICgoc3BhY2VzID09IG51bGwpIHx8IHNwYWNlcy5sZW5ndGggPT09IDAgfHwgdGhpcy5wZWVrKCkgPT09ICcjJyB8fCAodGhpcy5mbG93X2xldmVsID09PSAwICYmIHRoaXMuY29sdW1uIDwgaW5kZW50KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdG9rZW5zLlNjYWxhclRva2VuKGNodW5rcy5qb2luKCcnKSwgdHJ1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICAgVGhlIHNwZWNpZmljYXRpb24gaXMgcmVhbGx5IGNvbmZ1c2luZyBhYm91dCB0YWJzIGluIHBsYWluIHNjYWxhcnMuXG4gICAgICBXZSBqdXN0IGZvcmJpZCB0aGVtIGNvbXBsZXRlbHkuIERvIG5vdCB1c2UgdGFicyBpbiBZQU1MIVxuICAgICAgKi9cbiAgICAgIHNjYW5fcGxhaW5fc3BhY2VzKGluZGVudCwgc3RhcnRfbWFyaykge1xuICAgICAgICB2YXIgYnJlYWtzLCBjaGFyLCBjaHVua3MsIGxlbmd0aCwgbGluZV9icmVhaywgcHJlZml4LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHdoaXRlc3BhY2VzO1xuICAgICAgICBjaHVua3MgPSBbXTtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgd2hpbGUgKHJlZiA9IHRoaXMucGVlayhsZW5ndGgpLCBpbmRleE9mLmNhbGwoJyAnLCByZWYpID49IDApIHtcbiAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICB3aGl0ZXNwYWNlcyA9IHRoaXMucHJlZml4KGxlbmd0aCk7XG4gICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmIChpbmRleE9mLmNhbGwoQ19MQiwgY2hhcikgPj0gMCkge1xuICAgICAgICAgIGxpbmVfYnJlYWsgPSB0aGlzLnNjYW5fbGluZV9icmVhaygpO1xuICAgICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IHRydWU7XG4gICAgICAgICAgcHJlZml4ID0gdGhpcy5wcmVmaXgoMyk7XG4gICAgICAgICAgaWYgKHByZWZpeCA9PT0gJy0tLScgfHwgcHJlZml4ID09PSAnLi4uJyAmJiAocmVmMSA9IHRoaXMucGVlaygzKSwgaW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgcmVmMSkgPj0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtzID0gW107XG4gICAgICAgICAgd2hpbGUgKHJlZjMgPSB0aGlzLnBlZWsoKSwgaW5kZXhPZi5jYWxsKENfTEIgKyAnICcsIHJlZjMpID49IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWtzLnB1c2godGhpcy5zY2FuX2xpbmVfYnJlYWsoKSk7XG4gICAgICAgICAgICAgIHByZWZpeCA9IHRoaXMucHJlZml4KDMpO1xuICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSAnLS0tJyB8fCBwcmVmaXggPT09ICcuLi4nICYmIChyZWYyID0gdGhpcy5wZWVrKDMpLCBpbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCByZWYyKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGluZV9icmVhayAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGxpbmVfYnJlYWspO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYnJlYWtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goJyAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdChicmVha3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VzKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2god2hpdGVzcGFjZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICBGb3Igc29tZSBzdHJhbmdlIHJlYXNvbnMsIHRoZSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGFsbG93ICdfJyBpbiB0YWdcbiAgICAgIGhhbmRsZXMuIEkgaGF2ZSBhbGxvd2VkIGl0IGFueXdheS5cbiAgICAgICovXG4gICAgICBzY2FuX3RhZ19oYW5kbGUobmFtZSwgc3RhcnRfbWFyaykge1xuICAgICAgICB2YXIgY2hhciwgbGVuZ3RoLCB2YWx1ZTtcbiAgICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoY2hhciAhPT0gJyEnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKGB3aGlsZSBzY2FubmluZyBhICR7bmFtZX1gLCBzdGFydF9tYXJrLCBgZXhwZWN0ZWQgJyEnIGJ1dCBmb3VuZCAke2NoYXJ9YCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgICB3aGlsZSAoKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknKSB8fCAoJ0EnIDw9IGNoYXIgJiYgY2hhciA8PSAnWicpIHx8ICgnYScgPD0gY2hhciAmJiBjaGFyIDw9ICd6JykgfHwgaW5kZXhPZi5jYWxsKCctXycsIGNoYXIpID49IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciAhPT0gJyEnKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihgd2hpbGUgc2Nhbm5pbmcgYSAke25hbWV9YCwgc3RhcnRfbWFyaywgYGV4cGVjdGVkICchJyBidXQgZm91bmQgJHtjaGFyfWAsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdGhpcy5wcmVmaXgobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgIE5vdGU6IHdlIGRvIG5vdCBjaGVjayBpZiBVUkkgaXMgd2VsbC1mb3JtZWQuXG4gICAgICAqL1xuICAgICAgc2Nhbl90YWdfdXJpKG5hbWUsIHN0YXJ0X21hcmspIHtcbiAgICAgICAgdmFyIGNoYXIsIGNodW5rcywgbGVuZ3RoO1xuICAgICAgICBjaHVua3MgPSBbXTtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknKSB8fCAoJ0EnIDw9IGNoYXIgJiYgY2hhciA8PSAnWicpIHx8ICgnYScgPD0gY2hhciAmJiBjaGFyIDw9ICd6JykgfHwgaW5kZXhPZi5jYWxsKCctOy8/OkAmPSskLF8uIX4qXFwnKClbXSUnLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgaWYgKGNoYXIgPT09ICclJykge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5wcmVmaXgobGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLnNjYW5fdXJpX2VzY2FwZXMobmFtZSwgc3RhcnRfbWFyaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLnByZWZpeChsZW5ndGgpKTtcbiAgICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKGB3aGlsZSBwYXJzaW5nIGEgJHtuYW1lfWAsIHN0YXJ0X21hcmssIGBleHBlY3RlZCBVUkkgYnV0IGZvdW5kICR7Y2hhcn1gLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVua3Muam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAqL1xuICAgICAgc2Nhbl91cmlfZXNjYXBlcyhuYW1lLCBzdGFydF9tYXJrKSB7XG4gICAgICAgIHZhciBieXRlcywgaSwgaywgbWFyaztcbiAgICAgICAgYnl0ZXMgPSBbXTtcbiAgICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSAnJScpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICBmb3IgKGsgPSBpID0gMDsgaSA8PSAyOyBrID0gKytpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoYHdoaWxlIHNjYW5uaW5nIGEgJHtuYW1lfWAsIHN0YXJ0X21hcmssIGBleHBlY3RlZCBVUkkgZXNjYXBlIHNlcXVlbmNlIG9mIDIgaGV4YWRlY2ltYWwgbnVtYmVycyBidXQgZm91bmQgJHt0aGlzLnBlZWsoayl9YCwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnl0ZXMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHRoaXMucHJlZml4KDIpLCAxNikpKTtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgVHJhbnNmb3JtczpcbiAgICAgICdcXHJcXG4nICAgICAgOiAgICdcXG4nXG4gICAgICAnXFxyJyAgICAgICAgOiAgICdcXG4nXG4gICAgICAnXFxuJyAgICAgICAgOiAgICdcXG4nXG4gICAgICAnXFx4ODUnICAgICAgOiAgICdcXG4nXG4gICAgICAnXFx1MjAyOCcgICAgOiAgICdcXHUyMDI4J1xuICAgICAgJ1xcdTIwMjkgICAgIDogICAnXFx1MjAyOSdcbiAgICAgIGRlZmF1bHQgICAgIDogICAnJ1xuICAgICAgKi9cbiAgICAgIHNjYW5fbGluZV9icmVhaygpIHtcbiAgICAgICAgdmFyIGNoYXI7XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGluZGV4T2YuY2FsbCgnXFxyXFxuXFx4ODUnLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJlZml4KDIpID09PSAnXFxyXFxuJykge1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdcXG4nO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4T2YuY2FsbCgnXFx1MjAyOFxcdTIwMjknLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIENfTEIgPSAnXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOSc7XG5cbiAgICBDX1dTID0gJ1xcdCAnO1xuXG4gICAgQ19OVU1CRVJTID0gJzAxMjM0NTY3ODknO1xuXG4gICAgRVNDQVBFX1JFUExBQ0VNRU5UUyA9IHtcbiAgICAgICcwJzogJ1xceDAwJyxcbiAgICAgICdhJzogJ1xceDA3JyxcbiAgICAgICdiJzogJ1xceDA4JyxcbiAgICAgICd0JzogJ1xceDA5JyxcbiAgICAgICdcXHQnOiAnXFx4MDknLFxuICAgICAgJ24nOiAnXFx4MEEnLFxuICAgICAgJ3YnOiAnXFx4MEInLFxuICAgICAgJ2YnOiAnXFx4MEMnLFxuICAgICAgJ3InOiAnXFx4MEQnLFxuICAgICAgJ2UnOiAnXFx4MUInLFxuICAgICAgJyAnOiAnXFx4MjAnLFxuICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgJ04nOiAnXFx4ODUnLFxuICAgICAgJ18nOiAnXFx4QTAnLFxuICAgICAgJ0wnOiAnXFx1MjAyOCcsXG4gICAgICAnUCc6ICdcXHUyMDI5J1xuICAgIH07XG5cbiAgICBFU0NBUEVfQ09ERVMgPSB7XG4gICAgICAneCc6IDIsXG4gICAgICAndSc6IDQsXG4gICAgICAnVSc6IDhcbiAgICB9O1xuXG4gICAgY3RvciA9IFNjYW5uZXIucHJvdG90eXBlLmluaXRpYWxpc2U7XG5cbiAgICByZXR1cm4gU2Nhbm5lcjtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///265\n")},472:function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){eval("(function() {\n  var YAMLError, events, nodes, util;\n\n  events = __webpack_require__(63);\n\n  nodes = __webpack_require__(914);\n\n  util = __webpack_require__(823);\n\n  ({YAMLError} = __webpack_require__(372));\n\n  this.SerializerError = class SerializerError extends YAMLError {};\n\n  this.Serializer = (function() {\n    var ctor;\n\n    class Serializer {\n      constructor() {\n        return ctor.apply(this, arguments);\n      }\n\n      initialise({\n          encoding: encoding,\n          explicit_start: explicit_start,\n          explicit_end: explicit_end,\n          version: version,\n          tags: tags\n        } = {}) {\n        this.encoding = encoding;\n        this.explicit_start = explicit_start;\n        this.explicit_end = explicit_end;\n        this.version = version;\n        this.tags = tags;\n        this.serialized_nodes = {};\n        this.anchors = {};\n        this.last_anchor_id = 0;\n        return this.closed = null;\n      }\n\n      open() {\n        if (this.closed === null) {\n          this.emit(new events.StreamStartEvent(this.encoding));\n          return this.closed = false;\n        } else if (this.closed) {\n          throw new SerializerError('serializer is closed');\n        } else {\n          throw new SerializerError('serializer is already open');\n        }\n      }\n\n      close() {\n        if (this.closed === null) {\n          throw new SerializerError('serializer is not opened');\n        } else if (!this.closed) {\n          this.emit(new events.StreamEndEvent);\n          return this.closed = true;\n        }\n      }\n\n      serialize(node) {\n        if (this.closed === null) {\n          throw new SerializerError('serializer is not opened');\n        } else if (this.closed) {\n          throw new SerializerError('serializer is closed');\n        }\n        if (node != null) {\n          this.emit(new events.DocumentStartEvent(void 0, void 0, this.explicit_start, this.version, this.tags));\n          this.anchor_node(node);\n          this.serialize_node(node);\n          this.emit(new events.DocumentEndEvent(void 0, void 0, this.explicit_end));\n        }\n        this.serialized_nodes = {};\n        this.anchors = {};\n        return this.last_anchor_id = 0;\n      }\n\n      anchor_node(node) {\n        var base, i, item, j, key, len, len1, name, ref, ref1, results, results1, value;\n        if (node.unique_id in this.anchors) {\n          return (base = this.anchors)[name = node.unique_id] != null ? base[name] : base[name] = this.generate_anchor(node);\n        } else {\n          this.anchors[node.unique_id] = null;\n          if (node instanceof nodes.SequenceNode) {\n            ref = node.value;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              item = ref[i];\n              results.push(this.anchor_node(item));\n            }\n            return results;\n          } else if (node instanceof nodes.MappingNode) {\n            ref1 = node.value;\n            results1 = [];\n            for (j = 0, len1 = ref1.length; j < len1; j++) {\n              [key, value] = ref1[j];\n              this.anchor_node(key);\n              results1.push(this.anchor_node(value));\n            }\n            return results1;\n          }\n        }\n      }\n\n      generate_anchor(node) {\n        return `id${util.pad_left(++this.last_anchor_id, '0', 4)}`;\n      }\n\n      serialize_node(node, parent, index) {\n        var alias, default_tag, detected_tag, i, implicit, item, j, key, len, len1, ref, ref1, value;\n        alias = this.anchors[node.unique_id];\n        if (node.unique_id in this.serialized_nodes) {\n          return this.emit(new events.AliasEvent(alias));\n        } else {\n          this.serialized_nodes[node.unique_id] = true;\n          this.descend_resolver(parent, index);\n          if (node instanceof nodes.ScalarNode) {\n            detected_tag = this.resolve(nodes.ScalarNode, node.value, [true, false]);\n            default_tag = this.resolve(nodes.ScalarNode, node.value, [false, true]);\n            implicit = [node.tag === detected_tag, node.tag === default_tag];\n            this.emit(new events.ScalarEvent(alias, node.tag, implicit, node.value, void 0, void 0, node.style));\n          } else if (node instanceof nodes.SequenceNode) {\n            implicit = node.tag === this.resolve(nodes.SequenceNode, node.value, true);\n            this.emit(new events.SequenceStartEvent(alias, node.tag, implicit, void 0, void 0, node.flow_style));\n            ref = node.value;\n            for (index = i = 0, len = ref.length; i < len; index = ++i) {\n              item = ref[index];\n              this.serialize_node(item, node, index);\n            }\n            this.emit(new events.SequenceEndEvent);\n          } else if (node instanceof nodes.MappingNode) {\n            implicit = node.tag === this.resolve(nodes.MappingNode, node.value, true);\n            this.emit(new events.MappingStartEvent(alias, node.tag, implicit, void 0, void 0, node.flow_style));\n            ref1 = node.value;\n            for (j = 0, len1 = ref1.length; j < len1; j++) {\n              [key, value] = ref1[j];\n              this.serialize_node(key, node, null);\n              this.serialize_node(value, node, key);\n            }\n            this.emit(new events.MappingEndEvent);\n          }\n          return this.ascend_resolver();\n        }\n      }\n\n    };\n\n    ctor = Serializer.prototype.initialise;\n\n    return Serializer;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLEVBQVU7O0FBRTdCLFVBQVUsbUJBQU8sQ0FBQyxHQUFTOztBQUUzQixTQUFTLG1CQUFPLENBQUMsR0FBUTs7QUFFekIsSUFBSSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxHQUFVOztBQUVuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMveWFtbC1qcy9saWIvc2VyaWFsaXplci5qcz9lOWRhIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpIHtcbiAgdmFyIFlBTUxFcnJvciwgZXZlbnRzLCBub2RlcywgdXRpbDtcblxuICBldmVudHMgPSByZXF1aXJlKCcuL2V2ZW50cycpO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAoe1lBTUxFcnJvcn0gPSByZXF1aXJlKCcuL2Vycm9ycycpKTtcblxuICB0aGlzLlNlcmlhbGl6ZXJFcnJvciA9IGNsYXNzIFNlcmlhbGl6ZXJFcnJvciBleHRlbmRzIFlBTUxFcnJvciB7fTtcblxuICB0aGlzLlNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0b3I7XG5cbiAgICBjbGFzcyBTZXJpYWxpemVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICByZXR1cm4gY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsaXNlKHtcbiAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICAgICAgZXhwbGljaXRfc3RhcnQ6IGV4cGxpY2l0X3N0YXJ0LFxuICAgICAgICAgIGV4cGxpY2l0X2VuZDogZXhwbGljaXRfZW5kLFxuICAgICAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICAgICAgdGFnczogdGFnc1xuICAgICAgICB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLmV4cGxpY2l0X3N0YXJ0ID0gZXhwbGljaXRfc3RhcnQ7XG4gICAgICAgIHRoaXMuZXhwbGljaXRfZW5kID0gZXhwbGljaXRfZW5kO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZWRfbm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5hbmNob3JzID0ge307XG4gICAgICAgIHRoaXMubGFzdF9hbmNob3JfaWQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZWQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmVtaXQobmV3IGV2ZW50cy5TdHJlYW1TdGFydEV2ZW50KHRoaXMuZW5jb2RpbmcpKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTZXJpYWxpemVyRXJyb3IoJ3NlcmlhbGl6ZXIgaXMgY2xvc2VkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcmlhbGl6ZXJFcnJvcignc2VyaWFsaXplciBpcyBhbHJlYWR5IG9wZW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcmlhbGl6ZXJFcnJvcignc2VyaWFsaXplciBpcyBub3Qgb3BlbmVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KG5ldyBldmVudHMuU3RyZWFtRW5kRXZlbnQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VyaWFsaXplKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcmlhbGl6ZXJFcnJvcignc2VyaWFsaXplciBpcyBub3Qgb3BlbmVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU2VyaWFsaXplckVycm9yKCdzZXJpYWxpemVyIGlzIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmVtaXQobmV3IGV2ZW50cy5Eb2N1bWVudFN0YXJ0RXZlbnQodm9pZCAwLCB2b2lkIDAsIHRoaXMuZXhwbGljaXRfc3RhcnQsIHRoaXMudmVyc2lvbiwgdGhpcy50YWdzKSk7XG4gICAgICAgICAgdGhpcy5hbmNob3Jfbm9kZShub2RlKTtcbiAgICAgICAgICB0aGlzLnNlcmlhbGl6ZV9ub2RlKG5vZGUpO1xuICAgICAgICAgIHRoaXMuZW1pdChuZXcgZXZlbnRzLkRvY3VtZW50RW5kRXZlbnQodm9pZCAwLCB2b2lkIDAsIHRoaXMuZXhwbGljaXRfZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJpYWxpemVkX25vZGVzID0ge307XG4gICAgICAgIHRoaXMuYW5jaG9ycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0X2FuY2hvcl9pZCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGFuY2hvcl9ub2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIGJhc2UsIGksIGl0ZW0sIGosIGtleSwgbGVuLCBsZW4xLCBuYW1lLCByZWYsIHJlZjEsIHJlc3VsdHMsIHJlc3VsdHMxLCB2YWx1ZTtcbiAgICAgICAgaWYgKG5vZGUudW5pcXVlX2lkIGluIHRoaXMuYW5jaG9ycykge1xuICAgICAgICAgIHJldHVybiAoYmFzZSA9IHRoaXMuYW5jaG9ycylbbmFtZSA9IG5vZGUudW5pcXVlX2lkXSAhPSBudWxsID8gYmFzZVtuYW1lXSA6IGJhc2VbbmFtZV0gPSB0aGlzLmdlbmVyYXRlX2FuY2hvcihub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFuY2hvcnNbbm9kZS51bmlxdWVfaWRdID0gbnVsbDtcbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNlcXVlbmNlTm9kZSkge1xuICAgICAgICAgICAgcmVmID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICBpdGVtID0gcmVmW2ldO1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5hbmNob3Jfbm9kZShpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkge1xuICAgICAgICAgICAgcmVmMSA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICByZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICAgIFtrZXksIHZhbHVlXSA9IHJlZjFbal07XG4gICAgICAgICAgICAgIHRoaXMuYW5jaG9yX25vZGUoa2V5KTtcbiAgICAgICAgICAgICAgcmVzdWx0czEucHVzaCh0aGlzLmFuY2hvcl9ub2RlKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0czE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRlX2FuY2hvcihub2RlKSB7XG4gICAgICAgIHJldHVybiBgaWQke3V0aWwucGFkX2xlZnQoKyt0aGlzLmxhc3RfYW5jaG9yX2lkLCAnMCcsIDQpfWA7XG4gICAgICB9XG5cbiAgICAgIHNlcmlhbGl6ZV9ub2RlKG5vZGUsIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGFsaWFzLCBkZWZhdWx0X3RhZywgZGV0ZWN0ZWRfdGFnLCBpLCBpbXBsaWNpdCwgaXRlbSwgaiwga2V5LCBsZW4sIGxlbjEsIHJlZiwgcmVmMSwgdmFsdWU7XG4gICAgICAgIGFsaWFzID0gdGhpcy5hbmNob3JzW25vZGUudW5pcXVlX2lkXTtcbiAgICAgICAgaWYgKG5vZGUudW5pcXVlX2lkIGluIHRoaXMuc2VyaWFsaXplZF9ub2Rlcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQobmV3IGV2ZW50cy5BbGlhc0V2ZW50KGFsaWFzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXJpYWxpemVkX25vZGVzW25vZGUudW5pcXVlX2lkXSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5kZXNjZW5kX3Jlc29sdmVyKHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2NhbGFyTm9kZSkge1xuICAgICAgICAgICAgZGV0ZWN0ZWRfdGFnID0gdGhpcy5yZXNvbHZlKG5vZGVzLlNjYWxhck5vZGUsIG5vZGUudmFsdWUsIFt0cnVlLCBmYWxzZV0pO1xuICAgICAgICAgICAgZGVmYXVsdF90YWcgPSB0aGlzLnJlc29sdmUobm9kZXMuU2NhbGFyTm9kZSwgbm9kZS52YWx1ZSwgW2ZhbHNlLCB0cnVlXSk7XG4gICAgICAgICAgICBpbXBsaWNpdCA9IFtub2RlLnRhZyA9PT0gZGV0ZWN0ZWRfdGFnLCBub2RlLnRhZyA9PT0gZGVmYXVsdF90YWddO1xuICAgICAgICAgICAgdGhpcy5lbWl0KG5ldyBldmVudHMuU2NhbGFyRXZlbnQoYWxpYXMsIG5vZGUudGFnLCBpbXBsaWNpdCwgbm9kZS52YWx1ZSwgdm9pZCAwLCB2b2lkIDAsIG5vZGUuc3R5bGUpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5TZXF1ZW5jZU5vZGUpIHtcbiAgICAgICAgICAgIGltcGxpY2l0ID0gbm9kZS50YWcgPT09IHRoaXMucmVzb2x2ZShub2Rlcy5TZXF1ZW5jZU5vZGUsIG5vZGUudmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KG5ldyBldmVudHMuU2VxdWVuY2VTdGFydEV2ZW50KGFsaWFzLCBub2RlLnRhZywgaW1wbGljaXQsIHZvaWQgMCwgdm9pZCAwLCBub2RlLmZsb3dfc3R5bGUpKTtcbiAgICAgICAgICAgIHJlZiA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGluZGV4ID0gKytpKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSByZWZbaW5kZXhdO1xuICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZV9ub2RlKGl0ZW0sIG5vZGUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChuZXcgZXZlbnRzLlNlcXVlbmNlRW5kRXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgICAgICBpbXBsaWNpdCA9IG5vZGUudGFnID09PSB0aGlzLnJlc29sdmUobm9kZXMuTWFwcGluZ05vZGUsIG5vZGUudmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KG5ldyBldmVudHMuTWFwcGluZ1N0YXJ0RXZlbnQoYWxpYXMsIG5vZGUudGFnLCBpbXBsaWNpdCwgdm9pZCAwLCB2b2lkIDAsIG5vZGUuZmxvd19zdHlsZSkpO1xuICAgICAgICAgICAgcmVmMSA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICAgICAgW2tleSwgdmFsdWVdID0gcmVmMVtqXTtcbiAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVfbm9kZShrZXksIG5vZGUsIG51bGwpO1xuICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZV9ub2RlKHZhbHVlLCBub2RlLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KG5ldyBldmVudHMuTWFwcGluZ0VuZEV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXNjZW5kX3Jlc29sdmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBjdG9yID0gU2VyaWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGlzZTtcblxuICAgIHJldHVybiBTZXJpYWxpemVyO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///472\n")},902:function(){eval("(function() {\n  this.Token = class Token {\n    constructor(start_mark1, end_mark1) {\n      this.start_mark = start_mark1;\n      this.end_mark = end_mark1;\n    }\n\n  };\n\n  this.DirectiveToken = (function() {\n    class DirectiveToken extends this.Token {\n      constructor(name, value, start_mark, end_mark) {\n        super(start_mark, end_mark);\n        this.name = name;\n        this.value = value;\n      }\n\n    };\n\n    DirectiveToken.prototype.id = '<directive>';\n\n    return DirectiveToken;\n\n  }).call(this);\n\n  this.DocumentStartToken = (function() {\n    class DocumentStartToken extends this.Token {};\n\n    DocumentStartToken.prototype.id = '<document start>';\n\n    return DocumentStartToken;\n\n  }).call(this);\n\n  this.DocumentEndToken = (function() {\n    class DocumentEndToken extends this.Token {};\n\n    DocumentEndToken.prototype.id = '<document end>';\n\n    return DocumentEndToken;\n\n  }).call(this);\n\n  this.StreamStartToken = (function() {\n    class StreamStartToken extends this.Token {\n      constructor(start_mark, end_mark, encoding) {\n        super(start_mark, end_mark);\n        this.encoding = encoding;\n      }\n\n    };\n\n    StreamStartToken.prototype.id = '<stream start>';\n\n    return StreamStartToken;\n\n  }).call(this);\n\n  this.StreamEndToken = (function() {\n    class StreamEndToken extends this.Token {};\n\n    StreamEndToken.prototype.id = '<stream end>';\n\n    return StreamEndToken;\n\n  }).call(this);\n\n  this.BlockSequenceStartToken = (function() {\n    class BlockSequenceStartToken extends this.Token {};\n\n    BlockSequenceStartToken.prototype.id = '<block sequence start>';\n\n    return BlockSequenceStartToken;\n\n  }).call(this);\n\n  this.BlockMappingStartToken = (function() {\n    class BlockMappingStartToken extends this.Token {};\n\n    BlockMappingStartToken.prototype.id = '<block mapping end>';\n\n    return BlockMappingStartToken;\n\n  }).call(this);\n\n  this.BlockEndToken = (function() {\n    class BlockEndToken extends this.Token {};\n\n    BlockEndToken.prototype.id = '<block end>';\n\n    return BlockEndToken;\n\n  }).call(this);\n\n  this.FlowSequenceStartToken = (function() {\n    class FlowSequenceStartToken extends this.Token {};\n\n    FlowSequenceStartToken.prototype.id = '[';\n\n    return FlowSequenceStartToken;\n\n  }).call(this);\n\n  this.FlowMappingStartToken = (function() {\n    class FlowMappingStartToken extends this.Token {};\n\n    FlowMappingStartToken.prototype.id = '{';\n\n    return FlowMappingStartToken;\n\n  }).call(this);\n\n  this.FlowSequenceEndToken = (function() {\n    class FlowSequenceEndToken extends this.Token {};\n\n    FlowSequenceEndToken.prototype.id = ']';\n\n    return FlowSequenceEndToken;\n\n  }).call(this);\n\n  this.FlowMappingEndToken = (function() {\n    class FlowMappingEndToken extends this.Token {};\n\n    FlowMappingEndToken.prototype.id = '}';\n\n    return FlowMappingEndToken;\n\n  }).call(this);\n\n  this.KeyToken = (function() {\n    class KeyToken extends this.Token {};\n\n    KeyToken.prototype.id = '?';\n\n    return KeyToken;\n\n  }).call(this);\n\n  this.ValueToken = (function() {\n    class ValueToken extends this.Token {};\n\n    ValueToken.prototype.id = ':';\n\n    return ValueToken;\n\n  }).call(this);\n\n  this.BlockEntryToken = (function() {\n    class BlockEntryToken extends this.Token {};\n\n    BlockEntryToken.prototype.id = '-';\n\n    return BlockEntryToken;\n\n  }).call(this);\n\n  this.FlowEntryToken = (function() {\n    class FlowEntryToken extends this.Token {};\n\n    FlowEntryToken.prototype.id = ',';\n\n    return FlowEntryToken;\n\n  }).call(this);\n\n  this.AliasToken = (function() {\n    class AliasToken extends this.Token {\n      constructor(value, start_mark, end_mark) {\n        super(start_mark, end_mark);\n        this.value = value;\n      }\n\n    };\n\n    AliasToken.prototype.id = '<alias>';\n\n    return AliasToken;\n\n  }).call(this);\n\n  this.AnchorToken = (function() {\n    class AnchorToken extends this.Token {\n      constructor(value, start_mark, end_mark) {\n        super(start_mark, end_mark);\n        this.value = value;\n      }\n\n    };\n\n    AnchorToken.prototype.id = '<anchor>';\n\n    return AnchorToken;\n\n  }).call(this);\n\n  this.TagToken = (function() {\n    class TagToken extends this.Token {\n      constructor(value, start_mark, end_mark) {\n        super(start_mark, end_mark);\n        this.value = value;\n      }\n\n    };\n\n    TagToken.prototype.id = '<tag>';\n\n    return TagToken;\n\n  }).call(this);\n\n  this.ScalarToken = (function() {\n    class ScalarToken extends this.Token {\n      constructor(value, plain, start_mark, end_mark, style) {\n        super(start_mark, end_mark);\n        this.value = value;\n        this.plain = plain;\n        this.style = style;\n      }\n\n    };\n\n    ScalarToken.prototype.id = '<scalar>';\n\n    return ScalarToken;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwtanMvbGliL3Rva2Vucy5qcz9mMzkzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpIHtcbiAgdGhpcy5Ub2tlbiA9IGNsYXNzIFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydF9tYXJrMSwgZW5kX21hcmsxKSB7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrMTtcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyazE7XG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5EaXJlY3RpdmVUb2tlbiA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBEaXJlY3RpdmVUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge1xuICAgICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0X21hcmssIGVuZF9tYXJrKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIERpcmVjdGl2ZVRva2VuLnByb3RvdHlwZS5pZCA9ICc8ZGlyZWN0aXZlPic7XG5cbiAgICByZXR1cm4gRGlyZWN0aXZlVG9rZW47XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICB0aGlzLkRvY3VtZW50U3RhcnRUb2tlbiA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBEb2N1bWVudFN0YXJ0VG9rZW4gZXh0ZW5kcyB0aGlzLlRva2VuIHt9O1xuXG4gICAgRG9jdW1lbnRTdGFydFRva2VuLnByb3RvdHlwZS5pZCA9ICc8ZG9jdW1lbnQgc3RhcnQ+JztcblxuICAgIHJldHVybiBEb2N1bWVudFN0YXJ0VG9rZW47XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICB0aGlzLkRvY3VtZW50RW5kVG9rZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgRG9jdW1lbnRFbmRUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge307XG5cbiAgICBEb2N1bWVudEVuZFRva2VuLnByb3RvdHlwZS5pZCA9ICc8ZG9jdW1lbnQgZW5kPic7XG5cbiAgICByZXR1cm4gRG9jdW1lbnRFbmRUb2tlbjtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuU3RyZWFtU3RhcnRUb2tlbiA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBTdHJlYW1TdGFydFRva2VuIGV4dGVuZHMgdGhpcy5Ub2tlbiB7XG4gICAgICBjb25zdHJ1Y3RvcihzdGFydF9tYXJrLCBlbmRfbWFyaywgZW5jb2RpbmcpIHtcbiAgICAgICAgc3VwZXIoc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgU3RyZWFtU3RhcnRUb2tlbi5wcm90b3R5cGUuaWQgPSAnPHN0cmVhbSBzdGFydD4nO1xuXG4gICAgcmV0dXJuIFN0cmVhbVN0YXJ0VG9rZW47XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICB0aGlzLlN0cmVhbUVuZFRva2VuID0gKGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzIFN0cmVhbUVuZFRva2VuIGV4dGVuZHMgdGhpcy5Ub2tlbiB7fTtcblxuICAgIFN0cmVhbUVuZFRva2VuLnByb3RvdHlwZS5pZCA9ICc8c3RyZWFtIGVuZD4nO1xuXG4gICAgcmV0dXJuIFN0cmVhbUVuZFRva2VuO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5CbG9ja1NlcXVlbmNlU3RhcnRUb2tlbiA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBCbG9ja1NlcXVlbmNlU3RhcnRUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge307XG5cbiAgICBCbG9ja1NlcXVlbmNlU3RhcnRUb2tlbi5wcm90b3R5cGUuaWQgPSAnPGJsb2NrIHNlcXVlbmNlIHN0YXJ0Pic7XG5cbiAgICByZXR1cm4gQmxvY2tTZXF1ZW5jZVN0YXJ0VG9rZW47XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICB0aGlzLkJsb2NrTWFwcGluZ1N0YXJ0VG9rZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgQmxvY2tNYXBwaW5nU3RhcnRUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge307XG5cbiAgICBCbG9ja01hcHBpbmdTdGFydFRva2VuLnByb3RvdHlwZS5pZCA9ICc8YmxvY2sgbWFwcGluZyBlbmQ+JztcblxuICAgIHJldHVybiBCbG9ja01hcHBpbmdTdGFydFRva2VuO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5CbG9ja0VuZFRva2VuID0gKGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzIEJsb2NrRW5kVG9rZW4gZXh0ZW5kcyB0aGlzLlRva2VuIHt9O1xuXG4gICAgQmxvY2tFbmRUb2tlbi5wcm90b3R5cGUuaWQgPSAnPGJsb2NrIGVuZD4nO1xuXG4gICAgcmV0dXJuIEJsb2NrRW5kVG9rZW47XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICB0aGlzLkZsb3dTZXF1ZW5jZVN0YXJ0VG9rZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgRmxvd1NlcXVlbmNlU3RhcnRUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge307XG5cbiAgICBGbG93U2VxdWVuY2VTdGFydFRva2VuLnByb3RvdHlwZS5pZCA9ICdbJztcblxuICAgIHJldHVybiBGbG93U2VxdWVuY2VTdGFydFRva2VuO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5GbG93TWFwcGluZ1N0YXJ0VG9rZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgRmxvd01hcHBpbmdTdGFydFRva2VuIGV4dGVuZHMgdGhpcy5Ub2tlbiB7fTtcblxuICAgIEZsb3dNYXBwaW5nU3RhcnRUb2tlbi5wcm90b3R5cGUuaWQgPSAneyc7XG5cbiAgICByZXR1cm4gRmxvd01hcHBpbmdTdGFydFRva2VuO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5GbG93U2VxdWVuY2VFbmRUb2tlbiA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBGbG93U2VxdWVuY2VFbmRUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge307XG5cbiAgICBGbG93U2VxdWVuY2VFbmRUb2tlbi5wcm90b3R5cGUuaWQgPSAnXSc7XG5cbiAgICByZXR1cm4gRmxvd1NlcXVlbmNlRW5kVG9rZW47XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICB0aGlzLkZsb3dNYXBwaW5nRW5kVG9rZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgRmxvd01hcHBpbmdFbmRUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge307XG5cbiAgICBGbG93TWFwcGluZ0VuZFRva2VuLnByb3RvdHlwZS5pZCA9ICd9JztcblxuICAgIHJldHVybiBGbG93TWFwcGluZ0VuZFRva2VuO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5LZXlUb2tlbiA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBLZXlUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge307XG5cbiAgICBLZXlUb2tlbi5wcm90b3R5cGUuaWQgPSAnPyc7XG5cbiAgICByZXR1cm4gS2V5VG9rZW47XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICB0aGlzLlZhbHVlVG9rZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgVmFsdWVUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge307XG5cbiAgICBWYWx1ZVRva2VuLnByb3RvdHlwZS5pZCA9ICc6JztcblxuICAgIHJldHVybiBWYWx1ZVRva2VuO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5CbG9ja0VudHJ5VG9rZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgQmxvY2tFbnRyeVRva2VuIGV4dGVuZHMgdGhpcy5Ub2tlbiB7fTtcblxuICAgIEJsb2NrRW50cnlUb2tlbi5wcm90b3R5cGUuaWQgPSAnLSc7XG5cbiAgICByZXR1cm4gQmxvY2tFbnRyeVRva2VuO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5GbG93RW50cnlUb2tlbiA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBGbG93RW50cnlUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge307XG5cbiAgICBGbG93RW50cnlUb2tlbi5wcm90b3R5cGUuaWQgPSAnLCc7XG5cbiAgICByZXR1cm4gRmxvd0VudHJ5VG9rZW47XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICB0aGlzLkFsaWFzVG9rZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgQWxpYXNUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge1xuICAgICAgY29uc3RydWN0b3IodmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0X21hcmssIGVuZF9tYXJrKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIEFsaWFzVG9rZW4ucHJvdG90eXBlLmlkID0gJzxhbGlhcz4nO1xuXG4gICAgcmV0dXJuIEFsaWFzVG9rZW47XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICB0aGlzLkFuY2hvclRva2VuID0gKGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzIEFuY2hvclRva2VuIGV4dGVuZHMgdGhpcy5Ub2tlbiB7XG4gICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgICAgc3VwZXIoc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgQW5jaG9yVG9rZW4ucHJvdG90eXBlLmlkID0gJzxhbmNob3I+JztcblxuICAgIHJldHVybiBBbmNob3JUb2tlbjtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuVGFnVG9rZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgVGFnVG9rZW4gZXh0ZW5kcyB0aGlzLlRva2VuIHtcbiAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaykge1xuICAgICAgICBzdXBlcihzdGFydF9tYXJrLCBlbmRfbWFyayk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBUYWdUb2tlbi5wcm90b3R5cGUuaWQgPSAnPHRhZz4nO1xuXG4gICAgcmV0dXJuIFRhZ1Rva2VuO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5TY2FsYXJUb2tlbiA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBTY2FsYXJUb2tlbiBleHRlbmRzIHRoaXMuVG9rZW4ge1xuICAgICAgY29uc3RydWN0b3IodmFsdWUsIHBsYWluLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgc3R5bGUpIHtcbiAgICAgICAgc3VwZXIoc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMucGxhaW4gPSBwbGFpbjtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNjYWxhclRva2VuLnByb3RvdHlwZS5pZCA9ICc8c2NhbGFyPic7XG5cbiAgICByZXR1cm4gU2NhbGFyVG9rZW47XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///902\n")},823:function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){eval("(function() {\n  /*\n  A small class to stand-in for a stream when you simply want to write to a string.\n  */\n  var ref, ref1, ref2,\n    hasProp = {}.hasOwnProperty;\n\n  this.StringStream = class StringStream {\n    constructor() {\n      this.string = '';\n    }\n\n    write(chunk) {\n      return this.string += chunk;\n    }\n\n  };\n\n  this.clone = (obj) => {\n    return Object.assign({}, obj);\n  };\n\n  this.extend = function(destination, ...sources) {\n    var i, j, len, len1, name, ref, source;\n    for (i = 0, len = sources.length; i < len; i++) {\n      source = sources[i];\n      while (source !== Object.prototype) {\n        ref = Object.getOwnPropertyNames(source);\n        for (j = 0, len1 = ref.length; j < len1; j++) {\n          name = ref[j];\n          if (destination[name] == null) {\n            destination[name] = source[name];\n          }\n        }\n        source = Object.getPrototypeOf(source);\n      }\n    }\n    return destination;\n  };\n\n  this.is_empty = function(obj) {\n    var key;\n    if (Array.isArray(obj) || typeof obj === 'string') {\n      return obj.length === 0;\n    }\n    for (key in obj) {\n      if (!hasProp.call(obj, key)) continue;\n      return false;\n    }\n    return true;\n  };\n\n  this.inspect = (ref = (ref1 = (ref2 = __webpack_require__(539)) != null ? ref2.inspect : void 0) != null ? ref1 : __webpack_require__.g.inspect) != null ? ref : function(a) {\n    return `${a}`;\n  };\n\n  this.pad_left = function(str, char, length) {\n    str = String(str);\n    if (str.length >= length) {\n      return str;\n    } else if (str.length + 1 === length) {\n      return `${char}${str}`;\n    } else {\n      return `${new Array(length - str.length + 1).join(char)}${str}`;\n    }\n  };\n\n  this.to_hex = function(num) {\n    if (typeof num === 'string') {\n      num = num.charCodeAt(0);\n    }\n    return num.toString(16);\n  };\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsbUJBQU8sQ0FBQyxHQUFNLHFEQUFxRCxxQkFBTTtBQUNqSCxjQUFjLEVBQUU7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZ0JBQWdCLEtBQUssRUFBRSxJQUFJO0FBQzNCLE1BQU07QUFDTixnQkFBZ0IsOENBQThDLEVBQUUsSUFBSTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwtanMvbGliL3V0aWwuanM/ZGM1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIC8qXG4gIEEgc21hbGwgY2xhc3MgdG8gc3RhbmQtaW4gZm9yIGEgc3RyZWFtIHdoZW4geW91IHNpbXBseSB3YW50IHRvIHdyaXRlIHRvIGEgc3RyaW5nLlxuICAqL1xuICB2YXIgcmVmLCByZWYxLCByZWYyLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICB0aGlzLlN0cmluZ1N0cmVhbSA9IGNsYXNzIFN0cmluZ1N0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLnN0cmluZyA9ICcnO1xuICAgIH1cblxuICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmcgKz0gY2h1bms7XG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5jbG9uZSA9IChvYmopID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgfTtcblxuICB0aGlzLmV4dGVuZCA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCAuLi5zb3VyY2VzKSB7XG4gICAgdmFyIGksIGosIGxlbiwgbGVuMSwgbmFtZSwgcmVmLCBzb3VyY2U7XG4gICAgZm9yIChpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgIHdoaWxlIChzb3VyY2UgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgcmVmID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZi5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICBuYW1lID0gcmVmW2pdO1xuICAgICAgICAgIGlmIChkZXN0aW5hdGlvbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltuYW1lXSA9IHNvdXJjZVtuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgfTtcblxuICB0aGlzLmlzX2VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopIHx8IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoIWhhc1Byb3AuY2FsbChvYmosIGtleSkpIGNvbnRpbnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB0aGlzLmluc3BlY3QgPSAocmVmID0gKHJlZjEgPSAocmVmMiA9IHJlcXVpcmUoJ3V0aWwnKSkgIT0gbnVsbCA/IHJlZjIuaW5zcGVjdCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiBnbG9iYWwuaW5zcGVjdCkgIT0gbnVsbCA/IHJlZiA6IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gYCR7YX1gO1xuICB9O1xuXG4gIHRoaXMucGFkX2xlZnQgPSBmdW5jdGlvbihzdHIsIGNoYXIsIGxlbmd0aCkge1xuICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgIGlmIChzdHIubGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBgJHtjaGFyfSR7c3RyfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHtuZXcgQXJyYXkobGVuZ3RoIC0gc3RyLmxlbmd0aCArIDEpLmpvaW4oY2hhcil9JHtzdHJ9YDtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy50b19oZXggPSBmdW5jdGlvbihudW0pIHtcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG51bSA9IG51bS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICByZXR1cm4gbnVtLnRvU3RyaW5nKDE2KTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///823\n")},740:function(__unused_webpack_module,exports,__webpack_require__){eval("(function() {\n  var composer, constructor, dumper, errors, events, loader, nodes, parser, reader, resolver, scanner, tokens, util;\n\n  composer = this.composer = __webpack_require__(391);\n\n  constructor = this.constructor = __webpack_require__(574);\n\n  dumper = this.dumper = __webpack_require__(190);\n\n  errors = this.errors = __webpack_require__(372);\n\n  events = this.events = __webpack_require__(63);\n\n  loader = this.loader = __webpack_require__(696);\n\n  nodes = this.nodes = __webpack_require__(914);\n\n  parser = this.parser = __webpack_require__(806);\n\n  reader = this.reader = __webpack_require__(26);\n\n  resolver = this.resolver = __webpack_require__(579);\n\n  scanner = this.scanner = __webpack_require__(265);\n\n  tokens = this.tokens = __webpack_require__(902);\n\n  util = __webpack_require__(823);\n\n  /*\n  Scan a YAML stream and produce scanning tokens.\n  */\n  this.scan = function(stream, Loader = loader.Loader) {\n    var _loader, results;\n    _loader = new Loader(stream);\n    results = [];\n    while (_loader.check_token()) {\n      results.push(_loader.get_token());\n    }\n    return results;\n  };\n\n  /*\n  Parse a YAML stream and produce parsing events.\n  */\n  this.parse = function(stream, Loader = loader.Loader) {\n    var _loader, results;\n    _loader = new Loader(stream);\n    results = [];\n    while (_loader.check_event()) {\n      results.push(_loader.get_event());\n    }\n    return results;\n  };\n\n  /*\n  Parse the first YAML document in a stream and produce the corresponding\n  representation tree.\n  */\n  this.compose = function(stream, Loader = loader.Loader) {\n    var _loader;\n    _loader = new Loader(stream);\n    return _loader.get_single_node();\n  };\n\n  /*\n  Parse all YAML documents in a stream and produce corresponding representation\n  trees.\n  */\n  this.compose_all = function(stream, Loader = loader.Loader) {\n    var _loader, results;\n    _loader = new Loader(stream);\n    results = [];\n    while (_loader.check_node()) {\n      results.push(_loader.get_node());\n    }\n    return results;\n  };\n\n  /*\n  Parse the first YAML document in a stream and produce the corresponding\n  Javascript object.\n  */\n  this.load = function(stream, Loader = loader.Loader) {\n    var _loader;\n    _loader = new Loader(stream);\n    return _loader.get_single_data();\n  };\n\n  /*\n  Parse all YAML documents in a stream and produce the corresponing Javascript\n  object.\n  */\n  this.load_all = function(stream, Loader = loader.Loader) {\n    var _loader, results;\n    _loader = new Loader(stream);\n    results = [];\n    while (_loader.check_data()) {\n      results.push(_loader.get_data());\n    }\n    return results;\n  };\n\n  /*\n  Emit YAML parsing events into a stream.\n  If stream is falsey, return the produced string instead.\n  */\n  this.emit = function(events, stream, Dumper = dumper.Dumper, options = {}) {\n    var _dumper, dest, event, i, len;\n    dest = stream || new util.StringStream;\n    _dumper = new Dumper(dest, options);\n    try {\n      for (i = 0, len = events.length; i < len; i++) {\n        event = events[i];\n        _dumper.emit(event);\n      }\n    } finally {\n      _dumper.dispose();\n    }\n    return stream || dest.string;\n  };\n\n  /*\n  Serialize a representation tree into a YAML stream.\n  If stream is falsey, return the produced string instead.\n  */\n  this.serialize = function(node, stream, Dumper = dumper.Dumper, options = {}) {\n    return exports.serialize_all([node], stream, Dumper, options);\n  };\n\n  /*\n  Serialize a sequence of representation tress into a YAML stream.\n  If stream is falsey, return the produced string instead.\n  */\n  this.serialize_all = function(nodes, stream, Dumper = dumper.Dumper, options = {}) {\n    var _dumper, dest, i, len, node;\n    dest = stream || new util.StringStream;\n    _dumper = new Dumper(dest, options);\n    try {\n      _dumper.open();\n      for (i = 0, len = nodes.length; i < len; i++) {\n        node = nodes[i];\n        _dumper.serialize(node);\n      }\n      _dumper.close();\n    } finally {\n      _dumper.dispose();\n    }\n    return stream || dest.string;\n  };\n\n  /*\n  Serialize a Javascript object into a YAML stream.\n  If stream is falsey, return the produced string instead.\n  */\n  this.dump = function(data, stream, Dumper = dumper.Dumper, options = {}) {\n    return exports.dump_all([data], stream, Dumper, options);\n  };\n\n  /*\n  Serialize a sequence of Javascript objects into a YAML stream.\n  If stream is falsey, return the produced string instead.\n  */\n  this.dump_all = function(documents, stream, Dumper = dumper.Dumper, options = {}) {\n    var _dumper, dest, document, i, len;\n    dest = stream || new util.StringStream;\n    _dumper = new Dumper(dest, options);\n    try {\n      _dumper.open();\n      for (i = 0, len = documents.length; i < len; i++) {\n        document = documents[i];\n        _dumper.represent(document);\n      }\n      _dumper.close();\n    } finally {\n      _dumper.dispose();\n    }\n    return stream || dest.string;\n  };\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsNkJBQTZCLG1CQUFPLENBQUMsR0FBWTs7QUFFakQsbUNBQW1DLG1CQUFPLENBQUMsR0FBZTs7QUFFMUQseUJBQXlCLG1CQUFPLENBQUMsR0FBVTs7QUFFM0MseUJBQXlCLG1CQUFPLENBQUMsR0FBVTs7QUFFM0MseUJBQXlCLG1CQUFPLENBQUMsRUFBVTs7QUFFM0MseUJBQXlCLG1CQUFPLENBQUMsR0FBVTs7QUFFM0MsdUJBQXVCLG1CQUFPLENBQUMsR0FBUzs7QUFFeEMseUJBQXlCLG1CQUFPLENBQUMsR0FBVTs7QUFFM0MseUJBQXlCLG1CQUFPLENBQUMsRUFBVTs7QUFFM0MsNkJBQTZCLG1CQUFPLENBQUMsR0FBWTs7QUFFakQsMkJBQTJCLG1CQUFPLENBQUMsR0FBVzs7QUFFOUMseUJBQXlCLG1CQUFPLENBQUMsR0FBVTs7QUFFM0MsU0FBUyxtQkFBTyxDQUFDLEdBQVE7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwtanMvbGliL3lhbWwuanM/MTUxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIHZhciBjb21wb3NlciwgY29uc3RydWN0b3IsIGR1bXBlciwgZXJyb3JzLCBldmVudHMsIGxvYWRlciwgbm9kZXMsIHBhcnNlciwgcmVhZGVyLCByZXNvbHZlciwgc2Nhbm5lciwgdG9rZW5zLCB1dGlsO1xuXG4gIGNvbXBvc2VyID0gdGhpcy5jb21wb3NlciA9IHJlcXVpcmUoJy4vY29tcG9zZXInKTtcblxuICBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3IgPSByZXF1aXJlKCcuL2NvbnN0cnVjdG9yJyk7XG5cbiAgZHVtcGVyID0gdGhpcy5kdW1wZXIgPSByZXF1aXJlKCcuL2R1bXBlcicpO1xuXG4gIGVycm9ycyA9IHRoaXMuZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuICBldmVudHMgPSB0aGlzLmV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG5cbiAgbG9hZGVyID0gdGhpcy5sb2FkZXIgPSByZXF1aXJlKCcuL2xvYWRlcicpO1xuXG4gIG5vZGVzID0gdGhpcy5ub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICBwYXJzZXIgPSB0aGlzLnBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG5cbiAgcmVhZGVyID0gdGhpcy5yZWFkZXIgPSByZXF1aXJlKCcuL3JlYWRlcicpO1xuXG4gIHJlc29sdmVyID0gdGhpcy5yZXNvbHZlciA9IHJlcXVpcmUoJy4vcmVzb2x2ZXInKTtcblxuICBzY2FubmVyID0gdGhpcy5zY2FubmVyID0gcmVxdWlyZSgnLi9zY2FubmVyJyk7XG5cbiAgdG9rZW5zID0gdGhpcy50b2tlbnMgPSByZXF1aXJlKCcuL3Rva2VucycpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKlxuICBTY2FuIGEgWUFNTCBzdHJlYW0gYW5kIHByb2R1Y2Ugc2Nhbm5pbmcgdG9rZW5zLlxuICAqL1xuICB0aGlzLnNjYW4gPSBmdW5jdGlvbihzdHJlYW0sIExvYWRlciA9IGxvYWRlci5Mb2FkZXIpIHtcbiAgICB2YXIgX2xvYWRlciwgcmVzdWx0cztcbiAgICBfbG9hZGVyID0gbmV3IExvYWRlcihzdHJlYW0pO1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAoX2xvYWRlci5jaGVja190b2tlbigpKSB7XG4gICAgICByZXN1bHRzLnB1c2goX2xvYWRlci5nZXRfdG9rZW4oKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qXG4gIFBhcnNlIGEgWUFNTCBzdHJlYW0gYW5kIHByb2R1Y2UgcGFyc2luZyBldmVudHMuXG4gICovXG4gIHRoaXMucGFyc2UgPSBmdW5jdGlvbihzdHJlYW0sIExvYWRlciA9IGxvYWRlci5Mb2FkZXIpIHtcbiAgICB2YXIgX2xvYWRlciwgcmVzdWx0cztcbiAgICBfbG9hZGVyID0gbmV3IExvYWRlcihzdHJlYW0pO1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAoX2xvYWRlci5jaGVja19ldmVudCgpKSB7XG4gICAgICByZXN1bHRzLnB1c2goX2xvYWRlci5nZXRfZXZlbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qXG4gIFBhcnNlIHRoZSBmaXJzdCBZQU1MIGRvY3VtZW50IGluIGEgc3RyZWFtIGFuZCBwcm9kdWNlIHRoZSBjb3JyZXNwb25kaW5nXG4gIHJlcHJlc2VudGF0aW9uIHRyZWUuXG4gICovXG4gIHRoaXMuY29tcG9zZSA9IGZ1bmN0aW9uKHN0cmVhbSwgTG9hZGVyID0gbG9hZGVyLkxvYWRlcikge1xuICAgIHZhciBfbG9hZGVyO1xuICAgIF9sb2FkZXIgPSBuZXcgTG9hZGVyKHN0cmVhbSk7XG4gICAgcmV0dXJuIF9sb2FkZXIuZ2V0X3NpbmdsZV9ub2RlKCk7XG4gIH07XG5cbiAgLypcbiAgUGFyc2UgYWxsIFlBTUwgZG9jdW1lbnRzIGluIGEgc3RyZWFtIGFuZCBwcm9kdWNlIGNvcnJlc3BvbmRpbmcgcmVwcmVzZW50YXRpb25cbiAgdHJlZXMuXG4gICovXG4gIHRoaXMuY29tcG9zZV9hbGwgPSBmdW5jdGlvbihzdHJlYW0sIExvYWRlciA9IGxvYWRlci5Mb2FkZXIpIHtcbiAgICB2YXIgX2xvYWRlciwgcmVzdWx0cztcbiAgICBfbG9hZGVyID0gbmV3IExvYWRlcihzdHJlYW0pO1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAoX2xvYWRlci5jaGVja19ub2RlKCkpIHtcbiAgICAgIHJlc3VsdHMucHVzaChfbG9hZGVyLmdldF9ub2RlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvKlxuICBQYXJzZSB0aGUgZmlyc3QgWUFNTCBkb2N1bWVudCBpbiBhIHN0cmVhbSBhbmQgcHJvZHVjZSB0aGUgY29ycmVzcG9uZGluZ1xuICBKYXZhc2NyaXB0IG9iamVjdC5cbiAgKi9cbiAgdGhpcy5sb2FkID0gZnVuY3Rpb24oc3RyZWFtLCBMb2FkZXIgPSBsb2FkZXIuTG9hZGVyKSB7XG4gICAgdmFyIF9sb2FkZXI7XG4gICAgX2xvYWRlciA9IG5ldyBMb2FkZXIoc3RyZWFtKTtcbiAgICByZXR1cm4gX2xvYWRlci5nZXRfc2luZ2xlX2RhdGEoKTtcbiAgfTtcblxuICAvKlxuICBQYXJzZSBhbGwgWUFNTCBkb2N1bWVudHMgaW4gYSBzdHJlYW0gYW5kIHByb2R1Y2UgdGhlIGNvcnJlc3BvbmluZyBKYXZhc2NyaXB0XG4gIG9iamVjdC5cbiAgKi9cbiAgdGhpcy5sb2FkX2FsbCA9IGZ1bmN0aW9uKHN0cmVhbSwgTG9hZGVyID0gbG9hZGVyLkxvYWRlcikge1xuICAgIHZhciBfbG9hZGVyLCByZXN1bHRzO1xuICAgIF9sb2FkZXIgPSBuZXcgTG9hZGVyKHN0cmVhbSk7XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIHdoaWxlIChfbG9hZGVyLmNoZWNrX2RhdGEoKSkge1xuICAgICAgcmVzdWx0cy5wdXNoKF9sb2FkZXIuZ2V0X2RhdGEoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qXG4gIEVtaXQgWUFNTCBwYXJzaW5nIGV2ZW50cyBpbnRvIGEgc3RyZWFtLlxuICBJZiBzdHJlYW0gaXMgZmFsc2V5LCByZXR1cm4gdGhlIHByb2R1Y2VkIHN0cmluZyBpbnN0ZWFkLlxuICAqL1xuICB0aGlzLmVtaXQgPSBmdW5jdGlvbihldmVudHMsIHN0cmVhbSwgRHVtcGVyID0gZHVtcGVyLkR1bXBlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9kdW1wZXIsIGRlc3QsIGV2ZW50LCBpLCBsZW47XG4gICAgZGVzdCA9IHN0cmVhbSB8fCBuZXcgdXRpbC5TdHJpbmdTdHJlYW07XG4gICAgX2R1bXBlciA9IG5ldyBEdW1wZXIoZGVzdCwgb3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgICAgX2R1bXBlci5lbWl0KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2R1bXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW0gfHwgZGVzdC5zdHJpbmc7XG4gIH07XG5cbiAgLypcbiAgU2VyaWFsaXplIGEgcmVwcmVzZW50YXRpb24gdHJlZSBpbnRvIGEgWUFNTCBzdHJlYW0uXG4gIElmIHN0cmVhbSBpcyBmYWxzZXksIHJldHVybiB0aGUgcHJvZHVjZWQgc3RyaW5nIGluc3RlYWQuXG4gICovXG4gIHRoaXMuc2VyaWFsaXplID0gZnVuY3Rpb24obm9kZSwgc3RyZWFtLCBEdW1wZXIgPSBkdW1wZXIuRHVtcGVyLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5zZXJpYWxpemVfYWxsKFtub2RlXSwgc3RyZWFtLCBEdW1wZXIsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qXG4gIFNlcmlhbGl6ZSBhIHNlcXVlbmNlIG9mIHJlcHJlc2VudGF0aW9uIHRyZXNzIGludG8gYSBZQU1MIHN0cmVhbS5cbiAgSWYgc3RyZWFtIGlzIGZhbHNleSwgcmV0dXJuIHRoZSBwcm9kdWNlZCBzdHJpbmcgaW5zdGVhZC5cbiAgKi9cbiAgdGhpcy5zZXJpYWxpemVfYWxsID0gZnVuY3Rpb24obm9kZXMsIHN0cmVhbSwgRHVtcGVyID0gZHVtcGVyLkR1bXBlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9kdW1wZXIsIGRlc3QsIGksIGxlbiwgbm9kZTtcbiAgICBkZXN0ID0gc3RyZWFtIHx8IG5ldyB1dGlsLlN0cmluZ1N0cmVhbTtcbiAgICBfZHVtcGVyID0gbmV3IER1bXBlcihkZXN0LCBvcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgX2R1bXBlci5vcGVuKCk7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIF9kdW1wZXIuc2VyaWFsaXplKG5vZGUpO1xuICAgICAgfVxuICAgICAgX2R1bXBlci5jbG9zZSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfZHVtcGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmVhbSB8fCBkZXN0LnN0cmluZztcbiAgfTtcblxuICAvKlxuICBTZXJpYWxpemUgYSBKYXZhc2NyaXB0IG9iamVjdCBpbnRvIGEgWUFNTCBzdHJlYW0uXG4gIElmIHN0cmVhbSBpcyBmYWxzZXksIHJldHVybiB0aGUgcHJvZHVjZWQgc3RyaW5nIGluc3RlYWQuXG4gICovXG4gIHRoaXMuZHVtcCA9IGZ1bmN0aW9uKGRhdGEsIHN0cmVhbSwgRHVtcGVyID0gZHVtcGVyLkR1bXBlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZHVtcF9hbGwoW2RhdGFdLCBzdHJlYW0sIER1bXBlciwgb3B0aW9ucyk7XG4gIH07XG5cbiAgLypcbiAgU2VyaWFsaXplIGEgc2VxdWVuY2Ugb2YgSmF2YXNjcmlwdCBvYmplY3RzIGludG8gYSBZQU1MIHN0cmVhbS5cbiAgSWYgc3RyZWFtIGlzIGZhbHNleSwgcmV0dXJuIHRoZSBwcm9kdWNlZCBzdHJpbmcgaW5zdGVhZC5cbiAgKi9cbiAgdGhpcy5kdW1wX2FsbCA9IGZ1bmN0aW9uKGRvY3VtZW50cywgc3RyZWFtLCBEdW1wZXIgPSBkdW1wZXIuRHVtcGVyLCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2R1bXBlciwgZGVzdCwgZG9jdW1lbnQsIGksIGxlbjtcbiAgICBkZXN0ID0gc3RyZWFtIHx8IG5ldyB1dGlsLlN0cmluZ1N0cmVhbTtcbiAgICBfZHVtcGVyID0gbmV3IER1bXBlcihkZXN0LCBvcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgX2R1bXBlci5vcGVuKCk7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkb2N1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZG9jdW1lbnQgPSBkb2N1bWVudHNbaV07XG4gICAgICAgIF9kdW1wZXIucmVwcmVzZW50KGRvY3VtZW50KTtcbiAgICAgIH1cbiAgICAgIF9kdW1wZXIuY2xvc2UoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2R1bXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW0gfHwgZGVzdC5zdHJpbmc7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///740\n")},291:module=>{eval("\nclass TfTree extends THREE.Object3D {\n  constructor({ros, tfClient, rootObject, frames, scale, showArrows, showAxes, showNames}){\n    super()\n    this.ros = ros\n    this.tfClient = tfClient\n    this.rootObject = rootObject\n    this.axisScale = scale || 1.0\n    this.frames = frames  //! Map of frameName to frameEnabled\n\n    this.sceneNodes = {}\n\n    this.tfSub = new ROSLIB.Topic({\n      ros: this.ros,\n      name: '/tf',\n      messageType: 'tf/tfMessage'\n    })\n\n    this.tfStaticSub = new ROSLIB.Topic({\n      ros: this.ros,\n      name: '/tf_static',\n      messageType: 'tf2_msgs/TFMessage'\n    })\n\n    this.listenForFrames()\n  }\n\n  listenForFrames(){\n    this.tfSub.subscribe(this.handleTfMessage.bind(this))\n    this.tfStaticSub.subscribe(this.handleTfMessage.bind(this))\n    setTimeout(this.stopListeningForFrames.bind(this), 2000)\n  }\n\n  handleTfMessage(msg){\n    for(let transform of msg.transforms){\n\n      if(this.frames[transform.header.frame_id] === undefined){\n        this.frames[transform.header.frame_id] = true\n      }\n\n      if(this.frames[transform.child_frame_id] === undefined){\n        this.frames[transform.child_frame_id] = true\n      }\n    }\n\n  }\n\n  stopListeningForFrames(){\n    this.tfSub.unsubscribe()\n    this.tfStaticSub.unsubscribe()\n\n    this.subscribe()\n  }\n\n  //! Subscribe to needed Tf frames\n  subscribe(){\n\n    for(const [frame, enabled] of Object.entries(this.frames)){\n\n      if(enabled){\n        //console.log('adding', frame)\n        let axis = new ROS3D.Axes({\n          shaftRadius: 0.03,\n          headRadius: 0.075,\n          headLength: 0.3,\n          scale: this.axisScale,\n          lineType: 'full',\n          lineDashLength: 0.1\n        })\n\n        this.sceneNodes[frame] = new ROS3D.SceneNode({\n          frameID: frame,\n          tfClient: this.tfClient,\n          object: axis\n        })\n\n        this.rootObject.add(this.sceneNodes[frame])\n      }\n    }\n  }\n\n}\n\nmodule.exports=TfTree;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkxLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLGVBQWUsMEVBQTBFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vc3JjL1RmVHJlZS5qcz9lNzFmIl0sInNvdXJjZXNDb250ZW50IjpbIlxuY2xhc3MgVGZUcmVlIGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3Rvcih7cm9zLCB0ZkNsaWVudCwgcm9vdE9iamVjdCwgZnJhbWVzLCBzY2FsZSwgc2hvd0Fycm93cywgc2hvd0F4ZXMsIHNob3dOYW1lc30pe1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnJvcyA9IHJvc1xuICAgIHRoaXMudGZDbGllbnQgPSB0ZkNsaWVudFxuICAgIHRoaXMucm9vdE9iamVjdCA9IHJvb3RPYmplY3RcbiAgICB0aGlzLmF4aXNTY2FsZSA9IHNjYWxlIHx8IDEuMFxuICAgIHRoaXMuZnJhbWVzID0gZnJhbWVzICAvLyEgTWFwIG9mIGZyYW1lTmFtZSB0byBmcmFtZUVuYWJsZWRcblxuICAgIHRoaXMuc2NlbmVOb2RlcyA9IHt9XG5cbiAgICB0aGlzLnRmU3ViID0gbmV3IFJPU0xJQi5Ub3BpYyh7XG4gICAgICByb3M6IHRoaXMucm9zLFxuICAgICAgbmFtZTogJy90ZicsXG4gICAgICBtZXNzYWdlVHlwZTogJ3RmL3RmTWVzc2FnZSdcbiAgICB9KVxuXG4gICAgdGhpcy50ZlN0YXRpY1N1YiA9IG5ldyBST1NMSUIuVG9waWMoe1xuICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgIG5hbWU6ICcvdGZfc3RhdGljJyxcbiAgICAgIG1lc3NhZ2VUeXBlOiAndGYyX21zZ3MvVEZNZXNzYWdlJ1xuICAgIH0pXG5cbiAgICB0aGlzLmxpc3RlbkZvckZyYW1lcygpXG4gIH1cblxuICBsaXN0ZW5Gb3JGcmFtZXMoKXtcbiAgICB0aGlzLnRmU3ViLnN1YnNjcmliZSh0aGlzLmhhbmRsZVRmTWVzc2FnZS5iaW5kKHRoaXMpKVxuICAgIHRoaXMudGZTdGF0aWNTdWIuc3Vic2NyaWJlKHRoaXMuaGFuZGxlVGZNZXNzYWdlLmJpbmQodGhpcykpXG4gICAgc2V0VGltZW91dCh0aGlzLnN0b3BMaXN0ZW5pbmdGb3JGcmFtZXMuYmluZCh0aGlzKSwgMjAwMClcbiAgfVxuXG4gIGhhbmRsZVRmTWVzc2FnZShtc2cpe1xuICAgIGZvcihsZXQgdHJhbnNmb3JtIG9mIG1zZy50cmFuc2Zvcm1zKXtcblxuICAgICAgaWYodGhpcy5mcmFtZXNbdHJhbnNmb3JtLmhlYWRlci5mcmFtZV9pZF0gPT09IHVuZGVmaW5lZCl7XG4gICAgICAgIHRoaXMuZnJhbWVzW3RyYW5zZm9ybS5oZWFkZXIuZnJhbWVfaWRdID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZih0aGlzLmZyYW1lc1t0cmFuc2Zvcm0uY2hpbGRfZnJhbWVfaWRdID09PSB1bmRlZmluZWQpe1xuICAgICAgICB0aGlzLmZyYW1lc1t0cmFuc2Zvcm0uY2hpbGRfZnJhbWVfaWRdID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgc3RvcExpc3RlbmluZ0ZvckZyYW1lcygpe1xuICAgIHRoaXMudGZTdWIudW5zdWJzY3JpYmUoKVxuICAgIHRoaXMudGZTdGF0aWNTdWIudW5zdWJzY3JpYmUoKVxuXG4gICAgdGhpcy5zdWJzY3JpYmUoKVxuICB9XG5cbiAgLy8hIFN1YnNjcmliZSB0byBuZWVkZWQgVGYgZnJhbWVzXG4gIHN1YnNjcmliZSgpe1xuXG4gICAgZm9yKGNvbnN0IFtmcmFtZSwgZW5hYmxlZF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5mcmFtZXMpKXtcblxuICAgICAgaWYoZW5hYmxlZCl7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2FkZGluZycsIGZyYW1lKVxuICAgICAgICBsZXQgYXhpcyA9IG5ldyBST1MzRC5BeGVzKHtcbiAgICAgICAgICBzaGFmdFJhZGl1czogMC4wMyxcbiAgICAgICAgICBoZWFkUmFkaXVzOiAwLjA3NSxcbiAgICAgICAgICBoZWFkTGVuZ3RoOiAwLjMsXG4gICAgICAgICAgc2NhbGU6IHRoaXMuYXhpc1NjYWxlLFxuICAgICAgICAgIGxpbmVUeXBlOiAnZnVsbCcsXG4gICAgICAgICAgbGluZURhc2hMZW5ndGg6IDAuMVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuc2NlbmVOb2Rlc1tmcmFtZV0gPSBuZXcgUk9TM0QuU2NlbmVOb2RlKHtcbiAgICAgICAgICBmcmFtZUlEOiBmcmFtZSxcbiAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICBvYmplY3Q6IGF4aXNcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnJvb3RPYmplY3QuYWRkKHRoaXMuc2NlbmVOb2Rlc1tmcmFtZV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHM9VGZUcmVlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///291\n")},138:(module,__unused_webpack_exports,__webpack_require__)=>{eval("const debug = __webpack_require__(227)('teleop')\nconst reach = __webpack_require__(329)\nconst yaml = __webpack_require__(740)\nconst path = __webpack_require__(470)\n\nconst TfTree = __webpack_require__(291)\n\nclass TeleOp {\n  constructor(){\n    debug('new TeleOp')\n\n    this.ros = null\n    this.host = null\n    this.fileContent = null\n    this.divId = null\n    this.viewer = null\n    this.tfClient = null\n    this.baseLink = null\n  }\n\n  async connectRos(){\n    return new Promise((resolve,reject)=>{\n\n      // Connect to ROS.\n      this.ros = new ROSLIB.Ros({\n        url : this.host\n      });\n\n      this.ros.on('error', (error) => {\n        debug('Connection error ' + this.host)\n        debug(error)\n        reject(error)\n      });\n      // Find out exactly when we made a connection.\n      this.ros.on('connection', () => {\n        debug('Connection open ' + this.host)\n        resolve()\n      })\n    })\n  }\n\n  async start(host, rvizFile, divId=\"viewer\"){\n    debug('start')\n\n    this.host = host\n    this.divId = divId\n    this.fileContent = yaml.load(rvizFile)\n\n    debug('fileContent', this.fileContent)\n\n    await this.connectRos()\n\n    let globalOptions = {\n      background: TeleOp.rvizColor2hex(reach(this.fileContent, 'Visualization Manager.Global Options.Background Color'), null),\n      fixedFrame: reach(this.fileContent, 'Visualization Manager.Global Options.Fixed Frame', '/base_link'),\n      frameRate: reach(this.fileContent, 'Visualization Manager.Global Options.Frame Rate', 30)\n    }\n\n    this.viewer = new ROS3D.Viewer({\n      divID: this.divId,\n      width: window.innerWidth,\n      height: window.innerHeight-70,\n      antialias: true,\n      background: globalOptions.background\n    });\n\n    window.onresize = (e)=>{this.onResize(e)}\n\n    /*this.viewer.addObject(new ROS3D.Grid({\n      color:'#0181c4',\n      cellSize: 1.0,\n      num_cells: 20\n    }));*/\n\n\n    console.log('Globals', { globalOptions })\n\n\n\n    this.tfClient = new ROSLIB.TFClient({\n      ros: this.ros,\n      serverName: `/tf2_web_republisher`,   //! Need to make configurable and autodetect correct one on the fly\n      angularThres: 0.03,\n      transThres: 0.01,\n      //rate: globalOptions.frameRate,\n      fixedFrame: globalOptions.fixedFrame\n    })\n\n    let displays = reach(this.fileContent, 'Visualization Manager.Displays', [])\n\n    for(let display of displays){\n      debug(`parsing display '${display.Class}'`, { display })\n\n      if(!display.Enabled){\n        debug(` not enabled`)\n        continue\n      }\n\n      let obj = undefined;\n      switch (display.Class) {\n        case 'rviz/Grid':\n          debug('display.color', display.Color)\n          obj=new ROS3D.Grid({\n            color: TeleOp.rvizColor2hex(display.Color, '#ff1010'),\n            cellSize: display['Cell Size'],\n            num_cells: display['Plane Cell Count']\n          })\n          this.viewer.addObject(obj)\n          break\n        case 'rviz/TF':\n          console.log(display)\n          const allEnabled = display.Frames['All Enabled'] || false\n\n          const frames = Object.fromEntries(\n            Object.entries(display.Frames)\n            .map(([key,value])=> {\n              return [key, allEnabled || value.Value && true]\n            })\n            .filter(([key, value]) => key != 'All Enabled')\n          )\n          \n          console.log('frames', frames)\n          obj = new TfTree({\n            frames,\n            ros: this.ros,\n            tfClient: this.tfClient,\n            rootObject: this.viewer.scene,\n            scale: display['Marker Scale'],\n            showAxes: display['Show Axes'],\n            showNames: display['Show Names'],\n            showArrows: display['Show Arrows']\n          })\n          break;\n        case 'rviz/LaserScan':\n         console.warn(display.Class, 'support is in development and untested')\n          obj = new ROS3D.LaserScan({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            tfClient: this.tfClient,\n            color: display.color, // need to check if this is in the right format\n            // texture: , // (optional) Image url for a texture to use for the points. Defaults to a single white pixel.\n            rootObject: this.viewer.scene,\n            material: {\n              size: display['Size (Pixels)'], // (optional) defaults to 0.05\n            },\n            max_pts: 50000 // (optional) defaults to 100\n          })\n          break\n        case 'rviz/PointCloud2':\n          obj = new ROS3D.PointCloud2({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            max_pts: 50000,\n            //colorsrc: display[\"Color Transformer\"],\n            material: { \n              size: 0.02\n            }\n          })\n\n          console.log('pt', display[\"Color Transformer\"])\n          break\n        case 'rviz/Marker':\n          obj = new ROS3D.MarkerClient({\n            ros: this.ros,\n            topic: `${display['Marker Topic']}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient\n          })\n          break\n        case 'rviz/MarkerArray':\n          obj = new ROS3D.MarkerArrayClient({\n            ros: this.ros,\n            topic: `${display['Marker Topic']}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient\n          })\n          break\n        case 'rviz/Map':\n          obj = new ROS3D.OccupancyGridClient({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            continuous: true\n          })\n          break\n        case 'rviz/Odometry':\n          debug(display.Class)\n          obj = new ROS3D.Odometry({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            keep: display.Keep,\n            length: reach(display, 'Shape.Axes Length'),\n            headlength: reach(display, 'Shape.Head Length'),\n            shaftLength: reach(display, 'Shape.Shaft Length'),\n            headDiameter: reach(display, 'Shape.Head Radius')*2.0,\n            shaftDiameter: reach(display, 'Shape.Shaft Radius')*2.0,\n            color: TeleOp.rvizColor2hex(reach(display,'Shape.Color'), '#cc00ff')\n          })\n          break\n        case 'rviz/Path':\n          debug(display.Class)\n          obj = new ROS3D.Path({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            color: TeleOp.rvizColor2hex(display.Color, '#cc00ff')\n          })\n          break\n        case 'rviz/RobotModel':\n          debug(display.Class)\n          console.log(display)\n\n          let paramPath = path.join('/', display['Robot Description'])\n\n          console.log(paramPath)\n\n          const urdfText = await new Promise((resolve,reject)=>{\n            let descParam = new ROSLIB.Param({\n              ros: this.ros, name: paramPath\n            })\n\n            descParam.get(val=>{ resolve(val) })\n          })\n\n          console.log('urdf', urdfText)\n\n          let publicModelPath = ''\n          if(urdfText.length > 0){\n            let parser = new DOMParser()\n            let xmlDoc = parser.parseFromString(urdfText, 'text/xml')\n\n            const robotTag = xmlDoc.getElementsByTagName('robot')[0]\n            const robotName = robotTag.getAttribute('name')\n            console.log('urdf robot name', robotName, robotName.indexOf('magni'))\n            if(robotName.indexOf('magni') != -1){\n              publicModelPath = 'https://raw.githubusercontent.com/UbiquityRobotics/magni_robot/noetic-devel'\n            }\n          }\n          \n\n          try{\n            obj = new ROS3D.UrdfClient({\n              path: publicModelPath,\n              ros: this.ros,\n              param: paramPath,\n              rootObject: this.viewer.scene,\n              tfClient: this.tfClient,\n              tfPrefix: display['TF Prefix']\n            })\n          }\n          catch(err){\n            console.log('urdf error', err)\n            //delete obj\n            obj = null\n          }\n          \n\n          console.log(obj)\n          break\n        default:\n          console.warn(`display class '${display.Class}' not supported`)\n          console.warn(display)\n          break\n      }\n\n      if (obj) {\n        debug(obj)\n      }\n    }\n\n  }\n\n  onResize(event) {\n    debug('resize')\n\n    this.viewer.resize(event.target.innerWidth, event.target.innerHeight-70)\n  }\n\n  disableViz() {\n    /** @todo */\n    debug('disable viz - not implemented')\n  }\n\n\n  static rvizColor2hex(color, defaultHex) {\n    if (!color) { return defaultHex }\n    return TeleOp.rgb2hex(color.replace(/;/g, ','))\n  }\n  \n  static rgb2hex(rgb) {\n    rgb = rgb.match(/[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n    return (rgb && rgb.length === 4) ? \"#\" +\n      (\"0\" + parseInt(rgb[1], 10).toString(16)).slice(-2) +\n      (\"0\" + parseInt(rgb[2], 10).toString(16)).slice(-2) +\n      (\"0\" + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';\n  }\n}\n\nmodule.exports=TeleOp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxHQUFPO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxHQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxHQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxHQUFNOztBQUUzQixlQUFlLG1CQUFPLENBQUMsR0FBVTs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7O0FBR1IsNkJBQTZCLGVBQWU7Ozs7QUFJNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsZ0NBQWdDLGNBQWMsTUFBTSxTQUFTOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViLGlDQUFpQyxjQUFjO0FBQy9DLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esa0JBQWtCO0FBQ2xCLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgndGVsZW9wJylcbmNvbnN0IHJlYWNoID0gcmVxdWlyZSgnLi9yZWFjaCcpXG5jb25zdCB5YW1sID0gcmVxdWlyZSgneWFtbC1qcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IFRmVHJlZSA9IHJlcXVpcmUoJy4vVGZUcmVlJylcblxuY2xhc3MgVGVsZU9wIHtcbiAgY29uc3RydWN0b3IoKXtcbiAgICBkZWJ1ZygnbmV3IFRlbGVPcCcpXG5cbiAgICB0aGlzLnJvcyA9IG51bGxcbiAgICB0aGlzLmhvc3QgPSBudWxsXG4gICAgdGhpcy5maWxlQ29udGVudCA9IG51bGxcbiAgICB0aGlzLmRpdklkID0gbnVsbFxuICAgIHRoaXMudmlld2VyID0gbnVsbFxuICAgIHRoaXMudGZDbGllbnQgPSBudWxsXG4gICAgdGhpcy5iYXNlTGluayA9IG51bGxcbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3RSb3MoKXtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e1xuXG4gICAgICAvLyBDb25uZWN0IHRvIFJPUy5cbiAgICAgIHRoaXMucm9zID0gbmV3IFJPU0xJQi5Sb3Moe1xuICAgICAgICB1cmwgOiB0aGlzLmhvc3RcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnJvcy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgZGVidWcoJ0Nvbm5lY3Rpb24gZXJyb3IgJyArIHRoaXMuaG9zdClcbiAgICAgICAgZGVidWcoZXJyb3IpXG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0pO1xuICAgICAgLy8gRmluZCBvdXQgZXhhY3RseSB3aGVuIHdlIG1hZGUgYSBjb25uZWN0aW9uLlxuICAgICAgdGhpcy5yb3Mub24oJ2Nvbm5lY3Rpb24nLCAoKSA9PiB7XG4gICAgICAgIGRlYnVnKCdDb25uZWN0aW9uIG9wZW4gJyArIHRoaXMuaG9zdClcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBzdGFydChob3N0LCBydml6RmlsZSwgZGl2SWQ9XCJ2aWV3ZXJcIil7XG4gICAgZGVidWcoJ3N0YXJ0JylcblxuICAgIHRoaXMuaG9zdCA9IGhvc3RcbiAgICB0aGlzLmRpdklkID0gZGl2SWRcbiAgICB0aGlzLmZpbGVDb250ZW50ID0geWFtbC5sb2FkKHJ2aXpGaWxlKVxuXG4gICAgZGVidWcoJ2ZpbGVDb250ZW50JywgdGhpcy5maWxlQ29udGVudClcblxuICAgIGF3YWl0IHRoaXMuY29ubmVjdFJvcygpXG5cbiAgICBsZXQgZ2xvYmFsT3B0aW9ucyA9IHtcbiAgICAgIGJhY2tncm91bmQ6IFRlbGVPcC5ydml6Q29sb3IyaGV4KHJlYWNoKHRoaXMuZmlsZUNvbnRlbnQsICdWaXN1YWxpemF0aW9uIE1hbmFnZXIuR2xvYmFsIE9wdGlvbnMuQmFja2dyb3VuZCBDb2xvcicpLCBudWxsKSxcbiAgICAgIGZpeGVkRnJhbWU6IHJlYWNoKHRoaXMuZmlsZUNvbnRlbnQsICdWaXN1YWxpemF0aW9uIE1hbmFnZXIuR2xvYmFsIE9wdGlvbnMuRml4ZWQgRnJhbWUnLCAnL2Jhc2VfbGluaycpLFxuICAgICAgZnJhbWVSYXRlOiByZWFjaCh0aGlzLmZpbGVDb250ZW50LCAnVmlzdWFsaXphdGlvbiBNYW5hZ2VyLkdsb2JhbCBPcHRpb25zLkZyYW1lIFJhdGUnLCAzMClcbiAgICB9XG5cbiAgICB0aGlzLnZpZXdlciA9IG5ldyBST1MzRC5WaWV3ZXIoe1xuICAgICAgZGl2SUQ6IHRoaXMuZGl2SWQsXG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodC03MCxcbiAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgIGJhY2tncm91bmQ6IGdsb2JhbE9wdGlvbnMuYmFja2dyb3VuZFxuICAgIH0pO1xuXG4gICAgd2luZG93Lm9ucmVzaXplID0gKGUpPT57dGhpcy5vblJlc2l6ZShlKX1cblxuICAgIC8qdGhpcy52aWV3ZXIuYWRkT2JqZWN0KG5ldyBST1MzRC5HcmlkKHtcbiAgICAgIGNvbG9yOicjMDE4MWM0JyxcbiAgICAgIGNlbGxTaXplOiAxLjAsXG4gICAgICBudW1fY2VsbHM6IDIwXG4gICAgfSkpOyovXG5cblxuICAgIGNvbnNvbGUubG9nKCdHbG9iYWxzJywgeyBnbG9iYWxPcHRpb25zIH0pXG5cblxuXG4gICAgdGhpcy50ZkNsaWVudCA9IG5ldyBST1NMSUIuVEZDbGllbnQoe1xuICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgIHNlcnZlck5hbWU6IGAvdGYyX3dlYl9yZXB1Ymxpc2hlcmAsICAgLy8hIE5lZWQgdG8gbWFrZSBjb25maWd1cmFibGUgYW5kIGF1dG9kZXRlY3QgY29ycmVjdCBvbmUgb24gdGhlIGZseVxuICAgICAgYW5ndWxhclRocmVzOiAwLjAzLFxuICAgICAgdHJhbnNUaHJlczogMC4wMSxcbiAgICAgIC8vcmF0ZTogZ2xvYmFsT3B0aW9ucy5mcmFtZVJhdGUsXG4gICAgICBmaXhlZEZyYW1lOiBnbG9iYWxPcHRpb25zLmZpeGVkRnJhbWVcbiAgICB9KVxuXG4gICAgbGV0IGRpc3BsYXlzID0gcmVhY2godGhpcy5maWxlQ29udGVudCwgJ1Zpc3VhbGl6YXRpb24gTWFuYWdlci5EaXNwbGF5cycsIFtdKVxuXG4gICAgZm9yKGxldCBkaXNwbGF5IG9mIGRpc3BsYXlzKXtcbiAgICAgIGRlYnVnKGBwYXJzaW5nIGRpc3BsYXkgJyR7ZGlzcGxheS5DbGFzc30nYCwgeyBkaXNwbGF5IH0pXG5cbiAgICAgIGlmKCFkaXNwbGF5LkVuYWJsZWQpe1xuICAgICAgICBkZWJ1ZyhgIG5vdCBlbmFibGVkYClcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgbGV0IG9iaiA9IHVuZGVmaW5lZDtcbiAgICAgIHN3aXRjaCAoZGlzcGxheS5DbGFzcykge1xuICAgICAgICBjYXNlICdydml6L0dyaWQnOlxuICAgICAgICAgIGRlYnVnKCdkaXNwbGF5LmNvbG9yJywgZGlzcGxheS5Db2xvcilcbiAgICAgICAgICBvYmo9bmV3IFJPUzNELkdyaWQoe1xuICAgICAgICAgICAgY29sb3I6IFRlbGVPcC5ydml6Q29sb3IyaGV4KGRpc3BsYXkuQ29sb3IsICcjZmYxMDEwJyksXG4gICAgICAgICAgICBjZWxsU2l6ZTogZGlzcGxheVsnQ2VsbCBTaXplJ10sXG4gICAgICAgICAgICBudW1fY2VsbHM6IGRpc3BsYXlbJ1BsYW5lIENlbGwgQ291bnQnXVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy52aWV3ZXIuYWRkT2JqZWN0KG9iailcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdydml6L1RGJzpcbiAgICAgICAgICBjb25zb2xlLmxvZyhkaXNwbGF5KVxuICAgICAgICAgIGNvbnN0IGFsbEVuYWJsZWQgPSBkaXNwbGF5LkZyYW1lc1snQWxsIEVuYWJsZWQnXSB8fCBmYWxzZVxuXG4gICAgICAgICAgY29uc3QgZnJhbWVzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGlzcGxheS5GcmFtZXMpXG4gICAgICAgICAgICAubWFwKChba2V5LHZhbHVlXSk9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBba2V5LCBhbGxFbmFibGVkIHx8IHZhbHVlLlZhbHVlICYmIHRydWVdXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiBrZXkgIT0gJ0FsbCBFbmFibGVkJylcbiAgICAgICAgICApXG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coJ2ZyYW1lcycsIGZyYW1lcylcbiAgICAgICAgICBvYmogPSBuZXcgVGZUcmVlKHtcbiAgICAgICAgICAgIGZyYW1lcyxcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgIHJvb3RPYmplY3Q6IHRoaXMudmlld2VyLnNjZW5lLFxuICAgICAgICAgICAgc2NhbGU6IGRpc3BsYXlbJ01hcmtlciBTY2FsZSddLFxuICAgICAgICAgICAgc2hvd0F4ZXM6IGRpc3BsYXlbJ1Nob3cgQXhlcyddLFxuICAgICAgICAgICAgc2hvd05hbWVzOiBkaXNwbGF5WydTaG93IE5hbWVzJ10sXG4gICAgICAgICAgICBzaG93QXJyb3dzOiBkaXNwbGF5WydTaG93IEFycm93cyddXG4gICAgICAgICAgfSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncnZpei9MYXNlclNjYW4nOlxuICAgICAgICAgY29uc29sZS53YXJuKGRpc3BsYXkuQ2xhc3MsICdzdXBwb3J0IGlzIGluIGRldmVsb3BtZW50IGFuZCB1bnRlc3RlZCcpXG4gICAgICAgICAgb2JqID0gbmV3IFJPUzNELkxhc2VyU2Nhbih7XG4gICAgICAgICAgICByb3M6IHRoaXMucm9zLFxuICAgICAgICAgICAgdG9waWM6IGAke2Rpc3BsYXkuVG9waWN9YCxcbiAgICAgICAgICAgIHRmQ2xpZW50OiB0aGlzLnRmQ2xpZW50LFxuICAgICAgICAgICAgY29sb3I6IGRpc3BsYXkuY29sb3IsIC8vIG5lZWQgdG8gY2hlY2sgaWYgdGhpcyBpcyBpbiB0aGUgcmlnaHQgZm9ybWF0XG4gICAgICAgICAgICAvLyB0ZXh0dXJlOiAsIC8vIChvcHRpb25hbCkgSW1hZ2UgdXJsIGZvciBhIHRleHR1cmUgdG8gdXNlIGZvciB0aGUgcG9pbnRzLiBEZWZhdWx0cyB0byBhIHNpbmdsZSB3aGl0ZSBwaXhlbC5cbiAgICAgICAgICAgIHJvb3RPYmplY3Q6IHRoaXMudmlld2VyLnNjZW5lLFxuICAgICAgICAgICAgbWF0ZXJpYWw6IHtcbiAgICAgICAgICAgICAgc2l6ZTogZGlzcGxheVsnU2l6ZSAoUGl4ZWxzKSddLCAvLyAob3B0aW9uYWwpIGRlZmF1bHRzIHRvIDAuMDVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhfcHRzOiA1MDAwMCAvLyAob3B0aW9uYWwpIGRlZmF1bHRzIHRvIDEwMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncnZpei9Qb2ludENsb3VkMic6XG4gICAgICAgICAgb2JqID0gbmV3IFJPUzNELlBvaW50Q2xvdWQyKHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0b3BpYzogYCR7ZGlzcGxheS5Ub3BpY31gLFxuICAgICAgICAgICAgcm9vdE9iamVjdDogdGhpcy52aWV3ZXIuc2NlbmUsXG4gICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgIG1heF9wdHM6IDUwMDAwLFxuICAgICAgICAgICAgLy9jb2xvcnNyYzogZGlzcGxheVtcIkNvbG9yIFRyYW5zZm9ybWVyXCJdLFxuICAgICAgICAgICAgbWF0ZXJpYWw6IHsgXG4gICAgICAgICAgICAgIHNpemU6IDAuMDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ3B0JywgZGlzcGxheVtcIkNvbG9yIFRyYW5zZm9ybWVyXCJdKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3J2aXovTWFya2VyJzpcbiAgICAgICAgICBvYmogPSBuZXcgUk9TM0QuTWFya2VyQ2xpZW50KHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0b3BpYzogYCR7ZGlzcGxheVsnTWFya2VyIFRvcGljJ119YCxcbiAgICAgICAgICAgIHJvb3RPYmplY3Q6IHRoaXMudmlld2VyLnNjZW5lLFxuICAgICAgICAgICAgdGZDbGllbnQ6IHRoaXMudGZDbGllbnRcbiAgICAgICAgICB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3J2aXovTWFya2VyQXJyYXknOlxuICAgICAgICAgIG9iaiA9IG5ldyBST1MzRC5NYXJrZXJBcnJheUNsaWVudCh7XG4gICAgICAgICAgICByb3M6IHRoaXMucm9zLFxuICAgICAgICAgICAgdG9waWM6IGAke2Rpc3BsYXlbJ01hcmtlciBUb3BpYyddfWAsXG4gICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zY2VuZSxcbiAgICAgICAgICAgIHRmQ2xpZW50OiB0aGlzLnRmQ2xpZW50XG4gICAgICAgICAgfSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdydml6L01hcCc6XG4gICAgICAgICAgb2JqID0gbmV3IFJPUzNELk9jY3VwYW5jeUdyaWRDbGllbnQoe1xuICAgICAgICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgICAgICAgIHRvcGljOiBgJHtkaXNwbGF5LlRvcGljfWAsXG4gICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zY2VuZSxcbiAgICAgICAgICAgIHRmQ2xpZW50OiB0aGlzLnRmQ2xpZW50LFxuICAgICAgICAgICAgY29udGludW91czogdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncnZpei9PZG9tZXRyeSc6XG4gICAgICAgICAgZGVidWcoZGlzcGxheS5DbGFzcylcbiAgICAgICAgICBvYmogPSBuZXcgUk9TM0QuT2RvbWV0cnkoe1xuICAgICAgICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgICAgICAgIHRvcGljOiBgJHtkaXNwbGF5LlRvcGljfWAsXG4gICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zY2VuZSxcbiAgICAgICAgICAgIHRmQ2xpZW50OiB0aGlzLnRmQ2xpZW50LFxuICAgICAgICAgICAga2VlcDogZGlzcGxheS5LZWVwLFxuICAgICAgICAgICAgbGVuZ3RoOiByZWFjaChkaXNwbGF5LCAnU2hhcGUuQXhlcyBMZW5ndGgnKSxcbiAgICAgICAgICAgIGhlYWRsZW5ndGg6IHJlYWNoKGRpc3BsYXksICdTaGFwZS5IZWFkIExlbmd0aCcpLFxuICAgICAgICAgICAgc2hhZnRMZW5ndGg6IHJlYWNoKGRpc3BsYXksICdTaGFwZS5TaGFmdCBMZW5ndGgnKSxcbiAgICAgICAgICAgIGhlYWREaWFtZXRlcjogcmVhY2goZGlzcGxheSwgJ1NoYXBlLkhlYWQgUmFkaXVzJykqMi4wLFxuICAgICAgICAgICAgc2hhZnREaWFtZXRlcjogcmVhY2goZGlzcGxheSwgJ1NoYXBlLlNoYWZ0IFJhZGl1cycpKjIuMCxcbiAgICAgICAgICAgIGNvbG9yOiBUZWxlT3AucnZpekNvbG9yMmhleChyZWFjaChkaXNwbGF5LCdTaGFwZS5Db2xvcicpLCAnI2NjMDBmZicpXG4gICAgICAgICAgfSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdydml6L1BhdGgnOlxuICAgICAgICAgIGRlYnVnKGRpc3BsYXkuQ2xhc3MpXG4gICAgICAgICAgb2JqID0gbmV3IFJPUzNELlBhdGgoe1xuICAgICAgICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgICAgICAgIHRvcGljOiBgJHtkaXNwbGF5LlRvcGljfWAsXG4gICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zY2VuZSxcbiAgICAgICAgICAgIHRmQ2xpZW50OiB0aGlzLnRmQ2xpZW50LFxuICAgICAgICAgICAgY29sb3I6IFRlbGVPcC5ydml6Q29sb3IyaGV4KGRpc3BsYXkuQ29sb3IsICcjY2MwMGZmJylcbiAgICAgICAgICB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3J2aXovUm9ib3RNb2RlbCc6XG4gICAgICAgICAgZGVidWcoZGlzcGxheS5DbGFzcylcbiAgICAgICAgICBjb25zb2xlLmxvZyhkaXNwbGF5KVxuXG4gICAgICAgICAgbGV0IHBhcmFtUGF0aCA9IHBhdGguam9pbignLycsIGRpc3BsYXlbJ1JvYm90IERlc2NyaXB0aW9uJ10pXG5cbiAgICAgICAgICBjb25zb2xlLmxvZyhwYXJhbVBhdGgpXG5cbiAgICAgICAgICBjb25zdCB1cmRmVGV4dCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntcbiAgICAgICAgICAgIGxldCBkZXNjUGFyYW0gPSBuZXcgUk9TTElCLlBhcmFtKHtcbiAgICAgICAgICAgICAgcm9zOiB0aGlzLnJvcywgbmFtZTogcGFyYW1QYXRoXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBkZXNjUGFyYW0uZ2V0KHZhbD0+eyByZXNvbHZlKHZhbCkgfSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ3VyZGYnLCB1cmRmVGV4dClcblxuICAgICAgICAgIGxldCBwdWJsaWNNb2RlbFBhdGggPSAnJ1xuICAgICAgICAgIGlmKHVyZGZUZXh0Lmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgbGV0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKVxuICAgICAgICAgICAgbGV0IHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodXJkZlRleHQsICd0ZXh0L3htbCcpXG5cbiAgICAgICAgICAgIGNvbnN0IHJvYm90VGFnID0geG1sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdyb2JvdCcpWzBdXG4gICAgICAgICAgICBjb25zdCByb2JvdE5hbWUgPSByb2JvdFRhZy5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3VyZGYgcm9ib3QgbmFtZScsIHJvYm90TmFtZSwgcm9ib3ROYW1lLmluZGV4T2YoJ21hZ25pJykpXG4gICAgICAgICAgICBpZihyb2JvdE5hbWUuaW5kZXhPZignbWFnbmknKSAhPSAtMSl7XG4gICAgICAgICAgICAgIHB1YmxpY01vZGVsUGF0aCA9ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vVWJpcXVpdHlSb2JvdGljcy9tYWduaV9yb2JvdC9ub2V0aWMtZGV2ZWwnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuXG4gICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgb2JqID0gbmV3IFJPUzNELlVyZGZDbGllbnQoe1xuICAgICAgICAgICAgICBwYXRoOiBwdWJsaWNNb2RlbFBhdGgsXG4gICAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICAgIHBhcmFtOiBwYXJhbVBhdGgsXG4gICAgICAgICAgICAgIHJvb3RPYmplY3Q6IHRoaXMudmlld2VyLnNjZW5lLFxuICAgICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgICAgdGZQcmVmaXg6IGRpc3BsYXlbJ1RGIFByZWZpeCddXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaChlcnIpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3VyZGYgZXJyb3InLCBlcnIpXG4gICAgICAgICAgICAvL2RlbGV0ZSBvYmpcbiAgICAgICAgICAgIG9iaiA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgXG5cbiAgICAgICAgICBjb25zb2xlLmxvZyhvYmopXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLndhcm4oYGRpc3BsYXkgY2xhc3MgJyR7ZGlzcGxheS5DbGFzc30nIG5vdCBzdXBwb3J0ZWRgKVxuICAgICAgICAgIGNvbnNvbGUud2FybihkaXNwbGF5KVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGlmIChvYmopIHtcbiAgICAgICAgZGVidWcob2JqKVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgb25SZXNpemUoZXZlbnQpIHtcbiAgICBkZWJ1ZygncmVzaXplJylcblxuICAgIHRoaXMudmlld2VyLnJlc2l6ZShldmVudC50YXJnZXQuaW5uZXJXaWR0aCwgZXZlbnQudGFyZ2V0LmlubmVySGVpZ2h0LTcwKVxuICB9XG5cbiAgZGlzYWJsZVZpeigpIHtcbiAgICAvKiogQHRvZG8gKi9cbiAgICBkZWJ1ZygnZGlzYWJsZSB2aXogLSBub3QgaW1wbGVtZW50ZWQnKVxuICB9XG5cblxuICBzdGF0aWMgcnZpekNvbG9yMmhleChjb2xvciwgZGVmYXVsdEhleCkge1xuICAgIGlmICghY29sb3IpIHsgcmV0dXJuIGRlZmF1bHRIZXggfVxuICAgIHJldHVybiBUZWxlT3AucmdiMmhleChjb2xvci5yZXBsYWNlKC87L2csICcsJykpXG4gIH1cbiAgXG4gIHN0YXRpYyByZ2IyaGV4KHJnYikge1xuICAgIHJnYiA9IHJnYi5tYXRjaCgvW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8vaSk7XG4gICAgcmV0dXJuIChyZ2IgJiYgcmdiLmxlbmd0aCA9PT0gNCkgPyBcIiNcIiArXG4gICAgICAoXCIwXCIgKyBwYXJzZUludChyZ2JbMV0sIDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKSArXG4gICAgICAoXCIwXCIgKyBwYXJzZUludChyZ2JbMl0sIDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKSArXG4gICAgICAoXCIwXCIgKyBwYXJzZUludChyZ2JbM10sIDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKSA6ICcnO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzPVRlbGVPcDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///138\n")},329:module=>{eval("module.exports = function(obj, path, defaultVal){\n  var tokens = path.split('.')\n  var val = obj;\n\n  try{\n    for(var i=0; i<tokens.length; i++){\n      val = val[tokens[i]]\n    }\n\n    if(val == undefined){ val = defaultVal }\n  }\n  catch(excp){\n    val = (defaultVal != undefined) ? defaultVal : null\n  }\n\n  return val;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL3NyYy9yZWFjaC5qcz83ZjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBwYXRoLCBkZWZhdWx0VmFsKXtcbiAgdmFyIHRva2VucyA9IHBhdGguc3BsaXQoJy4nKVxuICB2YXIgdmFsID0gb2JqO1xuXG4gIHRyeXtcbiAgICBmb3IodmFyIGk9MDsgaTx0b2tlbnMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFsID0gdmFsW3Rva2Vuc1tpXV1cbiAgICB9XG5cbiAgICBpZih2YWwgPT0gdW5kZWZpbmVkKXsgdmFsID0gZGVmYXVsdFZhbCB9XG4gIH1cbiAgY2F0Y2goZXhjcCl7XG4gICAgdmFsID0gKGRlZmF1bHRWYWwgIT0gdW5kZWZpbmVkKSA/IGRlZmF1bHRWYWwgOiBudWxsXG4gIH1cblxuICByZXR1cm4gdmFsO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///329\n")},83:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLHFCQUFNOztBQUVsRDtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcz8wN2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///83\n")},882:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar GetIntrinsic = __webpack_require__(210);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODgyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLEdBQWU7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmpzPzE4NTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///882\n")}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var n=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g].call(n.exports,n,n.exports,__webpack_require__),n.exports}__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(g){if("object"==typeof window)return window}}();var __webpack_exports__=__webpack_require__(138);teleopxyz=__webpack_exports__})();