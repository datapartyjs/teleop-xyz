/*! For license information please see teleopxyz.js.LICENSE.txt */
var teleopxyz;(()=>{var __webpack_modules__={"./node_modules/debug/src/browser.js":(module,exports,__webpack_require__)=>{"use strict";eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFelU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/MzRlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cblxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblxuXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fCAvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xufVxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICBhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7IC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluZGV4Kys7XG5cbiAgICBpZiAobWF0Y2ggPT09ICclYycpIHtcbiAgICAgIC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAodHlwZW9mIGNvbnNvbGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb25zb2xlKSkgPT09ICdvYmplY3QnICYmIGNvbnNvbGUubG9nICYmIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG5cbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fSAvLyBTd2FsbG93XG4gIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cblxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgLy8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuICAgIC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG4gIH1cbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/debug/src/browser.js\n")},"./node_modules/debug/src/common.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsc0NBQUk7QUFDckM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWEsZUFBZTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEUsYUFBYTtBQUN2RjtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0NBQWtDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanM/ZGM5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcbiAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuICB9KTtcbiAgLyoqXG4gICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuICAvKipcbiAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAvKipcbiAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICpcbiAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAvKipcbiAgKiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG4gIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG4gIC8qKlxuICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgdmFyIHByZXZUaW1lO1xuXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICAvLyBEaXNhYmxlZD9cbiAgICAgIGlmICghZGVidWcuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IGRlYnVnOyAvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXG4gICAgICB2YXIgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcbiAgICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICBzZWxmLmRpZmYgPSBtcztcbiAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgIHByZXZUaW1lID0gY3VycjtcbiAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgfSAvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTsgLy8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXG4gICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTsgLy8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblxuICAgICAgY3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuICAgICAgdmFyIGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG4gICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDsgLy8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgLy8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gICpcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIENvZXJjZSBgdmFsYC5cbiAgKlxuICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAqIEByZXR1cm4ge01peGVkfVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gIHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/debug/src/common.js\n")},"./node_modules/gamepad.js/gamepad.js":function(module){eval('!function(t,e){ true?module.exports=e():0}(this,(function(){return(()=>{var t={944:function(t){t.exports=(()=>{"use strict";var t={d:(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};function n(t){return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function r(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!n){if(Array.isArray(t)||(n=i(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var r=0,o=function(){};return{s:o,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,u=!0,s=!1;return{s:function(){n=n.call(t)},n:function(){var t=n.next();return u=t.done,t},e:function(t){s=!0,a=t},f:function(){try{u||null==n.return||n.return()}finally{if(s)throw a}}}}function o(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=t&&("undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"]);if(null!=n){var r,o,i=[],a=!0,u=!1;try{for(n=n.call(t);!(a=(r=n.next()).done)&&(i.push(r.value),!e||i.length!==e);a=!0);}catch(t){u=!0,o=t}finally{try{a||null==n.return||n.return()}finally{if(u)throw o}}return i}}(t,e)||i(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function i(t,e){if(t){if("string"==typeof t)return a(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?a(t,e):void 0}}function a(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function u(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}t.d(e,{default:()=>s});var s=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];u(this,t),this.allowExtra=e,this.defaults=new Map,this.types=new Map,this.optional=new Set,this.required=new Set}var e;return(e=[{key:"setDefaults",value:function(t){var e=this;return Object.entries(t).forEach((function(t){var n=o(t,2),r=n[0],i=n[1];return e.defaults.set(r,i)})),this}},{key:"setTypes",value:function(t){var e=this;return Object.entries(t).forEach((function(t){var n=o(t,2),r=n[0],i=n[1];return e.types.set(r,i)})),this}},{key:"setOptional",value:function(t){var e=this;return t.forEach((function(t){return e.optional.add(t)})),this}},{key:"setRequired",value:function(t){var e=this;return t.forEach((function(t){return e.required.add(t)})),this}},{key:"resolve",value:function(t){var e=Object.assign(this.getDefaults(),t);return this.validate(e),e}},{key:"getDefaults",value:function(){var t,e={},n=r(this.defaults);try{for(n.s();!(t=n.n()).done;){var i=o(t.value,2),a=i[0],u=i[1];e[a]=u}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"validate",value:function(t){for(var e in t){if(!this.optionExists(e))throw new Error(\'Unkown option "\'.concat(e,\'".\'));this.checkType(e,t[e])}var n,o=r(this.required.values());try{for(o.s();!(n=o.n()).done;){var i=n.value;if(void 0===t[i])throw new Error(\'Option "\'.concat(i,\'" is required.\'))}}catch(t){o.e(t)}finally{o.f()}}},{key:"checkType",value:function(t,e){if(this.types.has(t)){var r=this.types.get(t),o=n(e);if(o!==r)throw new Error(\'Wrong value for option "\'.concat(t,\'". Expected type "\').concat(r,\'" but got "\').concat(o,\'".\'))}}},{key:"optionExists",value:function(t){return!!this.allowExtra||this.defaults.has(t)||this.optional.has(t)||this.required.has(t)||this.types.has(t)}}])&&function(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}(t.prototype,e),t}();return e.default})()},162:function(t){t.exports=(()=>{"use strict";var t={d:(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{default:()=>n});var n=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this._events={},this.on=this.addEventListener,this.off=this.removeEventListener}var e;return(e=[{key:"emit",value:function(t,e){if(Object.prototype.hasOwnProperty.call(this._events,t))for(var n=this._events[t],r={type:t,detail:e},o=n.length,i=0;i<o;i++)this.handle(n[i],r)}},{key:"handle",value:function(t,e){t(e)}},{key:"addEventListener",value:function(t,e){Object.prototype.hasOwnProperty.call(this._events,t)||(this._events[t]=[]),this._events[t].indexOf(e)<0&&this._events[t].push(e)}},{key:"removeEventListener",value:function(t,e){if(Object.prototype.hasOwnProperty.call(this._events,t)){var n=this._events[t],r=n.indexOf(e);r>=0&&n.splice(r,1),0===n.length&&delete this._events[t]}}}])&&function(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}(t.prototype,e),t}();return e.default})()}},e={};function n(r){var o=e[r];if(void 0!==o)return o.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};return(()=>{"use strict";n.r(r),n.d(r,{GamepadHandler:()=>d,GamepadListener:()=>x});var t=n(162),e=n.n(t),o=n(944),i=n.n(o);function a(t){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function u(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function c(t,e){return(c=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function l(t,e){return!e||"object"!==a(e)&&"function"!=typeof e?f(t):e}function f(t){if(void 0===t)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return t}function p(t){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var d=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&c(t,e)}(d,t);var e,n,r,o,i,a=(o=d,i=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=p(o);if(i){var n=p(this).constructor;t=Reflect.construct(e,arguments,n)}else t=e.apply(this,arguments);return l(this,t)});function d(t,e){var n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return u(this,d),(n=a.call(this)).index=t,n.options=n.constructor.resolveOptions(r),n.sticks=new Array(e.axes.length/2).fill(null).map((function(){return[null,null]})),n.buttons=new Array(e.buttons.length).fill(null),n.updateStick=n.updateStick.bind(f(n)),n.updateButton=n.updateButton.bind(f(n)),n}return e=d,r=[{key:"resolveOptions",value:function(t){var e=void 0!==t.stick,n=void 0!==t.button,r={stick:this.optionResolver.resolve(e?t.stick:n?{}:t),button:this.optionResolver.resolve(n?t.button:e?{}:t)};return r.stick.deadZone=Math.max(Math.min(r.stick.deadZone,1),0),r.button.deadZone=Math.max(Math.min(r.button.deadZone,1),0),r.stick.precision=r.stick.precision?Math.pow(10,r.stick.precision):0,r.button.precision=r.button.precision?Math.pow(10,r.button.precision):0,r}}],(n=[{key:"update",value:function(t){for(var e=0,n=this.sticks.length,r=0;r<n;r++)for(var o=0;o<2;o++)this.updateStick(t,r,o,t.axes[e++]);var i=this.buttons.length;for(e=0;e<i;e++)this.updateButton(t,t.buttons[e],e)}},{key:"updateStick",value:function(t,e,n,r){var o=this.options.stick,i=o.deadZone,a=o.analog,u=o.precision;i&&r<i&&r>-i&&(r=0),a?u&&(r=Math.round(r*u)/u):r=r>0?1:r<0?-1:0,this.sticks[e][n]!==r&&(this.sticks[e][n]=r,this.emit("axis",{gamepad:t,stick:e,axis:n,value:r,index:this.index}))}},{key:"updateButton",value:function(t,e,n){var r=this.options.button,o=r.deadZone,i=r.analog,a=r.precision,u=e.value,s=e.pressed,c=u;o&&e.value<o&&e.value>-o&&(c=0),i?a&&(c=Math.round(c*a)/a):c=s?1:0,this.buttons[n]!==c&&(this.buttons[n]=c,this.emit("button",{gamepad:t,button:n,pressed:s,value:c,index:this.index}))}}])&&s(e.prototype,n),r&&s(e,r),d}(e());function h(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}d.optionResolver=(new(i())).setDefaults({analog:!0,deadZone:0,precision:0}).setTypes({analog:"boolean",deadZone:"number",precision:"number"});var y=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.callback=e,this.frame=null,this.update=this.update.bind(this)}var e,n;return e=t,(n=[{key:"setCallback",value:function(t){this.callback=t}},{key:"start",value:function(){this.frame||(this.frame=window.requestAnimationFrame(this.update))}},{key:"stop",value:function(){this.frame&&(window.cancelAnimationFrame(this.frame),this.frame=null)}},{key:"update",value:function(){this.frame=window.requestAnimationFrame(this.update),this.callback()}}])&&h(e.prototype,n),t}();function v(t){return(v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function b(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function m(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function g(t,e){return(g=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function w(t,e){return!e||"object"!==v(e)&&"function"!=typeof e?k(t):e}function k(t){if(void 0===t)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return t}function O(t){return(O=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var x=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&g(t,e)}(a,t);var e,n,r,o,i=(r=a,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=O(r);if(o){var n=O(this).constructor;t=Reflect.construct(e,arguments,n)}else t=e.apply(this,arguments);return w(this,t)});function a(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(b(this,a),t=i.call(this),"function"!=typeof navigator.getGamepads)throw new Error("This browser does not support gamepad API.");return t.options=e,t.onAxis=t.onAxis.bind(k(t)),t.update=t.update.bind(k(t)),t.start=t.start.bind(k(t)),t.stop=t.stop.bind(k(t)),t.discover=t.discover.bind(k(t)),t.onButton=t.onButton.bind(k(t)),t.handlers=new Array(4).fill(null),t.loop=new y(t.update),window.addEventListener("error",t.stop),t}return e=a,(n=[{key:"start",value:function(){this.loop.start()}},{key:"stop",value:function(){this.loop.stop()}},{key:"update",value:function(){var t=navigator.getGamepads();this.discover(t[0],0),this.discover(t[1],1),this.discover(t[2],2),this.discover(t[3],3)}},{key:"discover",value:function(t,e){t?(this.handlers[e]||this.registerHandler(e,t),this.handlers[e].update(t)):this.handlers[e]&&this.removeGamepad(e)}},{key:"registerHandler",value:function(t,e){if(this.handlers[t])throw new Error("Gamepad #".concat(t," is already registered."));var n=new d(t,e,this.options);this.handlers[t]=n,n.addEventListener("axis",this.onAxis),n.addEventListener("button",this.onButton),this.emit("gamepad:connected",{index:t,gamepad:e}),this.emit("gamepad:".concat(t,":connected"),{index:t,gamepad:e})}},{key:"removeGamepad",value:function(t){if(!this.handlers[t])throw new Error("Gamepad #".concat(t," is not registered."));this.handlers[t].removeEventListener("axis",this.onAxis),this.handlers[t].removeEventListener("button",this.onButton),this.handlers[t]=null,this.emit("gamepad:disconnected",{index:t}),this.emit("gamepad:".concat(t,":disconnected"),{index:t})}},{key:"onAxis",value:function(t){var e=t.detail.index;this.emit("gamepad:axis",t.detail),this.emit("gamepad:".concat(e,":axis"),t.detail),this.emit("gamepad:".concat(e,":axis:").concat(t.detail.axis),t.detail)}},{key:"onButton",value:function(t){var e=t.detail.index;this.emit("gamepad:button",t.detail),this.emit("gamepad:".concat(e,":button"),t.detail),this.emit("gamepad:".concat(e,":button:").concat(t.detail.button),t.detail)}}])&&m(e.prototype,n),a}(e())})(),r})()}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2FtZXBhZC5qcy9nYW1lcGFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsS0FBaUQsb0JBQW9CLENBQTZHLENBQUMsa0JBQWtCLFlBQVksT0FBTyxnQkFBZ0IsZ0JBQWdCLGFBQWEsT0FBTyxVQUFVLCtEQUErRCx1QkFBdUIsRUFBRSxvREFBb0QsTUFBTSxjQUFjLGlGQUFpRixnQkFBZ0IsYUFBYSxvR0FBb0csS0FBSyxnQkFBZ0Isc0VBQXNFLE9BQU8sZ0VBQWdFLFNBQVMsdUJBQXVCLE9BQU8saUJBQWlCLG9CQUFvQixRQUFRLEVBQUUsc0JBQXNCLGVBQWUsUUFBUSxNQUFNLDZKQUE2SixnQkFBZ0IsT0FBTyxhQUFhLFlBQVksY0FBYyxlQUFlLGtCQUFrQixlQUFlLFNBQVMsY0FBYyxJQUFJLDhCQUE4QixRQUFRLGdCQUFnQixnQkFBZ0IsbUJBQW1CLDZCQUE2QixtQkFBbUIsMkVBQTJFLFlBQVksdUJBQXVCLElBQUksZ0JBQWdCLDJEQUEyRCxPQUFPLFNBQVMsU0FBUyxRQUFRLElBQUksOEJBQThCLFFBQVEsY0FBYyxVQUFVLDBCQUEwQixpS0FBaUssR0FBRyxnQkFBZ0IsTUFBTSxvQ0FBb0Msb0RBQW9ELGdMQUFnTCxnQkFBZ0Isb0NBQW9DLDJCQUEyQixJQUFJLGNBQWMsU0FBUyxnQkFBZ0IsOEVBQThFLE9BQU8sY0FBYyxFQUFFLGlCQUFpQixhQUFhLDhEQUE4RCxpSEFBaUgsTUFBTSxXQUFXLG9DQUFvQyxXQUFXLDhDQUE4QywyQkFBMkIsMkJBQTJCLFNBQVMsRUFBRSxpQ0FBaUMsV0FBVyw4Q0FBOEMsMkJBQTJCLHdCQUF3QixTQUFTLEVBQUUsb0NBQW9DLFdBQVcsOEJBQThCLHlCQUF5QixTQUFTLEVBQUUsb0NBQW9DLFdBQVcsOEJBQThCLHlCQUF5QixTQUFTLEVBQUUsZ0NBQWdDLDBDQUEwQywyQkFBMkIsRUFBRSxtQ0FBbUMsVUFBVSxvQkFBb0IsSUFBSSxVQUFVLGdCQUFnQixFQUFFLGlDQUFpQyxRQUFRLFNB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QkFBa0IsRUFBRSw4QkFBOEIsOEJBQThCLHlGQUF5RixFQUFFLG1DQUFtQyxvSEFBb0gsRUFBRSwwQ0FBMEMscUZBQXFGLDhCQUE4QixvSUFBb0ksa0JBQWtCLCtDQUErQyxrQkFBa0IsR0FBRyxFQUFFLHNDQUFzQyxrRkFBa0YsOEtBQThLLFFBQVEsa0RBQWtELFFBQVEsR0FBRyxFQUFFLCtCQUErQixxQkFBcUIsNkpBQTZKLEVBQUUsaUNBQWlDLHFCQUFxQixxS0FBcUssdUJBQXVCLE1BQU0sTUFBTSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL2dhbWVwYWQuanMvZ2FtZXBhZC5qcz9jY2M0Il0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuZ2FtZXBhZD1lKCk6dC5nYW1lcGFkPWUoKX0odGhpcywoZnVuY3Rpb24oKXtyZXR1cm4oKCk9Pnt2YXIgdD17OTQ0OmZ1bmN0aW9uKHQpe3QuZXhwb3J0cz0oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17ZDooZSxuKT0+e2Zvcih2YXIgciBpbiBuKXQubyhuLHIpJiYhdC5vKGUscikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0Om5bcl19KX0sbzoodCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSl9LGU9e307ZnVuY3Rpb24gbih0KXtyZXR1cm4obj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9ZnVuY3Rpb24gcih0LGUpe3ZhciBuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJnRbU3ltYm9sLml0ZXJhdG9yXXx8dFtcIkBAaXRlcmF0b3JcIl07aWYoIW4pe2lmKEFycmF5LmlzQXJyYXkodCl8fChuPWkodCkpfHxlJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe24mJih0PW4pO3ZhciByPTAsbz1mdW5jdGlvbigpe307cmV0dXJue3M6byxuOmZ1bmN0aW9uKCl7cmV0dXJuIHI+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W3IrK119fSxlOmZ1bmN0aW9uKHQpe3Rocm93IHR9LGY6b319dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciBhLHU9ITAscz0hMTtyZXR1cm57czpmdW5jdGlvbigpe249bi5jYWxsKHQpfSxuOmZ1bmN0aW9uKCl7dmFyIHQ9bi5uZXh0KCk7cmV0dXJuIHU9dC5kb25lLHR9LGU6ZnVuY3Rpb24odCl7cz0hMCxhPXR9LGY6ZnVuY3Rpb24oKXt0cnl7dXx8bnVsbD09bi5yZXR1cm58fG4ucmV0dXJuKCl9ZmluYWxseXtpZihzKXRocm93IGF9fX19ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0fSh0KXx8ZnVuY3Rpb24odCxlKXt2YXIgbj10JiYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmdFtTeW1ib2wuaXRlcmF0b3JdfHx0W1wiQEBpdGVyYXRvclwiXSk7aWYobnVsbCE9bil7dmFyIHIsbyxpPVtdLGE9ITAsdT0hMTt0cnl7Zm9yKG49bi5jYWxsKHQpOyEoYT0ocj1uLm5leHQoKSkuZG9uZSkmJihpLnB1c2goci52YWx1ZSksIWV8fGkubGVuZ3RoIT09ZSk7YT0hMCk7fWNhdGNoKHQpe3U9ITAsbz10fWZpbmFsbHl7dHJ5e2F8fG51bGw9PW4ucmV0dXJufHxuLnJldHVybigpfWZpbmFsbHl7aWYodSl0aHJvdyBvfX1yZXR1cm4gaX19KHQsZSl8fGkodCxlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfWZ1bmN0aW9uIGkodCxlKXtpZih0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gYSh0LGUpO3ZhciBuPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KS5zbGljZSg4LC0xKTtyZXR1cm5cIk9iamVjdFwiPT09biYmdC5jb25zdHJ1Y3RvciYmKG49dC5jb25zdHJ1Y3Rvci5uYW1lKSxcIk1hcFwiPT09bnx8XCJTZXRcIj09PW4/QXJyYXkuZnJvbSh0KTpcIkFyZ3VtZW50c1wiPT09bnx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3Qobik/YSh0LGUpOnZvaWQgMH19ZnVuY3Rpb24gYSh0LGUpeyhudWxsPT1lfHxlPnQubGVuZ3RoKSYmKGU9dC5sZW5ndGgpO2Zvcih2YXIgbj0wLHI9bmV3IEFycmF5KGUpO248ZTtuKyspcltuXT10W25dO3JldHVybiByfWZ1bmN0aW9uIHUodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfXQuZChlLHtkZWZhdWx0OigpPT5zfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTt1KHRoaXMsdCksdGhpcy5hbGxvd0V4dHJhPWUsdGhpcy5kZWZhdWx0cz1uZXcgTWFwLHRoaXMudHlwZXM9bmV3IE1hcCx0aGlzLm9wdGlvbmFsPW5ldyBTZXQsdGhpcy5yZXF1aXJlZD1uZXcgU2V0fXZhciBlO3JldHVybihlPVt7a2V5Olwic2V0RGVmYXVsdHNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbj1vKHQsMikscj1uWzBdLGk9blsxXTtyZXR1cm4gZS5kZWZhdWx0cy5zZXQocixpKX0pKSx0aGlzfX0se2tleTpcInNldFR5cGVzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gT2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG49byh0LDIpLHI9blswXSxpPW5bMV07cmV0dXJuIGUudHlwZXMuc2V0KHIsaSl9KSksdGhpc319LHtrZXk6XCJzZXRPcHRpb25hbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGUub3B0aW9uYWwuYWRkKHQpfSkpLHRoaXN9fSx7a2V5Olwic2V0UmVxdWlyZWRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBlLnJlcXVpcmVkLmFkZCh0KX0pKSx0aGlzfX0se2tleTpcInJlc29sdmVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1PYmplY3QuYXNzaWduKHRoaXMuZ2V0RGVmYXVsdHMoKSx0KTtyZXR1cm4gdGhpcy52YWxpZGF0ZShlKSxlfX0se2tleTpcImdldERlZmF1bHRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdCxlPXt9LG49cih0aGlzLmRlZmF1bHRzKTt0cnl7Zm9yKG4ucygpOyEodD1uLm4oKSkuZG9uZTspe3ZhciBpPW8odC52YWx1ZSwyKSxhPWlbMF0sdT1pWzFdO2VbYV09dX19Y2F0Y2godCl7bi5lKHQpfWZpbmFsbHl7bi5mKCl9cmV0dXJuIGV9fSx7a2V5OlwidmFsaWRhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdCl7aWYoIXRoaXMub3B0aW9uRXhpc3RzKGUpKXRocm93IG5ldyBFcnJvcignVW5rb3duIG9wdGlvbiBcIicuY29uY2F0KGUsJ1wiLicpKTt0aGlzLmNoZWNrVHlwZShlLHRbZV0pfXZhciBuLG89cih0aGlzLnJlcXVpcmVkLnZhbHVlcygpKTt0cnl7Zm9yKG8ucygpOyEobj1vLm4oKSkuZG9uZTspe3ZhciBpPW4udmFsdWU7aWYodm9pZCAwPT09dFtpXSl0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBcIicuY29uY2F0KGksJ1wiIGlzIHJlcXVpcmVkLicpKX19Y2F0Y2godCl7by5lKHQpfWZpbmFsbHl7by5mKCl9fX0se2tleTpcImNoZWNrVHlwZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy50eXBlcy5oYXModCkpe3ZhciByPXRoaXMudHlwZXMuZ2V0KHQpLG89bihlKTtpZihvIT09cil0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHZhbHVlIGZvciBvcHRpb24gXCInLmNvbmNhdCh0LCdcIi4gRXhwZWN0ZWQgdHlwZSBcIicpLmNvbmNhdChyLCdcIiBidXQgZ290IFwiJykuY29uY2F0KG8sJ1wiLicpKX19fSx7a2V5Olwib3B0aW9uRXhpc3RzXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuISF0aGlzLmFsbG93RXh0cmF8fHRoaXMuZGVmYXVsdHMuaGFzKHQpfHx0aGlzLm9wdGlvbmFsLmhhcyh0KXx8dGhpcy5yZXF1aXJlZC5oYXModCl8fHRoaXMudHlwZXMuaGFzKHQpfX1dKSYmZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fSh0LnByb3RvdHlwZSxlKSx0fSgpO3JldHVybiBlLmRlZmF1bHR9KSgpfSwxNjI6ZnVuY3Rpb24odCl7dC5leHBvcnRzPSgoKT0+e1widXNlIHN0cmljdFwiO3ZhciB0PXtkOihlLG4pPT57Zm9yKHZhciByIGluIG4pdC5vKG4scikmJiF0Lm8oZSxyKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6bltyXX0pfSxvOih0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sZT17fTt0LmQoZSx7ZGVmYXVsdDooKT0+bn0pO3ZhciBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpeyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsdCksdGhpcy5fZXZlbnRzPXt9LHRoaXMub249dGhpcy5hZGRFdmVudExpc3RlbmVyLHRoaXMub2ZmPXRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcn12YXIgZTtyZXR1cm4oZT1be2tleTpcImVtaXRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9ldmVudHMsdCkpZm9yKHZhciBuPXRoaXMuX2V2ZW50c1t0XSxyPXt0eXBlOnQsZGV0YWlsOmV9LG89bi5sZW5ndGgsaT0wO2k8bztpKyspdGhpcy5oYW5kbGUobltpXSxyKX19LHtrZXk6XCJoYW5kbGVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3QoZSl9fSx7a2V5OlwiYWRkRXZlbnRMaXN0ZW5lclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2V2ZW50cyx0KXx8KHRoaXMuX2V2ZW50c1t0XT1bXSksdGhpcy5fZXZlbnRzW3RdLmluZGV4T2YoZSk8MCYmdGhpcy5fZXZlbnRzW3RdLnB1c2goZSl9fSx7a2V5OlwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2V2ZW50cyx0KSl7dmFyIG49dGhpcy5fZXZlbnRzW3RdLHI9bi5pbmRleE9mKGUpO3I+PTAmJm4uc3BsaWNlKHIsMSksMD09PW4ubGVuZ3RoJiZkZWxldGUgdGhpcy5fZXZlbnRzW3RdfX19XSkmJmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX0odC5wcm90b3R5cGUsZSksdH0oKTtyZXR1cm4gZS5kZWZhdWx0fSkoKX19LGU9e307ZnVuY3Rpb24gbihyKXt2YXIgbz1lW3JdO2lmKHZvaWQgMCE9PW8pcmV0dXJuIG8uZXhwb3J0czt2YXIgaT1lW3JdPXtleHBvcnRzOnt9fTtyZXR1cm4gdFtyXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxuKSxpLmV4cG9ydHN9bi5uPXQ9Pnt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/KCk9PnQuZGVmYXVsdDooKT0+dDtyZXR1cm4gbi5kKGUse2E6ZX0pLGV9LG4uZD0odCxlKT0+e2Zvcih2YXIgciBpbiBlKW4ubyhlLHIpJiYhbi5vKHQscikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIse2VudW1lcmFibGU6ITAsZ2V0OmVbcl19KX0sbi5vPSh0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxuLnI9dD0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9O3ZhciByPXt9O3JldHVybigoKT0+e1widXNlIHN0cmljdFwiO24ucihyKSxuLmQocix7R2FtZXBhZEhhbmRsZXI6KCk9PmQsR2FtZXBhZExpc3RlbmVyOigpPT54fSk7dmFyIHQ9bigxNjIpLGU9bi5uKHQpLG89big5NDQpLGk9bi5uKG8pO2Z1bmN0aW9uIGEodCl7cmV0dXJuKGE9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWZ1bmN0aW9uIHUodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHModCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIGModCxlKXtyZXR1cm4oYz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0pKHQsZSl9ZnVuY3Rpb24gbCh0LGUpe3JldHVybiFlfHxcIm9iamVjdFwiIT09YShlKSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT9mKHQpOmV9ZnVuY3Rpb24gZih0KXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gdH1mdW5jdGlvbiBwKHQpe3JldHVybihwPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9KSh0KX12YXIgZD1mdW5jdGlvbih0KXshZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJmModCxlKX0oZCx0KTt2YXIgZSxuLHIsbyxpLGE9KG89ZCxpPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19KCksZnVuY3Rpb24oKXt2YXIgdCxlPXAobyk7aWYoaSl7dmFyIG49cCh0aGlzKS5jb25zdHJ1Y3Rvcjt0PVJlZmxlY3QuY29uc3RydWN0KGUsYXJndW1lbnRzLG4pfWVsc2UgdD1lLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gbCh0aGlzLHQpfSk7ZnVuY3Rpb24gZCh0LGUpe3ZhciBuLHI9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9O3JldHVybiB1KHRoaXMsZCksKG49YS5jYWxsKHRoaXMpKS5pbmRleD10LG4ub3B0aW9ucz1uLmNvbnN0cnVjdG9yLnJlc29sdmVPcHRpb25zKHIpLG4uc3RpY2tzPW5ldyBBcnJheShlLmF4ZXMubGVuZ3RoLzIpLmZpbGwobnVsbCkubWFwKChmdW5jdGlvbigpe3JldHVybltudWxsLG51bGxdfSkpLG4uYnV0dG9ucz1uZXcgQXJyYXkoZS5idXR0b25zLmxlbmd0aCkuZmlsbChudWxsKSxuLnVwZGF0ZVN0aWNrPW4udXBkYXRlU3RpY2suYmluZChmKG4pKSxuLnVwZGF0ZUJ1dHRvbj1uLnVwZGF0ZUJ1dHRvbi5iaW5kKGYobikpLG59cmV0dXJuIGU9ZCxyPVt7a2V5OlwicmVzb2x2ZU9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT12b2lkIDAhPT10LnN0aWNrLG49dm9pZCAwIT09dC5idXR0b24scj17c3RpY2s6dGhpcy5vcHRpb25SZXNvbHZlci5yZXNvbHZlKGU/dC5zdGljazpuP3t9OnQpLGJ1dHRvbjp0aGlzLm9wdGlvblJlc29sdmVyLnJlc29sdmUobj90LmJ1dHRvbjplP3t9OnQpfTtyZXR1cm4gci5zdGljay5kZWFkWm9uZT1NYXRoLm1heChNYXRoLm1pbihyLnN0aWNrLmRlYWRab25lLDEpLDApLHIuYnV0dG9uLmRlYWRab25lPU1hdGgubWF4KE1hdGgubWluKHIuYnV0dG9uLmRlYWRab25lLDEpLDApLHIuc3RpY2sucHJlY2lzaW9uPXIuc3RpY2sucHJlY2lzaW9uP01hdGgucG93KDEwLHIuc3RpY2sucHJlY2lzaW9uKTowLHIuYnV0dG9uLnByZWNpc2lvbj1yLmJ1dHRvbi5wcmVjaXNpb24/TWF0aC5wb3coMTAsci5idXR0b24ucHJlY2lzaW9uKTowLHJ9fV0sKG49W3trZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPXRoaXMuc3RpY2tzLmxlbmd0aCxyPTA7cjxuO3IrKylmb3IodmFyIG89MDtvPDI7bysrKXRoaXMudXBkYXRlU3RpY2sodCxyLG8sdC5heGVzW2UrK10pO3ZhciBpPXRoaXMuYnV0dG9ucy5sZW5ndGg7Zm9yKGU9MDtlPGk7ZSsrKXRoaXMudXBkYXRlQnV0dG9uKHQsdC5idXR0b25zW2VdLGUpfX0se2tleTpcInVwZGF0ZVN0aWNrXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dGhpcy5vcHRpb25zLnN0aWNrLGk9by5kZWFkWm9uZSxhPW8uYW5hbG9nLHU9by5wcmVjaXNpb247aSYmcjxpJiZyPi1pJiYocj0wKSxhP3UmJihyPU1hdGgucm91bmQocip1KS91KTpyPXI+MD8xOnI8MD8tMTowLHRoaXMuc3RpY2tzW2VdW25dIT09ciYmKHRoaXMuc3RpY2tzW2VdW25dPXIsdGhpcy5lbWl0KFwiYXhpc1wiLHtnYW1lcGFkOnQsc3RpY2s6ZSxheGlzOm4sdmFsdWU6cixpbmRleDp0aGlzLmluZGV4fSkpfX0se2tleTpcInVwZGF0ZUJ1dHRvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLm9wdGlvbnMuYnV0dG9uLG89ci5kZWFkWm9uZSxpPXIuYW5hbG9nLGE9ci5wcmVjaXNpb24sdT1lLnZhbHVlLHM9ZS5wcmVzc2VkLGM9dTtvJiZlLnZhbHVlPG8mJmUudmFsdWU+LW8mJihjPTApLGk/YSYmKGM9TWF0aC5yb3VuZChjKmEpL2EpOmM9cz8xOjAsdGhpcy5idXR0b25zW25dIT09YyYmKHRoaXMuYnV0dG9uc1tuXT1jLHRoaXMuZW1pdChcImJ1dHRvblwiLHtnYW1lcGFkOnQsYnV0dG9uOm4scHJlc3NlZDpzLHZhbHVlOmMsaW5kZXg6dGhpcy5pbmRleH0pKX19XSkmJnMoZS5wcm90b3R5cGUsbiksciYmcyhlLHIpLGR9KGUoKSk7ZnVuY3Rpb24gaCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZC5vcHRpb25SZXNvbHZlcj0obmV3KGkoKSkpLnNldERlZmF1bHRzKHthbmFsb2c6ITAsZGVhZFpvbmU6MCxwcmVjaXNpb246MH0pLnNldFR5cGVzKHthbmFsb2c6XCJib29sZWFuXCIsZGVhZFpvbmU6XCJudW1iZXJcIixwcmVjaXNpb246XCJudW1iZXJcIn0pO3ZhciB5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLHQpLHRoaXMuY2FsbGJhY2s9ZSx0aGlzLmZyYW1lPW51bGwsdGhpcy51cGRhdGU9dGhpcy51cGRhdGUuYmluZCh0aGlzKX12YXIgZSxuO3JldHVybiBlPXQsKG49W3trZXk6XCJzZXRDYWxsYmFja1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuY2FsbGJhY2s9dH19LHtrZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5mcmFtZXx8KHRoaXMuZnJhbWU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZSkpfX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZnJhbWUmJih3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mcmFtZSksdGhpcy5mcmFtZT1udWxsKX19LHtrZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZnJhbWU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZSksdGhpcy5jYWxsYmFjaygpfX1dKSYmaChlLnByb3RvdHlwZSxuKSx0fSgpO2Z1bmN0aW9uIHYodCl7cmV0dXJuKHY9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWZ1bmN0aW9uIGIodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIG0odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIGcodCxlKXtyZXR1cm4oZz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0pKHQsZSl9ZnVuY3Rpb24gdyh0LGUpe3JldHVybiFlfHxcIm9iamVjdFwiIT09dihlKSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT9rKHQpOmV9ZnVuY3Rpb24gayh0KXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gdH1mdW5jdGlvbiBPKHQpe3JldHVybihPPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9KSh0KX12YXIgeD1mdW5jdGlvbih0KXshZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJmcodCxlKX0oYSx0KTt2YXIgZSxuLHIsbyxpPShyPWEsbz1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpLGZ1bmN0aW9uKCl7dmFyIHQsZT1PKHIpO2lmKG8pe3ZhciBuPU8odGhpcykuY29uc3RydWN0b3I7dD1SZWZsZWN0LmNvbnN0cnVjdChlLGFyZ3VtZW50cyxuKX1lbHNlIHQ9ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHcodGhpcyx0KX0pO2Z1bmN0aW9uIGEoKXt2YXIgdCxlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpZihiKHRoaXMsYSksdD1pLmNhbGwodGhpcyksXCJmdW5jdGlvblwiIT10eXBlb2YgbmF2aWdhdG9yLmdldEdhbWVwYWRzKXRocm93IG5ldyBFcnJvcihcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGdhbWVwYWQgQVBJLlwiKTtyZXR1cm4gdC5vcHRpb25zPWUsdC5vbkF4aXM9dC5vbkF4aXMuYmluZChrKHQpKSx0LnVwZGF0ZT10LnVwZGF0ZS5iaW5kKGsodCkpLHQuc3RhcnQ9dC5zdGFydC5iaW5kKGsodCkpLHQuc3RvcD10LnN0b3AuYmluZChrKHQpKSx0LmRpc2NvdmVyPXQuZGlzY292ZXIuYmluZChrKHQpKSx0Lm9uQnV0dG9uPXQub25CdXR0b24uYmluZChrKHQpKSx0LmhhbmRsZXJzPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHQubG9vcD1uZXcgeSh0LnVwZGF0ZSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLHQuc3RvcCksdH1yZXR1cm4gZT1hLChuPVt7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubG9vcC5zdGFydCgpfX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubG9vcC5zdG9wKCl9fSx7a2V5OlwidXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1uYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKTt0aGlzLmRpc2NvdmVyKHRbMF0sMCksdGhpcy5kaXNjb3Zlcih0WzFdLDEpLHRoaXMuZGlzY292ZXIodFsyXSwyKSx0aGlzLmRpc2NvdmVyKHRbM10sMyl9fSx7a2V5OlwiZGlzY292ZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3Q/KHRoaXMuaGFuZGxlcnNbZV18fHRoaXMucmVnaXN0ZXJIYW5kbGVyKGUsdCksdGhpcy5oYW5kbGVyc1tlXS51cGRhdGUodCkpOnRoaXMuaGFuZGxlcnNbZV0mJnRoaXMucmVtb3ZlR2FtZXBhZChlKX19LHtrZXk6XCJyZWdpc3RlckhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKHRoaXMuaGFuZGxlcnNbdF0pdGhyb3cgbmV3IEVycm9yKFwiR2FtZXBhZCAjXCIuY29uY2F0KHQsXCIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLlwiKSk7dmFyIG49bmV3IGQodCxlLHRoaXMub3B0aW9ucyk7dGhpcy5oYW5kbGVyc1t0XT1uLG4uYWRkRXZlbnRMaXN0ZW5lcihcImF4aXNcIix0aGlzLm9uQXhpcyksbi5hZGRFdmVudExpc3RlbmVyKFwiYnV0dG9uXCIsdGhpcy5vbkJ1dHRvbiksdGhpcy5lbWl0KFwiZ2FtZXBhZDpjb25uZWN0ZWRcIix7aW5kZXg6dCxnYW1lcGFkOmV9KSx0aGlzLmVtaXQoXCJnYW1lcGFkOlwiLmNvbmNhdCh0LFwiOmNvbm5lY3RlZFwiKSx7aW5kZXg6dCxnYW1lcGFkOmV9KX19LHtrZXk6XCJyZW1vdmVHYW1lcGFkXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoIXRoaXMuaGFuZGxlcnNbdF0pdGhyb3cgbmV3IEVycm9yKFwiR2FtZXBhZCAjXCIuY29uY2F0KHQsXCIgaXMgbm90IHJlZ2lzdGVyZWQuXCIpKTt0aGlzLmhhbmRsZXJzW3RdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJheGlzXCIsdGhpcy5vbkF4aXMpLHRoaXMuaGFuZGxlcnNbdF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJ1dHRvblwiLHRoaXMub25CdXR0b24pLHRoaXMuaGFuZGxlcnNbdF09bnVsbCx0aGlzLmVtaXQoXCJnYW1lcGFkOmRpc2Nvbm5lY3RlZFwiLHtpbmRleDp0fSksdGhpcy5lbWl0KFwiZ2FtZXBhZDpcIi5jb25jYXQodCxcIjpkaXNjb25uZWN0ZWRcIikse2luZGV4OnR9KX19LHtrZXk6XCJvbkF4aXNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LmRldGFpbC5pbmRleDt0aGlzLmVtaXQoXCJnYW1lcGFkOmF4aXNcIix0LmRldGFpbCksdGhpcy5lbWl0KFwiZ2FtZXBhZDpcIi5jb25jYXQoZSxcIjpheGlzXCIpLHQuZGV0YWlsKSx0aGlzLmVtaXQoXCJnYW1lcGFkOlwiLmNvbmNhdChlLFwiOmF4aXM6XCIpLmNvbmNhdCh0LmRldGFpbC5heGlzKSx0LmRldGFpbCl9fSx7a2V5Olwib25CdXR0b25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LmRldGFpbC5pbmRleDt0aGlzLmVtaXQoXCJnYW1lcGFkOmJ1dHRvblwiLHQuZGV0YWlsKSx0aGlzLmVtaXQoXCJnYW1lcGFkOlwiLmNvbmNhdChlLFwiOmJ1dHRvblwiKSx0LmRldGFpbCksdGhpcy5lbWl0KFwiZ2FtZXBhZDpcIi5jb25jYXQoZSxcIjpidXR0b246XCIpLmNvbmNhdCh0LmRldGFpbC5idXR0b24pLHQuZGV0YWlsKX19XSkmJm0oZS5wcm90b3R5cGUsbiksYX0oZSgpKX0pKCkscn0pKCl9KSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gamepad.js/gamepad.js\n')},"./node_modules/ms/index.js":module=>{eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/MTQ2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ms/index.js\n")},"./node_modules/path-browserify/index.js":module=>{"use strict";eval("// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsWUFBWTtBQUNaO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQSxNQUFNO0FBQ04sZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlEO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcz9kZjdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICdwYXRoJyBtb2R1bGUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xIChvbmx5IHRoZSBwb3NpeCBwYXJ0KVxuLy8gdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbFxuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NlcnRQYXRoKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJyArIEpTT04uc3RyaW5naWZ5KHBhdGgpKTtcbiAgfVxufVxuXG4vLyBSZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggd2l0aCBkaXJlY3RvcnkgbmFtZXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsIGFsbG93QWJvdmVSb290KSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgdmFyIGxhc3RTbGFzaCA9IC0xO1xuICB2YXIgZG90cyA9IDA7XG4gIHZhciBjb2RlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgPCBwYXRoLmxlbmd0aClcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgZWxzZSBpZiAoY29kZSA9PT0gNDcgLyovKi8pXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBjb2RlID0gNDcgLyovKi87XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7XG4gICAgICAgIC8vIE5PT1BcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNsYXNoICE9PSBpIC0gMSAmJiBkb3RzID09PSAyKSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoIDwgMiB8fCBsYXN0U2VnbWVudExlbmd0aCAhPT0gMiB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMSkgIT09IDQ2IC8qLiovIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAyKSAhPT0gNDYgLyouKi8pIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBsYXN0U2xhc2hJbmRleCA9IHJlcy5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ICE9PSByZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSgwLCBsYXN0U2xhc2hJbmRleCk7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSByZXMubGVuZ3RoIC0gMSAtIHJlcy5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPT09IDIgfHwgcmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmVzICs9ICcvLi4nO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlcyA9ICcuLic7XG4gICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgcmVzICs9ICcvJyArIHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXMgPSBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IGkgLSBsYXN0U2xhc2ggLSAxO1xuICAgICAgfVxuICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgIGRvdHMgPSAwO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNDYgLyouKi8gJiYgZG90cyAhPT0gLTEpIHtcbiAgICAgICsrZG90cztcbiAgICB9IGVsc2Uge1xuICAgICAgZG90cyA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBfZm9ybWF0KHNlcCwgcGF0aE9iamVjdCkge1xuICB2YXIgZGlyID0gcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5yb290O1xuICB2YXIgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCAocGF0aE9iamVjdC5uYW1lIHx8ICcnKSArIChwYXRoT2JqZWN0LmV4dCB8fCAnJyk7XG4gIGlmICghZGlyKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgaWYgKGRpciA9PT0gcGF0aE9iamVjdC5yb290KSB7XG4gICAgcmV0dXJuIGRpciArIGJhc2U7XG4gIH1cbiAgcmV0dXJuIGRpciArIHNlcCArIGJhc2U7XG59XG5cbnZhciBwb3NpeCA9IHtcbiAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHZhciByZXNvbHZlZFBhdGggPSAnJztcbiAgICB2YXIgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuICAgIHZhciBjd2Q7XG5cbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgICAgdmFyIHBhdGg7XG4gICAgICBpZiAoaSA+PSAwKVxuICAgICAgICBwYXRoID0gYXJndW1lbnRzW2ldO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChjd2QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBjd2QgPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICBwYXRoID0gY3dkO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXNcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHJlc29sdmVkUGF0aCwgIXJlc29sdmVkQWJzb2x1dGUpO1xuXG4gICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcbiAgICAgIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJy4nO1xuICAgIH1cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcblxuICAgIHZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgICB2YXIgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gNDcgLyovKi87XG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICBwYXRoID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aCwgIWlzQWJzb2x1dGUpO1xuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwICYmICFpc0Fic29sdXRlKSBwYXRoID0gJy4nO1xuICAgIGlmIChwYXRoLmxlbmd0aCA+IDAgJiYgdHJhaWxpbmdTZXBhcmF0b3IpIHBhdGggKz0gJy8nO1xuXG4gICAgaWYgKGlzQWJzb2x1dGUpIHJldHVybiAnLycgKyBwYXRoO1xuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIGlzQWJzb2x1dGU6IGZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICB9LFxuXG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gJy4nO1xuICAgIHZhciBqb2luZWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICBhc3NlcnRQYXRoKGFyZyk7XG4gICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGpvaW5lZCA9IGFyZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGpvaW5lZCArPSAnLycgKyBhcmc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAnLic7XG4gICAgcmV0dXJuIHBvc2l4Lm5vcm1hbGl6ZShqb2luZWQpO1xuICB9LFxuXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiByZWxhdGl2ZShmcm9tLCB0bykge1xuICAgIGFzc2VydFBhdGgoZnJvbSk7XG4gICAgYXNzZXJ0UGF0aCh0byk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiAnJztcblxuICAgIGZyb20gPSBwb3NpeC5yZXNvbHZlKGZyb20pO1xuICAgIHRvID0gcG9zaXgucmVzb2x2ZSh0byk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiAnJztcblxuICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcbiAgICB2YXIgZnJvbVN0YXJ0ID0gMTtcbiAgICBmb3IgKDsgZnJvbVN0YXJ0IDwgZnJvbS5sZW5ndGg7ICsrZnJvbVN0YXJ0KSB7XG4gICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCkgIT09IDQ3IC8qLyovKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGZyb21FbmQgPSBmcm9tLmxlbmd0aDtcbiAgICB2YXIgZnJvbUxlbiA9IGZyb21FbmQgLSBmcm9tU3RhcnQ7XG5cbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgdmFyIHRvU3RhcnQgPSAxO1xuICAgIGZvciAoOyB0b1N0YXJ0IDwgdG8ubGVuZ3RoOyArK3RvU3RhcnQpIHtcbiAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQpICE9PSA0NyAvKi8qLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciB0b0VuZCA9IHRvLmxlbmd0aDtcbiAgICB2YXIgdG9MZW4gPSB0b0VuZCAtIHRvU3RhcnQ7XG5cbiAgICAvLyBDb21wYXJlIHBhdGhzIHRvIGZpbmQgdGhlIGxvbmdlc3QgY29tbW9uIHBhdGggZnJvbSByb290XG4gICAgdmFyIGxlbmd0aCA9IGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbjtcbiAgICB2YXIgbGFzdENvbW1vblNlcCA9IC0xO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8PSBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgPT09IGxlbmd0aCkge1xuICAgICAgICBpZiAodG9MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvZm9vL2Jhci9iYXonXG4gICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkgKyAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgcm9vdFxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy8nOyB0bz0nL2ZvbydcbiAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXIvYmF6JzsgdG89Jy9mb28vYmFyJ1xuICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSByb290LlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28nOyB0bz0nLydcbiAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBmcm9tQ29kZSA9IGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKTtcbiAgICAgIHZhciB0b0NvZGUgPSB0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKTtcbiAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG9Db2RlKVxuICAgICAgICBicmVhaztcbiAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSA0NyAvKi8qLylcbiAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIC8vIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBwYXRoIGJhc2VkIG9uIHRoZSBwYXRoIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9gXG4gICAgLy8gYW5kIGBmcm9tYFxuICAgIGZvciAoaSA9IGZyb21TdGFydCArIGxhc3RDb21tb25TZXAgKyAxOyBpIDw9IGZyb21FbmQ7ICsraSkge1xuICAgICAgaWYgKGkgPT09IGZyb21FbmQgfHwgZnJvbS5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBvdXQgKz0gJy4uJztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG91dCArPSAnLy4uJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMYXN0bHksIGFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgZGVzdGluYXRpb24gKGB0b2ApIHBhdGggdGhhdCBjb21lcyBhZnRlclxuICAgIC8vIHRoZSBjb21tb24gcGF0aCBwYXJ0c1xuICAgIGlmIChvdXQubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBvdXQgKyB0by5zbGljZSh0b1N0YXJ0ICsgbGFzdENvbW1vblNlcCk7XG4gICAgZWxzZSB7XG4gICAgICB0b1N0YXJ0ICs9IGxhc3RDb21tb25TZXA7XG4gICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0KSA9PT0gNDcgLyovKi8pXG4gICAgICAgICsrdG9TdGFydDtcbiAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0KTtcbiAgICB9XG4gIH0sXG5cbiAgX21ha2VMb25nOiBmdW5jdGlvbiBfbWFrZUxvbmcocGF0aCkge1xuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIGRpcm5hbWU6IGZ1bmN0aW9uIGRpcm5hbWUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHJldHVybiAnLy8nO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG4gIH0sXG5cbiAgYmFzZW5hbWU6IGZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgsIGV4dCkge1xuICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZXh0ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIHZhciBzdGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIGlmIChleHQubGVuZ3RoID09PSBwYXRoLmxlbmd0aCAmJiBleHQgPT09IHBhdGgpIHJldHVybiAnJztcbiAgICAgIHZhciBleHRJZHggPSBleHQubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBmaXJzdE5vblNsYXNoRW5kID0gLTE7XG4gICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgcmVtZW1iZXIgdGhpcyBpbmRleCBpbiBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGl0IGlmIHRoZSBleHRlbnNpb24gZW5kcyB1cCBub3QgbWF0Y2hpbmdcbiAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0SWR4ID49IDApIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZXhwbGljaXQgZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gZXh0LmNoYXJDb2RlQXQoZXh0SWR4KSkge1xuICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgZXh0ZW5zaW9uLCBzbyBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIgcGF0aFxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEV4dGVuc2lvbiBkb2VzIG5vdCBtYXRjaCwgc28gb3VyIHJlc3VsdCBpcyB0aGUgZW50aXJlIHBhdGhcbiAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtlbHNlIGlmIChlbmQgPT09IC0xKSBlbmQgPSBwYXRoLmxlbmd0aDtcbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LFxuXG4gIGV4dG5hbWU6IGZ1bmN0aW9uIGV4dG5hbWUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gICAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICB9LFxuXG4gIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHBhdGhPYmplY3QpIHtcbiAgICBpZiAocGF0aE9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2YgcGF0aE9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInBhdGhPYmplY3RcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgcGF0aE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBfZm9ybWF0KCcvJywgcGF0aE9iamVjdCk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgdmFyIHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJldDtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgaXNBYnNvbHV0ZSA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICAgIHZhciBzdGFydDtcbiAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgcmV0LnJvb3QgPSAnLyc7XG4gICAgICBzdGFydCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gICAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuXG4gICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgdmFyIHByZURvdFN0YXRlID0gMDtcblxuICAgIC8vIEdldCBub24tZGlyIGluZm9cbiAgICBmb3IgKDsgaSA+PSBzdGFydDsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHN0YXJ0RG90ID0gaTtlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICAgIGlmIChlbmQgIT09IC0xKSB7XG4gICAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2UoMSwgZW5kKTtlbHNlIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZSgxLCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZSgxLCBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgcmV0LmV4dCA9IHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0UGFydCA+IDApIHJldC5kaXIgPSBwYXRoLnNsaWNlKDAsIHN0YXJ0UGFydCAtIDEpO2Vsc2UgaWYgKGlzQWJzb2x1dGUpIHJldC5kaXIgPSAnLyc7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIHNlcDogJy8nLFxuICBkZWxpbWl0ZXI6ICc6JyxcbiAgd2luMzI6IG51bGwsXG4gIHBvc2l4OiBudWxsXG59O1xuXG5wb3NpeC5wb3NpeCA9IHBvc2l4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc2l4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/path-browserify/index.js\n")},"./src/TfTree.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('teleopxyz.TfTree')\nconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\n\nasync function getTopicType(ros, topic){\n  return new Promise((resolve, reject)=>{\n    ros.getTopicType(topic, resolve, reject)\n  })\n}\n\n\nfunction cleanPath(str){\n  return path.join('/', str)\n}\n\n\nclass TfTree extends THREE.Object3D {\n  constructor({ros, tfClient, rootObject, frames, scale, showArrows, showAxes, showNames}){\n    super()\n    this.ros = ros\n    this.tfClient = tfClient\n    this.rootObject = rootObject\n    this.axisScale = scale || 1.0\n    this.frames = {} //! Map of frameName to frameEnabled\n\n    for(const [frame, enabled] of Object.entries(frames)){\n      this.markFrame(frame, enabled)\n    }\n\n    this.sceneNodes = {}\n\n    this.tfSub = null\n\n    this.tfStaticSub = null\n\n  }\n\n\n  async setup(){\n    const [tfType, tfStaticType] = await Promise.all([\n      getTopicType(this.ros, '/tf'),\n      getTopicType(this.ros, '/tf_static')\n    ])\n\n    debug('types', tfType, tfStaticType)\n\n    this.tfSub = new ROSLIB.Topic({\n      ros: this.ros,\n      name: '/tf',\n      messageType: tfType\n    })\n\n    this.tfStaticSub = new ROSLIB.Topic({\n      ros: this.ros,\n      name: '/tf_static',\n      messageType: tfStaticType\n    })\n\n    this.listenForFrames()\n  }\n\n  listenForFrames(){\n    this.tfSub.subscribe(this.handleTfMessage.bind(this))\n    this.tfStaticSub.subscribe(this.handleTfMessage.bind(this))\n    setTimeout(this.stopListeningForFrames.bind(this), 3000)\n  }\n\n  frameExists(frame_id){\n    return this.frames[cleanPath(frame_id)] !== undefined\n  }\n\n  markFrame(frame, value){\n    const frame_id = cleanPath(frame)\n    if(!this.frameExists(frame_id)){\n      debug('discovered frame', frame_id)\n      this.frames[frame_id] = value\n    }\n  }\n  \n\n  handleTfMessage(msg){\n    for(let transform of msg.transforms){\n      this.markFrame(transform.child_frame_id, true)\n      this.markFrame(transform.header.frame_id, true)\n    }\n  }\n\n\n\n  stopListeningForFrames(){\n    debug('stopListeningForFrames done')\n    this.tfSub.unsubscribe()\n    this.tfStaticSub.unsubscribe()\n\n    this.subscribe()\n  }\n\n  //! Subscribe to needed Tf frames\n  subscribe(){\n\n    for(const [frame, enabled] of Object.entries(this.frames)){\n\n      if(enabled){\n        debug('subscribing to frame', frame)\n        let axis = new ROS3D.Axes({\n          lineType: 'full',\n          shaftRadius: 0.04,\n          scale: this.axisScale/5.0,\n        })\n\n        this.sceneNodes[frame] = new ROS3D.SceneNode({\n          frameID: frame,\n          tfClient: this.tfClient,\n          object: axis\n        })\n\n        this.rootObject.add(this.sceneNodes[frame])\n      }\n      else {\n        debug('ignoring frame', frame)\n      }\n    }\n  }\n\n}\n\nmodule.exports=TfTree;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVGZUcmVlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxrREFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMscURBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGVBQWUsMEVBQTBFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9zcmMvVGZUcmVlLmpzP2U3MWYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd0ZWxlb3B4eXouVGZUcmVlJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuYXN5bmMgZnVuY3Rpb24gZ2V0VG9waWNUeXBlKHJvcywgdG9waWMpe1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICByb3MuZ2V0VG9waWNUeXBlKHRvcGljLCByZXNvbHZlLCByZWplY3QpXG4gIH0pXG59XG5cblxuZnVuY3Rpb24gY2xlYW5QYXRoKHN0cil7XG4gIHJldHVybiBwYXRoLmpvaW4oJy8nLCBzdHIpXG59XG5cblxuY2xhc3MgVGZUcmVlIGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3Rvcih7cm9zLCB0ZkNsaWVudCwgcm9vdE9iamVjdCwgZnJhbWVzLCBzY2FsZSwgc2hvd0Fycm93cywgc2hvd0F4ZXMsIHNob3dOYW1lc30pe1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnJvcyA9IHJvc1xuICAgIHRoaXMudGZDbGllbnQgPSB0ZkNsaWVudFxuICAgIHRoaXMucm9vdE9iamVjdCA9IHJvb3RPYmplY3RcbiAgICB0aGlzLmF4aXNTY2FsZSA9IHNjYWxlIHx8IDEuMFxuICAgIHRoaXMuZnJhbWVzID0ge30gLy8hIE1hcCBvZiBmcmFtZU5hbWUgdG8gZnJhbWVFbmFibGVkXG5cbiAgICBmb3IoY29uc3QgW2ZyYW1lLCBlbmFibGVkXSBvZiBPYmplY3QuZW50cmllcyhmcmFtZXMpKXtcbiAgICAgIHRoaXMubWFya0ZyYW1lKGZyYW1lLCBlbmFibGVkKVxuICAgIH1cblxuICAgIHRoaXMuc2NlbmVOb2RlcyA9IHt9XG5cbiAgICB0aGlzLnRmU3ViID0gbnVsbFxuXG4gICAgdGhpcy50ZlN0YXRpY1N1YiA9IG51bGxcblxuICB9XG5cblxuICBhc3luYyBzZXR1cCgpe1xuICAgIGNvbnN0IFt0ZlR5cGUsIHRmU3RhdGljVHlwZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBnZXRUb3BpY1R5cGUodGhpcy5yb3MsICcvdGYnKSxcbiAgICAgIGdldFRvcGljVHlwZSh0aGlzLnJvcywgJy90Zl9zdGF0aWMnKVxuICAgIF0pXG5cbiAgICBkZWJ1ZygndHlwZXMnLCB0ZlR5cGUsIHRmU3RhdGljVHlwZSlcblxuICAgIHRoaXMudGZTdWIgPSBuZXcgUk9TTElCLlRvcGljKHtcbiAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICBuYW1lOiAnL3RmJyxcbiAgICAgIG1lc3NhZ2VUeXBlOiB0ZlR5cGVcbiAgICB9KVxuXG4gICAgdGhpcy50ZlN0YXRpY1N1YiA9IG5ldyBST1NMSUIuVG9waWMoe1xuICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgIG5hbWU6ICcvdGZfc3RhdGljJyxcbiAgICAgIG1lc3NhZ2VUeXBlOiB0ZlN0YXRpY1R5cGVcbiAgICB9KVxuXG4gICAgdGhpcy5saXN0ZW5Gb3JGcmFtZXMoKVxuICB9XG5cbiAgbGlzdGVuRm9yRnJhbWVzKCl7XG4gICAgdGhpcy50ZlN1Yi5zdWJzY3JpYmUodGhpcy5oYW5kbGVUZk1lc3NhZ2UuYmluZCh0aGlzKSlcbiAgICB0aGlzLnRmU3RhdGljU3ViLnN1YnNjcmliZSh0aGlzLmhhbmRsZVRmTWVzc2FnZS5iaW5kKHRoaXMpKVxuICAgIHNldFRpbWVvdXQodGhpcy5zdG9wTGlzdGVuaW5nRm9yRnJhbWVzLmJpbmQodGhpcyksIDMwMDApXG4gIH1cblxuICBmcmFtZUV4aXN0cyhmcmFtZV9pZCl7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVzW2NsZWFuUGF0aChmcmFtZV9pZCldICE9PSB1bmRlZmluZWRcbiAgfVxuXG4gIG1hcmtGcmFtZShmcmFtZSwgdmFsdWUpe1xuICAgIGNvbnN0IGZyYW1lX2lkID0gY2xlYW5QYXRoKGZyYW1lKVxuICAgIGlmKCF0aGlzLmZyYW1lRXhpc3RzKGZyYW1lX2lkKSl7XG4gICAgICBkZWJ1ZygnZGlzY292ZXJlZCBmcmFtZScsIGZyYW1lX2lkKVxuICAgICAgdGhpcy5mcmFtZXNbZnJhbWVfaWRdID0gdmFsdWVcbiAgICB9XG4gIH1cbiAgXG5cbiAgaGFuZGxlVGZNZXNzYWdlKG1zZyl7XG4gICAgZm9yKGxldCB0cmFuc2Zvcm0gb2YgbXNnLnRyYW5zZm9ybXMpe1xuICAgICAgdGhpcy5tYXJrRnJhbWUodHJhbnNmb3JtLmNoaWxkX2ZyYW1lX2lkLCB0cnVlKVxuICAgICAgdGhpcy5tYXJrRnJhbWUodHJhbnNmb3JtLmhlYWRlci5mcmFtZV9pZCwgdHJ1ZSlcbiAgICB9XG4gIH1cblxuXG5cbiAgc3RvcExpc3RlbmluZ0ZvckZyYW1lcygpe1xuICAgIGRlYnVnKCdzdG9wTGlzdGVuaW5nRm9yRnJhbWVzIGRvbmUnKVxuICAgIHRoaXMudGZTdWIudW5zdWJzY3JpYmUoKVxuICAgIHRoaXMudGZTdGF0aWNTdWIudW5zdWJzY3JpYmUoKVxuXG4gICAgdGhpcy5zdWJzY3JpYmUoKVxuICB9XG5cbiAgLy8hIFN1YnNjcmliZSB0byBuZWVkZWQgVGYgZnJhbWVzXG4gIHN1YnNjcmliZSgpe1xuXG4gICAgZm9yKGNvbnN0IFtmcmFtZSwgZW5hYmxlZF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5mcmFtZXMpKXtcblxuICAgICAgaWYoZW5hYmxlZCl7XG4gICAgICAgIGRlYnVnKCdzdWJzY3JpYmluZyB0byBmcmFtZScsIGZyYW1lKVxuICAgICAgICBsZXQgYXhpcyA9IG5ldyBST1MzRC5BeGVzKHtcbiAgICAgICAgICBsaW5lVHlwZTogJ2Z1bGwnLFxuICAgICAgICAgIHNoYWZ0UmFkaXVzOiAwLjA0LFxuICAgICAgICAgIHNjYWxlOiB0aGlzLmF4aXNTY2FsZS81LjAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5zY2VuZU5vZGVzW2ZyYW1lXSA9IG5ldyBST1MzRC5TY2VuZU5vZGUoe1xuICAgICAgICAgIGZyYW1lSUQ6IGZyYW1lLFxuICAgICAgICAgIHRmQ2xpZW50OiB0aGlzLnRmQ2xpZW50LFxuICAgICAgICAgIG9iamVjdDogYXhpc1xuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMucm9vdE9iamVjdC5hZGQodGhpcy5zY2VuZU5vZGVzW2ZyYW1lXSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWJ1ZygnaWdub3JpbmcgZnJhbWUnLCBmcmFtZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cz1UZlRyZWU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/TfTree.js\n")},"./src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('teleopxyz.TeleOp')\nconst reach = __webpack_require__(/*! ./reach */ \"./src/reach.js\")\nconst yaml = __webpack_require__(/*! yaml */ \"./node_modules/yaml/browser/index.js\")\nconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\n\nconst Pkg = __webpack_require__(/*! ../package.json */ \"./package.json\")\n\nconst { GamepadListener } = __webpack_require__(/*! gamepad.js */ \"./node_modules/gamepad.js/gamepad.js\")\n\n\nconsole.log(Pkg.name, 'v'+Pkg.version, '')\nconsole.log('sense, plan, party ')\nconsole.log('\\n\\nWelcome fellow humans\\n\\nset localStorage.debug=\\'*\\' to activate debug output')\n\n\nconst TfTree = __webpack_require__(/*! ./TfTree */ \"./src/TfTree.js\")\n\nclass TeleOp {\n  constructor(){\n    debug('new TeleOp')\n\n    this.ros = null\n    this.host = null\n    this.fileContent = null\n    this.divId = null\n    this.viewer = null\n    this.tfClient = null\n    this.baseLink = null\n  this.gamepadListener = new GamepadListener({analog: true/*, deadZone: 0.2*/})\n\n    this.joyMsg = null\n    this.joyIndex = null\n    this.joyPub = null\n    this.joyEnabled = false\n    this.joyUserOptIn = null\n    this.joyAutoRepeatRate = 4\n    this.joyRepeatTimer = null\n  }\n\n  static get version(){\n    return Pkg.version\n  }\n\n  async connectRos(){\n    return new Promise((resolve,reject)=>{\n\n      // Connect to ROS.\n      this.ros = new ROSLIB.Ros({\n        url : this.host\n      });\n\n      this.ros.on('error', (error) => {\n        debug('Connection error ' + this.host)\n        debug(error)\n        reject(error)\n      });\n      // Find out exactly when we made a connection.\n      this.ros.on('connection', () => {\n        debug('Connection open ' + this.host)\n        resolve()\n      })\n    })\n  }\n\n  onResize(event) {\n    debug('resize', event)\n    const width = this.div.clientWidth\n    const height = this.div.clientHeight\n    debug('size', width, height)\n    this.viewer.resize(width, height)\n  }\n\n  async start(host, rvizFile, divId=\"viewer\"){\n    debug('start')\n\n    this.host = host\n    this.divId = divId\n    this.fileContent = yaml.parse(rvizFile)\n\n    this.div = document.getElementById(this.divId)\n\n    debug('fileContent', this.fileContent)\n\n    await this.connectRos()\n\n    let globalOptions = {\n      background: TeleOp.rvizColor2hex(reach(this.fileContent, 'Visualization Manager.Global Options.Background Color'), null),\n      fixedFrame: reach(this.fileContent, 'Visualization Manager.Global Options.Fixed Frame', '/base_link'),\n      frameRate: reach(this.fileContent, 'Visualization Manager.Global Options.Frame Rate', 30)\n    }\n\n    this.viewer = new ROS3D.Viewer({\n      divID: this.divId,\n      width: this.div.clientWidth,\n      height: this.div.clientHeight,\n      antialias: true,\n      background: globalOptions.background\n    });\n\n    window.onresize = (e)=>{this.onResize(e)}\n\n    /*this.viewer.addObject(new ROS3D.Grid({\n      color:'#0181c4',\n      cellSize: 1.0,\n      num_cells: 20\n    }));*/\n\n\n    console.log('Globals', { globalOptions })\n\n\n\n    this.tfClient = new ROSLIB.TFClient({\n      ros: this.ros,\n      serverName: `/tf2_web_republisher`,   //! Need to make configurable and autodetect correct one on the fly\n      angularThres: 0.03,\n      transThres: 0.01,\n      //rate: globalOptions.frameRate,\n      fixedFrame: globalOptions.fixedFrame\n    })\n\n    this.gamepadListener.on('gamepad:connected', this.addGamepad.bind(this))\n    this.gamepadListener.on('gamepad:disconnected', this.removeGamepad.bind(this))\n    this.gamepadListener.on('gamepad:axis', this.onAxisChange.bind(this))\n    this.gamepadListener.on('gamepad:button', this.onAxisChange.bind(this))\n\n    this.gamepadListener.start()\n\n    await this.renderFromFile()\n  }\n\n  addGamepad(event){\n    debug('addGamepad', event)\n    const gamepad = reach(event, 'detail.gamepad')\n\n    if(this.joyUserOptIn == null){\n      debug('prompting user for gamepad/joy support opt-in')\n      this.joyUserOptIn = window.confirm('Gamepad detected - would you like to use it as a /joy publisher?\\n\\n'+gamepad.id)\n      this.joyEnabled = this.joyUserOptIn\n\n      debug('joyUserOptIn =', this.joyUserOptIn)\n    }\n\n    if(this.joyUserOptIn == false){ return }\n\n    if(this.joyPub == null){\n      this.joyIndex = reach(event, 'detail.index')\n      \n      debug('advertising /joy idx=',this.joyIndex)\n      this.joyPub = new ROSLIB.Topic({\n        ros : this.ros,\n        name : '/joy',\n        messageType : 'sensor_msgs/Joy'\n      })\n  \n      this.joyPub.advertise()\n\n      this.updateJoy(gamepad)\n\n    }\n  }\n\n  removeGamepad(event){\n    debug('removeGamepad', event)\n\n    //! cleanup timer\n    if(this.joyRepeatTimer != null){\n      clearTimeout(this.joyRepeatTimer)\n      this.joyRepeatTimer = null\n    }\n\n    //! cleanup publisher\n    if(this.joyPub != null && event.detail.index == this.joyIndex){\n      this.joyPub.unadvertise()\n    }\n\n\n    this.joyPub = null\n    this.joyIndex = null\n    this.joyUserOptIn = null\n    this.joyEnabled = false\n  }\n\n  getJoyMsgFromGamepad(gamepad){\n    return new ROSLIB.Message({\n      axes: [...gamepad.axes],\n      buttons: gamepad.buttons.map( btn => parseInt(btn.value) )\n    })\n  }\n\n  autoUpdateJoy(){\n    if(this.joyMsg!=null && this.joyEnabled == true){\n      this.joyPub.publish(this.joyMsg)\n\n      this.joyRepeatTimer = null\n      this.debounceJoyAutoUpdate()\n    }\n  }\n\n  debounceJoyAutoUpdate(){\n    if(this.joyAutoRepeatRate > 0.0){\n      let repeatMs = 1000.0 / this.joyAutoRepeatRate\n      if(this.joyRepeatTimer != null){\n        clearTimeout(this.joyRepeatTimer)\n      }\n\n      //! set timer further into the future\n      this.joyRepeatTimer = setTimeout(this.autoUpdateJoy.bind(this), repeatMs)\n\n    }\n  }\n\n  updateJoy(gamepad){\n\n    if(!this.joyEnabled){return}\n\n    this.joyMsg = this.getJoyMsgFromGamepad(gamepad)\n\n    this.joyPub.publish(this.joyMsg)\n    this.debounceJoyAutoUpdate()\n  }\n\n  onAxisChange(event){\n    if(this.joyIndex != reach(event,'detail.index')){ return }\n\n    const gamepad = reach(event, 'detail.gamepad')\n    this.updateJoy(gamepad)\n  }\n\n  onButtonChange(event){\n    if(this.joyIndex != reach(event,'detail.index')){ return }\n\n    const gamepad = reach(event, 'detail.gamepad')\n    this.updateJoy(gamepad)\n  }\n\n  async renderFromFile(){\n\n    let displays = reach(this.fileContent, 'Visualization Manager.Displays', [])\n\n    for(let display of displays){\n      //debug(`parsing display '${display.Class}'`, { display })\n\n      if(!display.Enabled){\n        debug(`skipping ${display.Class}`)\n        continue\n      }\n\n      let obj = undefined;\n      switch (display.Class) {\n        case 'rviz/Grid':\n          debug('display.color', display.Color)\n          obj=new ROS3D.Grid({\n            color: TeleOp.rvizColor2hex(display.Color, '#ff1010'),\n            cellSize: display['Cell Size'],\n            num_cells: display['Plane Cell Count']\n          })\n          this.viewer.addObject(obj)\n          break\n        case 'rviz/TF':\n          debug(display.Class, display.Name)\n          const allEnabled = display.Frames['All Enabled'] || false\n\n          const frames = Object.fromEntries(\n            Object.entries(display.Frames)\n            .map(([key,value])=> {\n              return [key, allEnabled || value.Value && true]\n            })\n            .filter(([key, value]) => key != 'All Enabled')\n          )\n          \n          debug('\\t','frames', frames)\n          obj = new TfTree({\n            frames,\n            ros: this.ros,\n            tfClient: this.tfClient,\n            rootObject: this.viewer.scene,\n            scale: parseFloat(display['Marker Scale']),\n            showAxes: display['Show Axes'],\n            showNames: display['Show Names'],\n            showArrows: display['Show Arrows']\n          })\n\n          await obj.setup()\n          break;\n        case 'rviz/LaserScan':\n          debug(display.Class, display.Topic)\n\n          obj = new ROS3D.LaserScan({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            tfClient: this.tfClient,\n            color: display.color, // need to check if this is in the right format\n            // texture: , // (optional) Image url for a texture to use for the points. Defaults to a single white pixel.\n            rootObject: this.viewer.scene,\n            material: {\n              size: display['Size (Pixels)'], // (optional) defaults to 0.05\n            },\n            max_pts: 50000 // (optional) defaults to 100\n          })\n          break\n        case 'rviz/PointCloud2':\n          debug(display.Class, display.Topic)\n          obj = new ROS3D.PointCloud2({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            max_pts: 50000,\n            //colorsrc: display[\"Color Transformer\"],\n            material: { \n              size: 0.02\n            }\n          })\n\n          //debug('\\t','pt', display[\"Color Transformer\"])\n          break\n        case 'rviz/Marker':\n          debug(display.Class, display['Marker Topic'])\n          obj = new ROS3D.MarkerClient({\n            ros: this.ros,\n            topic: `${display['Marker Topic']}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient\n          })\n          break\n        case 'rviz/MarkerArray':\n          debug(display.Class, display['Marker Topic'])\n          obj = new ROS3D.MarkerArrayClient({\n            ros: this.ros,\n            topic: `${display['Marker Topic']}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient\n          })\n          break\n        case 'rviz/Map':\n          debug(display.Class, display.Topic)\n          obj = new ROS3D.OccupancyGridClient({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            continuous: true\n          })\n          break\n        case 'rviz/Odometry':\n          debug(display.Class, display.Topic)\n          obj = new ROS3D.Odometry({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            keep: display.Keep,\n            length: reach(display, 'Shape.Axes Length'),\n            headlength: reach(display, 'Shape.Head Length'),\n            shaftLength: reach(display, 'Shape.Shaft Length'),\n            headDiameter: reach(display, 'Shape.Head Radius')*2.0,\n            shaftDiameter: reach(display, 'Shape.Shaft Radius')*2.0,\n            color: TeleOp.rvizColor2hex(reach(display,'Shape.Color'), '#cc00ff')\n          })\n          break\n        case 'rviz/Path':\n          debug(display.Class)\n          obj = new ROS3D.Path({\n            ros: this.ros,\n            topic: `${display.Topic}`,\n            rootObject: this.viewer.scene,\n            tfClient: this.tfClient,\n            color: TeleOp.rvizColor2hex(display.Color, '#cc00ff')\n          })\n          break\n        case 'rviz/RobotModel':\n          debug(display.Class)\n          //console.log(display)\n\n          let paramPath = path.join('/', display['Robot Description'])\n\n          //console.log(paramPath)\n\n          const urdfText = await new Promise((resolve,reject)=>{\n            let descParam = new ROSLIB.Param({\n              ros: this.ros, name: paramPath\n            })\n\n            descParam.get(val=>{ resolve(val) })\n          })\n\n          debug('\\t','urdf', urdfText)\n\n          let publicModelPath = ''\n          if(urdfText != null && urdfText.length > 0){\n            let parser = new DOMParser()\n            let xmlDoc = parser.parseFromString(urdfText, 'text/xml')\n\n            const robotTag = xmlDoc.getElementsByTagName('robot')[0]\n            const robotName = robotTag.getAttribute('name')\n            debug('\\t','urdf robot name', robotName, robotName.indexOf('magni'))\n            if(robotName.indexOf('magni') != -1){\n              publicModelPath = 'https://raw.githubusercontent.com/UbiquityRobotics/magni_robot/noetic-devel'\n            }\n\n            try{\n              obj = new ROS3D.UrdfClient({\n                path: publicModelPath,\n                ros: this.ros,\n                param: paramPath,\n                rootObject: this.viewer.scene,\n                tfClient: this.tfClient,\n                tfPrefix: display['TF Prefix']\n              })\n            }\n            catch(err){\n              debug('\\t','urdf error', err)\n              //delete obj\n              obj = null\n            }\n            \n  \n            debug('\\t',obj)\n          }\n          \n          break\n        case 'rviz/InteractiveMarkers':\n          debug(display.Class, display['Update Topic'])\n\n          const topic = display['Update Topic'].replace('/update','')\n\n          debug('\\t', 'topic', topic)\n\n          obj = new ROS3D.InteractiveMarkerClient({\n            topic,\n            ros: this.ros,\n            tfClient: this.tfClient,\n            camera: this.viewer.camera,\n            rootObject: this.viewer.selectableObjects,\n          })\n\n          break;\n        default:\n          console.warn(`display class '${display.Class}' not supported`)\n          console.warn(display)\n          break\n      }\n\n      if (obj) {\n        debug(obj)\n      }\n    }\n\n  }\n\n\n\n  disableViz() {\n    /** @todo */\n    debug('disable viz - not implemented')\n  }\n\n\n  static rvizColor2hex(color, defaultHex) {\n    if (!color) { return defaultHex }\n    return TeleOp.rgb2hex(color.replace(/;/g, ','))\n  }\n  \n  static rgb2hex(rgb) {\n    rgb = rgb.match(/[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n    return (rgb && rgb.length === 4) ? \"#\" +\n      (\"0\" + parseInt(rgb[1], 10).toString(16)).slice(-2) +\n      (\"0\" + parseInt(rgb[2], 10).toString(16)).slice(-2) +\n      (\"0\" + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';\n  }\n}\n\nmodule.exports=TeleOp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLGtEQUFPO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQywrQkFBUztBQUMvQixhQUFhLG1CQUFPLENBQUMsa0RBQU07QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHFEQUFNOztBQUUzQixZQUFZLG1CQUFPLENBQUMsdUNBQWlCOztBQUVyQyxRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsd0RBQVk7OztBQUdoRDtBQUNBO0FBQ0E7OztBQUdBLGVBQWUsbUJBQU8sQ0FBQyxpQ0FBVTs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdDQUFnQzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7O0FBR1IsNkJBQTZCLGVBQWU7Ozs7QUFJNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLGNBQWMsTUFBTSxTQUFTOztBQUUvRDtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixpQ0FBaUMsY0FBYztBQUMvQyxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esa0JBQWtCO0FBQ2xCLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgndGVsZW9weHl6LlRlbGVPcCcpXG5jb25zdCByZWFjaCA9IHJlcXVpcmUoJy4vcmVhY2gnKVxuY29uc3QgeWFtbCA9IHJlcXVpcmUoJ3lhbWwnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5jb25zdCBQa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKVxuXG5jb25zdCB7IEdhbWVwYWRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnZ2FtZXBhZC5qcycpXG5cblxuY29uc29sZS5sb2coUGtnLm5hbWUsICd2JytQa2cudmVyc2lvbiwgJ/CfpJYnKVxuY29uc29sZS5sb2coJ3NlbnNlLCBwbGFuLCBwYXJ0eSDwn6SYJylcbmNvbnNvbGUubG9nKCdcXG5cXG5XZWxjb21lIGZlbGxvdyBodW1hbnNcXG5cXG5zZXQgbG9jYWxTdG9yYWdlLmRlYnVnPVxcJypcXCcgdG8gYWN0aXZhdGUgZGVidWcgb3V0cHV0JylcblxuXG5jb25zdCBUZlRyZWUgPSByZXF1aXJlKCcuL1RmVHJlZScpXG5cbmNsYXNzIFRlbGVPcCB7XG4gIGNvbnN0cnVjdG9yKCl7XG4gICAgZGVidWcoJ25ldyBUZWxlT3AnKVxuXG4gICAgdGhpcy5yb3MgPSBudWxsXG4gICAgdGhpcy5ob3N0ID0gbnVsbFxuICAgIHRoaXMuZmlsZUNvbnRlbnQgPSBudWxsXG4gICAgdGhpcy5kaXZJZCA9IG51bGxcbiAgICB0aGlzLnZpZXdlciA9IG51bGxcbiAgICB0aGlzLnRmQ2xpZW50ID0gbnVsbFxuICAgIHRoaXMuYmFzZUxpbmsgPSBudWxsXG4gIHRoaXMuZ2FtZXBhZExpc3RlbmVyID0gbmV3IEdhbWVwYWRMaXN0ZW5lcih7YW5hbG9nOiB0cnVlLyosIGRlYWRab25lOiAwLjIqL30pXG5cbiAgICB0aGlzLmpveU1zZyA9IG51bGxcbiAgICB0aGlzLmpveUluZGV4ID0gbnVsbFxuICAgIHRoaXMuam95UHViID0gbnVsbFxuICAgIHRoaXMuam95RW5hYmxlZCA9IGZhbHNlXG4gICAgdGhpcy5qb3lVc2VyT3B0SW4gPSBudWxsXG4gICAgdGhpcy5qb3lBdXRvUmVwZWF0UmF0ZSA9IDRcbiAgICB0aGlzLmpveVJlcGVhdFRpbWVyID0gbnVsbFxuICB9XG5cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCl7XG4gICAgcmV0dXJuIFBrZy52ZXJzaW9uXG4gIH1cblxuICBhc3luYyBjb25uZWN0Um9zKCl7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntcblxuICAgICAgLy8gQ29ubmVjdCB0byBST1MuXG4gICAgICB0aGlzLnJvcyA9IG5ldyBST1NMSUIuUm9zKHtcbiAgICAgICAgdXJsIDogdGhpcy5ob3N0XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5yb3Mub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgIGRlYnVnKCdDb25uZWN0aW9uIGVycm9yICcgKyB0aGlzLmhvc3QpXG4gICAgICAgIGRlYnVnKGVycm9yKVxuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIC8vIEZpbmQgb3V0IGV4YWN0bHkgd2hlbiB3ZSBtYWRlIGEgY29ubmVjdGlvbi5cbiAgICAgIHRoaXMucm9zLm9uKCdjb25uZWN0aW9uJywgKCkgPT4ge1xuICAgICAgICBkZWJ1ZygnQ29ubmVjdGlvbiBvcGVuICcgKyB0aGlzLmhvc3QpXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgb25SZXNpemUoZXZlbnQpIHtcbiAgICBkZWJ1ZygncmVzaXplJywgZXZlbnQpXG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmRpdi5jbGllbnRXaWR0aFxuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZGl2LmNsaWVudEhlaWdodFxuICAgIGRlYnVnKCdzaXplJywgd2lkdGgsIGhlaWdodClcbiAgICB0aGlzLnZpZXdlci5yZXNpemUod2lkdGgsIGhlaWdodClcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0KGhvc3QsIHJ2aXpGaWxlLCBkaXZJZD1cInZpZXdlclwiKXtcbiAgICBkZWJ1Zygnc3RhcnQnKVxuXG4gICAgdGhpcy5ob3N0ID0gaG9zdFxuICAgIHRoaXMuZGl2SWQgPSBkaXZJZFxuICAgIHRoaXMuZmlsZUNvbnRlbnQgPSB5YW1sLnBhcnNlKHJ2aXpGaWxlKVxuXG4gICAgdGhpcy5kaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmRpdklkKVxuXG4gICAgZGVidWcoJ2ZpbGVDb250ZW50JywgdGhpcy5maWxlQ29udGVudClcblxuICAgIGF3YWl0IHRoaXMuY29ubmVjdFJvcygpXG5cbiAgICBsZXQgZ2xvYmFsT3B0aW9ucyA9IHtcbiAgICAgIGJhY2tncm91bmQ6IFRlbGVPcC5ydml6Q29sb3IyaGV4KHJlYWNoKHRoaXMuZmlsZUNvbnRlbnQsICdWaXN1YWxpemF0aW9uIE1hbmFnZXIuR2xvYmFsIE9wdGlvbnMuQmFja2dyb3VuZCBDb2xvcicpLCBudWxsKSxcbiAgICAgIGZpeGVkRnJhbWU6IHJlYWNoKHRoaXMuZmlsZUNvbnRlbnQsICdWaXN1YWxpemF0aW9uIE1hbmFnZXIuR2xvYmFsIE9wdGlvbnMuRml4ZWQgRnJhbWUnLCAnL2Jhc2VfbGluaycpLFxuICAgICAgZnJhbWVSYXRlOiByZWFjaCh0aGlzLmZpbGVDb250ZW50LCAnVmlzdWFsaXphdGlvbiBNYW5hZ2VyLkdsb2JhbCBPcHRpb25zLkZyYW1lIFJhdGUnLCAzMClcbiAgICB9XG5cbiAgICB0aGlzLnZpZXdlciA9IG5ldyBST1MzRC5WaWV3ZXIoe1xuICAgICAgZGl2SUQ6IHRoaXMuZGl2SWQsXG4gICAgICB3aWR0aDogdGhpcy5kaXYuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuZGl2LmNsaWVudEhlaWdodCxcbiAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgIGJhY2tncm91bmQ6IGdsb2JhbE9wdGlvbnMuYmFja2dyb3VuZFxuICAgIH0pO1xuXG4gICAgd2luZG93Lm9ucmVzaXplID0gKGUpPT57dGhpcy5vblJlc2l6ZShlKX1cblxuICAgIC8qdGhpcy52aWV3ZXIuYWRkT2JqZWN0KG5ldyBST1MzRC5HcmlkKHtcbiAgICAgIGNvbG9yOicjMDE4MWM0JyxcbiAgICAgIGNlbGxTaXplOiAxLjAsXG4gICAgICBudW1fY2VsbHM6IDIwXG4gICAgfSkpOyovXG5cblxuICAgIGNvbnNvbGUubG9nKCdHbG9iYWxzJywgeyBnbG9iYWxPcHRpb25zIH0pXG5cblxuXG4gICAgdGhpcy50ZkNsaWVudCA9IG5ldyBST1NMSUIuVEZDbGllbnQoe1xuICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgIHNlcnZlck5hbWU6IGAvdGYyX3dlYl9yZXB1Ymxpc2hlcmAsICAgLy8hIE5lZWQgdG8gbWFrZSBjb25maWd1cmFibGUgYW5kIGF1dG9kZXRlY3QgY29ycmVjdCBvbmUgb24gdGhlIGZseVxuICAgICAgYW5ndWxhclRocmVzOiAwLjAzLFxuICAgICAgdHJhbnNUaHJlczogMC4wMSxcbiAgICAgIC8vcmF0ZTogZ2xvYmFsT3B0aW9ucy5mcmFtZVJhdGUsXG4gICAgICBmaXhlZEZyYW1lOiBnbG9iYWxPcHRpb25zLmZpeGVkRnJhbWVcbiAgICB9KVxuXG4gICAgdGhpcy5nYW1lcGFkTGlzdGVuZXIub24oJ2dhbWVwYWQ6Y29ubmVjdGVkJywgdGhpcy5hZGRHYW1lcGFkLmJpbmQodGhpcykpXG4gICAgdGhpcy5nYW1lcGFkTGlzdGVuZXIub24oJ2dhbWVwYWQ6ZGlzY29ubmVjdGVkJywgdGhpcy5yZW1vdmVHYW1lcGFkLmJpbmQodGhpcykpXG4gICAgdGhpcy5nYW1lcGFkTGlzdGVuZXIub24oJ2dhbWVwYWQ6YXhpcycsIHRoaXMub25BeGlzQ2hhbmdlLmJpbmQodGhpcykpXG4gICAgdGhpcy5nYW1lcGFkTGlzdGVuZXIub24oJ2dhbWVwYWQ6YnV0dG9uJywgdGhpcy5vbkF4aXNDaGFuZ2UuYmluZCh0aGlzKSlcblxuICAgIHRoaXMuZ2FtZXBhZExpc3RlbmVyLnN0YXJ0KClcblxuICAgIGF3YWl0IHRoaXMucmVuZGVyRnJvbUZpbGUoKVxuICB9XG5cbiAgYWRkR2FtZXBhZChldmVudCl7XG4gICAgZGVidWcoJ2FkZEdhbWVwYWQnLCBldmVudClcbiAgICBjb25zdCBnYW1lcGFkID0gcmVhY2goZXZlbnQsICdkZXRhaWwuZ2FtZXBhZCcpXG5cbiAgICBpZih0aGlzLmpveVVzZXJPcHRJbiA9PSBudWxsKXtcbiAgICAgIGRlYnVnKCdwcm9tcHRpbmcgdXNlciBmb3IgZ2FtZXBhZC9qb3kgc3VwcG9ydCBvcHQtaW4nKVxuICAgICAgdGhpcy5qb3lVc2VyT3B0SW4gPSB3aW5kb3cuY29uZmlybSgnR2FtZXBhZCBkZXRlY3RlZCAtIHdvdWxkIHlvdSBsaWtlIHRvIHVzZSBpdCBhcyBhIC9qb3kgcHVibGlzaGVyP1xcblxcbicrZ2FtZXBhZC5pZClcbiAgICAgIHRoaXMuam95RW5hYmxlZCA9IHRoaXMuam95VXNlck9wdEluXG5cbiAgICAgIGRlYnVnKCdqb3lVc2VyT3B0SW4gPScsIHRoaXMuam95VXNlck9wdEluKVxuICAgIH1cblxuICAgIGlmKHRoaXMuam95VXNlck9wdEluID09IGZhbHNlKXsgcmV0dXJuIH1cblxuICAgIGlmKHRoaXMuam95UHViID09IG51bGwpe1xuICAgICAgdGhpcy5qb3lJbmRleCA9IHJlYWNoKGV2ZW50LCAnZGV0YWlsLmluZGV4JylcbiAgICAgIFxuICAgICAgZGVidWcoJ2FkdmVydGlzaW5nIC9qb3kgaWR4PScsdGhpcy5qb3lJbmRleClcbiAgICAgIHRoaXMuam95UHViID0gbmV3IFJPU0xJQi5Ub3BpYyh7XG4gICAgICAgIHJvcyA6IHRoaXMucm9zLFxuICAgICAgICBuYW1lIDogJy9qb3knLFxuICAgICAgICBtZXNzYWdlVHlwZSA6ICdzZW5zb3JfbXNncy9Kb3knXG4gICAgICB9KVxuICBcbiAgICAgIHRoaXMuam95UHViLmFkdmVydGlzZSgpXG5cbiAgICAgIHRoaXMudXBkYXRlSm95KGdhbWVwYWQpXG5cbiAgICB9XG4gIH1cblxuICByZW1vdmVHYW1lcGFkKGV2ZW50KXtcbiAgICBkZWJ1ZygncmVtb3ZlR2FtZXBhZCcsIGV2ZW50KVxuXG4gICAgLy8hIGNsZWFudXAgdGltZXJcbiAgICBpZih0aGlzLmpveVJlcGVhdFRpbWVyICE9IG51bGwpe1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuam95UmVwZWF0VGltZXIpXG4gICAgICB0aGlzLmpveVJlcGVhdFRpbWVyID0gbnVsbFxuICAgIH1cblxuICAgIC8vISBjbGVhbnVwIHB1Ymxpc2hlclxuICAgIGlmKHRoaXMuam95UHViICE9IG51bGwgJiYgZXZlbnQuZGV0YWlsLmluZGV4ID09IHRoaXMuam95SW5kZXgpe1xuICAgICAgdGhpcy5qb3lQdWIudW5hZHZlcnRpc2UoKVxuICAgIH1cblxuXG4gICAgdGhpcy5qb3lQdWIgPSBudWxsXG4gICAgdGhpcy5qb3lJbmRleCA9IG51bGxcbiAgICB0aGlzLmpveVVzZXJPcHRJbiA9IG51bGxcbiAgICB0aGlzLmpveUVuYWJsZWQgPSBmYWxzZVxuICB9XG5cbiAgZ2V0Sm95TXNnRnJvbUdhbWVwYWQoZ2FtZXBhZCl7XG4gICAgcmV0dXJuIG5ldyBST1NMSUIuTWVzc2FnZSh7XG4gICAgICBheGVzOiBbLi4uZ2FtZXBhZC5heGVzXSxcbiAgICAgIGJ1dHRvbnM6IGdhbWVwYWQuYnV0dG9ucy5tYXAoIGJ0biA9PiBwYXJzZUludChidG4udmFsdWUpIClcbiAgICB9KVxuICB9XG5cbiAgYXV0b1VwZGF0ZUpveSgpe1xuICAgIGlmKHRoaXMuam95TXNnIT1udWxsICYmIHRoaXMuam95RW5hYmxlZCA9PSB0cnVlKXtcbiAgICAgIHRoaXMuam95UHViLnB1Ymxpc2godGhpcy5qb3lNc2cpXG5cbiAgICAgIHRoaXMuam95UmVwZWF0VGltZXIgPSBudWxsXG4gICAgICB0aGlzLmRlYm91bmNlSm95QXV0b1VwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgZGVib3VuY2VKb3lBdXRvVXBkYXRlKCl7XG4gICAgaWYodGhpcy5qb3lBdXRvUmVwZWF0UmF0ZSA+IDAuMCl7XG4gICAgICBsZXQgcmVwZWF0TXMgPSAxMDAwLjAgLyB0aGlzLmpveUF1dG9SZXBlYXRSYXRlXG4gICAgICBpZih0aGlzLmpveVJlcGVhdFRpbWVyICE9IG51bGwpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5qb3lSZXBlYXRUaW1lcilcbiAgICAgIH1cblxuICAgICAgLy8hIHNldCB0aW1lciBmdXJ0aGVyIGludG8gdGhlIGZ1dHVyZVxuICAgICAgdGhpcy5qb3lSZXBlYXRUaW1lciA9IHNldFRpbWVvdXQodGhpcy5hdXRvVXBkYXRlSm95LmJpbmQodGhpcyksIHJlcGVhdE1zKVxuXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSm95KGdhbWVwYWQpe1xuXG4gICAgaWYoIXRoaXMuam95RW5hYmxlZCl7cmV0dXJufVxuXG4gICAgdGhpcy5qb3lNc2cgPSB0aGlzLmdldEpveU1zZ0Zyb21HYW1lcGFkKGdhbWVwYWQpXG5cbiAgICB0aGlzLmpveVB1Yi5wdWJsaXNoKHRoaXMuam95TXNnKVxuICAgIHRoaXMuZGVib3VuY2VKb3lBdXRvVXBkYXRlKClcbiAgfVxuXG4gIG9uQXhpc0NoYW5nZShldmVudCl7XG4gICAgaWYodGhpcy5qb3lJbmRleCAhPSByZWFjaChldmVudCwnZGV0YWlsLmluZGV4JykpeyByZXR1cm4gfVxuXG4gICAgY29uc3QgZ2FtZXBhZCA9IHJlYWNoKGV2ZW50LCAnZGV0YWlsLmdhbWVwYWQnKVxuICAgIHRoaXMudXBkYXRlSm95KGdhbWVwYWQpXG4gIH1cblxuICBvbkJ1dHRvbkNoYW5nZShldmVudCl7XG4gICAgaWYodGhpcy5qb3lJbmRleCAhPSByZWFjaChldmVudCwnZGV0YWlsLmluZGV4JykpeyByZXR1cm4gfVxuXG4gICAgY29uc3QgZ2FtZXBhZCA9IHJlYWNoKGV2ZW50LCAnZGV0YWlsLmdhbWVwYWQnKVxuICAgIHRoaXMudXBkYXRlSm95KGdhbWVwYWQpXG4gIH1cblxuICBhc3luYyByZW5kZXJGcm9tRmlsZSgpe1xuXG4gICAgbGV0IGRpc3BsYXlzID0gcmVhY2godGhpcy5maWxlQ29udGVudCwgJ1Zpc3VhbGl6YXRpb24gTWFuYWdlci5EaXNwbGF5cycsIFtdKVxuXG4gICAgZm9yKGxldCBkaXNwbGF5IG9mIGRpc3BsYXlzKXtcbiAgICAgIC8vZGVidWcoYHBhcnNpbmcgZGlzcGxheSAnJHtkaXNwbGF5LkNsYXNzfSdgLCB7IGRpc3BsYXkgfSlcblxuICAgICAgaWYoIWRpc3BsYXkuRW5hYmxlZCl7XG4gICAgICAgIGRlYnVnKGBza2lwcGluZyAke2Rpc3BsYXkuQ2xhc3N9YClcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgbGV0IG9iaiA9IHVuZGVmaW5lZDtcbiAgICAgIHN3aXRjaCAoZGlzcGxheS5DbGFzcykge1xuICAgICAgICBjYXNlICdydml6L0dyaWQnOlxuICAgICAgICAgIGRlYnVnKCdkaXNwbGF5LmNvbG9yJywgZGlzcGxheS5Db2xvcilcbiAgICAgICAgICBvYmo9bmV3IFJPUzNELkdyaWQoe1xuICAgICAgICAgICAgY29sb3I6IFRlbGVPcC5ydml6Q29sb3IyaGV4KGRpc3BsYXkuQ29sb3IsICcjZmYxMDEwJyksXG4gICAgICAgICAgICBjZWxsU2l6ZTogZGlzcGxheVsnQ2VsbCBTaXplJ10sXG4gICAgICAgICAgICBudW1fY2VsbHM6IGRpc3BsYXlbJ1BsYW5lIENlbGwgQ291bnQnXVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy52aWV3ZXIuYWRkT2JqZWN0KG9iailcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdydml6L1RGJzpcbiAgICAgICAgICBkZWJ1ZyhkaXNwbGF5LkNsYXNzLCBkaXNwbGF5Lk5hbWUpXG4gICAgICAgICAgY29uc3QgYWxsRW5hYmxlZCA9IGRpc3BsYXkuRnJhbWVzWydBbGwgRW5hYmxlZCddIHx8IGZhbHNlXG5cbiAgICAgICAgICBjb25zdCBmcmFtZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhkaXNwbGF5LkZyYW1lcylcbiAgICAgICAgICAgIC5tYXAoKFtrZXksdmFsdWVdKT0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIGFsbEVuYWJsZWQgfHwgdmFsdWUuVmFsdWUgJiYgdHJ1ZV1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IGtleSAhPSAnQWxsIEVuYWJsZWQnKVxuICAgICAgICAgIClcbiAgICAgICAgICBcbiAgICAgICAgICBkZWJ1ZygnXFx0JywnZnJhbWVzJywgZnJhbWVzKVxuICAgICAgICAgIG9iaiA9IG5ldyBUZlRyZWUoe1xuICAgICAgICAgICAgZnJhbWVzLFxuICAgICAgICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgICAgICAgIHRmQ2xpZW50OiB0aGlzLnRmQ2xpZW50LFxuICAgICAgICAgICAgcm9vdE9iamVjdDogdGhpcy52aWV3ZXIuc2NlbmUsXG4gICAgICAgICAgICBzY2FsZTogcGFyc2VGbG9hdChkaXNwbGF5WydNYXJrZXIgU2NhbGUnXSksXG4gICAgICAgICAgICBzaG93QXhlczogZGlzcGxheVsnU2hvdyBBeGVzJ10sXG4gICAgICAgICAgICBzaG93TmFtZXM6IGRpc3BsYXlbJ1Nob3cgTmFtZXMnXSxcbiAgICAgICAgICAgIHNob3dBcnJvd3M6IGRpc3BsYXlbJ1Nob3cgQXJyb3dzJ11cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgYXdhaXQgb2JqLnNldHVwKClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncnZpei9MYXNlclNjYW4nOlxuICAgICAgICAgIGRlYnVnKGRpc3BsYXkuQ2xhc3MsIGRpc3BsYXkuVG9waWMpXG5cbiAgICAgICAgICBvYmogPSBuZXcgUk9TM0QuTGFzZXJTY2FuKHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0b3BpYzogYCR7ZGlzcGxheS5Ub3BpY31gLFxuICAgICAgICAgICAgdGZDbGllbnQ6IHRoaXMudGZDbGllbnQsXG4gICAgICAgICAgICBjb2xvcjogZGlzcGxheS5jb2xvciwgLy8gbmVlZCB0byBjaGVjayBpZiB0aGlzIGlzIGluIHRoZSByaWdodCBmb3JtYXRcbiAgICAgICAgICAgIC8vIHRleHR1cmU6ICwgLy8gKG9wdGlvbmFsKSBJbWFnZSB1cmwgZm9yIGEgdGV4dHVyZSB0byB1c2UgZm9yIHRoZSBwb2ludHMuIERlZmF1bHRzIHRvIGEgc2luZ2xlIHdoaXRlIHBpeGVsLlxuICAgICAgICAgICAgcm9vdE9iamVjdDogdGhpcy52aWV3ZXIuc2NlbmUsXG4gICAgICAgICAgICBtYXRlcmlhbDoge1xuICAgICAgICAgICAgICBzaXplOiBkaXNwbGF5WydTaXplIChQaXhlbHMpJ10sIC8vIChvcHRpb25hbCkgZGVmYXVsdHMgdG8gMC4wNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heF9wdHM6IDUwMDAwIC8vIChvcHRpb25hbCkgZGVmYXVsdHMgdG8gMTAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdydml6L1BvaW50Q2xvdWQyJzpcbiAgICAgICAgICBkZWJ1ZyhkaXNwbGF5LkNsYXNzLCBkaXNwbGF5LlRvcGljKVxuICAgICAgICAgIG9iaiA9IG5ldyBST1MzRC5Qb2ludENsb3VkMih7XG4gICAgICAgICAgICByb3M6IHRoaXMucm9zLFxuICAgICAgICAgICAgdG9waWM6IGAke2Rpc3BsYXkuVG9waWN9YCxcbiAgICAgICAgICAgIHJvb3RPYmplY3Q6IHRoaXMudmlld2VyLnNjZW5lLFxuICAgICAgICAgICAgdGZDbGllbnQ6IHRoaXMudGZDbGllbnQsXG4gICAgICAgICAgICBtYXhfcHRzOiA1MDAwMCxcbiAgICAgICAgICAgIC8vY29sb3JzcmM6IGRpc3BsYXlbXCJDb2xvciBUcmFuc2Zvcm1lclwiXSxcbiAgICAgICAgICAgIG1hdGVyaWFsOiB7IFxuICAgICAgICAgICAgICBzaXplOiAwLjAyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIC8vZGVidWcoJ1xcdCcsJ3B0JywgZGlzcGxheVtcIkNvbG9yIFRyYW5zZm9ybWVyXCJdKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3J2aXovTWFya2VyJzpcbiAgICAgICAgICBkZWJ1ZyhkaXNwbGF5LkNsYXNzLCBkaXNwbGF5WydNYXJrZXIgVG9waWMnXSlcbiAgICAgICAgICBvYmogPSBuZXcgUk9TM0QuTWFya2VyQ2xpZW50KHtcbiAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICB0b3BpYzogYCR7ZGlzcGxheVsnTWFya2VyIFRvcGljJ119YCxcbiAgICAgICAgICAgIHJvb3RPYmplY3Q6IHRoaXMudmlld2VyLnNjZW5lLFxuICAgICAgICAgICAgdGZDbGllbnQ6IHRoaXMudGZDbGllbnRcbiAgICAgICAgICB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3J2aXovTWFya2VyQXJyYXknOlxuICAgICAgICAgIGRlYnVnKGRpc3BsYXkuQ2xhc3MsIGRpc3BsYXlbJ01hcmtlciBUb3BpYyddKVxuICAgICAgICAgIG9iaiA9IG5ldyBST1MzRC5NYXJrZXJBcnJheUNsaWVudCh7XG4gICAgICAgICAgICByb3M6IHRoaXMucm9zLFxuICAgICAgICAgICAgdG9waWM6IGAke2Rpc3BsYXlbJ01hcmtlciBUb3BpYyddfWAsXG4gICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zY2VuZSxcbiAgICAgICAgICAgIHRmQ2xpZW50OiB0aGlzLnRmQ2xpZW50XG4gICAgICAgICAgfSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdydml6L01hcCc6XG4gICAgICAgICAgZGVidWcoZGlzcGxheS5DbGFzcywgZGlzcGxheS5Ub3BpYylcbiAgICAgICAgICBvYmogPSBuZXcgUk9TM0QuT2NjdXBhbmN5R3JpZENsaWVudCh7XG4gICAgICAgICAgICByb3M6IHRoaXMucm9zLFxuICAgICAgICAgICAgdG9waWM6IGAke2Rpc3BsYXkuVG9waWN9YCxcbiAgICAgICAgICAgIHJvb3RPYmplY3Q6IHRoaXMudmlld2VyLnNjZW5lLFxuICAgICAgICAgICAgdGZDbGllbnQ6IHRoaXMudGZDbGllbnQsXG4gICAgICAgICAgICBjb250aW51b3VzOiB0cnVlXG4gICAgICAgICAgfSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdydml6L09kb21ldHJ5JzpcbiAgICAgICAgICBkZWJ1ZyhkaXNwbGF5LkNsYXNzLCBkaXNwbGF5LlRvcGljKVxuICAgICAgICAgIG9iaiA9IG5ldyBST1MzRC5PZG9tZXRyeSh7XG4gICAgICAgICAgICByb3M6IHRoaXMucm9zLFxuICAgICAgICAgICAgdG9waWM6IGAke2Rpc3BsYXkuVG9waWN9YCxcbiAgICAgICAgICAgIHJvb3RPYmplY3Q6IHRoaXMudmlld2VyLnNjZW5lLFxuICAgICAgICAgICAgdGZDbGllbnQ6IHRoaXMudGZDbGllbnQsXG4gICAgICAgICAgICBrZWVwOiBkaXNwbGF5LktlZXAsXG4gICAgICAgICAgICBsZW5ndGg6IHJlYWNoKGRpc3BsYXksICdTaGFwZS5BeGVzIExlbmd0aCcpLFxuICAgICAgICAgICAgaGVhZGxlbmd0aDogcmVhY2goZGlzcGxheSwgJ1NoYXBlLkhlYWQgTGVuZ3RoJyksXG4gICAgICAgICAgICBzaGFmdExlbmd0aDogcmVhY2goZGlzcGxheSwgJ1NoYXBlLlNoYWZ0IExlbmd0aCcpLFxuICAgICAgICAgICAgaGVhZERpYW1ldGVyOiByZWFjaChkaXNwbGF5LCAnU2hhcGUuSGVhZCBSYWRpdXMnKSoyLjAsXG4gICAgICAgICAgICBzaGFmdERpYW1ldGVyOiByZWFjaChkaXNwbGF5LCAnU2hhcGUuU2hhZnQgUmFkaXVzJykqMi4wLFxuICAgICAgICAgICAgY29sb3I6IFRlbGVPcC5ydml6Q29sb3IyaGV4KHJlYWNoKGRpc3BsYXksJ1NoYXBlLkNvbG9yJyksICcjY2MwMGZmJylcbiAgICAgICAgICB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3J2aXovUGF0aCc6XG4gICAgICAgICAgZGVidWcoZGlzcGxheS5DbGFzcylcbiAgICAgICAgICBvYmogPSBuZXcgUk9TM0QuUGF0aCh7XG4gICAgICAgICAgICByb3M6IHRoaXMucm9zLFxuICAgICAgICAgICAgdG9waWM6IGAke2Rpc3BsYXkuVG9waWN9YCxcbiAgICAgICAgICAgIHJvb3RPYmplY3Q6IHRoaXMudmlld2VyLnNjZW5lLFxuICAgICAgICAgICAgdGZDbGllbnQ6IHRoaXMudGZDbGllbnQsXG4gICAgICAgICAgICBjb2xvcjogVGVsZU9wLnJ2aXpDb2xvcjJoZXgoZGlzcGxheS5Db2xvciwgJyNjYzAwZmYnKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncnZpei9Sb2JvdE1vZGVsJzpcbiAgICAgICAgICBkZWJ1ZyhkaXNwbGF5LkNsYXNzKVxuICAgICAgICAgIC8vY29uc29sZS5sb2coZGlzcGxheSlcblxuICAgICAgICAgIGxldCBwYXJhbVBhdGggPSBwYXRoLmpvaW4oJy8nLCBkaXNwbGF5WydSb2JvdCBEZXNjcmlwdGlvbiddKVxuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhwYXJhbVBhdGgpXG5cbiAgICAgICAgICBjb25zdCB1cmRmVGV4dCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntcbiAgICAgICAgICAgIGxldCBkZXNjUGFyYW0gPSBuZXcgUk9TTElCLlBhcmFtKHtcbiAgICAgICAgICAgICAgcm9zOiB0aGlzLnJvcywgbmFtZTogcGFyYW1QYXRoXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBkZXNjUGFyYW0uZ2V0KHZhbD0+eyByZXNvbHZlKHZhbCkgfSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgZGVidWcoJ1xcdCcsJ3VyZGYnLCB1cmRmVGV4dClcblxuICAgICAgICAgIGxldCBwdWJsaWNNb2RlbFBhdGggPSAnJ1xuICAgICAgICAgIGlmKHVyZGZUZXh0ICE9IG51bGwgJiYgdXJkZlRleHQubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICBsZXQgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpXG4gICAgICAgICAgICBsZXQgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1cmRmVGV4dCwgJ3RleHQveG1sJylcblxuICAgICAgICAgICAgY29uc3Qgcm9ib3RUYWcgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3JvYm90JylbMF1cbiAgICAgICAgICAgIGNvbnN0IHJvYm90TmFtZSA9IHJvYm90VGFnLmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgICAgICAgICBkZWJ1ZygnXFx0JywndXJkZiByb2JvdCBuYW1lJywgcm9ib3ROYW1lLCByb2JvdE5hbWUuaW5kZXhPZignbWFnbmknKSlcbiAgICAgICAgICAgIGlmKHJvYm90TmFtZS5pbmRleE9mKCdtYWduaScpICE9IC0xKXtcbiAgICAgICAgICAgICAgcHVibGljTW9kZWxQYXRoID0gJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9VYmlxdWl0eVJvYm90aWNzL21hZ25pX3JvYm90L25vZXRpYy1kZXZlbCdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBvYmogPSBuZXcgUk9TM0QuVXJkZkNsaWVudCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcHVibGljTW9kZWxQYXRoLFxuICAgICAgICAgICAgICAgIHJvczogdGhpcy5yb3MsXG4gICAgICAgICAgICAgICAgcGFyYW06IHBhcmFtUGF0aCxcbiAgICAgICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zY2VuZSxcbiAgICAgICAgICAgICAgICB0ZkNsaWVudDogdGhpcy50ZkNsaWVudCxcbiAgICAgICAgICAgICAgICB0ZlByZWZpeDogZGlzcGxheVsnVEYgUHJlZml4J11cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGVycil7XG4gICAgICAgICAgICAgIGRlYnVnKCdcXHQnLCd1cmRmIGVycm9yJywgZXJyKVxuICAgICAgICAgICAgICAvL2RlbGV0ZSBvYmpcbiAgICAgICAgICAgICAgb2JqID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gIFxuICAgICAgICAgICAgZGVidWcoJ1xcdCcsb2JqKVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdydml6L0ludGVyYWN0aXZlTWFya2Vycyc6XG4gICAgICAgICAgZGVidWcoZGlzcGxheS5DbGFzcywgZGlzcGxheVsnVXBkYXRlIFRvcGljJ10pXG5cbiAgICAgICAgICBjb25zdCB0b3BpYyA9IGRpc3BsYXlbJ1VwZGF0ZSBUb3BpYyddLnJlcGxhY2UoJy91cGRhdGUnLCcnKVxuXG4gICAgICAgICAgZGVidWcoJ1xcdCcsICd0b3BpYycsIHRvcGljKVxuXG4gICAgICAgICAgb2JqID0gbmV3IFJPUzNELkludGVyYWN0aXZlTWFya2VyQ2xpZW50KHtcbiAgICAgICAgICAgIHRvcGljLFxuICAgICAgICAgICAgcm9zOiB0aGlzLnJvcyxcbiAgICAgICAgICAgIHRmQ2xpZW50OiB0aGlzLnRmQ2xpZW50LFxuICAgICAgICAgICAgY2FtZXJhOiB0aGlzLnZpZXdlci5jYW1lcmEsXG4gICAgICAgICAgICByb290T2JqZWN0OiB0aGlzLnZpZXdlci5zZWxlY3RhYmxlT2JqZWN0cyxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS53YXJuKGBkaXNwbGF5IGNsYXNzICcke2Rpc3BsYXkuQ2xhc3N9JyBub3Qgc3VwcG9ydGVkYClcbiAgICAgICAgICBjb25zb2xlLndhcm4oZGlzcGxheSlcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqKSB7XG4gICAgICAgIGRlYnVnKG9iailcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG5cblxuICBkaXNhYmxlVml6KCkge1xuICAgIC8qKiBAdG9kbyAqL1xuICAgIGRlYnVnKCdkaXNhYmxlIHZpeiAtIG5vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuXG4gIHN0YXRpYyBydml6Q29sb3IyaGV4KGNvbG9yLCBkZWZhdWx0SGV4KSB7XG4gICAgaWYgKCFjb2xvcikgeyByZXR1cm4gZGVmYXVsdEhleCB9XG4gICAgcmV0dXJuIFRlbGVPcC5yZ2IyaGV4KGNvbG9yLnJlcGxhY2UoLzsvZywgJywnKSlcbiAgfVxuICBcbiAgc3RhdGljIHJnYjJoZXgocmdiKSB7XG4gICAgcmdiID0gcmdiLm1hdGNoKC9bXFxzK10/KFxcZCspW1xccytdPyxbXFxzK10/KFxcZCspW1xccytdPyxbXFxzK10/KFxcZCspW1xccytdPy9pKTtcbiAgICByZXR1cm4gKHJnYiAmJiByZ2IubGVuZ3RoID09PSA0KSA/IFwiI1wiICtcbiAgICAgIChcIjBcIiArIHBhcnNlSW50KHJnYlsxXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpICtcbiAgICAgIChcIjBcIiArIHBhcnNlSW50KHJnYlsyXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpICtcbiAgICAgIChcIjBcIiArIHBhcnNlSW50KHJnYlszXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpIDogJyc7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHM9VGVsZU9wOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n")},"./src/reach.js":module=>{eval("module.exports = function(obj, path, defaultVal){\n  var tokens = path.split('.')\n  var val = obj;\n\n  try{\n    for(var i=0; i<tokens.length; i++){\n      val = val[tokens[i]]\n    }\n\n    if(val == undefined){ val = defaultVal }\n  }\n  catch(excp){\n    val = (defaultVal != undefined) ? defaultVal : null\n  }\n\n  return val;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVhY2guanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vc3JjL3JlYWNoLmpzPzdmNDQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHBhdGgsIGRlZmF1bHRWYWwpe1xuICB2YXIgdG9rZW5zID0gcGF0aC5zcGxpdCgnLicpXG4gIHZhciB2YWwgPSBvYmo7XG5cbiAgdHJ5e1xuICAgIGZvcih2YXIgaT0wOyBpPHRva2Vucy5sZW5ndGg7IGkrKyl7XG4gICAgICB2YWwgPSB2YWxbdG9rZW5zW2ldXVxuICAgIH1cblxuICAgIGlmKHZhbCA9PSB1bmRlZmluZWQpeyB2YWwgPSBkZWZhdWx0VmFsIH1cbiAgfVxuICBjYXRjaChleGNwKXtcbiAgICB2YWwgPSAoZGVmYXVsdFZhbCAhPSB1bmRlZmluZWQpID8gZGVmYXVsdFZhbCA6IG51bGxcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/reach.js\n")},"./node_modules/yaml/browser/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('module.exports = __webpack_require__(/*! ./dist */ "./node_modules/yaml/browser/dist/index.js").YAML\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9HQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbGVvcHh5ei8uL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvaW5kZXguanM/ODlmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdCcpLllBTUxcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/index.js\n')},"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"C\": () => (/* binding */ Char),\n/* harmony export */   \"N\": () => (/* binding */ Node),\n/* harmony export */   \"P\": () => (/* binding */ PlainValue),\n/* harmony export */   \"R\": () => (/* binding */ Range),\n/* harmony export */   \"T\": () => (/* binding */ Type),\n/* harmony export */   \"Y\": () => (/* binding */ YAMLSyntaxError),\n/* harmony export */   \"_\": () => (/* binding */ _createForOfIteratorHelper),\n/* harmony export */   \"a\": () => (/* binding */ _typeof),\n/* harmony export */   \"b\": () => (/* binding */ _createClass),\n/* harmony export */   \"c\": () => (/* binding */ _classCallCheck),\n/* harmony export */   \"d\": () => (/* binding */ defaultTagPrefix),\n/* harmony export */   \"e\": () => (/* binding */ _defineProperty),\n/* harmony export */   \"f\": () => (/* binding */ YAMLWarning),\n/* harmony export */   \"g\": () => (/* binding */ YAMLSemanticError),\n/* harmony export */   \"h\": () => (/* binding */ _slicedToArray),\n/* harmony export */   \"i\": () => (/* binding */ YAMLError),\n/* harmony export */   \"j\": () => (/* binding */ _inherits),\n/* harmony export */   \"k\": () => (/* binding */ _createSuper),\n/* harmony export */   \"l\": () => (/* binding */ _get),\n/* harmony export */   \"m\": () => (/* binding */ _getPrototypeOf),\n/* harmony export */   \"n\": () => (/* binding */ defaultTags),\n/* harmony export */   \"o\": () => (/* binding */ YAMLReferenceError),\n/* harmony export */   \"p\": () => (/* binding */ _assertThisInitialized),\n/* harmony export */   \"q\": () => (/* binding */ _toArray),\n/* harmony export */   \"r\": () => (/* binding */ _possibleConstructorReturn)\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '';\n      col -= src.length - maxWidth;\n      src = '' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }], [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  return Range;\n}();\n\n/** Root class of all nodes */\n\nvar Node = /*#__PURE__*/function () {\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3);\n                _tag$match2[0];\n                var handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvUGxhaW5WYWx1ZS1iODAzNmI3NS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsK0JBQStCO0FBQzdFOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LEtBQUs7O0FBRTNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLFNBQVM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRTZlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L1BsYWluVmFsdWUtYjgwMzZiNzUuanM/NGRmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcblxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICAgIGY6IEZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgICAgZGlkRXJyID0gZmFsc2UsXG4gICAgICBlcnI7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gKCkge1xuICAgICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xuICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTtcbiAgICAgIHJldHVybiBzdGVwO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRpZEVyciA9IHRydWU7XG4gICAgICBlcnIgPSBlO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciBDaGFyID0ge1xuICBBTkNIT1I6ICcmJyxcbiAgQ09NTUVOVDogJyMnLFxuICBUQUc6ICchJyxcbiAgRElSRUNUSVZFU19FTkQ6ICctJyxcbiAgRE9DVU1FTlRfRU5EOiAnLidcbn07XG52YXIgVHlwZSA9IHtcbiAgQUxJQVM6ICdBTElBUycsXG4gIEJMQU5LX0xJTkU6ICdCTEFOS19MSU5FJyxcbiAgQkxPQ0tfRk9MREVEOiAnQkxPQ0tfRk9MREVEJyxcbiAgQkxPQ0tfTElURVJBTDogJ0JMT0NLX0xJVEVSQUwnLFxuICBDT01NRU5UOiAnQ09NTUVOVCcsXG4gIERJUkVDVElWRTogJ0RJUkVDVElWRScsXG4gIERPQ1VNRU5UOiAnRE9DVU1FTlQnLFxuICBGTE9XX01BUDogJ0ZMT1dfTUFQJyxcbiAgRkxPV19TRVE6ICdGTE9XX1NFUScsXG4gIE1BUDogJ01BUCcsXG4gIE1BUF9LRVk6ICdNQVBfS0VZJyxcbiAgTUFQX1ZBTFVFOiAnTUFQX1ZBTFVFJyxcbiAgUExBSU46ICdQTEFJTicsXG4gIFFVT1RFX0RPVUJMRTogJ1FVT1RFX0RPVUJMRScsXG4gIFFVT1RFX1NJTkdMRTogJ1FVT1RFX1NJTkdMRScsXG4gIFNFUTogJ1NFUScsXG4gIFNFUV9JVEVNOiAnU0VRX0lURU0nXG59O1xudmFyIGRlZmF1bHRUYWdQcmVmaXggPSAndGFnOnlhbWwub3JnLDIwMDI6JztcbnZhciBkZWZhdWx0VGFncyA9IHtcbiAgTUFQOiAndGFnOnlhbWwub3JnLDIwMDI6bWFwJyxcbiAgU0VROiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJyxcbiAgU1RSOiAndGFnOnlhbWwub3JnLDIwMDI6c3RyJ1xufTtcblxuZnVuY3Rpb24gZmluZExpbmVTdGFydHMoc3JjKSB7XG4gIHZhciBscyA9IFswXTtcbiAgdmFyIG9mZnNldCA9IHNyYy5pbmRleE9mKCdcXG4nKTtcblxuICB3aGlsZSAob2Zmc2V0ICE9PSAtMSkge1xuICAgIG9mZnNldCArPSAxO1xuICAgIGxzLnB1c2gob2Zmc2V0KTtcbiAgICBvZmZzZXQgPSBzcmMuaW5kZXhPZignXFxuJywgb2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiBscztcbn1cblxuZnVuY3Rpb24gZ2V0U3JjSW5mbyhjc3QpIHtcbiAgdmFyIGxpbmVTdGFydHMsIHNyYztcblxuICBpZiAodHlwZW9mIGNzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBsaW5lU3RhcnRzID0gZmluZExpbmVTdGFydHMoY3N0KTtcbiAgICBzcmMgPSBjc3Q7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3N0KSkgY3N0ID0gY3N0WzBdO1xuXG4gICAgaWYgKGNzdCAmJiBjc3QuY29udGV4dCkge1xuICAgICAgaWYgKCFjc3QubGluZVN0YXJ0cykgY3N0LmxpbmVTdGFydHMgPSBmaW5kTGluZVN0YXJ0cyhjc3QuY29udGV4dC5zcmMpO1xuICAgICAgbGluZVN0YXJ0cyA9IGNzdC5saW5lU3RhcnRzO1xuICAgICAgc3JjID0gY3N0LmNvbnRleHQuc3JjO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGluZVN0YXJ0czogbGluZVN0YXJ0cyxcbiAgICBzcmM6IHNyY1xuICB9O1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaW5lUG9zIC0gT25lLWluZGV4ZWQgcG9zaXRpb24gaW4gdGhlIHNvdXJjZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xcbiAqL1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgbGluZS9jb2wgcG9zaXRpb24gbWF0Y2hpbmcgYSBjaGFyYWN0ZXIgb2Zmc2V0LlxuICpcbiAqIEFjY2VwdHMgYSBzb3VyY2Ugc3RyaW5nIG9yIGEgQ1NUIGRvY3VtZW50IGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLiBXaXRoXG4gKiB0aGUgbGF0dGVyLCBzdGFydGluZyBpbmRpY2VzIGZvciBsaW5lcyBhcmUgY2FjaGVkIGluIHRoZSBkb2N1bWVudCBhc1xuICogYGxpbmVTdGFydHM6IG51bWJlcltdYC5cbiAqXG4gKiBSZXR1cm5zIGEgb25lLWluZGV4ZWQgYHsgbGluZSwgY29sIH1gIGxvY2F0aW9uIGlmIGZvdW5kLCBvclxuICogYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfERvY3VtZW50fERvY3VtZW50W119IGNzdFxuICogQHJldHVybnMgez9MaW5lUG9zfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGluZVBvcyhvZmZzZXQsIGNzdCkge1xuICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0IDwgMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIF9nZXRTcmNJbmZvID0gZ2V0U3JjSW5mbyhjc3QpLFxuICAgICAgbGluZVN0YXJ0cyA9IF9nZXRTcmNJbmZvLmxpbmVTdGFydHMsXG4gICAgICBzcmMgPSBfZ2V0U3JjSW5mby5zcmM7XG5cbiAgaWYgKCFsaW5lU3RhcnRzIHx8ICFzcmMgfHwgb2Zmc2V0ID4gc3JjLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU3RhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHN0YXJ0ID0gbGluZVN0YXJ0c1tpXTtcblxuICAgIGlmIChvZmZzZXQgPCBzdGFydCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogaSxcbiAgICAgICAgY29sOiBvZmZzZXQgLSBsaW5lU3RhcnRzW2kgLSAxXSArIDFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA9PT0gc3RhcnQpIHJldHVybiB7XG4gICAgICBsaW5lOiBpICsgMSxcbiAgICAgIGNvbDogMVxuICAgIH07XG4gIH1cblxuICB2YXIgbGluZSA9IGxpbmVTdGFydHMubGVuZ3RoO1xuICByZXR1cm4ge1xuICAgIGxpbmU6IGxpbmUsXG4gICAgY29sOiBvZmZzZXQgLSBsaW5lU3RhcnRzW2xpbmUgLSAxXSArIDFcbiAgfTtcbn1cbi8qKlxuICogR2V0IGEgc3BlY2lmaWVkIGxpbmUgZnJvbSB0aGUgc291cmNlLlxuICpcbiAqIEFjY2VwdHMgYSBzb3VyY2Ugc3RyaW5nIG9yIGEgQ1NUIGRvY3VtZW50IGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLiBXaXRoXG4gKiB0aGUgbGF0dGVyLCBzdGFydGluZyBpbmRpY2VzIGZvciBsaW5lcyBhcmUgY2FjaGVkIGluIHRoZSBkb2N1bWVudCBhc1xuICogYGxpbmVTdGFydHM6IG51bWJlcltdYC5cbiAqXG4gKiBSZXR1cm5zIHRoZSBsaW5lIGFzIGEgc3RyaW5nIGlmIGZvdW5kLCBvciBgbnVsbGAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lIE9uZS1pbmRleGVkIGxpbmUgbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ3xEb2N1bWVudHxEb2N1bWVudFtdfSBjc3RcbiAqIEByZXR1cm5zIHs/c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldExpbmUobGluZSwgY3N0KSB7XG4gIHZhciBfZ2V0U3JjSW5mbzIgPSBnZXRTcmNJbmZvKGNzdCksXG4gICAgICBsaW5lU3RhcnRzID0gX2dldFNyY0luZm8yLmxpbmVTdGFydHMsXG4gICAgICBzcmMgPSBfZ2V0U3JjSW5mbzIuc3JjO1xuXG4gIGlmICghbGluZVN0YXJ0cyB8fCAhKGxpbmUgPj0gMSkgfHwgbGluZSA+IGxpbmVTdGFydHMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgdmFyIHN0YXJ0ID0gbGluZVN0YXJ0c1tsaW5lIC0gMV07XG4gIHZhciBlbmQgPSBsaW5lU3RhcnRzW2xpbmVdOyAvLyB1bmRlZmluZWQgZm9yIGxhc3QgbGluZTsgdGhhdCdzIG9rIGZvciBzbGljZSgpXG5cbiAgd2hpbGUgKGVuZCAmJiBlbmQgPiBzdGFydCAmJiBzcmNbZW5kIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgLS1lbmQ7XG4gIH1cblxuICByZXR1cm4gc3JjLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuLyoqXG4gKiBQcmV0dHktcHJpbnQgdGhlIHN0YXJ0aW5nIGxpbmUgZnJvbSB0aGUgc291cmNlIGluZGljYXRlZCBieSB0aGUgcmFuZ2UgYHBvc2BcbiAqXG4gKiBUcmltcyBvdXRwdXQgdG8gYG1heFdpZHRoYCBjaGFycyB3aGlsZSBrZWVwaW5nIHRoZSBzdGFydGluZyBjb2x1bW4gdmlzaWJsZSxcbiAqIHVzaW5nIGDigKZgIGF0IGVpdGhlciBlbmQgdG8gaW5kaWNhdGUgZHJvcHBlZCBjaGFyYWN0ZXJzLlxuICpcbiAqIFJldHVybnMgYSB0d28tbGluZSBzdHJpbmcgKG9yIGBudWxsYCkgd2l0aCBgXFxuYCBhcyBzZXBhcmF0b3I7IHRoZSBzZWNvbmQgbGluZVxuICogd2lsbCBob2xkIGFwcHJvcHJpYXRlbHkgaW5kZW50ZWQgYF5gIG1hcmtzIGluZGljYXRpbmcgdGhlIGNvbHVtbiByYW5nZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gKiBAcGFyYW0ge0xpbmVQb3N9IHBvcy5zdGFydFxuICogQHBhcmFtIHtMaW5lUG9zfSBbcG9zLmVuZF1cbiAqIEBwYXJhbSB7c3RyaW5nfERvY3VtZW50fERvY3VtZW50W10qfSBjc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4V2lkdGg9ODBdXG4gKiBAcmV0dXJucyB7P3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRQcmV0dHlDb250ZXh0KF9yZWYsIGNzdCkge1xuICB2YXIgc3RhcnQgPSBfcmVmLnN0YXJ0LFxuICAgICAgZW5kID0gX3JlZi5lbmQ7XG4gIHZhciBtYXhXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogODA7XG4gIHZhciBzcmMgPSBnZXRMaW5lKHN0YXJ0LmxpbmUsIGNzdCk7XG4gIGlmICghc3JjKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNvbCA9IHN0YXJ0LmNvbDtcblxuICBpZiAoc3JjLmxlbmd0aCA+IG1heFdpZHRoKSB7XG4gICAgaWYgKGNvbCA8PSBtYXhXaWR0aCAtIDEwKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyKDAsIG1heFdpZHRoIC0gMSkgKyAn4oCmJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhhbGZXaWR0aCA9IE1hdGgucm91bmQobWF4V2lkdGggLyAyKTtcbiAgICAgIGlmIChzcmMubGVuZ3RoID4gY29sICsgaGFsZldpZHRoKSBzcmMgPSBzcmMuc3Vic3RyKDAsIGNvbCArIGhhbGZXaWR0aCAtIDEpICsgJ+KApic7XG4gICAgICBjb2wgLT0gc3JjLmxlbmd0aCAtIG1heFdpZHRoO1xuICAgICAgc3JjID0gJ+KApicgKyBzcmMuc3Vic3RyKDEgLSBtYXhXaWR0aCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVyckxlbiA9IDE7XG4gIHZhciBlcnJFbmQgPSAnJztcblxuICBpZiAoZW5kKSB7XG4gICAgaWYgKGVuZC5saW5lID09PSBzdGFydC5saW5lICYmIGNvbCArIChlbmQuY29sIC0gc3RhcnQuY29sKSA8PSBtYXhXaWR0aCArIDEpIHtcbiAgICAgIGVyckxlbiA9IGVuZC5jb2wgLSBzdGFydC5jb2w7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVyckxlbiA9IE1hdGgubWluKHNyYy5sZW5ndGggKyAxLCBtYXhXaWR0aCkgLSBjb2w7XG4gICAgICBlcnJFbmQgPSAn4oCmJztcbiAgICB9XG4gIH1cblxuICB2YXIgb2Zmc2V0ID0gY29sID4gMSA/ICcgJy5yZXBlYXQoY29sIC0gMSkgOiAnJztcbiAgdmFyIGVyciA9ICdeJy5yZXBlYXQoZXJyTGVuKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHNyYywgXCJcXG5cIikuY29uY2F0KG9mZnNldCkuY29uY2F0KGVycikuY29uY2F0KGVyckVuZCk7XG59XG5cbnZhciBSYW5nZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFuZ2UpO1xuXG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kIHx8IHN0YXJ0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJhbmdlLCBbe1xuICAgIGtleTogXCJpc0VtcHR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHRoaXMuc3RhcnQgIT09ICdudW1iZXInIHx8ICF0aGlzLmVuZCB8fCB0aGlzLmVuZCA8PSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYG9yaWdTdGFydGAgYW5kIGBvcmlnRW5kYCB0byBwb2ludCB0byB0aGUgb3JpZ2luYWwgc291cmNlIHJhbmdlIGZvclxuICAgICAqIHRoaXMgbm9kZSwgd2hpY2ggbWF5IGRpZmZlciBkdWUgdG8gZHJvcHBlZCBDUiBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gY3IgLSBQb3NpdGlvbnMgb2YgZHJvcHBlZCBDUiBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFN0YXJ0aW5nIGluZGV4IG9mIGBjcmAgZnJvbSB0aGUgbGFzdCBjYWxsXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgbmV4dCBvZmZzZXQsIG1hdGNoaW5nIHRoZSBvbmUgZm91bmQgZm9yIGBvcmlnU3RhcnRgXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcmlnUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpIHtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgIGlmIChjci5sZW5ndGggPT09IDAgfHwgZW5kIDw9IGNyWzBdKSB7XG4gICAgICAgIHRoaXMub3JpZ1N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMub3JpZ0VuZCA9IGVuZDtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSBvZmZzZXQ7XG5cbiAgICAgIHdoaWxlIChpIDwgY3IubGVuZ3RoKSB7XG4gICAgICAgIGlmIChjcltpXSA+IHN0YXJ0KSBicmVhaztlbHNlICsraTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcmlnU3RhcnQgPSBzdGFydCArIGk7XG4gICAgICB2YXIgbmV4dE9mZnNldCA9IGk7XG5cbiAgICAgIHdoaWxlIChpIDwgY3IubGVuZ3RoKSB7XG4gICAgICAgIC8vIGlmIGVuZCB3YXMgYXQgXFxuLCBpdCBzaG91bGQgbm93IGJlIGF0IFxcclxuICAgICAgICBpZiAoY3JbaV0gPj0gZW5kKSBicmVhaztlbHNlICsraTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcmlnRW5kID0gZW5kICsgaTtcbiAgICAgIHJldHVybiBuZXh0T2Zmc2V0O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShvcmlnKSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKG9yaWcuc3RhcnQsIG9yaWcuZW5kKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFuZ2U7XG59KCk7XG5cbi8qKiBSb290IGNsYXNzIG9mIGFsbCBub2RlcyAqL1xuXG52YXIgTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vZGUodHlwZSwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbnRleHQnLCB7XG4gICAgICB2YWx1ZTogY29udGV4dCB8fCBudWxsLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICB0aGlzLnJhbmdlID0gbnVsbDtcbiAgICB0aGlzLnZhbHVlUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcyB8fCBbXTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE5vZGUsIFt7XG4gICAga2V5OiBcImdldFByb3BWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9wVmFsdWUoaWR4LCBrZXksIHNraXBLZXkpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjO1xuICAgICAgdmFyIHByb3AgPSB0aGlzLnByb3BzW2lkeF07XG4gICAgICByZXR1cm4gcHJvcCAmJiBzcmNbcHJvcC5zdGFydF0gPT09IGtleSA/IHNyYy5zbGljZShwcm9wLnN0YXJ0ICsgKHNraXBLZXkgPyAxIDogMCksIHByb3AuZW5kKSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFuY2hvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBhbmNob3IgPSB0aGlzLmdldFByb3BWYWx1ZShpLCBDaGFyLkFOQ0hPUiwgdHJ1ZSk7XG4gICAgICAgIGlmIChhbmNob3IgIT0gbnVsbCkgcmV0dXJuIGFuY2hvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBjb21tZW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLmdldFByb3BWYWx1ZShpLCBDaGFyLkNPTU1FTlQsIHRydWUpO1xuICAgICAgICBpZiAoY29tbWVudCAhPSBudWxsKSBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tbWVudHMubGVuZ3RoID4gMCA/IGNvbW1lbnRzLmpvaW4oJ1xcbicpIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWVudEhhc1JlcXVpcmVkV2hpdGVzcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21tZW50SGFzUmVxdWlyZWRXaGl0ZXNwYWNlKHN0YXJ0KSB7XG4gICAgICB2YXIgc3JjID0gdGhpcy5jb250ZXh0LnNyYztcbiAgICAgIGlmICh0aGlzLmhlYWRlciAmJiBzdGFydCA9PT0gdGhpcy5oZWFkZXIuZW5kKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMudmFsdWVSYW5nZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGVuZCA9IHRoaXMudmFsdWVSYW5nZS5lbmQ7XG4gICAgICByZXR1cm4gc3RhcnQgIT09IGVuZCB8fCBOb2RlLmF0Qmxhbmsoc3JjLCBlbmQgLSAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQ29tbWVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgICB2YXIgc3JjID0gdGhpcy5jb250ZXh0LnNyYztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoc3JjW3RoaXMucHJvcHNbaV0uc3RhcnRdID09PSBDaGFyLkNPTU1FTlQpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzUHJvcHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHNyY1t0aGlzLnByb3BzW2ldLnN0YXJ0XSAhPT0gQ2hhci5DT01NRU5UKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluY2x1ZGVzVHJhaWxpbmdMaW5lc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqc29uTGlrZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGpzb25MaWtlVHlwZXMgPSBbVHlwZS5GTE9XX01BUCwgVHlwZS5GTE9XX1NFUSwgVHlwZS5RVU9URV9ET1VCTEUsIFR5cGUuUVVPVEVfU0lOR0xFXTtcbiAgICAgIHJldHVybiBqc29uTGlrZVR5cGVzLmluZGV4T2YodGhpcy50eXBlKSAhPT0gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhbmdlQXNMaW5lUG9zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMucmFuZ2UgfHwgIXRoaXMuY29udGV4dCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBzdGFydCA9IGdldExpbmVQb3ModGhpcy5yYW5nZS5zdGFydCwgdGhpcy5jb250ZXh0LnJvb3QpO1xuICAgICAgaWYgKCFzdGFydCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBlbmQgPSBnZXRMaW5lUG9zKHRoaXMucmFuZ2UuZW5kLCB0aGlzLmNvbnRleHQucm9vdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYXdWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLnZhbHVlUmFuZ2UgfHwgIXRoaXMuY29udGV4dCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgX3RoaXMkdmFsdWVSYW5nZSA9IHRoaXMudmFsdWVSYW5nZSxcbiAgICAgICAgICBzdGFydCA9IF90aGlzJHZhbHVlUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgZW5kID0gX3RoaXMkdmFsdWVSYW5nZS5lbmQ7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnNyYy5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGFnXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHRhZyA9IHRoaXMuZ2V0UHJvcFZhbHVlKGksIENoYXIuVEFHLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHRhZyAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHRhZ1sxXSA9PT0gJzwnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2ZXJiYXRpbTogdGFnLnNsaWNlKDIsIC0xKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgICB2YXIgX3RhZyRtYXRjaCA9IHRhZy5tYXRjaCgvXiguKiEpKFteIV0qKSQvKSxcbiAgICAgICAgICAgICAgICBfdGFnJG1hdGNoMiA9IF9zbGljZWRUb0FycmF5KF90YWckbWF0Y2gsIDMpO1xuICAgICAgICAgICAgICAgIF90YWckbWF0Y2gyWzBdO1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBfdGFnJG1hdGNoMlsxXSxcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBfdGFnJG1hdGNoMlsyXTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaGFuZGxlOiBoYW5kbGUsXG4gICAgICAgICAgICAgIHN1ZmZpeDogc3VmZml4XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVSYW5nZUNvbnRhaW5zTmV3bGluZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLnZhbHVlUmFuZ2UgfHwgIXRoaXMuY29udGV4dCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIF90aGlzJHZhbHVlUmFuZ2UyID0gdGhpcy52YWx1ZVJhbmdlLFxuICAgICAgICAgIHN0YXJ0ID0gX3RoaXMkdmFsdWVSYW5nZTIuc3RhcnQsXG4gICAgICAgICAgZW5kID0gX3RoaXMkdmFsdWVSYW5nZTIuZW5kO1xuICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmM7XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgIGlmIChzcmNbaV0gPT09ICdcXG4nKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUNvbW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VDb21tZW50KHN0YXJ0KSB7XG4gICAgICB2YXIgc3JjID0gdGhpcy5jb250ZXh0LnNyYztcblxuICAgICAgaWYgKHNyY1tzdGFydF0gPT09IENoYXIuQ09NTUVOVCkge1xuICAgICAgICB2YXIgZW5kID0gTm9kZS5lbmRPZkxpbmUoc3JjLCBzdGFydCArIDEpO1xuICAgICAgICB2YXIgY29tbWVudFJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnByb3BzLnB1c2goY29tbWVudFJhbmdlKTtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZXMgdGhlIGBvcmlnU3RhcnRgIGFuZCBgb3JpZ0VuZGAgdmFsdWVzIG9mIGFsbCByYW5nZXMgZm9yIHRoaXNcbiAgICAgKiBub2RlLiBFeHRlbmRlZCBieSBjaGlsZCBjbGFzc2VzIHRvIGhhbmRsZSBkZXNjZW5kYW50IG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gY3IgLSBQb3NpdGlvbnMgb2YgZHJvcHBlZCBDUiBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFN0YXJ0aW5nIGluZGV4IG9mIGBjcmAgZnJvbSB0aGUgbGFzdCBjYWxsXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgbmV4dCBvZmZzZXQsIG1hdGNoaW5nIHRoZSBvbmUgZm91bmQgZm9yIGBvcmlnU3RhcnRgXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcmlnUmFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCkge1xuICAgICAgaWYgKHRoaXMucmFuZ2UpIG9mZnNldCA9IHRoaXMucmFuZ2Uuc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpO1xuICAgICAgaWYgKHRoaXMudmFsdWVSYW5nZSkgdGhpcy52YWx1ZVJhbmdlLnNldE9yaWdSYW5nZShjciwgb2Zmc2V0KTtcbiAgICAgIHRoaXMucHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gcHJvcC5zZXRPcmlnUmFuZ2UoY3IsIG9mZnNldCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmMsXG4gICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlLFxuICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YXIgc3RyID0gc3JjLnNsaWNlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgICAgcmV0dXJuIE5vZGUuYWRkU3RyaW5nVGVybWluYXRvcihzcmMsIHJhbmdlLmVuZCwgc3RyKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJhZGRTdHJpbmdUZXJtaW5hdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFN0cmluZ1Rlcm1pbmF0b3Ioc3JjLCBvZmZzZXQsIHN0cikge1xuICAgICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSByZXR1cm4gc3RyO1xuICAgICAgdmFyIG5leHQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gICAgICByZXR1cm4gbmV4dCA+PSBzcmMubGVuZ3RoIHx8IHNyY1tuZXh0XSA9PT0gJ1xcbicgPyBzdHIgKyAnXFxuJyA6IHN0cjtcbiAgICB9IC8vIF4oLS0tfC4uLilcblxuICB9LCB7XG4gICAga2V5OiBcImF0RG9jdW1lbnRCb3VuZGFyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdERvY3VtZW50Qm91bmRhcnkoc3JjLCBvZmZzZXQsIHNlcCkge1xuICAgICAgdmFyIGNoMCA9IHNyY1tvZmZzZXRdO1xuICAgICAgaWYgKCFjaDApIHJldHVybiB0cnVlO1xuICAgICAgdmFyIHByZXYgPSBzcmNbb2Zmc2V0IC0gMV07XG4gICAgICBpZiAocHJldiAmJiBwcmV2ICE9PSAnXFxuJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoc2VwKSB7XG4gICAgICAgIGlmIChjaDAgIT09IHNlcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNoMCAhPT0gQ2hhci5ESVJFQ1RJVkVTX0VORCAmJiBjaDAgIT09IENoYXIuRE9DVU1FTlRfRU5EKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaDEgPSBzcmNbb2Zmc2V0ICsgMV07XG4gICAgICB2YXIgY2gyID0gc3JjW29mZnNldCArIDJdO1xuICAgICAgaWYgKGNoMSAhPT0gY2gwIHx8IGNoMiAhPT0gY2gwKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgY2gzID0gc3JjW29mZnNldCArIDNdO1xuICAgICAgcmV0dXJuICFjaDMgfHwgY2gzID09PSAnXFxuJyB8fCBjaDMgPT09ICdcXHQnIHx8IGNoMyA9PT0gJyAnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRPZklkZW50aWZpZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2ZJZGVudGlmaWVyKHNyYywgb2Zmc2V0KSB7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICAgIHZhciBpc1ZlcmJhdGltID0gY2ggPT09ICc8JztcbiAgICAgIHZhciBub3RPayA9IGlzVmVyYmF0aW0gPyBbJ1xcbicsICdcXHQnLCAnICcsICc+J10gOiBbJ1xcbicsICdcXHQnLCAnICcsICdbJywgJ10nLCAneycsICd9JywgJywnXTtcblxuICAgICAgd2hpbGUgKGNoICYmIG5vdE9rLmluZGV4T2YoY2gpID09PSAtMSkge1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXQgKz0gMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1ZlcmJhdGltICYmIGNoID09PSAnPicpIG9mZnNldCArPSAxO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kT2ZJbmRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2ZJbmRlbnQoc3JjLCBvZmZzZXQpIHtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgICB3aGlsZSAoY2ggPT09ICcgJykge1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXQgKz0gMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZE9mTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZkxpbmUoc3JjLCBvZmZzZXQpIHtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgICB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nKSB7XG4gICAgICAgIGNoID0gc3JjW29mZnNldCArPSAxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kT2ZXaGl0ZVNwYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCkge1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldF07XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJykge1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXQgKz0gMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0T2ZMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0T2ZMaW5lKHNyYywgb2Zmc2V0KSB7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0IC0gMV07XG4gICAgICBpZiAoY2ggPT09ICdcXG4nKSByZXR1cm4gb2Zmc2V0O1xuXG4gICAgICB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nKSB7XG4gICAgICAgIGNoID0gc3JjW29mZnNldCAtPSAxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldCArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuZCBvZiBpbmRlbnRhdGlvbiwgb3IgbnVsbCBpZiB0aGUgbGluZSdzIGluZGVudCBsZXZlbCBpcyBub3QgbW9yZVxuICAgICAqIHRoYW4gYGluZGVudGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVTdGFydFxuICAgICAqIEByZXR1cm5zIHs/bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kT2ZCbG9ja0luZGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZkJsb2NrSW5kZW50KHNyYywgaW5kZW50LCBsaW5lU3RhcnQpIHtcbiAgICAgIHZhciBpbkVuZCA9IE5vZGUuZW5kT2ZJbmRlbnQoc3JjLCBsaW5lU3RhcnQpO1xuXG4gICAgICBpZiAoaW5FbmQgPiBsaW5lU3RhcnQgKyBpbmRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGluRW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdzRW5kID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBpbkVuZCk7XG4gICAgICAgIHZhciBjaCA9IHNyY1t3c0VuZF07XG4gICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXG4nKSByZXR1cm4gd3NFbmQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdEJsYW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0Qmxhbmsoc3JjLCBvZmZzZXQsIGVuZEFzQmxhbmspIHtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuICAgICAgcmV0dXJuIGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJyB8fCBlbmRBc0JsYW5rICYmICFjaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dE5vZGVJc0luZGVudGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHROb2RlSXNJbmRlbnRlZChjaCwgaW5kZW50RGlmZiwgaW5kaWNhdG9yQXNJbmRlbnQpIHtcbiAgICAgIGlmICghY2ggfHwgaW5kZW50RGlmZiA8IDApIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChpbmRlbnREaWZmID4gMCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gaW5kaWNhdG9yQXNJbmRlbnQgJiYgY2ggPT09ICctJztcbiAgICB9IC8vIHNob3VsZCBiZSBhdCBsaW5lIG9yIHN0cmluZyBlbmQsIG9yIGF0IG5leHQgbm9uLXdoaXRlc3BhY2UgY2hhclxuXG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldChzcmMsIG9mZnNldCkge1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldF07XG4gICAgICByZXR1cm4gIWNoID8gb2Zmc2V0IDogY2ggIT09ICdcXG4nICYmIHNyY1tvZmZzZXQgLSAxXSA9PT0gJ1xcbicgPyBvZmZzZXQgLSAxIDogTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgIH0gLy8gZm9sZCBzaW5nbGUgbmV3bGluZSBpbnRvIHNwYWNlLCBtdWx0aXBsZSBuZXdsaW5lcyB0byBOIC0gMSBuZXdsaW5lc1xuICAgIC8vIHByZXN1bWVzIHNyY1tvZmZzZXRdID09PSAnXFxuJ1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9sZE5ld2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9sZE5ld2xpbmUoc3JjLCBvZmZzZXQsIGluZGVudCkge1xuICAgICAgdmFyIGluQ291bnQgPSAwO1xuICAgICAgdmFyIGVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgZm9sZCA9ICcnO1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldCArIDFdO1xuXG4gICAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICdcXG4nKSB7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgaW5Db3VudCA9IDA7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIGZvbGQgKz0gJ1xcbic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICBpZiAoaW5Db3VudCA8PSBpbmRlbnQpIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0ICsgMikgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIGluQ291bnQgKz0gMTtcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjaCA9IHNyY1tvZmZzZXQgKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmb2xkKSBmb2xkID0gJyAnO1xuICAgICAgaWYgKGNoICYmIGluQ291bnQgPD0gaW5kZW50KSBlcnJvciA9IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb2xkOiBmb2xkLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlO1xufSgpO1xuXG52YXIgWUFNTEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKFlBTUxFcnJvciwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFlBTUxFcnJvcik7XG5cbiAgZnVuY3Rpb24gWUFNTEVycm9yKG5hbWUsIHNvdXJjZSwgbWVzc2FnZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBZQU1MRXJyb3IpO1xuXG4gICAgaWYgKCFtZXNzYWdlIHx8ICEoc291cmNlIGluc3RhbmNlb2YgTm9kZSkpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBuZXcgXCIuY29uY2F0KG5hbWUpKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIF90aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWUFNTEVycm9yLCBbe1xuICAgIGtleTogXCJtYWtlUHJldHR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VQcmV0dHkoKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlKSByZXR1cm47XG4gICAgICB0aGlzLm5vZGVUeXBlID0gdGhpcy5zb3VyY2UudHlwZTtcbiAgICAgIHZhciBjc3QgPSB0aGlzLnNvdXJjZS5jb250ZXh0ICYmIHRoaXMuc291cmNlLmNvbnRleHQucm9vdDtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5yYW5nZSA9IG5ldyBSYW5nZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gY3N0ICYmIGdldExpbmVQb3ModGhpcy5vZmZzZXQsIGNzdCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIGVuZCA9IHtcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjb2w6IHN0YXJ0LmNvbCArIDFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMubGluZVBvcyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLm9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNvdXJjZS5yYW5nZTtcbiAgICAgICAgdGhpcy5saW5lUG9zID0gdGhpcy5zb3VyY2UucmFuZ2VBc0xpbmVQb3M7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxpbmVQb3MpIHtcbiAgICAgICAgdmFyIF90aGlzJGxpbmVQb3Mkc3RhcnQgPSB0aGlzLmxpbmVQb3Muc3RhcnQsXG4gICAgICAgICAgICBsaW5lID0gX3RoaXMkbGluZVBvcyRzdGFydC5saW5lLFxuICAgICAgICAgICAgY29sID0gX3RoaXMkbGluZVBvcyRzdGFydC5jb2w7XG4gICAgICAgIHRoaXMubWVzc2FnZSArPSBcIiBhdCBsaW5lIFwiLmNvbmNhdChsaW5lLCBcIiwgY29sdW1uIFwiKS5jb25jYXQoY29sKTtcbiAgICAgICAgdmFyIGN0eCA9IGNzdCAmJiBnZXRQcmV0dHlDb250ZXh0KHRoaXMubGluZVBvcywgY3N0KTtcbiAgICAgICAgaWYgKGN0eCkgdGhpcy5tZXNzYWdlICs9IFwiOlxcblxcblwiLmNvbmNhdChjdHgsIFwiXFxuXCIpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgdGhpcy5zb3VyY2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFlBTUxFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG52YXIgWUFNTFJlZmVyZW5jZUVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfWUFNTEVycm9yKSB7XG4gIF9pbmhlcml0cyhZQU1MUmVmZXJlbmNlRXJyb3IsIF9ZQU1MRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKFlBTUxSZWZlcmVuY2VFcnJvcik7XG5cbiAgZnVuY3Rpb24gWUFNTFJlZmVyZW5jZUVycm9yKHNvdXJjZSwgbWVzc2FnZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBZQU1MUmVmZXJlbmNlRXJyb3IpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjIuY2FsbCh0aGlzLCAnWUFNTFJlZmVyZW5jZUVycm9yJywgc291cmNlLCBtZXNzYWdlKTtcbiAgfVxuXG4gIHJldHVybiBZQU1MUmVmZXJlbmNlRXJyb3I7XG59KFlBTUxFcnJvcik7XG52YXIgWUFNTFNlbWFudGljRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9ZQU1MRXJyb3IyKSB7XG4gIF9pbmhlcml0cyhZQU1MU2VtYW50aWNFcnJvciwgX1lBTUxFcnJvcjIpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKFlBTUxTZW1hbnRpY0Vycm9yKTtcblxuICBmdW5jdGlvbiBZQU1MU2VtYW50aWNFcnJvcihzb3VyY2UsIG1lc3NhZ2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWUFNTFNlbWFudGljRXJyb3IpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjMuY2FsbCh0aGlzLCAnWUFNTFNlbWFudGljRXJyb3InLCBzb3VyY2UsIG1lc3NhZ2UpO1xuICB9XG5cbiAgcmV0dXJuIFlBTUxTZW1hbnRpY0Vycm9yO1xufShZQU1MRXJyb3IpO1xudmFyIFlBTUxTeW50YXhFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1lBTUxFcnJvcjMpIHtcbiAgX2luaGVyaXRzKFlBTUxTeW50YXhFcnJvciwgX1lBTUxFcnJvcjMpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKFlBTUxTeW50YXhFcnJvcik7XG5cbiAgZnVuY3Rpb24gWUFNTFN5bnRheEVycm9yKHNvdXJjZSwgbWVzc2FnZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBZQU1MU3ludGF4RXJyb3IpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjQuY2FsbCh0aGlzLCAnWUFNTFN5bnRheEVycm9yJywgc291cmNlLCBtZXNzYWdlKTtcbiAgfVxuXG4gIHJldHVybiBZQU1MU3ludGF4RXJyb3I7XG59KFlBTUxFcnJvcik7XG52YXIgWUFNTFdhcm5pbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9ZQU1MRXJyb3I0KSB7XG4gIF9pbmhlcml0cyhZQU1MV2FybmluZywgX1lBTUxFcnJvcjQpO1xuXG4gIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKFlBTUxXYXJuaW5nKTtcblxuICBmdW5jdGlvbiBZQU1MV2FybmluZyhzb3VyY2UsIG1lc3NhZ2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWUFNTFdhcm5pbmcpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjUuY2FsbCh0aGlzLCAnWUFNTFdhcm5pbmcnLCBzb3VyY2UsIG1lc3NhZ2UpO1xuICB9XG5cbiAgcmV0dXJuIFlBTUxXYXJuaW5nO1xufShZQU1MRXJyb3IpO1xuXG52YXIgUGxhaW5WYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKFBsYWluVmFsdWUsIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFBsYWluVmFsdWUpO1xuXG4gIGZ1bmN0aW9uIFBsYWluVmFsdWUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYWluVmFsdWUpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBsYWluVmFsdWUsIFt7XG4gICAga2V5OiBcInN0clZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMudmFsdWVSYW5nZSB8fCAhdGhpcy5jb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBfdGhpcyR2YWx1ZVJhbmdlID0gdGhpcy52YWx1ZVJhbmdlLFxuICAgICAgICAgIHN0YXJ0ID0gX3RoaXMkdmFsdWVSYW5nZS5zdGFydCxcbiAgICAgICAgICBlbmQgPSBfdGhpcyR2YWx1ZVJhbmdlLmVuZDtcbiAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjO1xuICAgICAgdmFyIGNoID0gc3JjW2VuZCAtIDFdO1xuXG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgKGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJykpIHtcbiAgICAgICAgY2ggPSBzcmNbLS1lbmQgLSAxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICB2YXIgX2NoID0gc3JjW2ldO1xuXG4gICAgICAgIGlmIChfY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgdmFyIF9Ob2RlJGZvbGROZXdsaW5lID0gTm9kZS5mb2xkTmV3bGluZShzcmMsIGksIC0xKSxcbiAgICAgICAgICAgICAgZm9sZCA9IF9Ob2RlJGZvbGROZXdsaW5lLmZvbGQsXG4gICAgICAgICAgICAgIG9mZnNldCA9IF9Ob2RlJGZvbGROZXdsaW5lLm9mZnNldDtcblxuICAgICAgICAgIHN0ciArPSBmb2xkO1xuICAgICAgICAgIGkgPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NoID09PSAnICcgfHwgX2NoID09PSAnXFx0Jykge1xuICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgIHZhciB3c1N0YXJ0ID0gaTtcbiAgICAgICAgICB2YXIgbmV4dCA9IHNyY1tpICsgMV07XG5cbiAgICAgICAgICB3aGlsZSAoaSA8IGVuZCAmJiAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKSkge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgbmV4dCA9IHNyY1tpICsgMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHQgIT09ICdcXG4nKSBzdHIgKz0gaSA+IHdzU3RhcnQgPyBzcmMuc2xpY2Uod3NTdGFydCwgaSArIDEpIDogX2NoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSBfY2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNoMCA9IHNyY1tzdGFydF07XG5cbiAgICAgIHN3aXRjaCAoY2gwKSB7XG4gICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdQbGFpbiB2YWx1ZSBjYW5ub3Qgc3RhcnQgd2l0aCBhIHRhYiBjaGFyYWN0ZXInO1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtuZXcgWUFNTFNlbWFudGljRXJyb3IodGhpcywgbXNnKV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgICAgc3RyOiBzdHJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ0AnOlxuICAgICAgICBjYXNlICdgJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21zZyA9IFwiUGxhaW4gdmFsdWUgY2Fubm90IHN0YXJ0IHdpdGggcmVzZXJ2ZWQgY2hhcmFjdGVyIFwiLmNvbmNhdChjaDApO1xuXG4gICAgICAgICAgICB2YXIgX2Vycm9ycyA9IFtuZXcgWUFNTFNlbWFudGljRXJyb3IodGhpcywgX21zZyldO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZXJyb3JzOiBfZXJyb3JzLFxuICAgICAgICAgICAgICBzdHI6IHN0clxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUJsb2NrVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VCbG9ja1ZhbHVlKHN0YXJ0KSB7XG4gICAgICB2YXIgX3RoaXMkY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBpbmRlbnQgPSBfdGhpcyRjb250ZXh0LmluZGVudCxcbiAgICAgICAgICBpbkZsb3cgPSBfdGhpcyRjb250ZXh0LmluRmxvdyxcbiAgICAgICAgICBzcmMgPSBfdGhpcyRjb250ZXh0LnNyYztcbiAgICAgIHZhciBvZmZzZXQgPSBzdGFydDtcbiAgICAgIHZhciB2YWx1ZUVuZCA9IHN0YXJ0O1xuXG4gICAgICBmb3IgKHZhciBjaCA9IHNyY1tvZmZzZXRdOyBjaCA9PT0gJ1xcbic7IGNoID0gc3JjW29mZnNldF0pIHtcbiAgICAgICAgaWYgKE5vZGUuYXREb2N1bWVudEJvdW5kYXJ5KHNyYywgb2Zmc2V0ICsgMSkpIGJyZWFrO1xuICAgICAgICB2YXIgZW5kID0gTm9kZS5lbmRPZkJsb2NrSW5kZW50KHNyYywgaW5kZW50LCBvZmZzZXQgKyAxKTtcbiAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCB8fCBzcmNbZW5kXSA9PT0gJyMnKSBicmVhaztcblxuICAgICAgICBpZiAoc3JjW2VuZF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlRW5kID0gUGxhaW5WYWx1ZS5lbmRPZkxpbmUoc3JjLCBlbmQsIGluRmxvdyk7XG4gICAgICAgICAgb2Zmc2V0ID0gdmFsdWVFbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudmFsdWVSYW5nZS5pc0VtcHR5KCkpIHRoaXMudmFsdWVSYW5nZS5zdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy52YWx1ZVJhbmdlLmVuZCA9IHZhbHVlRW5kO1xuICAgICAgcmV0dXJuIHZhbHVlRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBwbGFpbiB2YWx1ZSBmcm9tIHRoZSBzb3VyY2VcbiAgICAgKlxuICAgICAqIEFjY2VwdGVkIGZvcm1zIGFyZTpcbiAgICAgKiBgYGBcbiAgICAgKiAjY29tbWVudFxuICAgICAqXG4gICAgICogZmlyc3QgbGluZVxuICAgICAqXG4gICAgICogZmlyc3QgbGluZSAjY29tbWVudFxuICAgICAqXG4gICAgICogZmlyc3QgbGluZVxuICAgICAqIGJsb2NrXG4gICAgICogbGluZXNcbiAgICAgKlxuICAgICAqICNjb21tZW50XG4gICAgICogYmxvY2tcbiAgICAgKiBsaW5lc1xuICAgICAqIGBgYFxuICAgICAqIHdoZXJlIGJsb2NrIGxpbmVzIGFyZSBlbXB0eSBvciBoYXZlIGFuIGluZGVudCBsZXZlbCBncmVhdGVyIHRoYW4gYGluZGVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzIHNjYWxhciwgbWF5IGJlIGBcXG5gXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHZhciBpbkZsb3cgPSBjb250ZXh0LmluRmxvdyxcbiAgICAgICAgICBzcmMgPSBjb250ZXh0LnNyYztcbiAgICAgIHZhciBvZmZzZXQgPSBzdGFydDtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgICBpZiAoY2ggJiYgY2ggIT09ICcjJyAmJiBjaCAhPT0gJ1xcbicpIHtcbiAgICAgICAgb2Zmc2V0ID0gUGxhaW5WYWx1ZS5lbmRPZkxpbmUoc3JjLCBzdGFydCwgaW5GbG93KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUNvbW1lbnQob2Zmc2V0KTtcblxuICAgICAgaWYgKCF0aGlzLmhhc0NvbW1lbnQgfHwgdGhpcy52YWx1ZVJhbmdlLmlzRW1wdHkoKSkge1xuICAgICAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQmxvY2tWYWx1ZShvZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImVuZE9mTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZkxpbmUoc3JjLCBzdGFydCwgaW5GbG93KSB7XG4gICAgICB2YXIgY2ggPSBzcmNbc3RhcnRdO1xuICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0O1xuXG4gICAgICB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nKSB7XG4gICAgICAgIGlmIChpbkZsb3cgJiYgKGNoID09PSAnWycgfHwgY2ggPT09ICddJyB8fCBjaCA9PT0gJ3snIHx8IGNoID09PSAnfScgfHwgY2ggPT09ICcsJykpIGJyZWFrO1xuICAgICAgICB2YXIgbmV4dCA9IHNyY1tvZmZzZXQgKyAxXTtcbiAgICAgICAgaWYgKGNoID09PSAnOicgJiYgKCFuZXh0IHx8IG5leHQgPT09ICdcXG4nIHx8IG5leHQgPT09ICdcXHQnIHx8IG5leHQgPT09ICcgJyB8fCBpbkZsb3cgJiYgbmV4dCA9PT0gJywnKSkgYnJlYWs7XG4gICAgICAgIGlmICgoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpICYmIG5leHQgPT09ICcjJykgYnJlYWs7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICBjaCA9IG5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBsYWluVmFsdWU7XG59KE5vZGUpO1xuXG5leHBvcnQgeyBDaGFyIGFzIEMsIE5vZGUgYXMgTiwgUGxhaW5WYWx1ZSBhcyBQLCBSYW5nZSBhcyBSLCBUeXBlIGFzIFQsIFlBTUxTeW50YXhFcnJvciBhcyBZLCBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciBhcyBfLCBfdHlwZW9mIGFzIGEsIF9jcmVhdGVDbGFzcyBhcyBiLCBfY2xhc3NDYWxsQ2hlY2sgYXMgYywgZGVmYXVsdFRhZ1ByZWZpeCBhcyBkLCBfZGVmaW5lUHJvcGVydHkgYXMgZSwgWUFNTFdhcm5pbmcgYXMgZiwgWUFNTFNlbWFudGljRXJyb3IgYXMgZywgX3NsaWNlZFRvQXJyYXkgYXMgaCwgWUFNTEVycm9yIGFzIGksIF9pbmhlcml0cyBhcyBqLCBfY3JlYXRlU3VwZXIgYXMgaywgX2dldCBhcyBsLCBfZ2V0UHJvdG90eXBlT2YgYXMgbSwgZGVmYXVsdFRhZ3MgYXMgbiwgWUFNTFJlZmVyZW5jZUVycm9yIGFzIG8sIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgYXMgcCwgX3RvQXJyYXkgYXMgcSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gYXMgciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\n")},"./node_modules/yaml/browser/dist/Schema-e94716c8.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"S\": () => (/* binding */ Schema)\n/* harmony export */ });\n/* harmony import */ var _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlainValue-b8036b75.js */ \"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\");\n/* harmony import */ var _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolveSeq-492ab440.js */ \"./node_modules/yaml/browser/dist/resolveSeq-492ab440.js\");\n/* harmony import */ var _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./warnings-df54cb69.js */ \"./node_modules/yaml/browser/dist/warnings-df54cb69.js\");\n\n\n\n\nfunction createMap(schema, obj, ctx) {\n  var map = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d(schema);\n\n  if (obj instanceof Map) {\n    var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(obj),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.h)(_step.value, 2),\n            key = _step$value[0],\n            value = _step$value[1];\n\n        map.items.push(schema.createPair(key, value, ctx));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (obj && (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(obj) === 'object') {\n    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n      var _key = _Object$keys[_i];\n      map.items.push(schema.createPair(_key, obj[_key], ctx));\n    }\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nvar map = {\n  createNode: createMap,\n  default: true,\n  nodeClass: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.g\n};\n\nfunction createSeq(schema, obj, ctx) {\n  var seq = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.Y(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(obj),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var it = _step.value;\n        var v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n        seq.items.push(v);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return seq;\n}\n\nvar seq = {\n  createNode: createSeq,\n  default: true,\n  nodeClass: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.Y,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.h\n};\n\nvar string = {\n  identify: function identify(value) {\n    return typeof value === 'string';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.j,\n  stringify: function stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.c)(item, ctx, onComment, onChompKeep);\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.s\n};\n\nvar failsafe = [map, seq, string];\n\n/* global BigInt */\n\nvar intIdentify$2 = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nvar intResolve$1 = function intResolve(src, part, radix) {\n  return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i.asBigInt ? BigInt(src) : parseInt(part, radix);\n};\n\nfunction intStringify$1(node, radix, prefix) {\n  var value = node.value;\n  if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);\n  return (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k)(node);\n}\n\nvar nullObj = {\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(null) : null;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: function resolve() {\n    return null;\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.n,\n  stringify: function stringify() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.n.nullStr;\n  }\n};\nvar boolObj = {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: function resolve(str) {\n    return str[0] === 't' || str[0] === 'T';\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a,\n  stringify: function stringify(_ref) {\n    var value = _ref.value;\n    return value ? _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a.trueStr : _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a.falseStr;\n  }\n};\nvar octObj = {\n  identify: function identify(value) {\n    return intIdentify$2(value) && value >= 0;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: function resolve(str, oct) {\n    return intResolve$1(str, oct, 8);\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i,\n  stringify: function stringify(node) {\n    return intStringify$1(node, 8, '0o');\n  }\n};\nvar intObj = {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return intResolve$1(str, str, 10);\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i,\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n};\nvar hexObj = {\n  identify: function identify(value) {\n    return intIdentify$2(value) && value >= 0;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: function resolve(str, hex) {\n    return intResolve$1(str, hex, 16);\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i,\n  stringify: function stringify(node) {\n    return intStringify$1(node, 16, '0x');\n  }\n};\nvar nanObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: function resolve(str, nan) {\n    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  },\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n};\nvar expObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return parseFloat(str);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return Number(value).toExponential();\n  }\n};\nvar floatObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n  resolve: function resolve(str, frac1, frac2) {\n    var frac = frac1 || frac2;\n    var node = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n};\nvar core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n\n/* global BigInt */\n\nvar intIdentify$1 = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nvar stringifyJSON = function stringifyJSON(_ref) {\n  var value = _ref.value;\n  return JSON.stringify(value);\n};\n\nvar json = [map, seq, {\n  identify: function identify(value) {\n    return typeof value === 'string';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.j,\n  stringify: stringifyJSON\n}, {\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(null) : null;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: function resolve() {\n    return null;\n  },\n  stringify: stringifyJSON\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: function resolve(str) {\n    return str === 'true';\n  },\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: function resolve(str) {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i.asBigInt ? BigInt(str) : parseInt(str, 10);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return intIdentify$1(value) ? value.toString() : JSON.stringify(value);\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: function resolve(str) {\n    return parseFloat(str);\n  },\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = function (str) {\n  throw new SyntaxError(\"Unresolved plain scalar \".concat(JSON.stringify(str)));\n};\n\n/* global BigInt */\n\nvar boolStringify = function boolStringify(_ref) {\n  var value = _ref.value;\n  return value ? _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a.trueStr : _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a.falseStr;\n};\n\nvar intIdentify = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nfunction intResolve(sign, src, radix) {\n  var str = src.replace(/_/g, '');\n\n  if (_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.i.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = \"0b\".concat(str);\n        break;\n\n      case 8:\n        str = \"0o\".concat(str);\n        break;\n\n      case 16:\n        str = \"0x\".concat(str);\n        break;\n    }\n\n    var _n = BigInt(str);\n\n    return sign === '-' ? BigInt(-1) * _n : _n;\n  }\n\n  var n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify(node, radix, prefix) {\n  var value = node.value;\n\n  if (intIdentify(value)) {\n    var str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k)(node);\n}\n\nvar yaml11 = failsafe.concat([{\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(null) : null;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: function resolve() {\n    return null;\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.n,\n  stringify: function stringify() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.n.nullStr;\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: function resolve() {\n    return true;\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a,\n  stringify: boolStringify\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: function resolve() {\n    return false;\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.a,\n  stringify: boolStringify\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: function resolve(str, sign, bin) {\n    return intResolve(sign, bin, 2);\n  },\n  stringify: function stringify(node) {\n    return intStringify(node, 2, '0b');\n  }\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: function resolve(str, sign, oct) {\n    return intResolve(sign, oct, 8);\n  },\n  stringify: function stringify(node) {\n    return intStringify(node, 8, '0');\n  }\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: function resolve(str, sign, abs) {\n    return intResolve(sign, abs, 10);\n  },\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: function resolve(str, sign, hex) {\n    return intResolve(sign, hex, 16);\n  },\n  stringify: function stringify(node) {\n    return intStringify(node, 16, '0x');\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: function resolve(str, nan) {\n    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  },\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return parseFloat(str.replace(/_/g, ''));\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return Number(value).toExponential();\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n  resolve: function resolve(str, frac) {\n    var node = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      var f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n  stringify: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k\n}], _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.b, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.o, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.p, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.s, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.i, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.f, _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.t);\n\nvar schemas = {\n  core: core,\n  failsafe: failsafe,\n  json: json,\n  yaml11: yaml11\n};\nvar tags = {\n  binary: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.b,\n  bool: boolObj,\n  float: floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.f,\n  int: intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.i,\n  map: map,\n  null: nullObj,\n  omap: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.o,\n  pairs: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.p,\n  seq: seq,\n  set: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.s,\n  timestamp: _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.t\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    var match = tags.filter(function (t) {\n      return t.tag === tagName;\n    });\n    var tagObj = match.find(function (t) {\n      return !t.format;\n    }) || match[0];\n    if (!tagObj) throw new Error(\"Tag \".concat(tagName, \" not found\"));\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(function (t) {\n    return (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format;\n  });\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.N) return value;\n  var defaultPrefix = ctx.defaultPrefix,\n      onTagObj = ctx.onTagObj,\n      prevObjects = ctx.prevObjects,\n      schema = ctx.schema,\n      wrapScalars = ctx.wrapScalars;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  var tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (!value || (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) !== 'object') return wrapScalars ? new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  var obj = {\n    value: undefined,\n    node: undefined\n  };\n\n  if (value && (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === 'object' && prevObjects) {\n    var prev = prevObjects.get(value);\n\n    if (prev) {\n      var alias = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.A(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S(value) : value;\n  if (tagName && obj.node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.N) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  var tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    var keys = Object.keys(schemas).map(function (key) {\n      return JSON.stringify(key);\n    }).join(', ');\n    throw new Error(\"Unknown schema \\\"\".concat(schemaId, \"\\\"; use one of \").concat(keys));\n  }\n\n  if (Array.isArray(customTags)) {\n    var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(customTags),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var tag = _step.value;\n        tags = tags.concat(tag);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (var i = 0; i < tags.length; ++i) {\n    var _tag = tags[i];\n\n    if (typeof _tag === 'string') {\n      var tagObj = knownTags[_tag];\n\n      if (!tagObj) {\n        var _keys = Object.keys(knownTags).map(function (key) {\n          return JSON.stringify(key);\n        }).join(', ');\n\n        throw new Error(\"Unknown custom tag \\\"\".concat(_tag, \"\\\"; use one of \").concat(_keys));\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nvar sortMapEntriesByKey = function sortMapEntriesByKey(a, b) {\n  return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n};\n\nvar Schema = /*#__PURE__*/function () {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  function Schema(_ref) {\n    var customTags = _ref.customTags,\n        merge = _ref.merge,\n        schema = _ref.schema,\n        sortMapEntries = _ref.sortMapEntries,\n        deprecatedCustomTags = _ref.tags;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Schema);\n\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) (0,_warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_2__.a)('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Schema, [{\n    key: \"createNode\",\n    value: function createNode$1(value, wrapScalars, tagName, ctx) {\n      var baseCtx = {\n        defaultPrefix: Schema.defaultPrefix,\n        schema: this,\n        wrapScalars: wrapScalars\n      };\n      var createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n      return createNode(value, tagName, createCtx);\n    }\n  }, {\n    key: \"createPair\",\n    value: function createPair(key, value, ctx) {\n      if (!ctx) ctx = {\n        wrapScalars: true\n      };\n      var k = this.createNode(key, ctx.wrapScalars, null, ctx);\n      var v = this.createNode(value, ctx.wrapScalars, null, ctx);\n      return new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P(k, v);\n    }\n  }]);\n\n  return Schema;\n}();\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Schema, \"defaultPrefix\", _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.d);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Schema, \"defaultTags\", _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvU2NoZW1hLWU5NDcxNmM4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc047QUFDdUU7QUFDN0g7O0FBRWhLO0FBQ0EsZ0JBQWdCLHNEQUFPOztBQUV2QjtBQUNBLG9CQUFvQiwwREFBMEI7QUFDOUM7O0FBRUE7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hELDBCQUEwQiwwREFBYztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUksZ0JBQWdCLDBEQUFPO0FBQzNCLHNEQUFzRCwwQkFBMEI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBTztBQUNwQjtBQUNBLFdBQVcsc0RBQVU7QUFDckI7O0FBRUE7QUFDQSxnQkFBZ0Isc0RBQU87O0FBRXZCO0FBQ0Esb0JBQW9CLDBEQUEwQjtBQUM5Qzs7QUFFQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBTztBQUNwQjtBQUNBLFdBQVcsc0RBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLHNEQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLDBEQUFlO0FBQzFCLEdBQUc7QUFDSCxXQUFXLHNEQUFVO0FBQ3JCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsK0RBQW1CO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQWU7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUNBQWlD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QUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQUk7QUFDckI7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCwwREFBZSwwQkFBMEIsc0RBQWdCOztBQUV6RCwwREFBZSx3QkFBd0Isc0RBQVc7O0FBRTNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L1NjaGVtYS1lOTQ3MTZjOC5qcz80M2QwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF8gYXMgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIsIGggYXMgX3NsaWNlZFRvQXJyYXksIGEgYXMgX3R5cGVvZiwgYiBhcyBfY3JlYXRlQ2xhc3MsIGUgYXMgX2RlZmluZVByb3BlcnR5LCBjIGFzIF9jbGFzc0NhbGxDaGVjaywgZCBhcyBkZWZhdWx0VGFnUHJlZml4LCBuIGFzIGRlZmF1bHRUYWdzIH0gZnJvbSAnLi9QbGFpblZhbHVlLWI4MDM2Yjc1LmpzJztcbmltcG9ydCB7IGQgYXMgWUFNTE1hcCwgZyBhcyByZXNvbHZlTWFwLCBZIGFzIFlBTUxTZXEsIGggYXMgcmVzb2x2ZVNlcSwgaiBhcyByZXNvbHZlU3RyaW5nLCBjIGFzIHN0cmluZ2lmeVN0cmluZywgcyBhcyBzdHJPcHRpb25zLCBTIGFzIFNjYWxhciwgbiBhcyBudWxsT3B0aW9ucywgYSBhcyBib29sT3B0aW9ucywgaSBhcyBpbnRPcHRpb25zLCBrIGFzIHN0cmluZ2lmeU51bWJlciwgTiBhcyBOb2RlLCBBIGFzIEFsaWFzLCBQIGFzIFBhaXIgfSBmcm9tICcuL3Jlc29sdmVTZXEtNDkyYWI0NDAuanMnO1xuaW1wb3J0IHsgYiBhcyBiaW5hcnksIG8gYXMgb21hcCwgcCBhcyBwYWlycywgcyBhcyBzZXQsIGkgYXMgaW50VGltZSwgZiBhcyBmbG9hdFRpbWUsIHQgYXMgdGltZXN0YW1wLCBhIGFzIHdhcm5PcHRpb25EZXByZWNhdGlvbiB9IGZyb20gJy4vd2FybmluZ3MtZGY1NGNiNjkuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVNYXAoc2NoZW1hLCBvYmosIGN0eCkge1xuICB2YXIgbWFwID0gbmV3IFlBTUxNYXAoc2NoZW1hKTtcblxuICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG9iaiksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICBtYXAuaXRlbXMucHVzaChzY2hlbWEuY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9iaiAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGtleXMgPSBPYmplY3Qua2V5cyhvYmopOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfa2V5ID0gX09iamVjdCRrZXlzW19pXTtcbiAgICAgIG1hcC5pdGVtcy5wdXNoKHNjaGVtYS5jcmVhdGVQYWlyKF9rZXksIG9ialtfa2V5XSwgY3R4KSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEuc29ydE1hcEVudHJpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtYXAuaXRlbXMuc29ydChzY2hlbWEuc29ydE1hcEVudHJpZXMpO1xuICB9XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIG1hcCA9IHtcbiAgY3JlYXRlTm9kZTogY3JlYXRlTWFwLFxuICBkZWZhdWx0OiB0cnVlLFxuICBub2RlQ2xhc3M6IFlBTUxNYXAsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsXG4gIHJlc29sdmU6IHJlc29sdmVNYXBcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcShzY2hlbWEsIG9iaiwgY3R4KSB7XG4gIHZhciBzZXEgPSBuZXcgWUFNTFNlcShzY2hlbWEpO1xuXG4gIGlmIChvYmogJiYgb2JqW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob2JqKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGl0ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHZhciB2ID0gc2NoZW1hLmNyZWF0ZU5vZGUoaXQsIGN0eC53cmFwU2NhbGFycywgbnVsbCwgY3R4KTtcbiAgICAgICAgc2VxLml0ZW1zLnB1c2godik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXE7XG59XG5cbnZhciBzZXEgPSB7XG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZVNlcSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgbm9kZUNsYXNzOiBZQU1MU2VxLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLFxuICByZXNvbHZlOiByZXNvbHZlU2VxXG59O1xuXG52YXIgc3RyaW5nID0ge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVN0cmluZyxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBhY3R1YWxTdHJpbmc6IHRydWVcbiAgICB9LCBjdHgpO1xuICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfSxcbiAgb3B0aW9uczogc3RyT3B0aW9uc1xufTtcblxudmFyIGZhaWxzYWZlID0gW21hcCwgc2VxLCBzdHJpbmddO1xuXG4vKiBnbG9iYWwgQmlnSW50ICovXG5cbnZhciBpbnRJZGVudGlmeSQyID0gZnVuY3Rpb24gaW50SWRlbnRpZnkodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59O1xuXG52YXIgaW50UmVzb2x2ZSQxID0gZnVuY3Rpb24gaW50UmVzb2x2ZShzcmMsIHBhcnQsIHJhZGl4KSB7XG4gIHJldHVybiBpbnRPcHRpb25zLmFzQmlnSW50ID8gQmlnSW50KHNyYykgOiBwYXJzZUludChwYXJ0LCByYWRpeCk7XG59O1xuXG5mdW5jdGlvbiBpbnRTdHJpbmdpZnkkMShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIGlmIChpbnRJZGVudGlmeSQyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwKSByZXR1cm4gcHJlZml4ICsgdmFsdWUudG9TdHJpbmcocmFkaXgpO1xuICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuXG52YXIgbnVsbE9iaiA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gIH0sXG4gIGNyZWF0ZU5vZGU6IGZ1bmN0aW9uIGNyZWF0ZU5vZGUoc2NoZW1hLCB2YWx1ZSwgY3R4KSB7XG4gICAgcmV0dXJuIGN0eC53cmFwU2NhbGFycyA/IG5ldyBTY2FsYXIobnVsbCkgOiBudWxsO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgdGVzdDogL14oPzp+fFtObl11bGx8TlVMTCk/JC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIG9wdGlvbnM6IG51bGxPcHRpb25zLFxuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeSgpIHtcbiAgICByZXR1cm4gbnVsbE9wdGlvbnMubnVsbFN0cjtcbiAgfVxufTtcbnZhciBib29sT2JqID0ge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICB0ZXN0OiAvXig/OltUdF1ydWV8VFJVRXxbRmZdYWxzZXxGQUxTRSkkLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyWzBdID09PSAndCcgfHwgc3RyWzBdID09PSAnVCc7XG4gIH0sXG4gIG9wdGlvbnM6IGJvb2xPcHRpb25zLFxuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShfcmVmKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgPyBib29sT3B0aW9ucy50cnVlU3RyIDogYm9vbE9wdGlvbnMuZmFsc2VTdHI7XG4gIH1cbn07XG52YXIgb2N0T2JqID0ge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gaW50SWRlbnRpZnkkMih2YWx1ZSkgJiYgdmFsdWUgPj0gMDtcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgZm9ybWF0OiAnT0NUJyxcbiAgdGVzdDogL14wbyhbMC03XSspJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyLCBvY3QpIHtcbiAgICByZXR1cm4gaW50UmVzb2x2ZSQxKHN0ciwgb2N0LCA4KTtcbiAgfSxcbiAgb3B0aW9uczogaW50T3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkobm9kZSkge1xuICAgIHJldHVybiBpbnRTdHJpbmdpZnkkMShub2RlLCA4LCAnMG8nKTtcbiAgfVxufTtcbnZhciBpbnRPYmogPSB7XG4gIGlkZW50aWZ5OiBpbnRJZGVudGlmeSQyLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICB0ZXN0OiAvXlstK10/WzAtOV0rJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyKSB7XG4gICAgcmV0dXJuIGludFJlc29sdmUkMShzdHIsIHN0ciwgMTApO1xuICB9LFxuICBvcHRpb25zOiBpbnRPcHRpb25zLFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbnZhciBoZXhPYmogPSB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRJZGVudGlmeSQyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdIRVgnLFxuICB0ZXN0OiAvXjB4KFswLTlhLWZBLUZdKykkLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIsIGhleCkge1xuICAgIHJldHVybiBpbnRSZXNvbHZlJDEoc3RyLCBoZXgsIDE2KTtcbiAgfSxcbiAgb3B0aW9uczogaW50T3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkobm9kZSkge1xuICAgIHJldHVybiBpbnRTdHJpbmdpZnkkMShub2RlLCAxNiwgJzB4Jyk7XG4gIH1cbn07XG52YXIgbmFuT2JqID0ge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICB0ZXN0OiAvXig/OlstK10/XFwuaW5mfChcXC5uYW4pKSQvaSxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIsIG5hbikge1xuICAgIHJldHVybiBuYW4gPyBOYU4gOiBzdHJbMF0gPT09ICctJyA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG52YXIgZXhwT2JqID0ge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICBmb3JtYXQ6ICdFWFAnLFxuICB0ZXN0OiAvXlstK10/KD86XFwuWzAtOV0rfFswLTldKyg/OlxcLlswLTldKik/KVtlRV1bLStdP1swLTldKyQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0cikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gIH0sXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KF9yZWYyKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSkudG9FeHBvbmVudGlhbCgpO1xuICB9XG59O1xudmFyIGZsb2F0T2JqID0ge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICB0ZXN0OiAvXlstK10/KD86XFwuKFswLTldKyl8WzAtOV0rXFwuKFswLTldKikpJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyLCBmcmFjMSwgZnJhYzIpIHtcbiAgICB2YXIgZnJhYyA9IGZyYWMxIHx8IGZyYWMyO1xuICAgIHZhciBub2RlID0gbmV3IFNjYWxhcihwYXJzZUZsb2F0KHN0cikpO1xuICAgIGlmIChmcmFjICYmIGZyYWNbZnJhYy5sZW5ndGggLSAxXSA9PT0gJzAnKSBub2RlLm1pbkZyYWN0aW9uRGlnaXRzID0gZnJhYy5sZW5ndGg7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xudmFyIGNvcmUgPSBmYWlsc2FmZS5jb25jYXQoW251bGxPYmosIGJvb2xPYmosIG9jdE9iaiwgaW50T2JqLCBoZXhPYmosIG5hbk9iaiwgZXhwT2JqLCBmbG9hdE9ial0pO1xuXG4vKiBnbG9iYWwgQmlnSW50ICovXG5cbnZhciBpbnRJZGVudGlmeSQxID0gZnVuY3Rpb24gaW50SWRlbnRpZnkodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59O1xuXG52YXIgc3RyaW5naWZ5SlNPTiA9IGZ1bmN0aW9uIHN0cmluZ2lmeUpTT04oX3JlZikge1xuICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xufTtcblxudmFyIGpzb24gPSBbbWFwLCBzZXEsIHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gIHJlc29sdmU6IHJlc29sdmVTdHJpbmcsXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxufSwge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgfSxcbiAgY3JlYXRlTm9kZTogZnVuY3Rpb24gY3JlYXRlTm9kZShzY2hlbWEsIHZhbHVlLCBjdHgpIHtcbiAgICByZXR1cm4gY3R4LndyYXBTY2FsYXJzID8gbmV3IFNjYWxhcihudWxsKSA6IG51bGw7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICB0ZXN0OiAvXm51bGwkLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG59LCB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gIHRlc3Q6IC9edHJ1ZXxmYWxzZSQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0cikge1xuICAgIHJldHVybiBzdHIgPT09ICd0cnVlJztcbiAgfSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG59LCB7XG4gIGlkZW50aWZ5OiBpbnRJZGVudGlmeSQxLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICB0ZXN0OiAvXi0/KD86MHxbMS05XVswLTldKikkLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIpIHtcbiAgICByZXR1cm4gaW50T3B0aW9ucy5hc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLCAxMCk7XG4gIH0sXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KF9yZWYyKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG4gICAgcmV0dXJuIGludElkZW50aWZ5JDEodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxufSwge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICB0ZXN0OiAvXi0/KD86MHxbMS05XVswLTldKikoPzpcXC5bMC05XSopPyg/OltlRV1bLStdP1swLTldKyk/JC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgfSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG59XTtcblxuanNvbi5zY2FsYXJGYWxsYmFjayA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5yZXNvbHZlZCBwbGFpbiBzY2FsYXIgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHN0cikpKTtcbn07XG5cbi8qIGdsb2JhbCBCaWdJbnQgKi9cblxudmFyIGJvb2xTdHJpbmdpZnkgPSBmdW5jdGlvbiBib29sU3RyaW5naWZ5KF9yZWYpIHtcbiAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgcmV0dXJuIHZhbHVlID8gYm9vbE9wdGlvbnMudHJ1ZVN0ciA6IGJvb2xPcHRpb25zLmZhbHNlU3RyO1xufTtcblxudmFyIGludElkZW50aWZ5ID0gZnVuY3Rpb24gaW50SWRlbnRpZnkodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiBpbnRSZXNvbHZlKHNpZ24sIHNyYywgcmFkaXgpIHtcbiAgdmFyIHN0ciA9IHNyYy5yZXBsYWNlKC9fL2csICcnKTtcblxuICBpZiAoaW50T3B0aW9ucy5hc0JpZ0ludCkge1xuICAgIHN3aXRjaCAocmFkaXgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgc3RyID0gXCIwYlwiLmNvbmNhdChzdHIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA4OlxuICAgICAgICBzdHIgPSBcIjBvXCIuY29uY2F0KHN0cik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE2OlxuICAgICAgICBzdHIgPSBcIjB4XCIuY29uY2F0KHN0cik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBfbiA9IEJpZ0ludChzdHIpO1xuXG4gICAgcmV0dXJuIHNpZ24gPT09ICctJyA/IEJpZ0ludCgtMSkgKiBfbiA6IF9uO1xuICB9XG5cbiAgdmFyIG4gPSBwYXJzZUludChzdHIsIHJhZGl4KTtcbiAgcmV0dXJuIHNpZ24gPT09ICctJyA/IC0xICogbiA6IG47XG59XG5cbmZ1bmN0aW9uIGludFN0cmluZ2lmeShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG5cbiAgaWYgKGludElkZW50aWZ5KHZhbHVlKSkge1xuICAgIHZhciBzdHIgPSB2YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgcmV0dXJuIHZhbHVlIDwgMCA/ICctJyArIHByZWZpeCArIHN0ci5zdWJzdHIoMSkgOiBwcmVmaXggKyBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuXG52YXIgeWFtbDExID0gZmFpbHNhZmUuY29uY2F0KFt7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICB9LFxuICBjcmVhdGVOb2RlOiBmdW5jdGlvbiBjcmVhdGVOb2RlKHNjaGVtYSwgdmFsdWUsIGN0eCkge1xuICAgIHJldHVybiBjdHgud3JhcFNjYWxhcnMgPyBuZXcgU2NhbGFyKG51bGwpIDogbnVsbDtcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsXG4gIHRlc3Q6IC9eKD86fnxbTm5ddWxsfE5VTEwpPyQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBvcHRpb25zOiBudWxsT3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgcmV0dXJuIG51bGxPcHRpb25zLm51bGxTdHI7XG4gIH1cbn0sIHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgdGVzdDogL14oPzpZfHl8W1l5XWVzfFlFU3xbVHRdcnVlfFRSVUV8W09vXW58T04pJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIG9wdGlvbnM6IGJvb2xPcHRpb25zLFxuICBzdHJpbmdpZnk6IGJvb2xTdHJpbmdpZnlcbn0sIHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgdGVzdDogL14oPzpOfG58W05uXW98Tk98W0ZmXWFsc2V8RkFMU0V8W09vXWZmfE9GRikkL2ksXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBvcHRpb25zOiBib29sT3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59LCB7XG4gIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgZm9ybWF0OiAnQklOJyxcbiAgdGVzdDogL14oWy0rXT8pMGIoWzAtMV9dKykkLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIsIHNpZ24sIGJpbikge1xuICAgIHJldHVybiBpbnRSZXNvbHZlKHNpZ24sIGJpbiwgMik7XG4gIH0sXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUpIHtcbiAgICByZXR1cm4gaW50U3RyaW5naWZ5KG5vZGUsIDIsICcwYicpO1xuICB9XG59LCB7XG4gIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgZm9ybWF0OiAnT0NUJyxcbiAgdGVzdDogL14oWy0rXT8pMChbMC03X10rKSQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0ciwgc2lnbiwgb2N0KSB7XG4gICAgcmV0dXJuIGludFJlc29sdmUoc2lnbiwgb2N0LCA4KTtcbiAgfSxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkobm9kZSkge1xuICAgIHJldHVybiBpbnRTdHJpbmdpZnkobm9kZSwgOCwgJzAnKTtcbiAgfVxufSwge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIHRlc3Q6IC9eKFstK10/KShbMC05XVswLTlfXSopJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyLCBzaWduLCBhYnMpIHtcbiAgICByZXR1cm4gaW50UmVzb2x2ZShzaWduLCBhYnMsIDEwKTtcbiAgfSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn0sIHtcbiAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdIRVgnLFxuICB0ZXN0OiAvXihbLStdPykweChbMC05YS1mQS1GX10rKSQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0ciwgc2lnbiwgaGV4KSB7XG4gICAgcmV0dXJuIGludFJlc29sdmUoc2lnbiwgaGV4LCAxNik7XG4gIH0sXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUpIHtcbiAgICByZXR1cm4gaW50U3RyaW5naWZ5KG5vZGUsIDE2LCAnMHgnKTtcbiAgfVxufSwge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICB0ZXN0OiAvXig/OlstK10/XFwuaW5mfChcXC5uYW4pKSQvaSxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIsIG5hbikge1xuICAgIHJldHVybiBuYW4gPyBOYU4gOiBzdHJbMF0gPT09ICctJyA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn0sIHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgZm9ybWF0OiAnRVhQJyxcbiAgdGVzdDogL15bLStdPyhbMC05XVswLTlfXSopPyhcXC5bMC05X10qKT9bZUVdWy0rXT9bMC05XSskLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpO1xuICB9LFxuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShfcmVmMikge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpLnRvRXhwb25lbnRpYWwoKTtcbiAgfVxufSwge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICB0ZXN0OiAvXlstK10/KD86WzAtOV1bMC05X10qKT9cXC4oWzAtOV9dKikkLyxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShzdHIsIGZyYWMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBTY2FsYXIocGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpKTtcblxuICAgIGlmIChmcmFjKSB7XG4gICAgICB2YXIgZiA9IGZyYWMucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICBpZiAoZltmLmxlbmd0aCAtIDFdID09PSAnMCcpIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBmLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn1dLCBiaW5hcnksIG9tYXAsIHBhaXJzLCBzZXQsIGludFRpbWUsIGZsb2F0VGltZSwgdGltZXN0YW1wKTtcblxudmFyIHNjaGVtYXMgPSB7XG4gIGNvcmU6IGNvcmUsXG4gIGZhaWxzYWZlOiBmYWlsc2FmZSxcbiAganNvbjoganNvbixcbiAgeWFtbDExOiB5YW1sMTFcbn07XG52YXIgdGFncyA9IHtcbiAgYmluYXJ5OiBiaW5hcnksXG4gIGJvb2w6IGJvb2xPYmosXG4gIGZsb2F0OiBmbG9hdE9iaixcbiAgZmxvYXRFeHA6IGV4cE9iaixcbiAgZmxvYXROYU46IG5hbk9iaixcbiAgZmxvYXRUaW1lOiBmbG9hdFRpbWUsXG4gIGludDogaW50T2JqLFxuICBpbnRIZXg6IGhleE9iaixcbiAgaW50T2N0OiBvY3RPYmosXG4gIGludFRpbWU6IGludFRpbWUsXG4gIG1hcDogbWFwLFxuICBudWxsOiBudWxsT2JqLFxuICBvbWFwOiBvbWFwLFxuICBwYWlyczogcGFpcnMsXG4gIHNlcTogc2VxLFxuICBzZXQ6IHNldCxcbiAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbn07XG5cbmZ1bmN0aW9uIGZpbmRUYWdPYmplY3QodmFsdWUsIHRhZ05hbWUsIHRhZ3MpIHtcbiAgaWYgKHRhZ05hbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSB0YWdzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQudGFnID09PSB0YWdOYW1lO1xuICAgIH0pO1xuICAgIHZhciB0YWdPYmogPSBtYXRjaC5maW5kKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gIXQuZm9ybWF0O1xuICAgIH0pIHx8IG1hdGNoWzBdO1xuICAgIGlmICghdGFnT2JqKSB0aHJvdyBuZXcgRXJyb3IoXCJUYWcgXCIuY29uY2F0KHRhZ05hbWUsIFwiIG5vdCBmb3VuZFwiKSk7XG4gICAgcmV0dXJuIHRhZ09iajtcbiAgfSAvLyBUT0RPOiBkZXByZWNhdGUvcmVtb3ZlIGNsYXNzIGNoZWNrXG5cblxuICByZXR1cm4gdGFncy5maW5kKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuICh0LmlkZW50aWZ5ICYmIHQuaWRlbnRpZnkodmFsdWUpIHx8IHQuY2xhc3MgJiYgdmFsdWUgaW5zdGFuY2VvZiB0LmNsYXNzKSAmJiAhdC5mb3JtYXQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlLCB0YWdOYW1lLCBjdHgpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTm9kZSkgcmV0dXJuIHZhbHVlO1xuICB2YXIgZGVmYXVsdFByZWZpeCA9IGN0eC5kZWZhdWx0UHJlZml4LFxuICAgICAgb25UYWdPYmogPSBjdHgub25UYWdPYmosXG4gICAgICBwcmV2T2JqZWN0cyA9IGN0eC5wcmV2T2JqZWN0cyxcbiAgICAgIHNjaGVtYSA9IGN0eC5zY2hlbWEsXG4gICAgICB3cmFwU2NhbGFycyA9IGN0eC53cmFwU2NhbGFycztcbiAgaWYgKHRhZ05hbWUgJiYgdGFnTmFtZS5zdGFydHNXaXRoKCchIScpKSB0YWdOYW1lID0gZGVmYXVsdFByZWZpeCArIHRhZ05hbWUuc2xpY2UoMik7XG4gIHZhciB0YWdPYmogPSBmaW5kVGFnT2JqZWN0KHZhbHVlLCB0YWdOYW1lLCBzY2hlbWEudGFncyk7XG5cbiAgaWYgKCF0YWdPYmopIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSB2YWx1ZS50b0pTT04oKTtcbiAgICBpZiAoIXZhbHVlIHx8IF90eXBlb2YodmFsdWUpICE9PSAnb2JqZWN0JykgcmV0dXJuIHdyYXBTY2FsYXJzID8gbmV3IFNjYWxhcih2YWx1ZSkgOiB2YWx1ZTtcbiAgICB0YWdPYmogPSB2YWx1ZSBpbnN0YW5jZW9mIE1hcCA/IG1hcCA6IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0gPyBzZXEgOiBtYXA7XG4gIH1cblxuICBpZiAob25UYWdPYmopIHtcbiAgICBvblRhZ09iaih0YWdPYmopO1xuICAgIGRlbGV0ZSBjdHgub25UYWdPYmo7XG4gIH0gLy8gRGV0ZWN0IGR1cGxpY2F0ZSByZWZlcmVuY2VzIHRvIHRoZSBzYW1lIG9iamVjdCAmIHVzZSBBbGlhcyBub2RlcyBmb3IgYWxsXG4gIC8vIGFmdGVyIGZpcnN0LiBUaGUgYG9iamAgd3JhcHBlciBhbGxvd3MgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgdG8gcmVzb2x2ZS5cblxuXG4gIHZhciBvYmogPSB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBub2RlOiB1bmRlZmluZWRcbiAgfTtcblxuICBpZiAodmFsdWUgJiYgX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHByZXZPYmplY3RzKSB7XG4gICAgdmFyIHByZXYgPSBwcmV2T2JqZWN0cy5nZXQodmFsdWUpO1xuXG4gICAgaWYgKHByZXYpIHtcbiAgICAgIHZhciBhbGlhcyA9IG5ldyBBbGlhcyhwcmV2KTsgLy8gbGVhdmVzIHNvdXJjZSBkaXJ0eTsgbXVzdCBiZSBjbGVhbmVkIGJ5IGNhbGxlclxuXG4gICAgICBjdHguYWxpYXNOb2Rlcy5wdXNoKGFsaWFzKTsgLy8gZGVmaW5lZCBhbG9uZyB3aXRoIHByZXZPYmplY3RzXG5cbiAgICAgIHJldHVybiBhbGlhcztcbiAgICB9XG5cbiAgICBvYmoudmFsdWUgPSB2YWx1ZTtcbiAgICBwcmV2T2JqZWN0cy5zZXQodmFsdWUsIG9iaik7XG4gIH1cblxuICBvYmoubm9kZSA9IHRhZ09iai5jcmVhdGVOb2RlID8gdGFnT2JqLmNyZWF0ZU5vZGUoY3R4LnNjaGVtYSwgdmFsdWUsIGN0eCkgOiB3cmFwU2NhbGFycyA/IG5ldyBTY2FsYXIodmFsdWUpIDogdmFsdWU7XG4gIGlmICh0YWdOYW1lICYmIG9iai5ub2RlIGluc3RhbmNlb2YgTm9kZSkgb2JqLm5vZGUudGFnID0gdGFnTmFtZTtcbiAgcmV0dXJuIG9iai5ub2RlO1xufVxuXG5mdW5jdGlvbiBnZXRTY2hlbWFUYWdzKHNjaGVtYXMsIGtub3duVGFncywgY3VzdG9tVGFncywgc2NoZW1hSWQpIHtcbiAgdmFyIHRhZ3MgPSBzY2hlbWFzW3NjaGVtYUlkLnJlcGxhY2UoL1xcVy9nLCAnJyldOyAvLyAneWFtbC0xLjEnIC0+ICd5YW1sMTEnXG5cbiAgaWYgKCF0YWdzKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWFzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgfSkuam9pbignLCAnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNjaGVtYSBcXFwiXCIuY29uY2F0KHNjaGVtYUlkLCBcIlxcXCI7IHVzZSBvbmUgb2YgXCIpLmNvbmNhdChrZXlzKSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSkge1xuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjdXN0b21UYWdzKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHRhZyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB0YWdzID0gdGFncy5jb25jYXQodGFnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBjdXN0b21UYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGFncyA9IGN1c3RvbVRhZ3ModGFncy5zbGljZSgpKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBfdGFnID0gdGFnc1tpXTtcblxuICAgIGlmICh0eXBlb2YgX3RhZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciB0YWdPYmogPSBrbm93blRhZ3NbX3RhZ107XG5cbiAgICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIHZhciBfa2V5cyA9IE9iamVjdC5rZXlzKGtub3duVGFncykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgfSkuam9pbignLCAnKTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGN1c3RvbSB0YWcgXFxcIlwiLmNvbmNhdChfdGFnLCBcIlxcXCI7IHVzZSBvbmUgb2YgXCIpLmNvbmNhdChfa2V5cykpO1xuICAgICAgfVxuXG4gICAgICB0YWdzW2ldID0gdGFnT2JqO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWdzO1xufVxuXG52YXIgc29ydE1hcEVudHJpZXNCeUtleSA9IGZ1bmN0aW9uIHNvcnRNYXBFbnRyaWVzQnlLZXkoYSwgYikge1xuICByZXR1cm4gYS5rZXkgPCBiLmtleSA/IC0xIDogYS5rZXkgPiBiLmtleSA/IDEgOiAwO1xufTtcblxudmFyIFNjaGVtYSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIFRPRE86IHJlbW92ZSBpbiB2MlxuICAvLyBUT0RPOiByZW1vdmUgaW4gdjJcbiAgZnVuY3Rpb24gU2NoZW1hKF9yZWYpIHtcbiAgICB2YXIgY3VzdG9tVGFncyA9IF9yZWYuY3VzdG9tVGFncyxcbiAgICAgICAgbWVyZ2UgPSBfcmVmLm1lcmdlLFxuICAgICAgICBzY2hlbWEgPSBfcmVmLnNjaGVtYSxcbiAgICAgICAgc29ydE1hcEVudHJpZXMgPSBfcmVmLnNvcnRNYXBFbnRyaWVzLFxuICAgICAgICBkZXByZWNhdGVkQ3VzdG9tVGFncyA9IF9yZWYudGFncztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2hlbWEpO1xuXG4gICAgdGhpcy5tZXJnZSA9ICEhbWVyZ2U7XG4gICAgdGhpcy5uYW1lID0gc2NoZW1hO1xuICAgIHRoaXMuc29ydE1hcEVudHJpZXMgPSBzb3J0TWFwRW50cmllcyA9PT0gdHJ1ZSA/IHNvcnRNYXBFbnRyaWVzQnlLZXkgOiBzb3J0TWFwRW50cmllcyB8fCBudWxsO1xuICAgIGlmICghY3VzdG9tVGFncyAmJiBkZXByZWNhdGVkQ3VzdG9tVGFncykgd2Fybk9wdGlvbkRlcHJlY2F0aW9uKCd0YWdzJywgJ2N1c3RvbVRhZ3MnKTtcbiAgICB0aGlzLnRhZ3MgPSBnZXRTY2hlbWFUYWdzKHNjaGVtYXMsIHRhZ3MsIGN1c3RvbVRhZ3MgfHwgZGVwcmVjYXRlZEN1c3RvbVRhZ3MsIHNjaGVtYSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2NoZW1hLCBbe1xuICAgIGtleTogXCJjcmVhdGVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU5vZGUkMSh2YWx1ZSwgd3JhcFNjYWxhcnMsIHRhZ05hbWUsIGN0eCkge1xuICAgICAgdmFyIGJhc2VDdHggPSB7XG4gICAgICAgIGRlZmF1bHRQcmVmaXg6IFNjaGVtYS5kZWZhdWx0UHJlZml4LFxuICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgIHdyYXBTY2FsYXJzOiB3cmFwU2NhbGFyc1xuICAgICAgfTtcbiAgICAgIHZhciBjcmVhdGVDdHggPSBjdHggPyBPYmplY3QuYXNzaWduKGN0eCwgYmFzZUN0eCkgOiBiYXNlQ3R4O1xuICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUodmFsdWUsIHRhZ05hbWUsIGNyZWF0ZUN0eCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVBhaXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpIHtcbiAgICAgIGlmICghY3R4KSBjdHggPSB7XG4gICAgICAgIHdyYXBTY2FsYXJzOiB0cnVlXG4gICAgICB9O1xuICAgICAgdmFyIGsgPSB0aGlzLmNyZWF0ZU5vZGUoa2V5LCBjdHgud3JhcFNjYWxhcnMsIG51bGwsIGN0eCk7XG4gICAgICB2YXIgdiA9IHRoaXMuY3JlYXRlTm9kZSh2YWx1ZSwgY3R4LndyYXBTY2FsYXJzLCBudWxsLCBjdHgpO1xuICAgICAgcmV0dXJuIG5ldyBQYWlyKGssIHYpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY2hlbWE7XG59KCk7XG5cbl9kZWZpbmVQcm9wZXJ0eShTY2hlbWEsIFwiZGVmYXVsdFByZWZpeFwiLCBkZWZhdWx0VGFnUHJlZml4KTtcblxuX2RlZmluZVByb3BlcnR5KFNjaGVtYSwgXCJkZWZhdWx0VGFnc1wiLCBkZWZhdWx0VGFncyk7XG5cbmV4cG9ydCB7IFNjaGVtYSBhcyBTIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/Schema-e94716c8.js\n")},"./node_modules/yaml/browser/dist/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"YAML\": () => (/* binding */ YAML)\n/* harmony export */ });\n/* harmony import */ var _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlainValue-b8036b75.js */ \"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\");\n/* harmony import */ var _parse_cst_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse-cst.js */ \"./node_modules/yaml/browser/dist/parse-cst.js\");\n/* harmony import */ var _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resolveSeq-492ab440.js */ \"./node_modules/yaml/browser/dist/resolveSeq-492ab440.js\");\n/* harmony import */ var _Schema_e94716c8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Schema-e94716c8.js */ \"./node_modules/yaml/browser/dist/Schema-e94716c8.js\");\n/* harmony import */ var _warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./warnings-df54cb69.js */ \"./node_modules/yaml/browser/dist/warnings-df54cb69.js\");\n\n\n\n\n\n\nvar defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nvar scalarOptions = {\n  get binary() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.b;\n  },\n\n  set binary(opt) {\n    Object.assign(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.b, opt);\n  },\n\n  get bool() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.a;\n  },\n\n  set bool(opt) {\n    Object.assign(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.a, opt);\n  },\n\n  get int() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.i;\n  },\n\n  set int(opt) {\n    Object.assign(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.i, opt);\n  },\n\n  get null() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.n;\n  },\n\n  set null(opt) {\n    Object.assign(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.n, opt);\n  },\n\n  get str() {\n    return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.s;\n  },\n\n  set str(opt) {\n    Object.assign(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.s, opt);\n  }\n\n};\nvar documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.d\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.d\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.d\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    var priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? \"!\".concat(vocab[1], \"/\").concat(vocab[2]) : \"!\".concat(tag.replace(/^tag:/, ''));\n  }\n\n  var p = doc.tagPrefixes.find(function (p) {\n    return tag.indexOf(p.prefix) === 0;\n  });\n\n  if (!p) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(function (p) {\n      return tag.indexOf(p.prefix) === 0;\n    });\n  }\n\n  if (!p) return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  var suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, function (ch) {\n    return {\n      '!': '%21',\n      ',': '%2C',\n      '[': '%5B',\n      ']': '%5D',\n      '{': '%7B',\n      '}': '%7D'\n    }[ch];\n  });\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.A) return _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.A;\n\n  if (item.tag) {\n    var match = tags.filter(function (t) {\n      return t.tag === item.tag;\n    });\n    if (match.length > 0) return match.find(function (t) {\n      return t.format === item.format;\n    }) || match[0];\n  }\n\n  var tagObj, obj;\n\n  if (item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    var _match = tags.filter(function (t) {\n      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;\n    });\n\n    tagObj = _match.find(function (t) {\n      return t.format === item.format;\n    }) || _match.find(function (t) {\n      return !t.format;\n    });\n  } else {\n    obj = item;\n    tagObj = tags.find(function (t) {\n      return t.nodeClass && obj instanceof t.nodeClass;\n    });\n  }\n\n  if (!tagObj) {\n    var name = obj && obj.constructor ? obj.constructor.name : (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(obj);\n    throw new Error(\"Tag not resolved for \".concat(name, \" value\"));\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, _ref) {\n  var anchors = _ref.anchors,\n      doc = _ref.doc;\n  var props = [];\n  var anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(\"&\".concat(anchor));\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify$1(item, ctx, onComment, onChompKeep) {\n  var _ctx$doc = ctx.doc,\n      anchors = _ctx$doc.anchors,\n      schema = _ctx$doc.schema;\n  var tagObj;\n\n  if (!(item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.N)) {\n    var createCtx = {\n      aliasNodes: [],\n      onTagObj: function onTagObj(o) {\n        return tagObj = o;\n      },\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(createCtx.aliasNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var alias = _step.value;\n        alias.source = alias.source.node;\n        var name = anchors.getName(alias.source);\n\n        if (!name) {\n          name = anchors.newName();\n          anchors.map[name] = alias.source;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.P) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  var props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S ? (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.c)(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S || str[0] === '{' || str[0] === '[' ? \"\".concat(props, \" \").concat(str) : \"\".concat(props, \"\\n\").concat(ctx.indent).concat(str);\n}\n\nvar Anchors = /*#__PURE__*/function () {\n  function Anchors(prefix) {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Anchors);\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Anchors, [{\n    key: \"createAlias\",\n    value: function createAlias(node, name) {\n      this.setAnchor(node, name);\n      return new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.A(node);\n    }\n  }, {\n    key: \"createMergePair\",\n    value: function createMergePair() {\n      var _this = this;\n\n      var merge = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.M();\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      merge.value.items = sources.map(function (s) {\n        if (s instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.A) {\n          if (s.source instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.d) return s;\n        } else if (s instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.d) {\n          return _this.createAlias(s);\n        }\n\n        throw new Error('Merge sources must be Map nodes or their Aliases');\n      });\n      return merge;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(node) {\n      var map = this.map;\n      return Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      return Object.keys(this.map);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(name) {\n      return this.map[name];\n    }\n  }, {\n    key: \"newName\",\n    value: function newName(prefix) {\n      if (!prefix) prefix = this.prefix;\n      var names = Object.keys(this.map);\n\n      for (var i = 1; true; ++i) {\n        var name = \"\".concat(prefix).concat(i);\n        if (!names.includes(name)) return name;\n      }\n    } // During parsing, map & aliases contain CST nodes\n\n  }, {\n    key: \"resolveNodes\",\n    value: function resolveNodes() {\n      var map = this.map,\n          _cstAliases = this._cstAliases;\n      Object.keys(map).forEach(function (a) {\n        map[a] = map[a].resolved;\n      });\n\n      _cstAliases.forEach(function (a) {\n        a.source = a.source.resolved;\n      });\n\n      delete this._cstAliases;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(node, name) {\n      if (node != null && !Anchors.validAnchorNode(node)) {\n        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n      }\n\n      if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n        throw new Error('Anchor names must not contain whitespace or control characters');\n      }\n\n      var map = this.map;\n      var prev = node && Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n\n      if (prev) {\n        if (!name) {\n          return prev;\n        } else if (prev !== name) {\n          delete map[prev];\n          map[name] = node;\n        }\n      } else {\n        if (!name) {\n          if (!node) return null;\n          name = this.newName();\n        }\n\n        map[name] = node;\n      }\n\n      return name;\n    }\n  }], [{\n    key: \"validAnchorNode\",\n    value: function validAnchorNode(node) {\n      return node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S || node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.Y || node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.d;\n    }\n  }]);\n\n  return Anchors;\n}();\n\nvar visit = function visit(node, tags) {\n  if (node && (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(node) === 'object') {\n    var tag = node.tag;\n\n    if (node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(function (n) {\n        return visit(n, tags);\n      });\n    } else if (node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.P) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nvar listTagNames = function listTagNames(node) {\n  return Object.keys(visit(node, {}));\n};\n\nfunction parseContents(doc, contents) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var body = undefined;\n  var spaceBefore = false;\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(contents),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.valueRange) {\n        if (body !== undefined) {\n          var msg = 'Document contains trailing content not separated by a ... or --- line';\n          doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(node, msg));\n          break;\n        }\n\n        var res = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.r)(doc, node);\n\n        if (spaceBefore) {\n          res.spaceBefore = true;\n          spaceBefore = false;\n        }\n\n        body = res;\n      } else if (node.comment !== null) {\n        var cc = body === undefined ? comments.before : comments.after;\n        cc.push(node.comment);\n      } else if (node.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE) {\n        spaceBefore = true;\n\n        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n          // space-separated comments at start are parsed as document comments\n          doc.commentBefore = comments.before.join('\\n');\n          comments.before = [];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      var cbNode = body instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? \"\".concat(cb, \"\\n\").concat(cbNode.commentBefore) : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective(_ref, directive) {\n  var tagPrefixes = _ref.tagPrefixes;\n\n  var _directive$parameters = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.h)(directive.parameters, 2),\n      handle = _directive$parameters[0],\n      prefix = _directive$parameters[1];\n\n  if (!handle || !prefix) {\n    var msg = 'Insufficient parameters given for %TAG directive';\n    throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(directive, msg);\n  }\n\n  if (tagPrefixes.some(function (p) {\n    return p.handle === handle;\n  })) {\n    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(directive, _msg);\n  }\n\n  return {\n    handle: handle,\n    prefix: prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  var _directive$parameters2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.h)(directive.parameters, 1),\n      version = _directive$parameters2[0];\n\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    var msg = 'Insufficient parameters given for %YAML directive';\n    throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    var v0 = doc.version || doc.options.version;\n\n    var _msg2 = \"Document will be parsed as YAML \".concat(v0, \" rather than YAML \").concat(version);\n\n    doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(directive, _msg2));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  var directiveComments = [];\n  var hasDirectives = false;\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(directives),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      var comment = directive.comment,\n          name = directive.name;\n\n      switch (name) {\n        case 'TAG':\n          try {\n            doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        case 'YAML':\n        case 'YAML:1.0':\n          if (doc.version) {\n            var msg = 'The %YAML directive must only be given at most once per document.';\n            doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(directive, msg));\n          }\n\n          try {\n            doc.version = resolveYamlDirective(doc, directive);\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        default:\n          if (name) {\n            var _msg3 = \"YAML only supports %TAG and %YAML directives, and not %\".concat(name);\n\n            doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(directive, _msg3));\n          }\n\n      }\n\n      if (comment) directiveComments.push(comment);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    var copyTagPrefix = function copyTagPrefix(_ref2) {\n      var handle = _ref2.handle,\n          prefix = _ref2.prefix;\n      return {\n        handle: handle,\n        prefix: prefix\n      };\n    };\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nvar Document$1 = /*#__PURE__*/function () {\n  function Document(options) {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Document);\n\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Document, [{\n    key: \"add\",\n    value: function add(value) {\n      assertCollection(this.contents);\n      return this.contents.add(value);\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      assertCollection(this.contents);\n      this.contents.addIn(path, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      assertCollection(this.contents);\n      return this.contents.delete(key);\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      if ((0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.e)(path)) {\n        if (this.contents == null) return false;\n        this.contents = null;\n        return true;\n      }\n\n      assertCollection(this.contents);\n      return this.contents.deleteIn(path);\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      return this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C ? this.contents.get(key, keepScalar) : undefined;\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      if ((0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.e)(path)) return !keepScalar && this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S ? this.contents.value : this.contents;\n      return this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C ? this.contents.has(key) : false;\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      if ((0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.e)(path)) return this.contents !== undefined;\n      return this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.C ? this.contents.hasIn(path) : false;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assertCollection(this.contents);\n      this.contents.set(key, value);\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      if ((0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.e)(path)) this.contents = value;else {\n        assertCollection(this.contents);\n        this.contents.setIn(path, value);\n      }\n    }\n  }, {\n    key: \"setSchema\",\n    value: function setSchema(id, customTags) {\n      if (!id && !customTags && this.schema) return;\n      if (typeof id === 'number') id = id.toFixed(1);\n\n      if (id === '1.0' || id === '1.1' || id === '1.2') {\n        if (this.version) this.version = id;else this.options.version = id;\n        delete this.options.schema;\n      } else if (id && typeof id === 'string') {\n        this.options.schema = id;\n      }\n\n      if (Array.isArray(customTags)) this.options.customTags = customTags;\n      var opt = Object.assign({}, this.getDefaults(), this.options);\n      this.schema = new _Schema_e94716c8_js__WEBPACK_IMPORTED_MODULE_3__.S(opt);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(node, prevDoc) {\n      if (this.options.keepCstNodes) this.cstNode = node;\n      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n      var _node$directives = node.directives,\n          directives = _node$directives === void 0 ? [] : _node$directives,\n          _node$contents = node.contents,\n          contents = _node$contents === void 0 ? [] : _node$contents,\n          directivesEndMarker = node.directivesEndMarker,\n          error = node.error,\n          valueRange = node.valueRange;\n\n      if (error) {\n        if (!error.source) error.source = this;\n        this.errors.push(error);\n      }\n\n      parseDirectives(this, directives, prevDoc);\n      if (directivesEndMarker) this.directivesEndMarker = true;\n      this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n      this.setSchema();\n      this.anchors._cstAliases = [];\n      parseContents(this, contents);\n      this.anchors.resolveNodes();\n\n      if (this.options.prettyErrors) {\n        var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.errors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _error = _step.value;\n            if (_error instanceof _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.i) _error.makePretty();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.warnings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var warn = _step2.value;\n            if (warn instanceof _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.i) warn.makePretty();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"listNonDefaultTags\",\n    value: function listNonDefaultTags() {\n      return listTagNames(this.contents).filter(function (t) {\n        return t.indexOf(_Schema_e94716c8_js__WEBPACK_IMPORTED_MODULE_3__.S.defaultPrefix) !== 0;\n      });\n    }\n  }, {\n    key: \"setTagPrefix\",\n    value: function setTagPrefix(handle, prefix) {\n      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n      if (prefix) {\n        var prev = this.tagPrefixes.find(function (p) {\n          return p.handle === handle;\n        });\n        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n          handle: handle,\n          prefix: prefix\n        });\n      } else {\n        this.tagPrefixes = this.tagPrefixes.filter(function (p) {\n          return p.handle !== handle;\n        });\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, onAnchor) {\n      var _this = this;\n\n      var _this$options = this.options,\n          keepBlobsInJSON = _this$options.keepBlobsInJSON,\n          mapAsMap = _this$options.mapAsMap,\n          maxAliasCount = _this$options.maxAliasCount;\n      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.S));\n      var ctx = {\n        doc: this,\n        indentStep: '  ',\n        keep: keep,\n        mapAsMap: keep && !!mapAsMap,\n        maxAliasCount: maxAliasCount,\n        stringify: stringify$1 // Requiring directly in Pair would create circular dependencies\n\n      };\n      var anchorNames = Object.keys(this.anchors.map);\n      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {\n        return [_this.anchors.map[name], {\n          alias: [],\n          aliasCount: 0,\n          count: 1\n        }];\n      }));\n\n      var res = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.t)(this.contents, arg, ctx);\n\n      if (typeof onAnchor === 'function' && ctx.anchors) {\n        var _iterator3 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(ctx.anchors.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _step3.value,\n                count = _step3$value.count,\n                _res = _step3$value.res;\n            onAnchor(_res, count);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n      var indentSize = this.options.indent;\n\n      if (!Number.isInteger(indentSize) || indentSize <= 0) {\n        var s = JSON.stringify(indentSize);\n        throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n      }\n\n      this.setSchema();\n      var lines = [];\n      var hasDirectives = false;\n\n      if (this.version) {\n        var vd = '%YAML 1.2';\n\n        if (this.schema.name === 'yaml-1.1') {\n          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n        }\n\n        lines.push(vd);\n        hasDirectives = true;\n      }\n\n      var tagNames = this.listNonDefaultTags();\n      this.tagPrefixes.forEach(function (_ref) {\n        var handle = _ref.handle,\n            prefix = _ref.prefix;\n\n        if (tagNames.some(function (t) {\n          return t.indexOf(prefix) === 0;\n        })) {\n          lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n          hasDirectives = true;\n        }\n      });\n      if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n      if (this.commentBefore) {\n        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n        lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n      }\n\n      var ctx = {\n        anchors: Object.create(null),\n        doc: this,\n        indent: '',\n        indentStep: ' '.repeat(indentSize),\n        stringify: stringify$1 // Requiring directly in nodes would create circular dependencies\n\n      };\n      var chompKeep = false;\n      var contentComment = null;\n\n      if (this.contents) {\n        if (this.contents instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.N) {\n          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n          ctx.forceBlockIndent = !!this.comment;\n          contentComment = this.contents.comment;\n        }\n\n        var onChompKeep = contentComment ? null : function () {\n          return chompKeep = true;\n        };\n        var body = stringify$1(this.contents, ctx, function () {\n          return contentComment = null;\n        }, onChompKeep);\n        lines.push((0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_2__.f)(body, '', contentComment));\n      } else if (this.contents !== undefined) {\n        lines.push(stringify$1(this.contents, ctx));\n      }\n\n      if (this.comment) {\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n        lines.push(this.comment.replace(/^/gm, '#'));\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n  }]);\n\n  return Document;\n}();\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Document$1, \"defaults\", documentOptions);\n\nfunction createNode(value) {\n  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var tag = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);\n  var schema = new _Schema_e94716c8_js__WEBPACK_IMPORTED_MODULE_3__.S(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nvar Document = /*#__PURE__*/function (_YAMLDocument) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Document, _YAMLDocument);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Document);\n\n  function Document(options) {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Document);\n\n    return _super.call(this, Object.assign({}, defaultOptions, options));\n  }\n\n  return Document;\n}(Document$1);\n\nfunction parseAllDocuments(src, options) {\n  var stream = [];\n  var prev;\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_parse_cst_js__WEBPACK_IMPORTED_MODULE_1__.parse)(src)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var cstDoc = _step.value;\n      var doc = new Document(options);\n      doc.parse(cstDoc, prev);\n      stream.push(doc);\n      prev = doc;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  var cst = (0,_parse_cst_js__WEBPACK_IMPORTED_MODULE_1__.parse)(src);\n  var doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  var doc = parseDocument(src, options);\n  doc.warnings.forEach(function (warning) {\n    return (0,_warnings_df54cb69_js__WEBPACK_IMPORTED_MODULE_4__.w)(warning);\n  });\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  var doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nvar YAML = {\n  createNode: createNode,\n  defaultOptions: defaultOptions,\n  Document: Document,\n  parse: parse,\n  parseAllDocuments: parseAllDocuments,\n  parseCST: _parse_cst_js__WEBPACK_IMPORTED_MODULE_1__.parse,\n  parseDocument: parseDocument,\n  scalarOptions: scalarOptions,\n  stringify: stringify\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtVO0FBQ2hSO0FBQ2tSO0FBQ2pSO0FBQ0E7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNEQUFhO0FBQ3hCLEdBQUc7O0FBRUg7QUFDQSxrQkFBa0Isc0RBQWE7QUFDL0IsR0FBRzs7QUFFSDtBQUNBLFdBQVcsc0RBQVc7QUFDdEIsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQixzREFBVztBQUM3QixHQUFHOztBQUVIO0FBQ0EsV0FBVyxzREFBVTtBQUNyQixHQUFHOztBQUVIO0FBQ0Esa0JBQWtCLHNEQUFVO0FBQzVCLEdBQUc7O0FBRUg7QUFDQSxXQUFXLHNEQUFXO0FBQ3RCLEdBQUc7O0FBRUg7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0IsR0FBRzs7QUFFSDtBQUNBLFdBQVcsc0RBQVU7QUFDckIsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQixzREFBVTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQWdCO0FBQzlCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLHNEQUFnQjtBQUM5QixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsc0RBQWdCO0FBQzlCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsNERB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Q0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWxlb3B4eXovLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvaW5kZXguanM/ZGViMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkIGFzIGRlZmF1bHRUYWdQcmVmaXgsIF8gYXMgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIsIGEgYXMgX3R5cGVvZiwgYiBhcyBfY3JlYXRlQ2xhc3MsIGMgYXMgX2NsYXNzQ2FsbENoZWNrLCBlIGFzIF9kZWZpbmVQcm9wZXJ0eSwgWSBhcyBZQU1MU3ludGF4RXJyb3IsIFQgYXMgVHlwZSwgZiBhcyBZQU1MV2FybmluZywgZyBhcyBZQU1MU2VtYW50aWNFcnJvciwgaCBhcyBfc2xpY2VkVG9BcnJheSwgaSBhcyBZQU1MRXJyb3IsIGogYXMgX2luaGVyaXRzLCBrIGFzIF9jcmVhdGVTdXBlciB9IGZyb20gJy4vUGxhaW5WYWx1ZS1iODAzNmI3NS5qcyc7XG5pbXBvcnQgeyBwYXJzZSBhcyBwYXJzZSQxIH0gZnJvbSAnLi9wYXJzZS1jc3QuanMnO1xuaW1wb3J0IHsgYiBhcyBiaW5hcnlPcHRpb25zLCBhIGFzIGJvb2xPcHRpb25zLCBpIGFzIGludE9wdGlvbnMsIG4gYXMgbnVsbE9wdGlvbnMsIHMgYXMgc3RyT3B0aW9ucywgTiBhcyBOb2RlLCBQIGFzIFBhaXIsIFMgYXMgU2NhbGFyLCBjIGFzIHN0cmluZ2lmeVN0cmluZywgQSBhcyBBbGlhcywgWSBhcyBZQU1MU2VxLCBkIGFzIFlBTUxNYXAsIE0gYXMgTWVyZ2UsIEMgYXMgQ29sbGVjdGlvbiwgciBhcyByZXNvbHZlTm9kZSwgZSBhcyBpc0VtcHR5UGF0aCwgdCBhcyB0b0pTT04sIGYgYXMgYWRkQ29tbWVudCB9IGZyb20gJy4vcmVzb2x2ZVNlcS00OTJhYjQ0MC5qcyc7XG5pbXBvcnQgeyBTIGFzIFNjaGVtYSB9IGZyb20gJy4vU2NoZW1hLWU5NDcxNmM4LmpzJztcbmltcG9ydCB7IHcgYXMgd2FybiB9IGZyb20gJy4vd2FybmluZ3MtZGY1NGNiNjkuanMnO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFuY2hvclByZWZpeDogJ2EnLFxuICBjdXN0b21UYWdzOiBudWxsLFxuICBpbmRlbnQ6IDIsXG4gIGluZGVudFNlcTogdHJ1ZSxcbiAga2VlcENzdE5vZGVzOiBmYWxzZSxcbiAga2VlcE5vZGVUeXBlczogdHJ1ZSxcbiAga2VlcEJsb2JzSW5KU09OOiB0cnVlLFxuICBtYXBBc01hcDogZmFsc2UsXG4gIG1heEFsaWFzQ291bnQ6IDEwMCxcbiAgcHJldHR5RXJyb3JzOiBmYWxzZSxcbiAgLy8gVE9ETyBTZXQgdHJ1ZSBpbiB2MlxuICBzaW1wbGVLZXlzOiBmYWxzZSxcbiAgdmVyc2lvbjogJzEuMidcbn07XG52YXIgc2NhbGFyT3B0aW9ucyA9IHtcbiAgZ2V0IGJpbmFyeSgpIHtcbiAgICByZXR1cm4gYmluYXJ5T3B0aW9ucztcbiAgfSxcblxuICBzZXQgYmluYXJ5KG9wdCkge1xuICAgIE9iamVjdC5hc3NpZ24oYmluYXJ5T3B0aW9ucywgb3B0KTtcbiAgfSxcblxuICBnZXQgYm9vbCgpIHtcbiAgICByZXR1cm4gYm9vbE9wdGlvbnM7XG4gIH0sXG5cbiAgc2V0IGJvb2wob3B0KSB7XG4gICAgT2JqZWN0LmFzc2lnbihib29sT3B0aW9ucywgb3B0KTtcbiAgfSxcblxuICBnZXQgaW50KCkge1xuICAgIHJldHVybiBpbnRPcHRpb25zO1xuICB9LFxuXG4gIHNldCBpbnQob3B0KSB7XG4gICAgT2JqZWN0LmFzc2lnbihpbnRPcHRpb25zLCBvcHQpO1xuICB9LFxuXG4gIGdldCBudWxsKCkge1xuICAgIHJldHVybiBudWxsT3B0aW9ucztcbiAgfSxcblxuICBzZXQgbnVsbChvcHQpIHtcbiAgICBPYmplY3QuYXNzaWduKG51bGxPcHRpb25zLCBvcHQpO1xuICB9LFxuXG4gIGdldCBzdHIoKSB7XG4gICAgcmV0dXJuIHN0ck9wdGlvbnM7XG4gIH0sXG5cbiAgc2V0IHN0cihvcHQpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0ck9wdGlvbnMsIG9wdCk7XG4gIH1cblxufTtcbnZhciBkb2N1bWVudE9wdGlvbnMgPSB7XG4gICcxLjAnOiB7XG4gICAgc2NoZW1hOiAneWFtbC0xLjEnLFxuICAgIG1lcmdlOiB0cnVlLFxuICAgIHRhZ1ByZWZpeGVzOiBbe1xuICAgICAgaGFuZGxlOiAnIScsXG4gICAgICBwcmVmaXg6IGRlZmF1bHRUYWdQcmVmaXhcbiAgICB9LCB7XG4gICAgICBoYW5kbGU6ICchIScsXG4gICAgICBwcmVmaXg6ICd0YWc6cHJpdmF0ZS55YW1sLm9yZywyMDAyOidcbiAgICB9XVxuICB9LFxuICAxLjE6IHtcbiAgICBzY2hlbWE6ICd5YW1sLTEuMScsXG4gICAgbWVyZ2U6IHRydWUsXG4gICAgdGFnUHJlZml4ZXM6IFt7XG4gICAgICBoYW5kbGU6ICchJyxcbiAgICAgIHByZWZpeDogJyEnXG4gICAgfSwge1xuICAgICAgaGFuZGxlOiAnISEnLFxuICAgICAgcHJlZml4OiBkZWZhdWx0VGFnUHJlZml4XG4gICAgfV1cbiAgfSxcbiAgMS4yOiB7XG4gICAgc2NoZW1hOiAnY29yZScsXG4gICAgbWVyZ2U6IGZhbHNlLFxuICAgIHRhZ1ByZWZpeGVzOiBbe1xuICAgICAgaGFuZGxlOiAnIScsXG4gICAgICBwcmVmaXg6ICchJ1xuICAgIH0sIHtcbiAgICAgIGhhbmRsZTogJyEhJyxcbiAgICAgIHByZWZpeDogZGVmYXVsdFRhZ1ByZWZpeFxuICAgIH1dXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVRhZyhkb2MsIHRhZykge1xuICBpZiAoKGRvYy52ZXJzaW9uIHx8IGRvYy5vcHRpb25zLnZlcnNpb24pID09PSAnMS4wJykge1xuICAgIHZhciBwcml2ID0gdGFnLm1hdGNoKC9edGFnOnByaXZhdGVcXC55YW1sXFwub3JnLDIwMDI6KFteOi9dKykkLyk7XG4gICAgaWYgKHByaXYpIHJldHVybiAnIScgKyBwcml2WzFdO1xuICAgIHZhciB2b2NhYiA9IHRhZy5tYXRjaCgvXnRhZzooW2EtekEtWjAtOS1dKylcXC55YW1sXFwub3JnLDIwMDI6KC4qKS8pO1xuICAgIHJldHVybiB2b2NhYiA/IFwiIVwiLmNvbmNhdCh2b2NhYlsxXSwgXCIvXCIpLmNvbmNhdCh2b2NhYlsyXSkgOiBcIiFcIi5jb25jYXQodGFnLnJlcGxhY2UoL150YWc6LywgJycpKTtcbiAgfVxuXG4gIHZhciBwID0gZG9jLnRhZ1ByZWZpeGVzLmZpbmQoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gdGFnLmluZGV4T2YocC5wcmVmaXgpID09PSAwO1xuICB9KTtcblxuICBpZiAoIXApIHtcbiAgICB2YXIgZHRwID0gZG9jLmdldERlZmF1bHRzKCkudGFnUHJlZml4ZXM7XG4gICAgcCA9IGR0cCAmJiBkdHAuZmluZChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHRhZy5pbmRleE9mKHAucHJlZml4KSA9PT0gMDtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghcCkgcmV0dXJuIHRhZ1swXSA9PT0gJyEnID8gdGFnIDogXCIhPFwiLmNvbmNhdCh0YWcsIFwiPlwiKTtcbiAgdmFyIHN1ZmZpeCA9IHRhZy5zdWJzdHIocC5wcmVmaXgubGVuZ3RoKS5yZXBsYWNlKC9bISxbXFxde31dL2csIGZ1bmN0aW9uIChjaCkge1xuICAgIHJldHVybiB7XG4gICAgICAnISc6ICclMjEnLFxuICAgICAgJywnOiAnJTJDJyxcbiAgICAgICdbJzogJyU1QicsXG4gICAgICAnXSc6ICclNUQnLFxuICAgICAgJ3snOiAnJTdCJyxcbiAgICAgICd9JzogJyU3RCdcbiAgICB9W2NoXTtcbiAgfSk7XG4gIHJldHVybiBwLmhhbmRsZSArIHN1ZmZpeDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFnT2JqZWN0KHRhZ3MsIGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBbGlhcykgcmV0dXJuIEFsaWFzO1xuXG4gIGlmIChpdGVtLnRhZykge1xuICAgIHZhciBtYXRjaCA9IHRhZ3MuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC50YWcgPT09IGl0ZW0udGFnO1xuICAgIH0pO1xuICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKSByZXR1cm4gbWF0Y2guZmluZChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQuZm9ybWF0ID09PSBpdGVtLmZvcm1hdDtcbiAgICB9KSB8fCBtYXRjaFswXTtcbiAgfVxuXG4gIHZhciB0YWdPYmosIG9iajtcblxuICBpZiAoaXRlbSBpbnN0YW5jZW9mIFNjYWxhcikge1xuICAgIG9iaiA9IGl0ZW0udmFsdWU7IC8vIFRPRE86IGRlcHJlY2F0ZS9yZW1vdmUgY2xhc3MgY2hlY2tcblxuICAgIHZhciBfbWF0Y2ggPSB0YWdzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQuaWRlbnRpZnkgJiYgdC5pZGVudGlmeShvYmopIHx8IHQuY2xhc3MgJiYgb2JqIGluc3RhbmNlb2YgdC5jbGFzcztcbiAgICB9KTtcblxuICAgIHRhZ09iaiA9IF9tYXRjaC5maW5kKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0O1xuICAgIH0pIHx8IF9tYXRjaC5maW5kKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gIXQuZm9ybWF0O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iaiA9IGl0ZW07XG4gICAgdGFnT2JqID0gdGFncy5maW5kKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC5ub2RlQ2xhc3MgJiYgb2JqIGluc3RhbmNlb2YgdC5ub2RlQ2xhc3M7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIXRhZ09iaikge1xuICAgIHZhciBuYW1lID0gb2JqICYmIG9iai5jb25zdHJ1Y3RvciA/IG9iai5jb25zdHJ1Y3Rvci5uYW1lIDogX3R5cGVvZihvYmopO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRhZyBub3QgcmVzb2x2ZWQgZm9yIFwiLmNvbmNhdChuYW1lLCBcIiB2YWx1ZVwiKSk7XG4gIH1cblxuICByZXR1cm4gdGFnT2JqO1xufSAvLyBuZWVkcyB0byBiZSBjYWxsZWQgYmVmb3JlIHZhbHVlIHN0cmluZ2lmaWVyIHRvIGFsbG93IGZvciBjaXJjdWxhciBhbmNob3IgcmVmc1xuXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVByb3BzKG5vZGUsIHRhZ09iaiwgX3JlZikge1xuICB2YXIgYW5jaG9ycyA9IF9yZWYuYW5jaG9ycyxcbiAgICAgIGRvYyA9IF9yZWYuZG9jO1xuICB2YXIgcHJvcHMgPSBbXTtcbiAgdmFyIGFuY2hvciA9IGRvYy5hbmNob3JzLmdldE5hbWUobm9kZSk7XG5cbiAgaWYgKGFuY2hvcikge1xuICAgIGFuY2hvcnNbYW5jaG9yXSA9IG5vZGU7XG4gICAgcHJvcHMucHVzaChcIiZcIi5jb25jYXQoYW5jaG9yKSk7XG4gIH1cblxuICBpZiAobm9kZS50YWcpIHtcbiAgICBwcm9wcy5wdXNoKHN0cmluZ2lmeVRhZyhkb2MsIG5vZGUudGFnKSk7XG4gIH0gZWxzZSBpZiAoIXRhZ09iai5kZWZhdWx0KSB7XG4gICAgcHJvcHMucHVzaChzdHJpbmdpZnlUYWcoZG9jLCB0YWdPYmoudGFnKSk7XG4gIH1cblxuICByZXR1cm4gcHJvcHMuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkkMShpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgdmFyIF9jdHgkZG9jID0gY3R4LmRvYyxcbiAgICAgIGFuY2hvcnMgPSBfY3R4JGRvYy5hbmNob3JzLFxuICAgICAgc2NoZW1hID0gX2N0eCRkb2Muc2NoZW1hO1xuICB2YXIgdGFnT2JqO1xuXG4gIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHZhciBjcmVhdGVDdHggPSB7XG4gICAgICBhbGlhc05vZGVzOiBbXSxcbiAgICAgIG9uVGFnT2JqOiBmdW5jdGlvbiBvblRhZ09iaihvKSB7XG4gICAgICAgIHJldHVybiB0YWdPYmogPSBvO1xuICAgICAgfSxcbiAgICAgIHByZXZPYmplY3RzOiBuZXcgTWFwKClcbiAgICB9O1xuICAgIGl0ZW0gPSBzY2hlbWEuY3JlYXRlTm9kZShpdGVtLCB0cnVlLCBudWxsLCBjcmVhdGVDdHgpO1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNyZWF0ZUN0eC5hbGlhc05vZGVzKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGFsaWFzID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGFsaWFzLnNvdXJjZSA9IGFsaWFzLnNvdXJjZS5ub2RlO1xuICAgICAgICB2YXIgbmFtZSA9IGFuY2hvcnMuZ2V0TmFtZShhbGlhcy5zb3VyY2UpO1xuXG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBhbmNob3JzLm5ld05hbWUoKTtcbiAgICAgICAgICBhbmNob3JzLm1hcFtuYW1lXSA9IGFsaWFzLnNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBhaXIpIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIGlmICghdGFnT2JqKSB0YWdPYmogPSBnZXRUYWdPYmplY3Qoc2NoZW1hLnRhZ3MsIGl0ZW0pO1xuICB2YXIgcHJvcHMgPSBzdHJpbmdpZnlQcm9wcyhpdGVtLCB0YWdPYmosIGN0eCk7XG4gIGlmIChwcm9wcy5sZW5ndGggPiAwKSBjdHguaW5kZW50QXRTdGFydCA9IChjdHguaW5kZW50QXRTdGFydCB8fCAwKSArIHByb3BzLmxlbmd0aCArIDE7XG4gIHZhciBzdHIgPSB0eXBlb2YgdGFnT2JqLnN0cmluZ2lmeSA9PT0gJ2Z1bmN0aW9uJyA/IHRhZ09iai5zdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSA6IGl0ZW0gaW5zdGFuY2VvZiBTY2FsYXIgPyBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSA6IGl0ZW0udG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgaWYgKCFwcm9wcykgcmV0dXJuIHN0cjtcbiAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBTY2FsYXIgfHwgc3RyWzBdID09PSAneycgfHwgc3RyWzBdID09PSAnWycgPyBcIlwiLmNvbmNhdChwcm9wcywgXCIgXCIpLmNvbmNhdChzdHIpIDogXCJcIi5jb25jYXQocHJvcHMsIFwiXFxuXCIpLmNvbmNhdChjdHguaW5kZW50KS5jb25jYXQoc3RyKTtcbn1cblxudmFyIEFuY2hvcnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmNob3JzKHByZWZpeCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbmNob3JzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hcFwiLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFuY2hvcnMsIFt7XG4gICAga2V5OiBcImNyZWF0ZUFsaWFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUFsaWFzKG5vZGUsIG5hbWUpIHtcbiAgICAgIHRoaXMuc2V0QW5jaG9yKG5vZGUsIG5hbWUpO1xuICAgICAgcmV0dXJuIG5ldyBBbGlhcyhub2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlTWVyZ2VQYWlyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU1lcmdlUGFpcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBtZXJnZSA9IG5ldyBNZXJnZSgpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc291cmNlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgbWVyZ2UudmFsdWUuaXRlbXMgPSBzb3VyY2VzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICBpZiAocyBpbnN0YW5jZW9mIEFsaWFzKSB7XG4gICAgICAgICAgaWYgKHMuc291cmNlIGluc3RhbmNlb2YgWUFNTE1hcCkgcmV0dXJuIHM7XG4gICAgICAgIH0gZWxzZSBpZiAocyBpbnN0YW5jZW9mIFlBTUxNYXApIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlQWxpYXMocyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lcmdlIHNvdXJjZXMgbXVzdCBiZSBNYXAgbm9kZXMgb3IgdGhlaXIgQWxpYXNlcycpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWVyZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmFtZShub2RlKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5tYXA7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKS5maW5kKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBtYXBbYV0gPT09IG5vZGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmFtZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmFtZXMoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGUobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwW25hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXdOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld05hbWUocHJlZml4KSB7XG4gICAgICBpZiAoIXByZWZpeCkgcHJlZml4ID0gdGhpcy5wcmVmaXg7XG4gICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyB0cnVlOyArK2kpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdChpKTtcbiAgICAgICAgaWYgKCFuYW1lcy5pbmNsdWRlcyhuYW1lKSkgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgfSAvLyBEdXJpbmcgcGFyc2luZywgbWFwICYgYWxpYXNlcyBjb250YWluIENTVCBub2Rlc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZU5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVOb2RlcygpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCxcbiAgICAgICAgICBfY3N0QWxpYXNlcyA9IHRoaXMuX2NzdEFsaWFzZXM7XG4gICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgbWFwW2FdID0gbWFwW2FdLnJlc29sdmVkO1xuICAgICAgfSk7XG5cbiAgICAgIF9jc3RBbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS5zb3VyY2UgPSBhLnNvdXJjZS5yZXNvbHZlZDtcbiAgICAgIH0pO1xuXG4gICAgICBkZWxldGUgdGhpcy5fY3N0QWxpYXNlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QW5jaG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEFuY2hvcihub2RlLCBuYW1lKSB7XG4gICAgICBpZiAobm9kZSAhPSBudWxsICYmICFBbmNob3JzLnZhbGlkQW5jaG9yTm9kZShub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuY2hvcnMgbWF5IG9ubHkgYmUgc2V0IGZvciBTY2FsYXIsIFNlcSBhbmQgTWFwIG5vZGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lICYmIC9bXFx4MDAtXFx4MTlcXHMsW1xcXXt9XS8udGVzdChuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuY2hvciBuYW1lcyBtdXN0IG5vdCBjb250YWluIHdoaXRlc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXJzJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXAgPSB0aGlzLm1hcDtcbiAgICAgIHZhciBwcmV2ID0gbm9kZSAmJiBPYmplY3Qua2V5cyhtYXApLmZpbmQoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIG1hcFthXSA9PT0gbm9kZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocHJldikge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2ICE9PSBuYW1lKSB7XG4gICAgICAgICAgZGVsZXRlIG1hcFtwcmV2XTtcbiAgICAgICAgICBtYXBbbmFtZV0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLm5ld05hbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcFtuYW1lXSA9IG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInZhbGlkQW5jaG9yTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZEFuY2hvck5vZGUobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBTY2FsYXIgfHwgbm9kZSBpbnN0YW5jZW9mIFlBTUxTZXEgfHwgbm9kZSBpbnN0YW5jZW9mIFlBTUxNYXA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFuY2hvcnM7XG59KCk7XG5cbnZhciB2aXNpdCA9IGZ1bmN0aW9uIHZpc2l0KG5vZGUsIHRhZ3MpIHtcbiAgaWYgKG5vZGUgJiYgX3R5cGVvZihub2RlKSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgdGFnID0gbm9kZS50YWc7XG5cbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgIGlmICh0YWcpIHRhZ3NbdGFnXSA9IHRydWU7XG4gICAgICBub2RlLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0KG4sIHRhZ3MpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUGFpcikge1xuICAgICAgdmlzaXQobm9kZS5rZXksIHRhZ3MpO1xuICAgICAgdmlzaXQobm9kZS52YWx1ZSwgdGFncyk7XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgU2NhbGFyKSB7XG4gICAgICBpZiAodGFnKSB0YWdzW3RhZ10gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWdzO1xufTtcblxudmFyIGxpc3RUYWdOYW1lcyA9IGZ1bmN0aW9uIGxpc3RUYWdOYW1lcyhub2RlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2aXNpdChub2RlLCB7fSkpO1xufTtcblxuZnVuY3Rpb24gcGFyc2VDb250ZW50cyhkb2MsIGNvbnRlbnRzKSB7XG4gIHZhciBjb21tZW50cyA9IHtcbiAgICBiZWZvcmU6IFtdLFxuICAgIGFmdGVyOiBbXVxuICB9O1xuICB2YXIgYm9keSA9IHVuZGVmaW5lZDtcbiAgdmFyIHNwYWNlQmVmb3JlID0gZmFsc2U7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNvbnRlbnRzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBub2RlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmIChub2RlLnZhbHVlUmFuZ2UpIHtcbiAgICAgICAgaWYgKGJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBtc2cgPSAnRG9jdW1lbnQgY29udGFpbnMgdHJhaWxpbmcgY29udGVudCBub3Qgc2VwYXJhdGVkIGJ5IGEgLi4uIG9yIC0tLSBsaW5lJztcbiAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTeW50YXhFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXMgPSByZXNvbHZlTm9kZShkb2MsIG5vZGUpO1xuXG4gICAgICAgIGlmIChzcGFjZUJlZm9yZSkge1xuICAgICAgICAgIHJlcy5zcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgICAgICAgc3BhY2VCZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHkgPSByZXM7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2MgPSBib2R5ID09PSB1bmRlZmluZWQgPyBjb21tZW50cy5iZWZvcmUgOiBjb21tZW50cy5hZnRlcjtcbiAgICAgICAgY2MucHVzaChub2RlLmNvbW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFR5cGUuQkxBTktfTElORSkge1xuICAgICAgICBzcGFjZUJlZm9yZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGJvZHkgPT09IHVuZGVmaW5lZCAmJiBjb21tZW50cy5iZWZvcmUubGVuZ3RoID4gMCAmJiAhZG9jLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgICAvLyBzcGFjZS1zZXBhcmF0ZWQgY29tbWVudHMgYXQgc3RhcnQgYXJlIHBhcnNlZCBhcyBkb2N1bWVudCBjb21tZW50c1xuICAgICAgICAgIGRvYy5jb21tZW50QmVmb3JlID0gY29tbWVudHMuYmVmb3JlLmpvaW4oJ1xcbicpO1xuICAgICAgICAgIGNvbW1lbnRzLmJlZm9yZSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICBkb2MuY29udGVudHMgPSBib2R5IHx8IG51bGw7XG5cbiAgaWYgKCFib2R5KSB7XG4gICAgZG9jLmNvbW1lbnQgPSBjb21tZW50cy5iZWZvcmUuY29uY2F0KGNvbW1lbnRzLmFmdGVyKS5qb2luKCdcXG4nKSB8fCBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhciBjYiA9IGNvbW1lbnRzLmJlZm9yZS5qb2luKCdcXG4nKTtcblxuICAgIGlmIChjYikge1xuICAgICAgdmFyIGNiTm9kZSA9IGJvZHkgaW5zdGFuY2VvZiBDb2xsZWN0aW9uICYmIGJvZHkuaXRlbXNbMF0gPyBib2R5Lml0ZW1zWzBdIDogYm9keTtcbiAgICAgIGNiTm9kZS5jb21tZW50QmVmb3JlID0gY2JOb2RlLmNvbW1lbnRCZWZvcmUgPyBcIlwiLmNvbmNhdChjYiwgXCJcXG5cIikuY29uY2F0KGNiTm9kZS5jb21tZW50QmVmb3JlKSA6IGNiO1xuICAgIH1cblxuICAgIGRvYy5jb21tZW50ID0gY29tbWVudHMuYWZ0ZXIuam9pbignXFxuJykgfHwgbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFnRGlyZWN0aXZlKF9yZWYsIGRpcmVjdGl2ZSkge1xuICB2YXIgdGFnUHJlZml4ZXMgPSBfcmVmLnRhZ1ByZWZpeGVzO1xuXG4gIHZhciBfZGlyZWN0aXZlJHBhcmFtZXRlcnMgPSBfc2xpY2VkVG9BcnJheShkaXJlY3RpdmUucGFyYW1ldGVycywgMiksXG4gICAgICBoYW5kbGUgPSBfZGlyZWN0aXZlJHBhcmFtZXRlcnNbMF0sXG4gICAgICBwcmVmaXggPSBfZGlyZWN0aXZlJHBhcmFtZXRlcnNbMV07XG5cbiAgaWYgKCFoYW5kbGUgfHwgIXByZWZpeCkge1xuICAgIHZhciBtc2cgPSAnSW5zdWZmaWNpZW50IHBhcmFtZXRlcnMgZ2l2ZW4gZm9yICVUQUcgZGlyZWN0aXZlJztcbiAgICB0aHJvdyBuZXcgWUFNTFNlbWFudGljRXJyb3IoZGlyZWN0aXZlLCBtc2cpO1xuICB9XG5cbiAgaWYgKHRhZ1ByZWZpeGVzLnNvbWUoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC5oYW5kbGUgPT09IGhhbmRsZTtcbiAgfSkpIHtcbiAgICB2YXIgX21zZyA9ICdUaGUgJVRBRyBkaXJlY3RpdmUgbXVzdCBvbmx5IGJlIGdpdmVuIGF0IG1vc3Qgb25jZSBwZXIgaGFuZGxlIGluIHRoZSBzYW1lIGRvY3VtZW50Lic7XG4gICAgdGhyb3cgbmV3IFlBTUxTZW1hbnRpY0Vycm9yKGRpcmVjdGl2ZSwgX21zZyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhhbmRsZTogaGFuZGxlLFxuICAgIHByZWZpeDogcHJlZml4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRGlyZWN0aXZlKGRvYywgZGlyZWN0aXZlKSB7XG4gIHZhciBfZGlyZWN0aXZlJHBhcmFtZXRlcnMyID0gX3NsaWNlZFRvQXJyYXkoZGlyZWN0aXZlLnBhcmFtZXRlcnMsIDEpLFxuICAgICAgdmVyc2lvbiA9IF9kaXJlY3RpdmUkcGFyYW1ldGVyczJbMF07XG5cbiAgaWYgKGRpcmVjdGl2ZS5uYW1lID09PSAnWUFNTDoxLjAnKSB2ZXJzaW9uID0gJzEuMCc7XG5cbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgdmFyIG1zZyA9ICdJbnN1ZmZpY2llbnQgcGFyYW1ldGVycyBnaXZlbiBmb3IgJVlBTUwgZGlyZWN0aXZlJztcbiAgICB0aHJvdyBuZXcgWUFNTFNlbWFudGljRXJyb3IoZGlyZWN0aXZlLCBtc2cpO1xuICB9XG5cbiAgaWYgKCFkb2N1bWVudE9wdGlvbnNbdmVyc2lvbl0pIHtcbiAgICB2YXIgdjAgPSBkb2MudmVyc2lvbiB8fCBkb2Mub3B0aW9ucy52ZXJzaW9uO1xuXG4gICAgdmFyIF9tc2cyID0gXCJEb2N1bWVudCB3aWxsIGJlIHBhcnNlZCBhcyBZQU1MIFwiLmNvbmNhdCh2MCwgXCIgcmF0aGVyIHRoYW4gWUFNTCBcIikuY29uY2F0KHZlcnNpb24pO1xuXG4gICAgZG9jLndhcm5pbmdzLnB1c2gobmV3IFlBTUxXYXJuaW5nKGRpcmVjdGl2ZSwgX21zZzIpKTtcbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uO1xufVxuXG5mdW5jdGlvbiBwYXJzZURpcmVjdGl2ZXMoZG9jLCBkaXJlY3RpdmVzLCBwcmV2RG9jKSB7XG4gIHZhciBkaXJlY3RpdmVDb21tZW50cyA9IFtdO1xuICB2YXIgaGFzRGlyZWN0aXZlcyA9IGZhbHNlO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkaXJlY3RpdmVzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBkaXJlY3RpdmUgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHZhciBjb21tZW50ID0gZGlyZWN0aXZlLmNvbW1lbnQsXG4gICAgICAgICAgbmFtZSA9IGRpcmVjdGl2ZS5uYW1lO1xuXG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSAnVEFHJzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jLnRhZ1ByZWZpeGVzLnB1c2gocmVzb2x2ZVRhZ0RpcmVjdGl2ZShkb2MsIGRpcmVjdGl2ZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1lBTUwnOlxuICAgICAgICBjYXNlICdZQU1MOjEuMCc6XG4gICAgICAgICAgaWYgKGRvYy52ZXJzaW9uKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ1RoZSAlWUFNTCBkaXJlY3RpdmUgbXVzdCBvbmx5IGJlIGdpdmVuIGF0IG1vc3Qgb25jZSBwZXIgZG9jdW1lbnQuJztcbiAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IoZGlyZWN0aXZlLCBtc2cpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jLnZlcnNpb24gPSByZXNvbHZlWWFtbERpcmVjdGl2ZShkb2MsIGRpcmVjdGl2ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIF9tc2czID0gXCJZQU1MIG9ubHkgc3VwcG9ydHMgJVRBRyBhbmQgJVlBTUwgZGlyZWN0aXZlcywgYW5kIG5vdCAlXCIuY29uY2F0KG5hbWUpO1xuXG4gICAgICAgICAgICBkb2Mud2FybmluZ3MucHVzaChuZXcgWUFNTFdhcm5pbmcoZGlyZWN0aXZlLCBfbXNnMykpO1xuICAgICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWVudCkgZGlyZWN0aXZlQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIGlmIChwcmV2RG9jICYmICFoYXNEaXJlY3RpdmVzICYmICcxLjEnID09PSAoZG9jLnZlcnNpb24gfHwgcHJldkRvYy52ZXJzaW9uIHx8IGRvYy5vcHRpb25zLnZlcnNpb24pKSB7XG4gICAgdmFyIGNvcHlUYWdQcmVmaXggPSBmdW5jdGlvbiBjb3B5VGFnUHJlZml4KF9yZWYyKSB7XG4gICAgICB2YXIgaGFuZGxlID0gX3JlZjIuaGFuZGxlLFxuICAgICAgICAgIHByZWZpeCA9IF9yZWYyLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhbmRsZTogaGFuZGxlLFxuICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZG9jLnRhZ1ByZWZpeGVzID0gcHJldkRvYy50YWdQcmVmaXhlcy5tYXAoY29weVRhZ1ByZWZpeCk7XG4gICAgZG9jLnZlcnNpb24gPSBwcmV2RG9jLnZlcnNpb247XG4gIH1cblxuICBkb2MuY29tbWVudEJlZm9yZSA9IGRpcmVjdGl2ZUNvbW1lbnRzLmpvaW4oJ1xcbicpIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENvbGxlY3Rpb24oY29udGVudHMpIHtcbiAgaWYgKGNvbnRlbnRzIGluc3RhbmNlb2YgQ29sbGVjdGlvbikgcmV0dXJuIHRydWU7XG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBZQU1MIGNvbGxlY3Rpb24gYXMgZG9jdW1lbnQgY29udGVudHMnKTtcbn1cblxudmFyIERvY3VtZW50JDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEb2N1bWVudChvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvY3VtZW50KTtcblxuICAgIHRoaXMuYW5jaG9ycyA9IG5ldyBBbmNob3JzKG9wdGlvbnMuYW5jaG9yUHJlZml4KTtcbiAgICB0aGlzLmNvbW1lbnRCZWZvcmUgPSBudWxsO1xuICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG4gICAgdGhpcy5jb250ZW50cyA9IG51bGw7XG4gICAgdGhpcy5kaXJlY3RpdmVzRW5kTWFya2VyID0gbnVsbDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zY2hlbWEgPSBudWxsO1xuICAgIHRoaXMudGFnUHJlZml4ZXMgPSBbXTtcbiAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEb2N1bWVudCwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICBhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpO1xuICAgICAgdGhpcy5jb250ZW50cy5hZGRJbihwYXRoLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVJbihwYXRoKSB7XG4gICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudHMgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5kZWxldGVJbihwYXRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVmYXVsdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gICAgICByZXR1cm4gRG9jdW1lbnQuZGVmYXVsdHNbdGhpcy52ZXJzaW9uXSB8fCBEb2N1bWVudC5kZWZhdWx0c1t0aGlzLm9wdGlvbnMudmVyc2lvbl0gfHwge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5LCBrZWVwU2NhbGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50cyBpbnN0YW5jZW9mIENvbGxlY3Rpb24gPyB0aGlzLmNvbnRlbnRzLmdldChrZXksIGtlZXBTY2FsYXIpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbihwYXRoLCBrZWVwU2NhbGFyKSB7XG4gICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpIHJldHVybiAha2VlcFNjYWxhciAmJiB0aGlzLmNvbnRlbnRzIGluc3RhbmNlb2YgU2NhbGFyID8gdGhpcy5jb250ZW50cy52YWx1ZSA6IHRoaXMuY29udGVudHM7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50cyBpbnN0YW5jZW9mIENvbGxlY3Rpb24gPyB0aGlzLmNvbnRlbnRzLmdldEluKHBhdGgsIGtlZXBTY2FsYXIpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uID8gdGhpcy5jb250ZW50cy5oYXMoa2V5KSA6IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNJbihwYXRoKSB7XG4gICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpIHJldHVybiB0aGlzLmNvbnRlbnRzICE9PSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50cyBpbnN0YW5jZW9mIENvbGxlY3Rpb24gPyB0aGlzLmNvbnRlbnRzLmhhc0luKHBhdGgpIDogZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKTtcbiAgICAgIHRoaXMuY29udGVudHMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKSB0aGlzLmNvbnRlbnRzID0gdmFsdWU7ZWxzZSB7XG4gICAgICAgIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cyk7XG4gICAgICAgIHRoaXMuY29udGVudHMuc2V0SW4ocGF0aCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRTY2hlbWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2NoZW1hKGlkLCBjdXN0b21UYWdzKSB7XG4gICAgICBpZiAoIWlkICYmICFjdXN0b21UYWdzICYmIHRoaXMuc2NoZW1hKSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJykgaWQgPSBpZC50b0ZpeGVkKDEpO1xuXG4gICAgICBpZiAoaWQgPT09ICcxLjAnIHx8IGlkID09PSAnMS4xJyB8fCBpZCA9PT0gJzEuMicpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbikgdGhpcy52ZXJzaW9uID0gaWQ7ZWxzZSB0aGlzLm9wdGlvbnMudmVyc2lvbiA9IGlkO1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnNjaGVtYTtcbiAgICAgIH0gZWxzZSBpZiAoaWQgJiYgdHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2NoZW1hID0gaWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKSB0aGlzLm9wdGlvbnMuY3VzdG9tVGFncyA9IGN1c3RvbVRhZ3M7XG4gICAgICB2YXIgb3B0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXREZWZhdWx0cygpLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5zY2hlbWEgPSBuZXcgU2NoZW1hKG9wdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKG5vZGUsIHByZXZEb2MpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcENzdE5vZGVzKSB0aGlzLmNzdE5vZGUgPSBub2RlO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwTm9kZVR5cGVzKSB0aGlzLnR5cGUgPSAnRE9DVU1FTlQnO1xuICAgICAgdmFyIF9ub2RlJGRpcmVjdGl2ZXMgPSBub2RlLmRpcmVjdGl2ZXMsXG4gICAgICAgICAgZGlyZWN0aXZlcyA9IF9ub2RlJGRpcmVjdGl2ZXMgPT09IHZvaWQgMCA/IFtdIDogX25vZGUkZGlyZWN0aXZlcyxcbiAgICAgICAgICBfbm9kZSRjb250ZW50cyA9IG5vZGUuY29udGVudHMsXG4gICAgICAgICAgY29udGVudHMgPSBfbm9kZSRjb250ZW50cyA9PT0gdm9pZCAwID8gW10gOiBfbm9kZSRjb250ZW50cyxcbiAgICAgICAgICBkaXJlY3RpdmVzRW5kTWFya2VyID0gbm9kZS5kaXJlY3RpdmVzRW5kTWFya2VyLFxuICAgICAgICAgIGVycm9yID0gbm9kZS5lcnJvcixcbiAgICAgICAgICB2YWx1ZVJhbmdlID0gbm9kZS52YWx1ZVJhbmdlO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFlcnJvci5zb3VyY2UpIGVycm9yLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBwYXJzZURpcmVjdGl2ZXModGhpcywgZGlyZWN0aXZlcywgcHJldkRvYyk7XG4gICAgICBpZiAoZGlyZWN0aXZlc0VuZE1hcmtlcikgdGhpcy5kaXJlY3RpdmVzRW5kTWFya2VyID0gdHJ1ZTtcbiAgICAgIHRoaXMucmFuZ2UgPSB2YWx1ZVJhbmdlID8gW3ZhbHVlUmFuZ2Uuc3RhcnQsIHZhbHVlUmFuZ2UuZW5kXSA6IG51bGw7XG4gICAgICB0aGlzLnNldFNjaGVtYSgpO1xuICAgICAgdGhpcy5hbmNob3JzLl9jc3RBbGlhc2VzID0gW107XG4gICAgICBwYXJzZUNvbnRlbnRzKHRoaXMsIGNvbnRlbnRzKTtcbiAgICAgIHRoaXMuYW5jaG9ycy5yZXNvbHZlTm9kZXMoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV0dHlFcnJvcnMpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZXJyb3JzKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfZXJyb3IgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChfZXJyb3IgaW5zdGFuY2VvZiBZQU1MRXJyb3IpIF9lcnJvci5tYWtlUHJldHR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMud2FybmluZ3MpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciB3YXJuID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHdhcm4gaW5zdGFuY2VvZiBZQU1MRXJyb3IpIHdhcm4ubWFrZVByZXR0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpc3ROb25EZWZhdWx0VGFnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0Tm9uRGVmYXVsdFRhZ3MoKSB7XG4gICAgICByZXR1cm4gbGlzdFRhZ05hbWVzKHRoaXMuY29udGVudHMpLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pbmRleE9mKFNjaGVtYS5kZWZhdWx0UHJlZml4KSAhPT0gMDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRUYWdQcmVmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGFnUHJlZml4KGhhbmRsZSwgcHJlZml4KSB7XG4gICAgICBpZiAoaGFuZGxlWzBdICE9PSAnIScgfHwgaGFuZGxlW2hhbmRsZS5sZW5ndGggLSAxXSAhPT0gJyEnKSB0aHJvdyBuZXcgRXJyb3IoJ0hhbmRsZSBtdXN0IHN0YXJ0IGFuZCBlbmQgd2l0aCAhJyk7XG5cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLnRhZ1ByZWZpeGVzLmZpbmQoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICByZXR1cm4gcC5oYW5kbGUgPT09IGhhbmRsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmV2KSBwcmV2LnByZWZpeCA9IHByZWZpeDtlbHNlIHRoaXMudGFnUHJlZml4ZXMucHVzaCh7XG4gICAgICAgICAgaGFuZGxlOiBoYW5kbGUsXG4gICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRhZ1ByZWZpeGVzID0gdGhpcy50YWdQcmVmaXhlcy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICByZXR1cm4gcC5oYW5kbGUgIT09IGhhbmRsZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04kMShhcmcsIG9uQW5jaG9yKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBrZWVwQmxvYnNJbkpTT04gPSBfdGhpcyRvcHRpb25zLmtlZXBCbG9ic0luSlNPTixcbiAgICAgICAgICBtYXBBc01hcCA9IF90aGlzJG9wdGlvbnMubWFwQXNNYXAsXG4gICAgICAgICAgbWF4QWxpYXNDb3VudCA9IF90aGlzJG9wdGlvbnMubWF4QWxpYXNDb3VudDtcbiAgICAgIHZhciBrZWVwID0ga2VlcEJsb2JzSW5KU09OICYmICh0eXBlb2YgYXJnICE9PSAnc3RyaW5nJyB8fCAhKHRoaXMuY29udGVudHMgaW5zdGFuY2VvZiBTY2FsYXIpKTtcbiAgICAgIHZhciBjdHggPSB7XG4gICAgICAgIGRvYzogdGhpcyxcbiAgICAgICAgaW5kZW50U3RlcDogJyAgJyxcbiAgICAgICAga2VlcDoga2VlcCxcbiAgICAgICAgbWFwQXNNYXA6IGtlZXAgJiYgISFtYXBBc01hcCxcbiAgICAgICAgbWF4QWxpYXNDb3VudDogbWF4QWxpYXNDb3VudCxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnkkMSAvLyBSZXF1aXJpbmcgZGlyZWN0bHkgaW4gUGFpciB3b3VsZCBjcmVhdGUgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cbiAgICAgIH07XG4gICAgICB2YXIgYW5jaG9yTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmFuY2hvcnMubWFwKTtcbiAgICAgIGlmIChhbmNob3JOYW1lcy5sZW5ndGggPiAwKSBjdHguYW5jaG9ycyA9IG5ldyBNYXAoYW5jaG9yTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBbX3RoaXMuYW5jaG9ycy5tYXBbbmFtZV0sIHtcbiAgICAgICAgICBhbGlhczogW10sXG4gICAgICAgICAgYWxpYXNDb3VudDogMCxcbiAgICAgICAgICBjb3VudDogMVxuICAgICAgICB9XTtcbiAgICAgIH0pKTtcblxuICAgICAgdmFyIHJlcyA9IHRvSlNPTih0aGlzLmNvbnRlbnRzLCBhcmcsIGN0eCk7XG5cbiAgICAgIGlmICh0eXBlb2Ygb25BbmNob3IgPT09ICdmdW5jdGlvbicgJiYgY3R4LmFuY2hvcnMpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjdHguYW5jaG9ycy52YWx1ZXMoKSksXG4gICAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9zdGVwMyR2YWx1ZSA9IF9zdGVwMy52YWx1ZSxcbiAgICAgICAgICAgICAgICBjb3VudCA9IF9zdGVwMyR2YWx1ZS5jb3VudCxcbiAgICAgICAgICAgICAgICBfcmVzID0gX3N0ZXAzJHZhbHVlLnJlcztcbiAgICAgICAgICAgIG9uQW5jaG9yKF9yZXMsIGNvdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignRG9jdW1lbnQgd2l0aCBlcnJvcnMgY2Fubm90IGJlIHN0cmluZ2lmaWVkJyk7XG4gICAgICB2YXIgaW5kZW50U2l6ZSA9IHRoaXMub3B0aW9ucy5pbmRlbnQ7XG5cbiAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbmRlbnRTaXplKSB8fCBpbmRlbnRTaXplIDw9IDApIHtcbiAgICAgICAgdmFyIHMgPSBKU09OLnN0cmluZ2lmeShpbmRlbnRTaXplKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcImluZGVudFxcXCIgb3B0aW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBub3QgXCIuY29uY2F0KHMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTY2hlbWEoKTtcbiAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgdmFyIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMudmVyc2lvbikge1xuICAgICAgICB2YXIgdmQgPSAnJVlBTUwgMS4yJztcblxuICAgICAgICBpZiAodGhpcy5zY2hlbWEubmFtZSA9PT0gJ3lhbWwtMS4xJykge1xuICAgICAgICAgIGlmICh0aGlzLnZlcnNpb24gPT09ICcxLjAnKSB2ZCA9ICclWUFNTDoxLjAnO2Vsc2UgaWYgKHRoaXMudmVyc2lvbiA9PT0gJzEuMScpIHZkID0gJyVZQU1MIDEuMSc7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcy5wdXNoKHZkKTtcbiAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0YWdOYW1lcyA9IHRoaXMubGlzdE5vbkRlZmF1bHRUYWdzKCk7XG4gICAgICB0aGlzLnRhZ1ByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIGhhbmRsZSA9IF9yZWYuaGFuZGxlLFxuICAgICAgICAgICAgcHJlZml4ID0gX3JlZi5wcmVmaXg7XG5cbiAgICAgICAgaWYgKHRhZ05hbWVzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5pbmRleE9mKHByZWZpeCkgPT09IDA7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgbGluZXMucHVzaChcIiVUQUcgXCIuY29uY2F0KGhhbmRsZSwgXCIgXCIpLmNvbmNhdChwcmVmaXgpKTtcbiAgICAgICAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoaGFzRGlyZWN0aXZlcyB8fCB0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIpIGxpbmVzLnB1c2goJy0tLScpO1xuXG4gICAgICBpZiAodGhpcy5jb21tZW50QmVmb3JlKSB7XG4gICAgICAgIGlmIChoYXNEaXJlY3RpdmVzIHx8ICF0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIpIGxpbmVzLnVuc2hpZnQoJycpO1xuICAgICAgICBsaW5lcy51bnNoaWZ0KHRoaXMuY29tbWVudEJlZm9yZS5yZXBsYWNlKC9eL2dtLCAnIycpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IHtcbiAgICAgICAgYW5jaG9yczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgZG9jOiB0aGlzLFxuICAgICAgICBpbmRlbnQ6ICcnLFxuICAgICAgICBpbmRlbnRTdGVwOiAnICcucmVwZWF0KGluZGVudFNpemUpLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeSQxIC8vIFJlcXVpcmluZyBkaXJlY3RseSBpbiBub2RlcyB3b3VsZCBjcmVhdGUgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cbiAgICAgIH07XG4gICAgICB2YXIgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICB2YXIgY29udGVudENvbW1lbnQgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5jb250ZW50cykge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50cyBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5jb250ZW50cy5zcGFjZUJlZm9yZSAmJiAoaGFzRGlyZWN0aXZlcyB8fCB0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIpKSBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICBpZiAodGhpcy5jb250ZW50cy5jb21tZW50QmVmb3JlKSBsaW5lcy5wdXNoKHRoaXMuY29udGVudHMuY29tbWVudEJlZm9yZS5yZXBsYWNlKC9eL2dtLCAnIycpKTsgLy8gdG9wLWxldmVsIGJsb2NrIHNjYWxhcnMgbmVlZCB0byBiZSBpbmRlbnRlZCBpZiBmb2xsb3dlZCBieSBhIGNvbW1lbnRcblxuICAgICAgICAgIGN0eC5mb3JjZUJsb2NrSW5kZW50ID0gISF0aGlzLmNvbW1lbnQ7XG4gICAgICAgICAgY29udGVudENvbW1lbnQgPSB0aGlzLmNvbnRlbnRzLmNvbW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb25DaG9tcEtlZXAgPSBjb250ZW50Q29tbWVudCA/IG51bGwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNob21wS2VlcCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBib2R5ID0gc3RyaW5naWZ5JDEodGhpcy5jb250ZW50cywgY3R4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnRDb21tZW50ID0gbnVsbDtcbiAgICAgICAgfSwgb25DaG9tcEtlZXApO1xuICAgICAgICBsaW5lcy5wdXNoKGFkZENvbW1lbnQoYm9keSwgJycsIGNvbnRlbnRDb21tZW50KSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY29udGVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW5lcy5wdXNoKHN0cmluZ2lmeSQxKHRoaXMuY29udGVudHMsIGN0eCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAgIGlmICgoIWNob21wS2VlcCB8fCBjb250ZW50Q29tbWVudCkgJiYgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gIT09ICcnKSBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLmNvbW1lbnQucmVwbGFjZSgvXi9nbSwgJyMnKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKSArICdcXG4nO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEb2N1bWVudDtcbn0oKTtcblxuX2RlZmluZVByb3BlcnR5KERvY3VtZW50JDEsIFwiZGVmYXVsdHNcIiwgZG9jdW1lbnRPcHRpb25zKTtcblxuZnVuY3Rpb24gY3JlYXRlTm9kZSh2YWx1ZSkge1xuICB2YXIgd3JhcFNjYWxhcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciB0YWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblxuICBpZiAodGFnID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHdyYXBTY2FsYXJzID09PSAnc3RyaW5nJykge1xuICAgIHRhZyA9IHdyYXBTY2FsYXJzO1xuICAgIHdyYXBTY2FsYXJzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgRG9jdW1lbnQkMS5kZWZhdWx0c1tkZWZhdWx0T3B0aW9ucy52ZXJzaW9uXSwgZGVmYXVsdE9wdGlvbnMpO1xuICB2YXIgc2NoZW1hID0gbmV3IFNjaGVtYShvcHRpb25zKTtcbiAgcmV0dXJuIHNjaGVtYS5jcmVhdGVOb2RlKHZhbHVlLCB3cmFwU2NhbGFycywgdGFnKTtcbn1cblxudmFyIERvY3VtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfWUFNTERvY3VtZW50KSB7XG4gIF9pbmhlcml0cyhEb2N1bWVudCwgX1lBTUxEb2N1bWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEb2N1bWVudCk7XG5cbiAgZnVuY3Rpb24gRG9jdW1lbnQob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb2N1bWVudCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIHJldHVybiBEb2N1bWVudDtcbn0oRG9jdW1lbnQkMSk7XG5cbmZ1bmN0aW9uIHBhcnNlQWxsRG9jdW1lbnRzKHNyYywgb3B0aW9ucykge1xuICB2YXIgc3RyZWFtID0gW107XG4gIHZhciBwcmV2O1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwYXJzZSQxKHNyYykpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGNzdERvYyA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIGRvYyA9IG5ldyBEb2N1bWVudChvcHRpb25zKTtcbiAgICAgIGRvYy5wYXJzZShjc3REb2MsIHByZXYpO1xuICAgICAgc3RyZWFtLnB1c2goZG9jKTtcbiAgICAgIHByZXYgPSBkb2M7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50KHNyYywgb3B0aW9ucykge1xuICB2YXIgY3N0ID0gcGFyc2UkMShzcmMpO1xuICB2YXIgZG9jID0gbmV3IERvY3VtZW50KG9wdGlvbnMpLnBhcnNlKGNzdFswXSk7XG5cbiAgaWYgKGNzdC5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGVyck1zZyA9ICdTb3VyY2UgY29udGFpbnMgbXVsdGlwbGUgZG9jdW1lbnRzOyBwbGVhc2UgdXNlIFlBTUwucGFyc2VBbGxEb2N1bWVudHMoKSc7XG4gICAgZG9jLmVycm9ycy51bnNoaWZ0KG5ldyBZQU1MU2VtYW50aWNFcnJvcihjc3RbMV0sIGVyck1zZykpO1xuICB9XG5cbiAgcmV0dXJuIGRvYztcbn1cblxuZnVuY3Rpb24gcGFyc2Uoc3JjLCBvcHRpb25zKSB7XG4gIHZhciBkb2MgPSBwYXJzZURvY3VtZW50KHNyYywgb3B0aW9ucyk7XG4gIGRvYy53YXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgcmV0dXJuIHdhcm4od2FybmluZyk7XG4gIH0pO1xuICBpZiAoZG9jLmVycm9ycy5sZW5ndGggPiAwKSB0aHJvdyBkb2MuZXJyb3JzWzBdO1xuICByZXR1cm4gZG9jLnRvSlNPTigpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIGRvYyA9IG5ldyBEb2N1bWVudChvcHRpb25zKTtcbiAgZG9jLmNvbnRlbnRzID0gdmFsdWU7XG4gIHJldHVybiBTdHJpbmcoZG9jKTtcbn1cblxudmFyIFlBTUwgPSB7XG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZU5vZGUsXG4gIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcbiAgRG9jdW1lbnQ6IERvY3VtZW50LFxuICBwYXJzZTogcGFyc2UsXG4gIHBhcnNlQWxsRG9jdW1lbnRzOiBwYXJzZUFsbERvY3VtZW50cyxcbiAgcGFyc2VDU1Q6IHBhcnNlJDEsXG4gIHBhcnNlRG9jdW1lbnQ6IHBhcnNlRG9jdW1lbnQsXG4gIHNjYWxhck9wdGlvbnM6IHNjYWxhck9wdGlvbnMsXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5XG59O1xuXG5leHBvcnQgeyBZQU1MIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/index.js\n")},"./node_modules/yaml/browser/dist/parse-cst.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlainValue-b8036b75.js */ \"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\");\n\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(BlankLine, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(BlankLine);\n\n  function BlankLine() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, BlankLine);\n\n    return _super.call(this, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(BlankLine, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, start + 1);\n      return start + 1;\n    }\n  }]);\n\n  return BlankLine;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(CollectionItem, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(CollectionItem, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM) this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, offset + 1);\n\n          comments.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return CollectionItem;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Comment, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Comment);\n\n  function Comment() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Comment);\n\n    return _super.call(this, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nvar Collection = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Collection, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Collection);\n\n  function Collection(firstItem) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Collection);\n\n    _this = _super.call(this, firstItem.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ : _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Collection, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, lineStart);\n\n          if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atBlank(src, offset)) {\n            var wsEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, msg);\n          }\n        }\n\n        if (firstItem.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, offset) + 1;\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  return Collection;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Directive, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Directive);\n\n  function Directive() {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Directive);\n\n    _this = _super.call(this, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Directive, [{\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }, {\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Directive;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Document, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Document);\n\n  function Document() {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Document);\n\n    _this = _super.call(this, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(src, offset, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset);\n\n      while (!_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(src, offset, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }], [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  return Document;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Alias, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Alias);\n\n  function Alias() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Alias, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIdentifier(src, start + 1);\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start + 1, offset);\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(BlockValue, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(BlockValue, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch === ' ' || _ch === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }, {\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(src, offset)) break;\n        var end = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch2 = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch2 && _ch2 !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }]);\n\n  return BlockValue;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(FlowCollection, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset + 1);\n\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(QuoteDouble, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(QuoteDouble);\n\n  function QuoteDouble() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(QuoteDouble, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(src, i + 1)) errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }, {\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(QuoteSingle, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(QuoteSingle);\n\n  function QuoteSingle() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(QuoteSingle, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(src, i + 1)) errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.ALIAS:\n      return new Alias(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_KEY:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_VALUE:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN:\n      return new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.P(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, ParseContext);\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, \"parseNode\", function (overlay, start) {\n      if (_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.DOCUMENT) {\n          node.error = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, offset) : _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.ANCHOR || ch === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.COMMENT || ch === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var inEnd = offset;\n          var lineStart = void 0;\n\n          do {\n            lineStart = inEnd + 1;\n            inEnd = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIndent(src, lineStart);\n          } while (src[inEnd] === '\\n');\n\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM && parent.context.atLineStart;\n          if (src[inEnd] !== '#' && !_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.COMMENT) {\n          var end = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfLine(src, offset + 1);\n          props.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset, end));\n          offset = end;\n        } else {\n          var _end = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIdentifier(src, offset + 1);\n\n          if (ch === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.R(offset, _end));\n          lineHasProps = true;\n          offset = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }], [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.ALIAS;\n\n        case '>':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED;\n\n        case '|':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL;\n\n        case '{':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP;\n\n        case '[':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atBlank(src, offset + 1, true) ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_KEY : _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN;\n\n        case ':':\n          return !inFlow && _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atBlank(src, offset + 1, true) ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_VALUE : _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN;\n\n        case '-':\n          return !inFlow && _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.N.atBlank(src, offset + 1, true) ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM : _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN;\n\n        case '\"':\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE;\n\n        case \"'\":\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_SINGLE;\n\n        default:\n          return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN;\n      }\n    }\n  }]);\n\n  return ParseContext;\n}();\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UtY3N0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlSOztBQUV6UjtBQUNBLEVBQUUsMERBQVM7O0FBRVgsZUFBZSwwREFBWTs7QUFFM0I7QUFDQSxJQUFJLDBEQUFlOztBQUVuQiw2QkFBNkIsaUVBQWU7QUFDNUM7QUFDQTs7O0FBR0EsRUFBRSwwREFBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBSztBQUM1QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsQ0FBQyxzREFBSTs7QUFFTjtBQUNBLEVBQUUsMERBQVM7O0FBRVgsZUFBZSwwREFBWTs7QUFFM0I7QUFDQTs7QUFFQSxJQUFJLDBEQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDBEQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtEQUFhLG1CQUFtQixzREFBaUI7QUFDekY7QUFDQSxtQkFBbUIsc0VBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWM7O0FBRW5DLDRCQUE0QixzREFBSztBQUNqQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esc0JBQXNCLHNFQUFvQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsbUJBQW1CLGtFQUFnQjtBQUNuQzs7QUFFQTtBQUNBOztBQUVBLFVBQVUseUVBQXVCLGtEQUFr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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlLWNzdC5qcz9lN2QwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGogYXMgX2luaGVyaXRzLCBrIGFzIF9jcmVhdGVTdXBlciwgYyBhcyBfY2xhc3NDYWxsQ2hlY2ssIFQgYXMgVHlwZSwgYiBhcyBfY3JlYXRlQ2xhc3MsIFIgYXMgUmFuZ2UsIE4gYXMgTm9kZSwgZyBhcyBZQU1MU2VtYW50aWNFcnJvciwgbCBhcyBfZ2V0LCBtIGFzIF9nZXRQcm90b3R5cGVPZiwgWSBhcyBZQU1MU3ludGF4RXJyb3IsIEMgYXMgQ2hhciwgZSBhcyBfZGVmaW5lUHJvcGVydHksIFAgYXMgUGxhaW5WYWx1ZSB9IGZyb20gJy4vUGxhaW5WYWx1ZS1iODAzNmI3NS5qcyc7XG5cbnZhciBCbGFua0xpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhCbGFua0xpbmUsIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJsYW5rTGluZSk7XG5cbiAgZnVuY3Rpb24gQmxhbmtMaW5lKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCbGFua0xpbmUpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFR5cGUuQkxBTktfTElORSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCbGFua0xpbmUsIFt7XG4gICAga2V5OiBcImluY2x1ZGVzVHJhaWxpbmdMaW5lc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gVGhpcyBpcyBuZXZlciBjYWxsZWQgZnJvbSBhbnl3aGVyZSwgYnV0IGlmIGl0IHdlcmUsXG4gICAgICAvLyB0aGlzIGlzIHRoZSB2YWx1ZSBpdCBzaG91bGQgcmV0dXJuLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGJsYW5rIGxpbmUgZnJvbSB0aGUgc291cmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IFxcbiBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCArIDEpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgMTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmxhbmtMaW5lO1xufShOb2RlKTtcblxudmFyIENvbGxlY3Rpb25JdGVtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoQ29sbGVjdGlvbkl0ZW0sIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENvbGxlY3Rpb25JdGVtKTtcblxuICBmdW5jdGlvbiBDb2xsZWN0aW9uSXRlbSh0eXBlLCBwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xsZWN0aW9uSXRlbSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHByb3BzKTtcbiAgICBfdGhpcy5ub2RlID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29sbGVjdGlvbkl0ZW0sIFt7XG4gICAga2V5OiBcImluY2x1ZGVzVHJhaWxpbmdMaW5lc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5ub2RlICYmIHRoaXMubm9kZS5pbmNsdWRlc1RyYWlsaW5nTGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3QgY2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdmFyIHBhcnNlTm9kZSA9IGNvbnRleHQucGFyc2VOb2RlLFxuICAgICAgICAgIHNyYyA9IGNvbnRleHQuc3JjO1xuICAgICAgdmFyIGF0TGluZVN0YXJ0ID0gY29udGV4dC5hdExpbmVTdGFydCxcbiAgICAgICAgICBsaW5lU3RhcnQgPSBjb250ZXh0LmxpbmVTdGFydDtcbiAgICAgIGlmICghYXRMaW5lU3RhcnQgJiYgdGhpcy50eXBlID09PSBUeXBlLlNFUV9JVEVNKSB0aGlzLmVycm9yID0gbmV3IFlBTUxTZW1hbnRpY0Vycm9yKHRoaXMsICdTZXF1ZW5jZSBpdGVtcyBtdXN0IG5vdCBoYXZlIHByZWNlZGluZyBjb250ZW50IG9uIHRoZSBzYW1lIGxpbmUnKTtcbiAgICAgIHZhciBpbmRlbnQgPSBhdExpbmVTdGFydCA/IHN0YXJ0IC0gbGluZVN0YXJ0IDogY29udGV4dC5pbmRlbnQ7XG4gICAgICB2YXIgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBzdGFydCArIDEpO1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldF07XG4gICAgICB2YXIgaW5saW5lQ29tbWVudCA9IGNoID09PSAnIyc7XG4gICAgICB2YXIgY29tbWVudHMgPSBbXTtcbiAgICAgIHZhciBibGFua0xpbmUgPSBudWxsO1xuXG4gICAgICB3aGlsZSAoY2ggPT09ICdcXG4nIHx8IGNoID09PSAnIycpIHtcbiAgICAgICAgaWYgKGNoID09PSAnIycpIHtcbiAgICAgICAgICB2YXIgX2VuZCA9IE5vZGUuZW5kT2ZMaW5lKHNyYywgb2Zmc2V0ICsgMSk7XG5cbiAgICAgICAgICBjb21tZW50cy5wdXNoKG5ldyBSYW5nZShvZmZzZXQsIF9lbmQpKTtcbiAgICAgICAgICBvZmZzZXQgPSBfZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0TGluZVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICBsaW5lU3RhcnQgPSBvZmZzZXQgKyAxO1xuICAgICAgICAgIHZhciB3c0VuZCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgbGluZVN0YXJ0KTtcblxuICAgICAgICAgIGlmIChzcmNbd3NFbmRdID09PSAnXFxuJyAmJiBjb21tZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGJsYW5rTGluZSA9IG5ldyBCbGFua0xpbmUoKTtcbiAgICAgICAgICAgIGxpbmVTdGFydCA9IGJsYW5rTGluZS5wYXJzZSh7XG4gICAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgICAgICB9LCBsaW5lU3RhcnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZJbmRlbnQoc3JjLCBsaW5lU3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUubmV4dE5vZGVJc0luZGVudGVkKGNoLCBvZmZzZXQgLSAobGluZVN0YXJ0ICsgaW5kZW50KSwgdGhpcy50eXBlICE9PSBUeXBlLlNFUV9JVEVNKSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBwYXJzZU5vZGUoe1xuICAgICAgICAgIGF0TGluZVN0YXJ0OiBhdExpbmVTdGFydCxcbiAgICAgICAgICBpbkNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgICAgIGluZGVudDogaW5kZW50LFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIGlmIChjaCAmJiBsaW5lU3RhcnQgPiBzdGFydCArIDEpIHtcbiAgICAgICAgb2Zmc2V0ID0gbGluZVN0YXJ0IC0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgLy8gT25seSBibGFuayBsaW5lcyBwcmVjZWRpbmcgbm9uLWVtcHR5IG5vZGVzIGFyZSBjYXB0dXJlZC4gTm90ZSB0aGF0XG4gICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IGNvbGxlY3Rpb24gaXRlbSByYW5nZSBzdGFydCBpbmRpY2VzIGRvIG5vdCBhbHdheXNcbiAgICAgICAgICAvLyBpbmNyZWFzZSBtb25vdG9uaWNhbGx5LiAtLSBlZW1lbGkveWFtbCMxMjZcbiAgICAgICAgICB2YXIgaXRlbXMgPSBjb250ZXh0LnBhcmVudC5pdGVtcyB8fCBjb250ZXh0LnBhcmVudC5jb250ZW50cztcbiAgICAgICAgICBpZiAoaXRlbXMpIGl0ZW1zLnB1c2goYmxhbmtMaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tZW50cy5sZW5ndGgpIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucHJvcHMsIGNvbW1lbnRzKTtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5ub2RlLnJhbmdlLmVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbmxpbmVDb21tZW50KSB7XG4gICAgICAgICAgdmFyIGMgPSBjb21tZW50c1swXTtcbiAgICAgICAgICB0aGlzLnByb3BzLnB1c2goYyk7XG4gICAgICAgICAgb2Zmc2V0ID0gYy5lbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZkxpbmUoc3JjLCBzdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmQgPSB0aGlzLm5vZGUgPyB0aGlzLm5vZGUudmFsdWVSYW5nZS5lbmQgOiBvZmZzZXQ7XG4gICAgICB0aGlzLnZhbHVlUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcmlnUmFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gX2dldChfZ2V0UHJvdG90eXBlT2YoQ29sbGVjdGlvbkl0ZW0ucHJvdG90eXBlKSwgXCJzZXRPcmlnUmFuZ2VzXCIsIHRoaXMpLmNhbGwodGhpcywgY3IsIG9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlID8gdGhpcy5ub2RlLnNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCkgOiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmMsXG4gICAgICAgICAgbm9kZSA9IHRoaXMubm9kZSxcbiAgICAgICAgICByYW5nZSA9IHRoaXMucmFuZ2UsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhciBzdHIgPSBub2RlID8gc3JjLnNsaWNlKHJhbmdlLnN0YXJ0LCBub2RlLnJhbmdlLnN0YXJ0KSArIFN0cmluZyhub2RlKSA6IHNyYy5zbGljZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcbiAgICAgIHJldHVybiBOb2RlLmFkZFN0cmluZ1Rlcm1pbmF0b3Ioc3JjLCByYW5nZS5lbmQsIHN0cik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbGxlY3Rpb25JdGVtO1xufShOb2RlKTtcblxudmFyIENvbW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhDb21tZW50LCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDb21tZW50KTtcblxuICBmdW5jdGlvbiBDb21tZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21tZW50KTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBUeXBlLkNPTU1FTlQpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBjb21tZW50IGxpbmUgZnJvbSB0aGUgc291cmNlXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpcyBzY2FsYXJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ29tbWVudCwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5wYXJzZUNvbW1lbnQoc3RhcnQpO1xuICAgICAgdGhpcy5yYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbW1lbnQ7XG59KE5vZGUpO1xuXG5mdW5jdGlvbiBncmFiQ29sbGVjdGlvbkVuZENvbW1lbnRzKG5vZGUpIHtcbiAgdmFyIGNub2RlID0gbm9kZTtcblxuICB3aGlsZSAoY25vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uSXRlbSkge1xuICAgIGNub2RlID0gY25vZGUubm9kZTtcbiAgfVxuXG4gIGlmICghKGNub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbikpIHJldHVybiBudWxsO1xuICB2YXIgbGVuID0gY25vZGUuaXRlbXMubGVuZ3RoO1xuICB2YXIgY2kgPSAtMTtcblxuICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgbiA9IGNub2RlLml0ZW1zW2ldO1xuXG4gICAgaWYgKG4udHlwZSA9PT0gVHlwZS5DT01NRU5UKSB7XG4gICAgICAvLyBLZWVwIHN1ZmZpY2llbnRseSBpbmRlbnRlZCBjb21tZW50cyB3aXRoIHByZWNlZGluZyBub2RlXG4gICAgICB2YXIgX24kY29udGV4dCA9IG4uY29udGV4dCxcbiAgICAgICAgICBpbmRlbnQgPSBfbiRjb250ZXh0LmluZGVudCxcbiAgICAgICAgICBsaW5lU3RhcnQgPSBfbiRjb250ZXh0LmxpbmVTdGFydDtcbiAgICAgIGlmIChpbmRlbnQgPiAwICYmIG4ucmFuZ2Uuc3RhcnQgPj0gbGluZVN0YXJ0ICsgaW5kZW50KSBicmVhaztcbiAgICAgIGNpID0gaTtcbiAgICB9IGVsc2UgaWYgKG4udHlwZSA9PT0gVHlwZS5CTEFOS19MSU5FKSBjaSA9IGk7ZWxzZSBicmVhaztcbiAgfVxuXG4gIGlmIChjaSA9PT0gLTEpIHJldHVybiBudWxsO1xuICB2YXIgY2EgPSBjbm9kZS5pdGVtcy5zcGxpY2UoY2ksIGxlbiAtIGNpKTtcbiAgdmFyIHByZXZFbmQgPSBjYVswXS5yYW5nZS5zdGFydDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNub2RlLnJhbmdlLmVuZCA9IHByZXZFbmQ7XG4gICAgaWYgKGNub2RlLnZhbHVlUmFuZ2UgJiYgY25vZGUudmFsdWVSYW5nZS5lbmQgPiBwcmV2RW5kKSBjbm9kZS52YWx1ZVJhbmdlLmVuZCA9IHByZXZFbmQ7XG4gICAgaWYgKGNub2RlID09PSBub2RlKSBicmVhaztcbiAgICBjbm9kZSA9IGNub2RlLmNvbnRleHQucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGNhO1xufVxudmFyIENvbGxlY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhDb2xsZWN0aW9uLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDb2xsZWN0aW9uKTtcblxuICBmdW5jdGlvbiBDb2xsZWN0aW9uKGZpcnN0SXRlbSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xsZWN0aW9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZmlyc3RJdGVtLnR5cGUgPT09IFR5cGUuU0VRX0lURU0gPyBUeXBlLlNFUSA6IFR5cGUuTUFQKTtcblxuICAgIGZvciAodmFyIGkgPSBmaXJzdEl0ZW0ucHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGlmIChmaXJzdEl0ZW0ucHJvcHNbaV0uc3RhcnQgPCBmaXJzdEl0ZW0uY29udGV4dC5saW5lU3RhcnQpIHtcbiAgICAgICAgLy8gcHJvcHMgb24gcHJldmlvdXMgbGluZSBhcmUgYXNzdW1lZCBieSB0aGUgY29sbGVjdGlvblxuICAgICAgICBfdGhpcy5wcm9wcyA9IGZpcnN0SXRlbS5wcm9wcy5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgIGZpcnN0SXRlbS5wcm9wcyA9IGZpcnN0SXRlbS5wcm9wcy5zbGljZShpICsgMSk7XG4gICAgICAgIHZhciBpdGVtUmFuZ2UgPSBmaXJzdEl0ZW0ucHJvcHNbMF0gfHwgZmlyc3RJdGVtLnZhbHVlUmFuZ2U7XG4gICAgICAgIGZpcnN0SXRlbS5yYW5nZS5zdGFydCA9IGl0ZW1SYW5nZS5zdGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMuaXRlbXMgPSBbZmlyc3RJdGVtXTtcbiAgICB2YXIgZWMgPSBncmFiQ29sbGVjdGlvbkVuZENvbW1lbnRzKGZpcnN0SXRlbSk7XG4gICAgaWYgKGVjKSBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShfdGhpcy5pdGVtcywgZWMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2xsZWN0aW9uLCBbe1xuICAgIGtleTogXCJpbmNsdWRlc1RyYWlsaW5nTGluZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3QgY2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdmFyIHBhcnNlTm9kZSA9IGNvbnRleHQucGFyc2VOb2RlLFxuICAgICAgICAgIHNyYyA9IGNvbnRleHQuc3JjOyAvLyBJdCdzIGVhc2llciB0byByZWNhbGN1bGF0ZSBsaW5lU3RhcnQgaGVyZSByYXRoZXIgdGhhbiB0cmFja2luZyBkb3duIHRoZVxuICAgICAgLy8gbGFzdCBjb250ZXh0IGZyb20gd2hpY2ggdG8gcmVhZCBpdCAtLSBlZW1lbGkveWFtbCMyXG5cbiAgICAgIHZhciBsaW5lU3RhcnQgPSBOb2RlLnN0YXJ0T2ZMaW5lKHNyYywgc3RhcnQpO1xuICAgICAgdmFyIGZpcnN0SXRlbSA9IHRoaXMuaXRlbXNbMF07IC8vIEZpcnN0LWl0ZW0gY29udGV4dCBuZWVkcyB0byBiZSBjb3JyZWN0IGZvciBsYXRlciBjb21tZW50IGhhbmRsaW5nXG4gICAgICAvLyAtLSBlZW1lbGkveWFtbCMxN1xuXG4gICAgICBmaXJzdEl0ZW0uY29udGV4dC5wYXJlbnQgPSB0aGlzO1xuICAgICAgdGhpcy52YWx1ZVJhbmdlID0gUmFuZ2UuY29weShmaXJzdEl0ZW0udmFsdWVSYW5nZSk7XG4gICAgICB2YXIgaW5kZW50ID0gZmlyc3RJdGVtLnJhbmdlLnN0YXJ0IC0gZmlyc3RJdGVtLmNvbnRleHQubGluZVN0YXJ0O1xuICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0O1xuICAgICAgb2Zmc2V0ID0gTm9kZS5ub3JtYWxpemVPZmZzZXQoc3JjLCBvZmZzZXQpO1xuICAgICAgdmFyIGNoID0gc3JjW29mZnNldF07XG4gICAgICB2YXIgYXRMaW5lU3RhcnQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIGxpbmVTdGFydCkgPT09IG9mZnNldDtcbiAgICAgIHZhciBwcmV2SW5jbHVkZXNUcmFpbGluZ0xpbmVzID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICB3aGlsZSAoY2ggPT09ICdcXG4nIHx8IGNoID09PSAnIycpIHtcbiAgICAgICAgICBpZiAoYXRMaW5lU3RhcnQgJiYgY2ggPT09ICdcXG4nICYmICFwcmV2SW5jbHVkZXNUcmFpbGluZ0xpbmVzKSB7XG4gICAgICAgICAgICB2YXIgYmxhbmtMaW5lID0gbmV3IEJsYW5rTGluZSgpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gYmxhbmtMaW5lLnBhcnNlKHtcbiAgICAgICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgICAgIH0sIG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlUmFuZ2UuZW5kID0gb2Zmc2V0O1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID49IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2ggPSBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGJsYW5rTGluZSk7XG4gICAgICAgICAgICBvZmZzZXQgLT0gMTsgLy8gYmxhbmtMaW5lLnBhcnNlKCkgY29uc3VtZXMgdGVybWluYWwgbmV3bGluZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcjJykge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxpbmVTdGFydCArIGluZGVudCAmJiAhQ29sbGVjdGlvbi5uZXh0Q29udGVudEhhc0luZGVudChzcmMsIG9mZnNldCwgaW5kZW50KSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IG5ldyBDb21tZW50KCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBjb21tZW50LnBhcnNlKHtcbiAgICAgICAgICAgICAgaW5kZW50OiBpbmRlbnQsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzcmM6IHNyY1xuICAgICAgICAgICAgfSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVSYW5nZS5lbmQgPSBvZmZzZXQ7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gc3JjLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjaCA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpbmVTdGFydCA9IG9mZnNldCArIDE7XG4gICAgICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZkluZGVudChzcmMsIGxpbmVTdGFydCk7XG5cbiAgICAgICAgICBpZiAoTm9kZS5hdEJsYW5rKHNyYywgb2Zmc2V0KSkge1xuICAgICAgICAgICAgdmFyIHdzRW5kID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgICAgICAgICAgdmFyIG5leHQgPSBzcmNbd3NFbmRdO1xuXG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PT0gJ1xcbicgfHwgbmV4dCA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgIG9mZnNldCA9IHdzRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoID0gc3JjW29mZnNldF07XG4gICAgICAgICAgYXRMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldCAhPT0gbGluZVN0YXJ0ICsgaW5kZW50ICYmIChhdExpbmVTdGFydCB8fCBjaCAhPT0gJzonKSkge1xuICAgICAgICAgIGlmIChvZmZzZXQgPCBsaW5lU3RhcnQgKyBpbmRlbnQpIHtcbiAgICAgICAgICAgIGlmIChsaW5lU3RhcnQgPiBzdGFydCkgb2Zmc2V0ID0gbGluZVN0YXJ0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5lcnJvcikge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdBbGwgY29sbGVjdGlvbiBpdGVtcyBtdXN0IHN0YXJ0IGF0IHRoZSBzYW1lIGNvbHVtbic7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gbmV3IFlBTUxTeW50YXhFcnJvcih0aGlzLCBtc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaXJzdEl0ZW0udHlwZSA9PT0gVHlwZS5TRVFfSVRFTSkge1xuICAgICAgICAgIGlmIChjaCAhPT0gJy0nKSB7XG4gICAgICAgICAgICBpZiAobGluZVN0YXJ0ID4gc3RhcnQpIG9mZnNldCA9IGxpbmVTdGFydDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJy0nICYmICF0aGlzLmVycm9yKSB7XG4gICAgICAgICAgLy8gbWFwIGtleSBtYXkgc3RhcnQgd2l0aCAtLCBhcyBsb25nIGFzIGl0J3MgZm9sbG93ZWQgYnkgYSBub24td2hpdGVzcGFjZSBjaGFyXG4gICAgICAgICAgdmFyIF9uZXh0ID0gc3JjW29mZnNldCArIDFdO1xuXG4gICAgICAgICAgaWYgKCFfbmV4dCB8fCBfbmV4dCA9PT0gJ1xcbicgfHwgX25leHQgPT09ICdcXHQnIHx8IF9uZXh0ID09PSAnICcpIHtcbiAgICAgICAgICAgIHZhciBfbXNnID0gJ0EgY29sbGVjdGlvbiBjYW5ub3QgYmUgYm90aCBhIG1hcHBpbmcgYW5kIGEgc2VxdWVuY2UnO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBZQU1MU3ludGF4RXJyb3IodGhpcywgX21zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSBwYXJzZU5vZGUoe1xuICAgICAgICAgIGF0TGluZVN0YXJ0OiBhdExpbmVTdGFydCxcbiAgICAgICAgICBpbkNvbGxlY3Rpb246IHRydWUsXG4gICAgICAgICAgaW5kZW50OiBpbmRlbnQsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgICAgIH0sIG9mZnNldCk7XG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuIG9mZnNldDsgLy8gYXQgbmV4dCBkb2N1bWVudCBzdGFydFxuXG4gICAgICAgIHRoaXMuaXRlbXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy52YWx1ZVJhbmdlLmVuZCA9IG5vZGUudmFsdWVSYW5nZS5lbmQ7XG4gICAgICAgIG9mZnNldCA9IE5vZGUubm9ybWFsaXplT2Zmc2V0KHNyYywgbm9kZS5yYW5nZS5lbmQpO1xuICAgICAgICBjaCA9IHNyY1tvZmZzZXRdO1xuICAgICAgICBhdExpbmVTdGFydCA9IGZhbHNlO1xuICAgICAgICBwcmV2SW5jbHVkZXNUcmFpbGluZ0xpbmVzID0gbm9kZS5pbmNsdWRlc1RyYWlsaW5nTGluZXM7IC8vIE5lZWQgdG8gcmVzZXQgbGluZVN0YXJ0IGFuZCBhdExpbmVTdGFydCBoZXJlIGlmIHByZWNlZGluZyBub2RlJ3MgcmFuZ2VcbiAgICAgICAgLy8gaGFzIGFkdmFuY2VkIHRvIGNoZWNrIHRoZSBjdXJyZW50IGxpbmUncyBpbmRlbnRhdGlvbiBsZXZlbFxuICAgICAgICAvLyAtLSBlZW1lbGkveWFtbCMxMCAmIGVlbWVsaS95YW1sIzM4XG5cbiAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgdmFyIGxzID0gb2Zmc2V0IC0gMTtcbiAgICAgICAgICB2YXIgcHJldiA9IHNyY1tsc107XG5cbiAgICAgICAgICB3aGlsZSAocHJldiA9PT0gJyAnIHx8IHByZXYgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBwcmV2ID0gc3JjWy0tbHNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmV2ID09PSAnXFxuJykge1xuICAgICAgICAgICAgbGluZVN0YXJ0ID0gbHMgKyAxO1xuICAgICAgICAgICAgYXRMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlYyA9IGdyYWJDb2xsZWN0aW9uRW5kQ29tbWVudHMobm9kZSk7XG4gICAgICAgIGlmIChlYykgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5pdGVtcywgZWMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcmlnUmFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gX2dldChfZ2V0UHJvdG90eXBlT2YoQ29sbGVjdGlvbi5wcm90b3R5cGUpLCBcInNldE9yaWdSYW5nZXNcIiwgdGhpcykuY2FsbCh0aGlzLCBjciwgb2Zmc2V0KTtcbiAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBvZmZzZXQgPSBub2RlLnNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmMsXG4gICAgICAgICAgaXRlbXMgPSB0aGlzLml0ZW1zLFxuICAgICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZSxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFyIHN0ciA9IHNyYy5zbGljZShyYW5nZS5zdGFydCwgaXRlbXNbMF0ucmFuZ2Uuc3RhcnQpICsgU3RyaW5nKGl0ZW1zWzBdKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICB2YXIgX2l0ZW0kY29udGV4dCA9IGl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgIGF0TGluZVN0YXJ0ID0gX2l0ZW0kY29udGV4dC5hdExpbmVTdGFydCxcbiAgICAgICAgICAgIGluZGVudCA9IF9pdGVtJGNvbnRleHQuaW5kZW50O1xuICAgICAgICBpZiAoYXRMaW5lU3RhcnQpIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbmRlbnQ7ICsrX2kpIHtcbiAgICAgICAgICBzdHIgKz0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBTdHJpbmcoaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBOb2RlLmFkZFN0cmluZ1Rlcm1pbmF0b3Ioc3JjLCByYW5nZS5lbmQsIHN0cik7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibmV4dENvbnRlbnRIYXNJbmRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dENvbnRlbnRIYXNJbmRlbnQoc3JjLCBvZmZzZXQsIGluZGVudCkge1xuICAgICAgdmFyIGxpbmVTdGFydCA9IE5vZGUuZW5kT2ZMaW5lKHNyYywgb2Zmc2V0KSArIDE7XG4gICAgICBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIGxpbmVTdGFydCk7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICAgIGlmICghY2gpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChvZmZzZXQgPj0gbGluZVN0YXJ0ICsgaW5kZW50KSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChjaCAhPT0gJyMnICYmIGNoICE9PSAnXFxuJykgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIENvbGxlY3Rpb24ubmV4dENvbnRlbnRIYXNJbmRlbnQoc3JjLCBvZmZzZXQsIGluZGVudCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbGxlY3Rpb247XG59KE5vZGUpO1xuXG52YXIgRGlyZWN0aXZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoRGlyZWN0aXZlLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEaXJlY3RpdmUpO1xuXG4gIGZ1bmN0aW9uIERpcmVjdGl2ZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlyZWN0aXZlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgVHlwZS5ESVJFQ1RJVkUpO1xuICAgIF90aGlzLm5hbWUgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEaXJlY3RpdmUsIFt7XG4gICAga2V5OiBcInBhcmFtZXRlcnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciByYXcgPSB0aGlzLnJhd1ZhbHVlO1xuICAgICAgcmV0dXJuIHJhdyA/IHJhdy50cmltKCkuc3BsaXQoL1sgXFx0XSsvKSA6IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VOYW1lKHN0YXJ0KSB7XG4gICAgICB2YXIgc3JjID0gdGhpcy5jb250ZXh0LnNyYztcbiAgICAgIHZhciBvZmZzZXQgPSBzdGFydDtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgICB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nICYmIGNoICE9PSAnXFx0JyAmJiBjaCAhPT0gJyAnKSB7XG4gICAgICAgIGNoID0gc3JjW29mZnNldCArPSAxXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uYW1lID0gc3JjLnNsaWNlKHN0YXJ0LCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VQYXJhbWV0ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVycyhzdGFydCkge1xuICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmM7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJyAmJiBjaCAhPT0gJyMnKSB7XG4gICAgICAgIGNoID0gc3JjW29mZnNldCArPSAxXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5wYXJzZU5hbWUoc3RhcnQgKyAxKTtcbiAgICAgIG9mZnNldCA9IHRoaXMucGFyc2VQYXJhbWV0ZXJzKG9mZnNldCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQ29tbWVudChvZmZzZXQpO1xuICAgICAgdGhpcy5yYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERpcmVjdGl2ZTtcbn0oTm9kZSk7XG5cbnZhciBEb2N1bWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKERvY3VtZW50LCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEb2N1bWVudCk7XG5cbiAgZnVuY3Rpb24gRG9jdW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvY3VtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgVHlwZS5ET0NVTUVOVCk7XG4gICAgX3RoaXMuZGlyZWN0aXZlcyA9IG51bGw7XG4gICAgX3RoaXMuY29udGVudHMgPSBudWxsO1xuICAgIF90aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIgPSBudWxsO1xuICAgIF90aGlzLmRvY3VtZW50RW5kTWFya2VyID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRG9jdW1lbnQsIFt7XG4gICAga2V5OiBcInBhcnNlRGlyZWN0aXZlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURpcmVjdGl2ZXMoc3RhcnQpIHtcbiAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjO1xuICAgICAgdGhpcy5kaXJlY3RpdmVzID0gW107XG4gICAgICB2YXIgYXRMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgdmFyIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgIHZhciBvZmZzZXQgPSBzdGFydDtcblxuICAgICAgd2hpbGUgKCFOb2RlLmF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIG9mZnNldCwgQ2hhci5ESVJFQ1RJVkVTX0VORCkpIHtcbiAgICAgICAgb2Zmc2V0ID0gRG9jdW1lbnQuc3RhcnRDb21tZW50T3JFbmRCbGFua0xpbmUoc3JjLCBvZmZzZXQpO1xuXG4gICAgICAgIHN3aXRjaCAoc3JjW29mZnNldF0pIHtcbiAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgaWYgKGF0TGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgIHZhciBibGFua0xpbmUgPSBuZXcgQmxhbmtMaW5lKCk7XG4gICAgICAgICAgICAgIG9mZnNldCA9IGJsYW5rTGluZS5wYXJzZSh7XG4gICAgICAgICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgICAgICAgfSwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgc3JjLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5wdXNoKGJsYW5rTGluZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgICBhdExpbmVTdGFydCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBjb21tZW50ID0gbmV3IENvbW1lbnQoKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gY29tbWVudC5wYXJzZSh7XG4gICAgICAgICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgICAgICAgfSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgIGF0TGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlID0gbmV3IERpcmVjdGl2ZSgpO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBkaXJlY3RpdmUucGFyc2Uoe1xuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICBzcmM6IHNyY1xuICAgICAgICAgICAgICB9LCBvZmZzZXQpO1xuICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMucHVzaChkaXJlY3RpdmUpO1xuICAgICAgICAgICAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYXRMaW5lU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgWUFNTFNlbWFudGljRXJyb3IodGhpcywgJ01pc3NpbmcgZGlyZWN0aXZlcy1lbmQgaW5kaWNhdG9yIGxpbmUnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3RpdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IHRoaXMuZGlyZWN0aXZlcztcbiAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNyY1tvZmZzZXRdKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlc0VuZE1hcmtlciA9IG5ldyBSYW5nZShvZmZzZXQsIG9mZnNldCArIDMpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMztcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBZQU1MU2VtYW50aWNFcnJvcih0aGlzLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGl2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmNvbnRlbnRzID0gdGhpcy5kaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VDb250ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUNvbnRlbnRzKHN0YXJ0KSB7XG4gICAgICB2YXIgX3RoaXMkY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBwYXJzZU5vZGUgPSBfdGhpcyRjb250ZXh0LnBhcnNlTm9kZSxcbiAgICAgICAgICBzcmMgPSBfdGhpcyRjb250ZXh0LnNyYztcbiAgICAgIGlmICghdGhpcy5jb250ZW50cykgdGhpcy5jb250ZW50cyA9IFtdO1xuICAgICAgdmFyIGxpbmVTdGFydCA9IHN0YXJ0O1xuXG4gICAgICB3aGlsZSAoc3JjW2xpbmVTdGFydCAtIDFdID09PSAnLScpIHtcbiAgICAgICAgbGluZVN0YXJ0IC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIHN0YXJ0KTtcbiAgICAgIHZhciBhdExpbmVTdGFydCA9IGxpbmVTdGFydCA9PT0gc3RhcnQ7XG4gICAgICB0aGlzLnZhbHVlUmFuZ2UgPSBuZXcgUmFuZ2Uob2Zmc2V0KTtcblxuICAgICAgd2hpbGUgKCFOb2RlLmF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIG9mZnNldCwgQ2hhci5ET0NVTUVOVF9FTkQpKSB7XG4gICAgICAgIHN3aXRjaCAoc3JjW29mZnNldF0pIHtcbiAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgaWYgKGF0TGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgIHZhciBibGFua0xpbmUgPSBuZXcgQmxhbmtMaW5lKCk7XG4gICAgICAgICAgICAgIG9mZnNldCA9IGJsYW5rTGluZS5wYXJzZSh7XG4gICAgICAgICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgICAgICAgfSwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgc3JjLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudHMucHVzaChibGFua0xpbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgYXRMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IG5ldyBDb21tZW50KCk7XG4gICAgICAgICAgICAgIG9mZnNldCA9IGNvbW1lbnQucGFyc2Uoe1xuICAgICAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgICAgICAgIH0sIG9mZnNldCk7XG4gICAgICAgICAgICAgIHRoaXMuY29udGVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgYXRMaW5lU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGlFbmQgPSBOb2RlLmVuZE9mSW5kZW50KHNyYywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgYXRMaW5lU3RhcnQ6IGF0TGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIGluZGVudDogLTEsXG4gICAgICAgICAgICAgICAgaW5GbG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbkNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHBhcnNlTm9kZShjb250ZXh0LCBpRW5kKTtcbiAgICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gdGhpcy52YWx1ZVJhbmdlLmVuZCA9IGlFbmQ7IC8vIGF0IG5leHQgZG9jdW1lbnQgc3RhcnRcblxuICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgIG9mZnNldCA9IG5vZGUucmFuZ2UuZW5kO1xuICAgICAgICAgICAgICBhdExpbmVTdGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgZWMgPSBncmFiQ29sbGVjdGlvbkVuZENvbW1lbnRzKG5vZGUpO1xuICAgICAgICAgICAgICBpZiAoZWMpIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuY29udGVudHMsIGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldCA9IERvY3VtZW50LnN0YXJ0Q29tbWVudE9yRW5kQmxhbmtMaW5lKHNyYywgb2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWx1ZVJhbmdlLmVuZCA9IG9mZnNldDtcblxuICAgICAgaWYgKHNyY1tvZmZzZXRdKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRFbmRNYXJrZXIgPSBuZXcgUmFuZ2Uob2Zmc2V0LCBvZmZzZXQgKyAzKTtcbiAgICAgICAgb2Zmc2V0ICs9IDM7XG5cbiAgICAgICAgaWYgKHNyY1tvZmZzZXRdKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuXG4gICAgICAgICAgaWYgKHNyY1tvZmZzZXRdID09PSAnIycpIHtcbiAgICAgICAgICAgIHZhciBfY29tbWVudCA9IG5ldyBDb21tZW50KCk7XG5cbiAgICAgICAgICAgIG9mZnNldCA9IF9jb21tZW50LnBhcnNlKHtcbiAgICAgICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgICAgIH0sIG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzLnB1c2goX2NvbW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAoc3JjW29mZnNldF0pIHtcbiAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aGlzLmVycm9yID0gbmV3IFlBTUxTeW50YXhFcnJvcih0aGlzLCAnRG9jdW1lbnQgZW5kIG1hcmtlciBsaW5lIGNhbm5vdCBoYXZlIGEgbm9uLWNvbW1lbnQgc3VmZml4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UGFyc2VDb250ZXh0fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3QgY2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgICBjb250ZXh0LnJvb3QgPSB0aGlzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHZhciBzcmMgPSBjb250ZXh0LnNyYztcbiAgICAgIHZhciBvZmZzZXQgPSBzcmMuY2hhckNvZGVBdChzdGFydCkgPT09IDB4ZmVmZiA/IHN0YXJ0ICsgMSA6IHN0YXJ0OyAvLyBza2lwIEJPTVxuXG4gICAgICBvZmZzZXQgPSB0aGlzLnBhcnNlRGlyZWN0aXZlcyhvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUNvbnRlbnRzKG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcmlnUmFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gX2dldChfZ2V0UHJvdG90eXBlT2YoRG9jdW1lbnQucHJvdG90eXBlKSwgXCJzZXRPcmlnUmFuZ2VzXCIsIHRoaXMpLmNhbGwodGhpcywgY3IsIG9mZnNldCk7XG4gICAgICB0aGlzLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBvZmZzZXQgPSBub2RlLnNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXNFbmRNYXJrZXIpIG9mZnNldCA9IHRoaXMuZGlyZWN0aXZlc0VuZE1hcmtlci5zZXRPcmlnUmFuZ2UoY3IsIG9mZnNldCk7XG4gICAgICB0aGlzLmNvbnRlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5zZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5kb2N1bWVudEVuZE1hcmtlcikgb2Zmc2V0ID0gdGhpcy5kb2N1bWVudEVuZE1hcmtlci5zZXRPcmlnUmFuZ2UoY3IsIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBjb250ZW50cyA9IHRoaXMuY29udGVudHMsXG4gICAgICAgICAgZGlyZWN0aXZlcyA9IHRoaXMuZGlyZWN0aXZlcyxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFyIHN0ciA9IGRpcmVjdGl2ZXMuam9pbignJyk7XG5cbiAgICAgIGlmIChjb250ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA+IDAgfHwgY29udGVudHNbMF0udHlwZSA9PT0gVHlwZS5DT01NRU5UKSBzdHIgKz0gJy0tLVxcbic7XG4gICAgICAgIHN0ciArPSBjb250ZW50cy5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gIT09ICdcXG4nKSBzdHIgKz0gJ1xcbic7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInN0YXJ0Q29tbWVudE9yRW5kQmxhbmtMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0Q29tbWVudE9yRW5kQmxhbmtMaW5lKHNyYywgc3RhcnQpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIHN0YXJ0KTtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuICAgICAgcmV0dXJuIGNoID09PSAnIycgfHwgY2ggPT09ICdcXG4nID8gb2Zmc2V0IDogc3RhcnQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERvY3VtZW50O1xufShOb2RlKTtcblxudmFyIEFsaWFzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoQWxpYXMsIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEFsaWFzKTtcblxuICBmdW5jdGlvbiBBbGlhcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWxpYXMpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFsaWFzLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiAqYWxpYXMgZnJvbSB0aGUgc291cmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzIHNjYWxhclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdmFyIHNyYyA9IGNvbnRleHQuc3JjO1xuICAgICAgdmFyIG9mZnNldCA9IE5vZGUuZW5kT2ZJZGVudGlmaWVyKHNyYywgc3RhcnQgKyAxKTtcbiAgICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBSYW5nZShzdGFydCArIDEsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQ29tbWVudChvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWxpYXM7XG59KE5vZGUpO1xuXG52YXIgQ2hvbXAgPSB7XG4gIENMSVA6ICdDTElQJyxcbiAgS0VFUDogJ0tFRVAnLFxuICBTVFJJUDogJ1NUUklQJ1xufTtcbnZhciBCbG9ja1ZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoQmxvY2tWYWx1ZSwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQmxvY2tWYWx1ZSk7XG5cbiAgZnVuY3Rpb24gQmxvY2tWYWx1ZSh0eXBlLCBwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCbG9ja1ZhbHVlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgcHJvcHMpO1xuICAgIF90aGlzLmJsb2NrSW5kZW50ID0gbnVsbDtcbiAgICBfdGhpcy5jaG9tcGluZyA9IENob21wLkNMSVA7XG4gICAgX3RoaXMuaGVhZGVyID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmxvY2tWYWx1ZSwgW3tcbiAgICBrZXk6IFwiaW5jbHVkZXNUcmFpbGluZ0xpbmVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaG9tcGluZyA9PT0gQ2hvbXAuS0VFUDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RyVmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy52YWx1ZVJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiBudWxsO1xuICAgICAgdmFyIF90aGlzJHZhbHVlUmFuZ2UgPSB0aGlzLnZhbHVlUmFuZ2UsXG4gICAgICAgICAgc3RhcnQgPSBfdGhpcyR2YWx1ZVJhbmdlLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IF90aGlzJHZhbHVlUmFuZ2UuZW5kO1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgaW5kZW50ID0gX3RoaXMkY29udGV4dC5pbmRlbnQsXG4gICAgICAgICAgc3JjID0gX3RoaXMkY29udGV4dC5zcmM7XG4gICAgICBpZiAodGhpcy52YWx1ZVJhbmdlLmlzRW1wdHkoKSkgcmV0dXJuICcnO1xuICAgICAgdmFyIGxhc3ROZXdMaW5lID0gbnVsbDtcbiAgICAgIHZhciBjaCA9IHNyY1tlbmQgLSAxXTtcblxuICAgICAgd2hpbGUgKGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJykge1xuICAgICAgICBlbmQgLT0gMTtcblxuICAgICAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hvbXBpbmcgPT09IENob21wLktFRVApIGJyZWFrO2Vsc2UgcmV0dXJuICcnOyAvLyBwcm9iYWJseSBuZXZlciBoYXBwZW5zXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSBsYXN0TmV3TGluZSA9IGVuZDtcbiAgICAgICAgY2ggPSBzcmNbZW5kIC0gMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBrZWVwU3RhcnQgPSBlbmQgKyAxO1xuXG4gICAgICBpZiAobGFzdE5ld0xpbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hvbXBpbmcgPT09IENob21wLktFRVApIHtcbiAgICAgICAgICBrZWVwU3RhcnQgPSBsYXN0TmV3TGluZTtcbiAgICAgICAgICBlbmQgPSB0aGlzLnZhbHVlUmFuZ2UuZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IGxhc3ROZXdMaW5lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBiaSA9IGluZGVudCArIHRoaXMuYmxvY2tJbmRlbnQ7XG4gICAgICB2YXIgZm9sZGVkID0gdGhpcy50eXBlID09PSBUeXBlLkJMT0NLX0ZPTERFRDtcbiAgICAgIHZhciBhdFN0YXJ0ID0gdHJ1ZTtcbiAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgIHZhciBzZXAgPSAnJztcbiAgICAgIHZhciBwcmV2TW9yZUluZGVudGVkID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmk7ICsraikge1xuICAgICAgICAgIGlmIChzcmNbaV0gIT09ICcgJykgYnJlYWs7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9jaCA9IHNyY1tpXTtcblxuICAgICAgICBpZiAoX2NoID09PSAnXFxuJykge1xuICAgICAgICAgIGlmIChzZXAgPT09ICdcXG4nKSBzdHIgKz0gJ1xcbic7ZWxzZSBzZXAgPSAnXFxuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGluZUVuZCA9IE5vZGUuZW5kT2ZMaW5lKHNyYywgaSk7XG4gICAgICAgICAgdmFyIGxpbmUgPSBzcmMuc2xpY2UoaSwgbGluZUVuZCk7XG4gICAgICAgICAgaSA9IGxpbmVFbmQ7XG5cbiAgICAgICAgICBpZiAoZm9sZGVkICYmIChfY2ggPT09ICcgJyB8fCBfY2ggPT09ICdcXHQnKSAmJiBpIDwga2VlcFN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoc2VwID09PSAnICcpIHNlcCA9ICdcXG4nO2Vsc2UgaWYgKCFwcmV2TW9yZUluZGVudGVkICYmICFhdFN0YXJ0ICYmIHNlcCA9PT0gJ1xcbicpIHNlcCA9ICdcXG5cXG4nO1xuICAgICAgICAgICAgc3RyICs9IHNlcCArIGxpbmU7IC8vKyAoKGxpbmVFbmQgPCBlbmQgJiYgc3JjW2xpbmVFbmRdKSB8fCAnJylcblxuICAgICAgICAgICAgc2VwID0gbGluZUVuZCA8IGVuZCAmJiBzcmNbbGluZUVuZF0gfHwgJyc7XG4gICAgICAgICAgICBwcmV2TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyICs9IHNlcCArIGxpbmU7XG4gICAgICAgICAgICBzZXAgPSBmb2xkZWQgJiYgaSA8IGtlZXBTdGFydCA/ICcgJyA6ICdcXG4nO1xuICAgICAgICAgICAgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdFN0YXJ0ICYmIGxpbmUgIT09ICcnKSBhdFN0YXJ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2hvbXBpbmcgPT09IENob21wLlNUUklQID8gc3RyIDogc3RyICsgJ1xcbic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlQmxvY2tIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VCbG9ja0hlYWRlcihzdGFydCkge1xuICAgICAgdmFyIHNyYyA9IHRoaXMuY29udGV4dC5zcmM7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQgKyAxO1xuICAgICAgdmFyIGJpID0gJyc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIHRoaXMuY2hvbXBpbmcgPSBDaG9tcC5TVFJJUDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICB0aGlzLmNob21waW5nID0gQ2hvbXAuS0VFUDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgY2FzZSAnNic6XG4gICAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICBiaSArPSBjaDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuYmxvY2tJbmRlbnQgPSBOdW1iZXIoYmkpIHx8IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhlYWRlciA9IG5ldyBSYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VCbG9ja1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQmxvY2tWYWx1ZShzdGFydCkge1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQyID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGluZGVudCA9IF90aGlzJGNvbnRleHQyLmluZGVudCxcbiAgICAgICAgICBzcmMgPSBfdGhpcyRjb250ZXh0Mi5zcmM7XG4gICAgICB2YXIgZXhwbGljaXQgPSAhIXRoaXMuYmxvY2tJbmRlbnQ7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICB2YXIgdmFsdWVFbmQgPSBzdGFydDtcbiAgICAgIHZhciBtaW5CbG9ja0luZGVudCA9IDE7XG5cbiAgICAgIGZvciAodmFyIGNoID0gc3JjW29mZnNldF07IGNoID09PSAnXFxuJzsgY2ggPSBzcmNbb2Zmc2V0XSkge1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgaWYgKE5vZGUuYXREb2N1bWVudEJvdW5kYXJ5KHNyYywgb2Zmc2V0KSkgYnJlYWs7XG4gICAgICAgIHZhciBlbmQgPSBOb2RlLmVuZE9mQmxvY2tJbmRlbnQoc3JjLCBpbmRlbnQsIG9mZnNldCk7IC8vIHNob3VsZCBub3QgaW5jbHVkZSB0YWI/XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIHZhciBfY2gyID0gc3JjW2VuZF07XG4gICAgICAgIHZhciBsaW5lSW5kZW50ID0gZW5kIC0gKG9mZnNldCArIGluZGVudCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJsb2NrSW5kZW50KSB7XG4gICAgICAgICAgLy8gbm8gZXhwbGljaXQgYmxvY2sgaW5kZW50LCBub25lIHlldCBkZXRlY3RlZFxuICAgICAgICAgIGlmIChzcmNbZW5kXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGxpbmUgd2l0aCBub24td2hpdGVzcGFjZSBjb250ZW50XG4gICAgICAgICAgICBpZiAobGluZUluZGVudCA8IG1pbkJsb2NrSW5kZW50KSB7XG4gICAgICAgICAgICAgIHZhciBtc2cgPSAnQmxvY2sgc2NhbGFycyB3aXRoIG1vcmUtaW5kZW50ZWQgbGVhZGluZyBlbXB0eSBsaW5lcyBtdXN0IHVzZSBhbiBleHBsaWNpdCBpbmRlbnRhdGlvbiBpbmRpY2F0b3InO1xuICAgICAgICAgICAgICB0aGlzLmVycm9yID0gbmV3IFlBTUxTZW1hbnRpY0Vycm9yKHRoaXMsIG1zZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYmxvY2tJbmRlbnQgPSBsaW5lSW5kZW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAobGluZUluZGVudCA+IG1pbkJsb2NrSW5kZW50KSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBsaW5lIHdpdGggbW9yZSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBtaW5CbG9ja0luZGVudCA9IGxpbmVJbmRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9jaDIgJiYgX2NoMiAhPT0gJ1xcbicgJiYgbGluZUluZGVudCA8IHRoaXMuYmxvY2tJbmRlbnQpIHtcbiAgICAgICAgICBpZiAoc3JjW2VuZF0gPT09ICcjJykgYnJlYWs7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBfc3JjID0gZXhwbGljaXQgPyAnZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJyA6ICdmaXJzdCBsaW5lJztcblxuICAgICAgICAgICAgdmFyIF9tc2cgPSBcIkJsb2NrIHNjYWxhcnMgbXVzdCBub3QgYmUgbGVzcyBpbmRlbnRlZCB0aGFuIHRoZWlyIFwiLmNvbmNhdChfc3JjKTtcblxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBZQU1MU2VtYW50aWNFcnJvcih0aGlzLCBfbXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjW2VuZF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IHZhbHVlRW5kID0gTm9kZS5lbmRPZkxpbmUoc3JjLCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNob21waW5nICE9PSBDaG9tcC5LRUVQKSB7XG4gICAgICAgIG9mZnNldCA9IHNyY1t2YWx1ZUVuZF0gPyB2YWx1ZUVuZCArIDEgOiB2YWx1ZUVuZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0ICsgMSwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGJsb2NrIHZhbHVlIGZyb20gdGhlIHNvdXJjZVxuICAgICAqXG4gICAgICogQWNjZXB0ZWQgZm9ybXMgYXJlOlxuICAgICAqIGBgYFxuICAgICAqIEJTXG4gICAgICogYmxvY2tcbiAgICAgKiBsaW5lc1xuICAgICAqXG4gICAgICogQlMgI2NvbW1lbnRcbiAgICAgKiBibG9ja1xuICAgICAqIGxpbmVzXG4gICAgICogYGBgXG4gICAgICogd2hlcmUgdGhlIGJsb2NrIHN0eWxlIEJTIG1hdGNoZXMgdGhlIHJlZ2V4cCBgW3w+XVstKzEtOV0qYCBhbmQgYmxvY2sgbGluZXNcbiAgICAgKiBhcmUgZW1wdHkgb3IgaGF2ZSBhbiBpbmRlbnQgbGV2ZWwgZ3JlYXRlciB0aGFuIGBpbmRlbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpcyBibG9ja1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB2YXIgc3JjID0gY29udGV4dC5zcmM7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5wYXJzZUJsb2NrSGVhZGVyKHN0YXJ0KTtcbiAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCA9IHRoaXMucGFyc2VDb21tZW50KG9mZnNldCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQmxvY2tWYWx1ZShvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3JpZ1Jhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IF9nZXQoX2dldFByb3RvdHlwZU9mKEJsb2NrVmFsdWUucHJvdG90eXBlKSwgXCJzZXRPcmlnUmFuZ2VzXCIsIHRoaXMpLmNhbGwodGhpcywgY3IsIG9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkZXIgPyB0aGlzLmhlYWRlci5zZXRPcmlnUmFuZ2UoY3IsIG9mZnNldCkgOiBvZmZzZXQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJsb2NrVmFsdWU7XG59KE5vZGUpO1xuXG52YXIgRmxvd0NvbGxlY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhGbG93Q29sbGVjdGlvbiwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRmxvd0NvbGxlY3Rpb24pO1xuXG4gIGZ1bmN0aW9uIEZsb3dDb2xsZWN0aW9uKHR5cGUsIHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZsb3dDb2xsZWN0aW9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgcHJvcHMpO1xuICAgIF90aGlzLml0ZW1zID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmxvd0NvbGxlY3Rpb24sIFt7XG4gICAga2V5OiBcInByZXZOb2RlSXNKc29uTGlrZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmV2Tm9kZUlzSnNvbkxpa2UoKSB7XG4gICAgICB2YXIgaWR4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgIHZhciBub2RlID0gdGhpcy5pdGVtc1tpZHggLSAxXTtcbiAgICAgIHJldHVybiAhIW5vZGUgJiYgKG5vZGUuanNvbkxpa2UgfHwgbm9kZS50eXBlID09PSBUeXBlLkNPTU1FTlQgJiYgdGhpcy5wcmV2Tm9kZUlzSnNvbkxpa2UoaWR4IC0gMSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHZhciBwYXJzZU5vZGUgPSBjb250ZXh0LnBhcnNlTm9kZSxcbiAgICAgICAgICBzcmMgPSBjb250ZXh0LnNyYztcbiAgICAgIHZhciBpbmRlbnQgPSBjb250ZXh0LmluZGVudCxcbiAgICAgICAgICBsaW5lU3RhcnQgPSBjb250ZXh0LmxpbmVTdGFydDtcbiAgICAgIHZhciBjaGFyID0gc3JjW3N0YXJ0XTsgLy8geyBvciBbXG5cbiAgICAgIHRoaXMuaXRlbXMgPSBbe1xuICAgICAgICBjaGFyOiBjaGFyLFxuICAgICAgICBvZmZzZXQ6IHN0YXJ0XG4gICAgICB9XTtcbiAgICAgIHZhciBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIHN0YXJ0ICsgMSk7XG4gICAgICBjaGFyID0gc3JjW29mZnNldF07XG5cbiAgICAgIHdoaWxlIChjaGFyICYmIGNoYXIgIT09ICddJyAmJiBjaGFyICE9PSAnfScpIHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgdmFyIHdzRW5kID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBsaW5lU3RhcnQpO1xuXG4gICAgICAgICAgICAgIGlmIChzcmNbd3NFbmRdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIHZhciBibGFua0xpbmUgPSBuZXcgQmxhbmtMaW5lKCk7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gYmxhbmtMaW5lLnBhcnNlKHtcbiAgICAgICAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgICAgICAgICAgfSwgbGluZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goYmxhbmtMaW5lKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZJbmRlbnQoc3JjLCBsaW5lU3RhcnQpO1xuXG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gbGluZVN0YXJ0ICsgaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgY2hhciA9IHNyY1tvZmZzZXRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxpbmVTdGFydCArIGluZGVudCB8fCBjaGFyICE9PSAnXScgJiYgY2hhciAhPT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0luc3VmZmljaWVudCBpbmRlbnRhdGlvbiBpbiBmbG93IGNvbGxlY3Rpb24nO1xuICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBZQU1MU2VtYW50aWNFcnJvcih0aGlzLCBtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjaGFyOiBjaGFyLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBjb21tZW50ID0gbmV3IENvbW1lbnQoKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gY29tbWVudC5wYXJzZSh7XG4gICAgICAgICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgICAgICAgfSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIG5leHQgPSBzcmNbb2Zmc2V0ICsgMV07XG5cbiAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nIHx8IG5leHQgPT09ICdcXHQnIHx8IG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnLCcgfHwgLy8gaW4tZmxvdyA6IGFmdGVyIEpTT04tbGlrZSBrZXkgZG9lcyBub3QgbmVlZCB0byBiZSBmb2xsb3dlZCBieSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgIGNoYXIgPT09ICc6JyAmJiB0aGlzLnByZXZOb2RlSXNKc29uTGlrZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGNoYXI6IGNoYXIsXG4gICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gZmFsbHRocm91Z2hcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0gcGFyc2VOb2RlKHtcbiAgICAgICAgICAgICAgICBhdExpbmVTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5Db2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbkZsb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgaW5kZW50OiAtMSxcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgICAgICAgICAgfSwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBhdCBuZXh0IGRvY3VtZW50IHN0YXJ0XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgIG9mZnNldCA9IE5vZGUubm9ybWFsaXplT2Zmc2V0KHNyYywgbm9kZS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgICAgICBjaGFyID0gc3JjW29mZnNldF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgb2Zmc2V0ICsgMSk7XG5cbiAgICAgIGlmIChjaGFyKSB7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCh7XG4gICAgICAgICAgY2hhcjogY2hhcixcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUNvbW1lbnQob2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3JpZ1Jhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IF9nZXQoX2dldFByb3RvdHlwZU9mKEZsb3dDb2xsZWN0aW9uLnByb3RvdHlwZSksIFwic2V0T3JpZ1Jhbmdlc1wiLCB0aGlzKS5jYWxsKHRoaXMsIGNyLCBvZmZzZXQpO1xuICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIG9mZnNldCA9IG5vZGUuc2V0T3JpZ1Jhbmdlcyhjciwgb2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChjci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBub2RlLm9yaWdPZmZzZXQgPSBub2RlLm9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaSA9IG9mZnNldDtcblxuICAgICAgICAgIHdoaWxlIChpIDwgY3IubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoY3JbaV0gPiBub2RlLm9mZnNldCkgYnJlYWs7ZWxzZSArK2k7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZS5vcmlnT2Zmc2V0ID0gbm9kZS5vZmZzZXQgKyBpO1xuICAgICAgICAgIG9mZnNldCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgc3JjID0gdGhpcy5jb250ZXh0LnNyYyxcbiAgICAgICAgICBpdGVtcyA9IHRoaXMuaXRlbXMsXG4gICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlLFxuICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YXIgbm9kZXMgPSBpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBOb2RlO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICB2YXIgcHJldkVuZCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgcHJlZml4ID0gc3JjLnNsaWNlKHByZXZFbmQsIG5vZGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICBwcmV2RW5kID0gbm9kZS5yYW5nZS5lbmQ7XG4gICAgICAgIHN0ciArPSBwcmVmaXggKyBTdHJpbmcobm9kZSk7XG5cbiAgICAgICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICdcXG4nICYmIHNyY1twcmV2RW5kIC0gMV0gIT09ICdcXG4nICYmIHNyY1twcmV2RW5kXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAvLyBDb21tZW50IHJhbmdlIGRvZXMgbm90IGluY2x1ZGUgdGhlIHRlcm1pbmFsIG5ld2xpbmUsIGJ1dCBpdHNcbiAgICAgICAgICAvLyBzdHJpbmdpZmllZCB2YWx1ZSBkb2VzLiBXaXRob3V0IHRoaXMgZml4LCBuZXdsaW5lcyBhdCBjb21tZW50IGVuZHNcbiAgICAgICAgICAvLyBnZXQgZHVwbGljYXRlZC5cbiAgICAgICAgICBwcmV2RW5kICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc3RyICs9IHNyYy5zbGljZShwcmV2RW5kLCByYW5nZS5lbmQpO1xuICAgICAgcmV0dXJuIE5vZGUuYWRkU3RyaW5nVGVybWluYXRvcihzcmMsIHJhbmdlLmVuZCwgc3RyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmxvd0NvbGxlY3Rpb247XG59KE5vZGUpO1xuXG52YXIgUXVvdGVEb3VibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhRdW90ZURvdWJsZSwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUXVvdGVEb3VibGUpO1xuXG4gIGZ1bmN0aW9uIFF1b3RlRG91YmxlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdW90ZURvdWJsZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUXVvdGVEb3VibGUsIFt7XG4gICAga2V5OiBcInN0clZhbHVlXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB7IHN0cjogc3RyaW5nLCBlcnJvcnM6IFlBTUxTeW50YXhFcnJvcltdIH19XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLnZhbHVlUmFuZ2UgfHwgIXRoaXMuY29udGV4dCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgX3RoaXMkdmFsdWVSYW5nZSA9IHRoaXMudmFsdWVSYW5nZSxcbiAgICAgICAgICBzdGFydCA9IF90aGlzJHZhbHVlUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgZW5kID0gX3RoaXMkdmFsdWVSYW5nZS5lbmQ7XG4gICAgICB2YXIgX3RoaXMkY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBpbmRlbnQgPSBfdGhpcyRjb250ZXh0LmluZGVudCxcbiAgICAgICAgICBzcmMgPSBfdGhpcyRjb250ZXh0LnNyYztcbiAgICAgIGlmIChzcmNbZW5kIC0gMV0gIT09ICdcIicpIGVycm9ycy5wdXNoKG5ldyBZQU1MU3ludGF4RXJyb3IodGhpcywgJ01pc3NpbmcgY2xvc2luZyBcInF1b3RlJykpOyAvLyBVc2luZyBTdHJpbmcjcmVwbGFjZSBpcyB0b28gcGFpbmZ1bCB3aXRoIGVzY2FwZWQgbmV3bGluZXMgcHJlY2VkZWQgYnlcbiAgICAgIC8vIGVzY2FwZWQgYmFja3NsYXNoZXM7IGFsc28sIHRoaXMgc2hvdWxkIGJlIGZhc3Rlci5cblxuICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQgKyAxOyBpIDwgZW5kIC0gMTsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHNyY1tpXTtcblxuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgaWYgKE5vZGUuYXREb2N1bWVudEJvdW5kYXJ5KHNyYywgaSArIDEpKSBlcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IodGhpcywgJ0RvY3VtZW50IGJvdW5kYXJ5IGluZGljYXRvcnMgYXJlIG5vdCBhbGxvd2VkIHdpdGhpbiBzdHJpbmcgdmFsdWVzJykpO1xuXG4gICAgICAgICAgdmFyIF9Ob2RlJGZvbGROZXdsaW5lID0gTm9kZS5mb2xkTmV3bGluZShzcmMsIGksIGluZGVudCksXG4gICAgICAgICAgICAgIGZvbGQgPSBfTm9kZSRmb2xkTmV3bGluZS5mb2xkLFxuICAgICAgICAgICAgICBvZmZzZXQgPSBfTm9kZSRmb2xkTmV3bGluZS5vZmZzZXQsXG4gICAgICAgICAgICAgIGVycm9yID0gX05vZGUkZm9sZE5ld2xpbmUuZXJyb3I7XG5cbiAgICAgICAgICBzdHIgKz0gZm9sZDtcbiAgICAgICAgICBpID0gb2Zmc2V0O1xuICAgICAgICAgIGlmIChlcnJvcikgZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKHRoaXMsICdNdWx0aS1saW5lIGRvdWJsZS1xdW90ZWQgc3RyaW5nIG5lZWRzIHRvIGJlIHN1ZmZpY2llbnRseSBpbmRlbnRlZCcpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgaSArPSAxO1xuXG4gICAgICAgICAgc3dpdGNoIChzcmNbaV0pIHtcbiAgICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcMCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gbnVsbCBjaGFyYWN0ZXJcblxuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFx4MDcnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGJlbGwgY2hhcmFjdGVyXG5cbiAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcYic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gYmFja3NwYWNlXG5cbiAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xceDFiJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBlc2NhcGUgY2hhcmFjdGVyXG5cbiAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcZic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gZm9ybSBmZWVkXG5cbiAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gbGluZSBmZWVkXG5cbiAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FycmlhZ2UgcmV0dXJuXG5cbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCB0YWJcblxuICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFx2JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbCB0YWJcblxuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgIHN0ciArPSBcIlxceDg1XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gVW5pY29kZSBuZXh0IGxpbmVcblxuICAgICAgICAgICAgY2FzZSAnXyc6XG4gICAgICAgICAgICAgIHN0ciArPSBcIlxceEEwXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gVW5pY29kZSBub24tYnJlYWtpbmcgc3BhY2VcblxuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgIHN0ciArPSBcIlxcdTIwMjhcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBVbmljb2RlIGxpbmUgc2VwYXJhdG9yXG5cbiAgICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgICBzdHIgKz0gXCJcXHUyMDI5XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gVW5pY29kZSBwYXJhZ3JhcGggc2VwYXJhdG9yXG5cbiAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICBzdHIgKz0gJyAnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1wiJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICBzdHIgKz0gJy8nO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgc3RyICs9IHRoaXMucGFyc2VDaGFyQ29kZShpICsgMSwgMiwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgIHN0ciArPSB0aGlzLnBhcnNlQ2hhckNvZGUoaSArIDEsIDQsIGVycm9ycyk7XG4gICAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5wYXJzZUNoYXJDb2RlKGkgKyAxLCA4LCBlcnJvcnMpO1xuICAgICAgICAgICAgICBpICs9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgICAvLyBza2lwIGVzY2FwZWQgbmV3bGluZXMsIGJ1dCBzdGlsbCB0cmltIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICB3aGlsZSAoc3JjW2kgKyAxXSA9PT0gJyAnIHx8IHNyY1tpICsgMV0gPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBZQU1MU3ludGF4RXJyb3IodGhpcywgXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSBcIi5jb25jYXQoc3JjLnN1YnN0cihpIC0gMSwgMikpKSk7XG4gICAgICAgICAgICAgIHN0ciArPSAnXFxcXCcgKyBzcmNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgLy8gdHJpbSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgdmFyIHdzU3RhcnQgPSBpO1xuICAgICAgICAgIHZhciBuZXh0ID0gc3JjW2kgKyAxXTtcblxuICAgICAgICAgIHdoaWxlIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIG5leHQgPSBzcmNbaSArIDFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0ICE9PSAnXFxuJykgc3RyICs9IGkgPiB3c1N0YXJ0ID8gc3JjLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IGNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA+IDAgPyB7XG4gICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICBzdHI6IHN0clxuICAgICAgfSA6IHN0cjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VDaGFyQ29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUNoYXJDb2RlKG9mZnNldCwgbGVuZ3RoLCBlcnJvcnMpIHtcbiAgICAgIHZhciBzcmMgPSB0aGlzLmNvbnRleHQuc3JjO1xuICAgICAgdmFyIGNjID0gc3JjLnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgICB2YXIgb2sgPSBjYy5sZW5ndGggPT09IGxlbmd0aCAmJiAvXlswLTlhLWZBLUZdKyQvLnRlc3QoY2MpO1xuICAgICAgdmFyIGNvZGUgPSBvayA/IHBhcnNlSW50KGNjLCAxNikgOiBOYU47XG5cbiAgICAgIGlmIChpc05hTihjb2RlKSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgWUFNTFN5bnRheEVycm9yKHRoaXMsIFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgXCIuY29uY2F0KHNyYy5zdWJzdHIob2Zmc2V0IC0gMiwgbGVuZ3RoICsgMikpKSk7XG4gICAgICAgIHJldHVybiBzcmMuc3Vic3RyKG9mZnNldCAtIDIsIGxlbmd0aCArIDIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIFwiZG91YmxlIHF1b3RlZFwiIHZhbHVlIGZyb20gdGhlIHNvdXJjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhpcyBzY2FsYXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHN0YXJ0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdmFyIHNyYyA9IGNvbnRleHQuc3JjO1xuICAgICAgdmFyIG9mZnNldCA9IFF1b3RlRG91YmxlLmVuZE9mUXVvdGUoc3JjLCBzdGFydCArIDEpO1xuICAgICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUNvbW1lbnQob2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZW5kT2ZRdW90ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZlF1b3RlKHNyYywgb2Zmc2V0KSB7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXCInKSB7XG4gICAgICAgIG9mZnNldCArPSBjaCA9PT0gJ1xcXFwnID8gMiA6IDE7XG4gICAgICAgIGNoID0gc3JjW29mZnNldF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdW90ZURvdWJsZTtcbn0oTm9kZSk7XG5cbnZhciBRdW90ZVNpbmdsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKFF1b3RlU2luZ2xlLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihRdW90ZVNpbmdsZSk7XG5cbiAgZnVuY3Rpb24gUXVvdGVTaW5nbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1b3RlU2luZ2xlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhRdW90ZVNpbmdsZSwgW3tcbiAgICBrZXk6IFwic3RyVmFsdWVcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IHsgc3RyOiBzdHJpbmcsIGVycm9yczogWUFNTFN5bnRheEVycm9yW10gfX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMudmFsdWVSYW5nZSB8fCAhdGhpcy5jb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciBfdGhpcyR2YWx1ZVJhbmdlID0gdGhpcy52YWx1ZVJhbmdlLFxuICAgICAgICAgIHN0YXJ0ID0gX3RoaXMkdmFsdWVSYW5nZS5zdGFydCxcbiAgICAgICAgICBlbmQgPSBfdGhpcyR2YWx1ZVJhbmdlLmVuZDtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGluZGVudCA9IF90aGlzJGNvbnRleHQuaW5kZW50LFxuICAgICAgICAgIHNyYyA9IF90aGlzJGNvbnRleHQuc3JjO1xuICAgICAgaWYgKHNyY1tlbmQgLSAxXSAhPT0gXCInXCIpIGVycm9ycy5wdXNoKG5ldyBZQU1MU3ludGF4RXJyb3IodGhpcywgXCJNaXNzaW5nIGNsb3NpbmcgJ3F1b3RlXCIpKTtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8IGVuZCAtIDE7ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzcmNbaV07XG5cbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgIGlmIChOb2RlLmF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIGkgKyAxKSkgZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKHRoaXMsICdEb2N1bWVudCBib3VuZGFyeSBpbmRpY2F0b3JzIGFyZSBub3QgYWxsb3dlZCB3aXRoaW4gc3RyaW5nIHZhbHVlcycpKTtcblxuICAgICAgICAgIHZhciBfTm9kZSRmb2xkTmV3bGluZSA9IE5vZGUuZm9sZE5ld2xpbmUoc3JjLCBpLCBpbmRlbnQpLFxuICAgICAgICAgICAgICBmb2xkID0gX05vZGUkZm9sZE5ld2xpbmUuZm9sZCxcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gX05vZGUkZm9sZE5ld2xpbmUub2Zmc2V0LFxuICAgICAgICAgICAgICBlcnJvciA9IF9Ob2RlJGZvbGROZXdsaW5lLmVycm9yO1xuXG4gICAgICAgICAgc3RyICs9IGZvbGQ7XG4gICAgICAgICAgaSA9IG9mZnNldDtcbiAgICAgICAgICBpZiAoZXJyb3IpIGVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcih0aGlzLCAnTXVsdGktbGluZSBzaW5nbGUtcXVvdGVkIHN0cmluZyBuZWVkcyB0byBiZSBzdWZmaWNpZW50bHkgaW5kZW50ZWQnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiJ1wiKSB7XG4gICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBpZiAoc3JjW2ldICE9PSBcIidcIikgZXJyb3JzLnB1c2gobmV3IFlBTUxTeW50YXhFcnJvcih0aGlzLCAnVW5lc2NhcGVkIHNpbmdsZSBxdW90ZT8gVGhpcyBzaG91bGQgbm90IGhhcHBlbi4nKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAvLyB0cmltIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICB2YXIgd3NTdGFydCA9IGk7XG4gICAgICAgICAgdmFyIG5leHQgPSBzcmNbaSArIDFdO1xuXG4gICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0Jykge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgbmV4dCA9IHNyY1tpICsgMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHQgIT09ICdcXG4nKSBzdHIgKz0gaSA+IHdzU3RhcnQgPyBzcmMuc2xpY2Uod3NTdGFydCwgaSArIDEpIDogY2g7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgIHN0cjogc3RyXG4gICAgICB9IDogc3RyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSAnc2luZ2xlIHF1b3RlZCcgdmFsdWUgZnJvbSB0aGUgc291cmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIEluZGV4IG9mIGZpcnN0IGNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzIHNjYWxhclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB2YXIgc3JjID0gY29udGV4dC5zcmM7XG4gICAgICB2YXIgb2Zmc2V0ID0gUXVvdGVTaW5nbGUuZW5kT2ZRdW90ZShzcmMsIHN0YXJ0ICsgMSk7XG4gICAgICB0aGlzLnZhbHVlUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQ29tbWVudChvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJlbmRPZlF1b3RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE9mUXVvdGUoc3JjLCBvZmZzZXQpIHtcbiAgICAgIHZhciBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgaWYgKGNoID09PSBcIidcIikge1xuICAgICAgICAgIGlmIChzcmNbb2Zmc2V0ICsgMV0gIT09IFwiJ1wiKSBicmVhaztcbiAgICAgICAgICBjaCA9IHNyY1tvZmZzZXQgKz0gMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2ggPSBzcmNbb2Zmc2V0ICs9IDFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdW90ZVNpbmdsZTtcbn0oTm9kZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld05vZGUodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBUeXBlLkFMSUFTOlxuICAgICAgcmV0dXJuIG5ldyBBbGlhcyh0eXBlLCBwcm9wcyk7XG5cbiAgICBjYXNlIFR5cGUuQkxPQ0tfRk9MREVEOlxuICAgIGNhc2UgVHlwZS5CTE9DS19MSVRFUkFMOlxuICAgICAgcmV0dXJuIG5ldyBCbG9ja1ZhbHVlKHR5cGUsIHByb3BzKTtcblxuICAgIGNhc2UgVHlwZS5GTE9XX01BUDpcbiAgICBjYXNlIFR5cGUuRkxPV19TRVE6XG4gICAgICByZXR1cm4gbmV3IEZsb3dDb2xsZWN0aW9uKHR5cGUsIHByb3BzKTtcblxuICAgIGNhc2UgVHlwZS5NQVBfS0VZOlxuICAgIGNhc2UgVHlwZS5NQVBfVkFMVUU6XG4gICAgY2FzZSBUeXBlLlNFUV9JVEVNOlxuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uSXRlbSh0eXBlLCBwcm9wcyk7XG5cbiAgICBjYXNlIFR5cGUuQ09NTUVOVDpcbiAgICBjYXNlIFR5cGUuUExBSU46XG4gICAgICByZXR1cm4gbmV3IFBsYWluVmFsdWUodHlwZSwgcHJvcHMpO1xuXG4gICAgY2FzZSBUeXBlLlFVT1RFX0RPVUJMRTpcbiAgICAgIHJldHVybiBuZXcgUXVvdGVEb3VibGUodHlwZSwgcHJvcHMpO1xuXG4gICAgY2FzZSBUeXBlLlFVT1RFX1NJTkdMRTpcbiAgICAgIHJldHVybiBuZXcgUXVvdGVTaW5nbGUodHlwZSwgcHJvcHMpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBhdExpbmVTdGFydCAtIE5vZGUgc3RhcnRzIGF0IGJlZ2lubmluZyBvZiBsaW5lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluRmxvdyAtIHRydWUgaWYgY3VycmVudGx5IGluIGEgZmxvdyBjb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluQ29sbGVjdGlvbiAtIHRydWUgaWYgY3VycmVudGx5IGluIGEgY29sbGVjdGlvbiBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZW50IC0gQ3VycmVudCBsZXZlbCBvZiBpbmRlbnRhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGxpbmVTdGFydCAtIFN0YXJ0IG9mIHRoZSBjdXJyZW50IGxpbmVcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50IC0gVGhlIHBhcmVudCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyAtIFNvdXJjZSBvZiB0aGUgWUFNTCBkb2N1bWVudFxuICovXG5cblxudmFyIFBhcnNlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhcnNlQ29udGV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9yaWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBhdExpbmVTdGFydCA9IF9yZWYuYXRMaW5lU3RhcnQsXG4gICAgICAgIGluQ29sbGVjdGlvbiA9IF9yZWYuaW5Db2xsZWN0aW9uLFxuICAgICAgICBpbkZsb3cgPSBfcmVmLmluRmxvdyxcbiAgICAgICAgaW5kZW50ID0gX3JlZi5pbmRlbnQsXG4gICAgICAgIGxpbmVTdGFydCA9IF9yZWYubGluZVN0YXJ0LFxuICAgICAgICBwYXJlbnQgPSBfcmVmLnBhcmVudDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJzZUNvbnRleHQpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyc2VOb2RlXCIsIGZ1bmN0aW9uIChvdmVybGF5LCBzdGFydCkge1xuICAgICAgaWYgKE5vZGUuYXREb2N1bWVudEJvdW5kYXJ5KF90aGlzLnNyYywgc3RhcnQpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dChfdGhpcywgb3ZlcmxheSk7XG5cbiAgICAgIHZhciBfY29udGV4dCRwYXJzZVByb3BzID0gY29udGV4dC5wYXJzZVByb3BzKHN0YXJ0KSxcbiAgICAgICAgICBwcm9wcyA9IF9jb250ZXh0JHBhcnNlUHJvcHMucHJvcHMsXG4gICAgICAgICAgdHlwZSA9IF9jb250ZXh0JHBhcnNlUHJvcHMudHlwZSxcbiAgICAgICAgICB2YWx1ZVN0YXJ0ID0gX2NvbnRleHQkcGFyc2VQcm9wcy52YWx1ZVN0YXJ0O1xuXG4gICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5ld05vZGUodHlwZSwgcHJvcHMpO1xuICAgICAgdmFyIG9mZnNldCA9IG5vZGUucGFyc2UoY29udGV4dCwgdmFsdWVTdGFydCk7XG4gICAgICBub2RlLnJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgICAgIGlmIChvZmZzZXQgPD0gc3RhcnQpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgaWYgaXQgZG9lcywgbGV0J3MgbWFrZSBzdXJlIHRvIGF0IGxlYXN0XG4gICAgICAgIC8vIHN0ZXAgb25lIGNoYXJhY3RlciBmb3J3YXJkIHRvIGF2b2lkIGEgYnVzeSBsb29wLlxuICAgICAgICBub2RlLmVycm9yID0gbmV3IEVycm9yKFwiTm9kZSNwYXJzZSBjb25zdW1lZCBubyBjaGFyYWN0ZXJzXCIpO1xuICAgICAgICBub2RlLmVycm9yLnBhcnNlRW5kID0gb2Zmc2V0O1xuICAgICAgICBub2RlLmVycm9yLnNvdXJjZSA9IG5vZGU7XG4gICAgICAgIG5vZGUucmFuZ2UuZW5kID0gc3RhcnQgKyAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dC5ub2RlU3RhcnRzQ29sbGVjdGlvbihub2RlKSkge1xuICAgICAgICBpZiAoIW5vZGUuZXJyb3IgJiYgIWNvbnRleHQuYXRMaW5lU3RhcnQgJiYgY29udGV4dC5wYXJlbnQudHlwZSA9PT0gVHlwZS5ET0NVTUVOVCkge1xuICAgICAgICAgIG5vZGUuZXJyb3IgPSBuZXcgWUFNTFN5bnRheEVycm9yKG5vZGUsICdCbG9jayBjb2xsZWN0aW9uIG11c3Qgbm90IGhhdmUgcHJlY2VkaW5nIGNvbnRlbnQgaGVyZSAoZS5nLiBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IpJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKG5vZGUpO1xuICAgICAgICBvZmZzZXQgPSBjb2xsZWN0aW9uLnBhcnNlKG5ldyBQYXJzZUNvbnRleHQoY29udGV4dCksIG9mZnNldCk7XG4gICAgICAgIGNvbGxlY3Rpb24ucmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcblxuICAgIHRoaXMuYXRMaW5lU3RhcnQgPSBhdExpbmVTdGFydCAhPSBudWxsID8gYXRMaW5lU3RhcnQgOiBvcmlnLmF0TGluZVN0YXJ0IHx8IGZhbHNlO1xuICAgIHRoaXMuaW5Db2xsZWN0aW9uID0gaW5Db2xsZWN0aW9uICE9IG51bGwgPyBpbkNvbGxlY3Rpb24gOiBvcmlnLmluQ29sbGVjdGlvbiB8fCBmYWxzZTtcbiAgICB0aGlzLmluRmxvdyA9IGluRmxvdyAhPSBudWxsID8gaW5GbG93IDogb3JpZy5pbkZsb3cgfHwgZmFsc2U7XG4gICAgdGhpcy5pbmRlbnQgPSBpbmRlbnQgIT0gbnVsbCA/IGluZGVudCA6IG9yaWcuaW5kZW50O1xuICAgIHRoaXMubGluZVN0YXJ0ID0gbGluZVN0YXJ0ICE9IG51bGwgPyBsaW5lU3RhcnQgOiBvcmlnLmxpbmVTdGFydDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudCAhPSBudWxsID8gcGFyZW50IDogb3JpZy5wYXJlbnQgfHwge307XG4gICAgdGhpcy5yb290ID0gb3JpZy5yb290O1xuICAgIHRoaXMuc3JjID0gb3JpZy5zcmM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGFyc2VDb250ZXh0LCBbe1xuICAgIGtleTogXCJub2RlU3RhcnRzQ29sbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2RlU3RhcnRzQ29sbGVjdGlvbihub2RlKSB7XG4gICAgICB2YXIgaW5Db2xsZWN0aW9uID0gdGhpcy5pbkNvbGxlY3Rpb24sXG4gICAgICAgICAgaW5GbG93ID0gdGhpcy5pbkZsb3csXG4gICAgICAgICAgc3JjID0gdGhpcy5zcmM7XG4gICAgICBpZiAoaW5Db2xsZWN0aW9uIHx8IGluRmxvdykgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uSXRlbSkgcmV0dXJuIHRydWU7IC8vIGNoZWNrIGZvciBpbXBsaWNpdCBrZXlcblxuICAgICAgdmFyIG9mZnNldCA9IG5vZGUucmFuZ2UuZW5kO1xuICAgICAgaWYgKHNyY1tvZmZzZXRdID09PSAnXFxuJyB8fCBzcmNbb2Zmc2V0IC0gMV0gPT09ICdcXG4nKSByZXR1cm4gZmFsc2U7XG4gICAgICBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gICAgICByZXR1cm4gc3JjW29mZnNldF0gPT09ICc6JztcbiAgICB9IC8vIEFuY2hvciBhbmQgdGFnIGFyZSBiZWZvcmUgdHlwZSwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbm9kZSBpbXBsZW1lbnRhdGlvblxuICAgIC8vIGNsYXNzOyBoZW5jZSB0aGlzIGludGVybWVkaWF0ZSBzdGVwLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVByb3BzKG9mZnNldCkge1xuICAgICAgdmFyIGluRmxvdyA9IHRoaXMuaW5GbG93LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgICAgIHNyYyA9IHRoaXMuc3JjO1xuICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICB2YXIgbGluZUhhc1Byb3BzID0gZmFsc2U7XG4gICAgICBvZmZzZXQgPSB0aGlzLmF0TGluZVN0YXJ0ID8gTm9kZS5lbmRPZkluZGVudChzcmMsIG9mZnNldCkgOiBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gICAgICB2YXIgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgICAgd2hpbGUgKGNoID09PSBDaGFyLkFOQ0hPUiB8fCBjaCA9PT0gQ2hhci5DT01NRU5UIHx8IGNoID09PSBDaGFyLlRBRyB8fCBjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgIHZhciBpbkVuZCA9IG9mZnNldDtcbiAgICAgICAgICB2YXIgbGluZVN0YXJ0ID0gdm9pZCAwO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5FbmQgKyAxO1xuICAgICAgICAgICAgaW5FbmQgPSBOb2RlLmVuZE9mSW5kZW50KHNyYywgbGluZVN0YXJ0KTtcbiAgICAgICAgICB9IHdoaWxlIChzcmNbaW5FbmRdID09PSAnXFxuJyk7XG5cbiAgICAgICAgICB2YXIgaW5kZW50RGlmZiA9IGluRW5kIC0gKGxpbmVTdGFydCArIHRoaXMuaW5kZW50KTtcbiAgICAgICAgICB2YXIgbm9JbmRpY2F0b3JBc0luZGVudCA9IHBhcmVudC50eXBlID09PSBUeXBlLlNFUV9JVEVNICYmIHBhcmVudC5jb250ZXh0LmF0TGluZVN0YXJ0O1xuICAgICAgICAgIGlmIChzcmNbaW5FbmRdICE9PSAnIycgJiYgIU5vZGUubmV4dE5vZGVJc0luZGVudGVkKHNyY1tpbkVuZF0sIGluZGVudERpZmYsICFub0luZGljYXRvckFzSW5kZW50KSkgYnJlYWs7XG4gICAgICAgICAgdGhpcy5hdExpbmVTdGFydCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgbGluZUhhc1Byb3BzID0gZmFsc2U7XG4gICAgICAgICAgb2Zmc2V0ID0gaW5FbmQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IENoYXIuQ09NTUVOVCkge1xuICAgICAgICAgIHZhciBlbmQgPSBOb2RlLmVuZE9mTGluZShzcmMsIG9mZnNldCArIDEpO1xuICAgICAgICAgIHByb3BzLnB1c2gobmV3IFJhbmdlKG9mZnNldCwgZW5kKSk7XG4gICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfZW5kID0gTm9kZS5lbmRPZklkZW50aWZpZXIoc3JjLCBvZmZzZXQgKyAxKTtcblxuICAgICAgICAgIGlmIChjaCA9PT0gQ2hhci5UQUcgJiYgc3JjW19lbmRdID09PSAnLCcgJiYgL15bYS16QS1aMC05LV0rXFwuW2EtekEtWjAtOS1dKyxcXGRcXGRcXGRcXGQoLVxcZFxcZCl7MCwyfVxcL1xcUy8udGVzdChzcmMuc2xpY2Uob2Zmc2V0ICsgMSwgX2VuZCArIDEzKSkpIHtcbiAgICAgICAgICAgIC8vIExldCdzIHByZXN1bWUgd2UncmUgZGVhbGluZyB3aXRoIGEgWUFNTCAxLjAgZG9tYWluIHRhZyBoZXJlLCByYXRoZXJcbiAgICAgICAgICAgIC8vIHRoYW4gYW4gZW1wdHkgYnV0ICdmb28uYmFyJyBwcml2YXRlLXRhZ2dlZCBub2RlIGluIGEgZmxvdyBjb2xsZWN0aW9uXG4gICAgICAgICAgICAvLyBmb2xsb3dlZCB3aXRob3V0IHdoaXRlc3BhY2UgYnkgYSBwbGFpbiBzdHJpbmcgc3RhcnRpbmcgd2l0aCBhIHllYXJcbiAgICAgICAgICAgIC8vIG9yIGRhdGUgZGl2aWRlZCBieSBzb21ldGhpbmcuXG4gICAgICAgICAgICBfZW5kID0gTm9kZS5lbmRPZklkZW50aWZpZXIoc3JjLCBfZW5kICsgNSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJvcHMucHVzaChuZXcgUmFuZ2Uob2Zmc2V0LCBfZW5kKSk7XG4gICAgICAgICAgbGluZUhhc1Byb3BzID0gdHJ1ZTtcbiAgICAgICAgICBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIF9lbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICAgIH0gLy8gJy0gJmEgOiBiJyBoYXMgYW4gYW5jaG9yIG9uIGFuIGVtcHR5IG5vZGVcblxuXG4gICAgICBpZiAobGluZUhhc1Byb3BzICYmIGNoID09PSAnOicgJiYgTm9kZS5hdEJsYW5rKHNyYywgb2Zmc2V0ICsgMSwgdHJ1ZSkpIG9mZnNldCAtPSAxO1xuICAgICAgdmFyIHR5cGUgPSBQYXJzZUNvbnRleHQucGFyc2VUeXBlKHNyYywgb2Zmc2V0LCBpbkZsb3cpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB2YWx1ZVN0YXJ0OiBvZmZzZXRcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIG5vZGUgZnJvbSB0aGUgc291cmNlXG4gICAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIgZm9yIHRoZSBub2RlXG4gICAgICogQHJldHVybnMgez9Ob2RlfSAtIG51bGwgaWYgYXQgYSBkb2N1bWVudCBib3VuZGFyeVxuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VUeXBlKHNyYywgb2Zmc2V0LCBpbkZsb3cpIHtcbiAgICAgIHN3aXRjaCAoc3JjW29mZnNldF0pIHtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgcmV0dXJuIFR5cGUuQUxJQVM7XG5cbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgcmV0dXJuIFR5cGUuQkxPQ0tfRk9MREVEO1xuXG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgIHJldHVybiBUeXBlLkJMT0NLX0xJVEVSQUw7XG5cbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgcmV0dXJuIFR5cGUuRkxPV19NQVA7XG5cbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgcmV0dXJuIFR5cGUuRkxPV19TRVE7XG5cbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgcmV0dXJuICFpbkZsb3cgJiYgTm9kZS5hdEJsYW5rKHNyYywgb2Zmc2V0ICsgMSwgdHJ1ZSkgPyBUeXBlLk1BUF9LRVkgOiBUeXBlLlBMQUlOO1xuXG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgIHJldHVybiAhaW5GbG93ICYmIE5vZGUuYXRCbGFuayhzcmMsIG9mZnNldCArIDEsIHRydWUpID8gVHlwZS5NQVBfVkFMVUUgOiBUeXBlLlBMQUlOO1xuXG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiAhaW5GbG93ICYmIE5vZGUuYXRCbGFuayhzcmMsIG9mZnNldCArIDEsIHRydWUpID8gVHlwZS5TRVFfSVRFTSA6IFR5cGUuUExBSU47XG5cbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgIHJldHVybiBUeXBlLlFVT1RFX0RPVUJMRTtcblxuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgIHJldHVybiBUeXBlLlFVT1RFX1NJTkdMRTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBUeXBlLlBMQUlOO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXJzZUNvbnRleHQ7XG59KCk7XG5cbi8vIFB1Ymxpc2hlZCBhcyAneWFtbC9wYXJzZS1jc3QnXG5mdW5jdGlvbiBwYXJzZShzcmMpIHtcbiAgdmFyIGNyID0gW107XG5cbiAgaWYgKHNyYy5pbmRleE9mKCdcXHInKSAhPT0gLTEpIHtcbiAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFxyXFxuPy9nLCBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCkge1xuICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEpIGNyLnB1c2gob2Zmc2V0KTtcbiAgICAgIHJldHVybiAnXFxuJztcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBkb2N1bWVudHMgPSBbXTtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgZG8ge1xuICAgIHZhciBkb2MgPSBuZXcgRG9jdW1lbnQoKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQoe1xuICAgICAgc3JjOiBzcmNcbiAgICB9KTtcbiAgICBvZmZzZXQgPSBkb2MucGFyc2UoY29udGV4dCwgb2Zmc2V0KTtcbiAgICBkb2N1bWVudHMucHVzaChkb2MpO1xuICB9IHdoaWxlIChvZmZzZXQgPCBzcmMubGVuZ3RoKTtcblxuICBkb2N1bWVudHMuc2V0T3JpZ1JhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3IubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNyLmxlbmd0aDsgKytpKSB7XG4gICAgICBjcltpXSAtPSBpO1xuICAgIH1cblxuICAgIHZhciBjck9mZnNldCA9IDA7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZG9jdW1lbnRzLmxlbmd0aDsgKytfaSkge1xuICAgICAgY3JPZmZzZXQgPSBkb2N1bWVudHNbX2ldLnNldE9yaWdSYW5nZXMoY3IsIGNyT2Zmc2V0KTtcbiAgICB9XG5cbiAgICBjci5zcGxpY2UoMCwgY3IubGVuZ3RoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBkb2N1bWVudHMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50cy5qb2luKCcuLi5cXG4nKTtcbiAgfTtcblxuICByZXR1cm4gZG9jdW1lbnRzO1xufVxuXG5leHBvcnQgeyBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/parse-cst.js\n")},"./node_modules/yaml/browser/dist/resolveSeq-492ab440.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"A\": () => (/* binding */ Alias),\n/* harmony export */   \"C\": () => (/* binding */ Collection),\n/* harmony export */   \"M\": () => (/* binding */ Merge),\n/* harmony export */   \"N\": () => (/* binding */ Node),\n/* harmony export */   \"P\": () => (/* binding */ Pair),\n/* harmony export */   \"S\": () => (/* binding */ Scalar),\n/* harmony export */   \"Y\": () => (/* binding */ YAMLSeq),\n/* harmony export */   \"a\": () => (/* binding */ boolOptions),\n/* harmony export */   \"b\": () => (/* binding */ binaryOptions),\n/* harmony export */   \"c\": () => (/* binding */ stringifyString),\n/* harmony export */   \"d\": () => (/* binding */ YAMLMap),\n/* harmony export */   \"e\": () => (/* binding */ isEmptyPath),\n/* harmony export */   \"f\": () => (/* binding */ addComment),\n/* harmony export */   \"g\": () => (/* binding */ resolveMap),\n/* harmony export */   \"h\": () => (/* binding */ resolveSeq),\n/* harmony export */   \"i\": () => (/* binding */ intOptions),\n/* harmony export */   \"j\": () => (/* binding */ resolveString),\n/* harmony export */   \"k\": () => (/* binding */ stringifyNumber),\n/* harmony export */   \"l\": () => (/* binding */ findPair),\n/* harmony export */   \"n\": () => (/* binding */ nullOptions),\n/* harmony export */   \"r\": () => (/* binding */ resolveNode),\n/* harmony export */   \"s\": () => (/* binding */ strOptions),\n/* harmony export */   \"t\": () => (/* binding */ toJSON)\n/* harmony export */ });\n/* harmony import */ var _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlainValue-b8036b75.js */ \"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\");\n\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  var cc = comment.replace(/[\\s\\S]^/gm, \"$&\".concat(indent, \"#\"));\n  return \"#\".concat(cc, \"\\n\").concat(indent).concat(str);\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? \"\".concat(str, \" #\").concat(comment) : \"\".concat(str, \"\\n\") + comment.replace(/^/gm, \"\".concat(indent || '', \"#\"));\n}\n\nvar Node = function Node() {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Node);\n};\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map(function (v, i) {\n    return toJSON(v, String(i), ctx);\n  });\n\n  if (value && typeof value.toJSON === 'function') {\n    var anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = function (res) {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    var res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nvar Scalar = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Scalar, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Scalar);\n\n  function Scalar(value) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Scalar);\n\n    _this = _super.call(this);\n    _this.value = value;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Scalar, [{\n    key: \"toJSON\",\n    value: function toJSON$1(arg, ctx) {\n      return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return String(this.value);\n    }\n  }]);\n\n  return Scalar;\n}(Node);\n\nfunction collectionFromPath(schema, path, value) {\n  var v = value;\n\n  for (var i = path.length - 1; i >= 0; --i) {\n    var k = path[i];\n\n    if (Number.isInteger(k) && k >= 0) {\n      var a = [];\n      a[k] = v;\n      v = a;\n    } else {\n      var o = {};\n      Object.defineProperty(o, k, {\n        value: v,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n      v = o;\n    }\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nvar isEmptyPath = function isEmptyPath(path) {\n  return path == null || (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(path) === 'object' && path[Symbol.iterator]().next().done;\n};\nvar Collection = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Collection, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Collection);\n\n  function Collection(schema) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Collection);\n\n    _this = _super.call(this);\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"items\", []);\n\n    _this.schema = schema;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Collection, [{\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      if (isEmptyPath(path)) this.add(value);else {\n        var _path = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.q)(path),\n            key = _path[0],\n            rest = _path.slice(1);\n\n        var node = this.get(key, true);\n        if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n      }\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(_ref) {\n      var _ref2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.q)(_ref),\n          key = _ref2[0],\n          rest = _ref2.slice(1);\n\n      if (rest.length === 0) return this.delete(key);\n      var node = this.get(key, true);\n      if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(_ref3, keepScalar) {\n      var _ref4 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.q)(_ref3),\n          key = _ref4[0],\n          rest = _ref4.slice(1);\n\n      var node = this.get(key, true);\n      if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n    }\n  }, {\n    key: \"hasAllNullValues\",\n    value: function hasAllNullValues() {\n      return this.items.every(function (node) {\n        if (!node || node.type !== 'PAIR') return false;\n        var n = node.value;\n        return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n      });\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(_ref5) {\n      var _ref6 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.q)(_ref5),\n          key = _ref6[0],\n          rest = _ref6.slice(1);\n\n      if (rest.length === 0) return this.has(key);\n      var node = this.get(key, true);\n      return node instanceof Collection ? node.hasIn(rest) : false;\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(_ref7, value) {\n      var _ref8 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.q)(_ref7),\n          key = _ref8[0],\n          rest = _ref8.slice(1);\n\n      if (rest.length === 0) {\n        this.set(key, value);\n      } else {\n        var node = this.get(key, true);\n        if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n      }\n    } // overridden in implementations\n\n    /* istanbul ignore next */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return null;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, _ref9, onComment, onChompKeep) {\n      var _this2 = this;\n\n      var blockItem = _ref9.blockItem,\n          flowChars = _ref9.flowChars,\n          isMap = _ref9.isMap,\n          itemIndent = _ref9.itemIndent;\n      var _ctx = ctx,\n          indent = _ctx.indent,\n          indentStep = _ctx.indentStep,\n          stringify = _ctx.stringify;\n      var inFlow = this.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP || this.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ || ctx.inFlow;\n      if (inFlow) itemIndent += indentStep;\n      var allNullValues = isMap && this.hasAllNullValues();\n      ctx = Object.assign({}, ctx, {\n        allNullValues: allNullValues,\n        indent: itemIndent,\n        inFlow: inFlow,\n        type: null\n      });\n      var chompKeep = false;\n      var hasItemWithNewLine = false;\n      var nodes = this.items.reduce(function (nodes, item, i) {\n        var comment;\n\n        if (item) {\n          if (!chompKeep && item.spaceBefore) nodes.push({\n            type: 'comment',\n            str: ''\n          });\n          if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(function (line) {\n            nodes.push({\n              type: 'comment',\n              str: \"#\".concat(line)\n            });\n          });\n          if (item.comment) comment = item.comment;\n          if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n        }\n\n        chompKeep = false;\n        var str = stringify(item, ctx, function () {\n          return comment = null;\n        }, function () {\n          return chompKeep = true;\n        });\n        if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n        if (inFlow && i < _this2.items.length - 1) str += ',';\n        str = addComment(str, itemIndent, comment);\n        if (chompKeep && (comment || inFlow)) chompKeep = false;\n        nodes.push({\n          type: 'item',\n          str: str\n        });\n        return nodes;\n      }, []);\n      var str;\n\n      if (nodes.length === 0) {\n        str = flowChars.start + flowChars.end;\n      } else if (inFlow) {\n        var start = flowChars.start,\n            end = flowChars.end;\n        var strings = nodes.map(function (n) {\n          return n.str;\n        });\n\n        if (hasItemWithNewLine || strings.reduce(function (sum, str) {\n          return sum + str.length + 2;\n        }, 2) > Collection.maxFlowStringSingleLineLength) {\n          str = start;\n\n          var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(strings),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var s = _step.value;\n              str += s ? \"\\n\".concat(indentStep).concat(indent).concat(s) : '\\n';\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          str += \"\\n\".concat(indent).concat(end);\n        } else {\n          str = \"\".concat(start, \" \").concat(strings.join(' '), \" \").concat(end);\n        }\n      } else {\n        var _strings = nodes.map(blockItem);\n\n        str = _strings.shift();\n\n        var _iterator2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(_strings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _s = _step2.value;\n            str += _s ? \"\\n\".concat(indent).concat(_s) : '\\n';\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      if (this.comment) {\n        str += '\\n' + this.comment.replace(/^/gm, \"\".concat(indent, \"#\"));\n        if (onComment) onComment();\n      } else if (chompKeep && onChompKeep) onChompKeep();\n\n      return str;\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  var idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nvar YAMLSeq = /*#__PURE__*/function (_Collection) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(YAMLSeq, _Collection);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(YAMLSeq);\n\n  function YAMLSeq() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, YAMLSeq);\n\n    return _super.apply(this, arguments);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(YAMLSeq, [{\n    key: \"add\",\n    value: function add(value) {\n      this.items.push(value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') return false;\n      var del = this.items.splice(idx, 1);\n      return del.length > 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') return undefined;\n      var it = this.items[idx];\n      return !keepScalar && it instanceof Scalar ? it.value : it;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var idx = asItemIndex(key);\n      return typeof idx === 'number' && idx < this.items.length;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') throw new Error(\"Expected a valid index, not \".concat(key, \".\"));\n      this.items[idx] = value;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(_, ctx) {\n      var seq = [];\n      if (ctx && ctx.onCreate) ctx.onCreate(seq);\n      var i = 0;\n\n      var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          seq.push(toJSON(item, String(i++), ctx));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return seq;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n      return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(YAMLSeq.prototype), \"toString\", this).call(this, ctx, {\n        blockItem: function blockItem(n) {\n          return n.type === 'comment' ? n.str : \"- \".concat(n.str);\n        },\n        flowChars: {\n          start: '[',\n          end: ']'\n        },\n        isMap: false,\n        itemIndent: (ctx.indent || '') + '  '\n      }, onComment, onChompKeep);\n    }\n  }]);\n\n  return YAMLSeq;\n}(Collection);\n\nvar stringifyKey = function stringifyKey(key, jsKey, ctx) {\n  if (jsKey === null) return '';\n  if ((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(jsKey) !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: Object.create(null),\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nvar Pair = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Pair, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Pair);\n\n  function Pair(key) {\n    var _this;\n\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Pair);\n\n    _this = _super.call(this);\n    _this.key = key;\n    _this.value = value;\n    _this.type = Pair.Type.PAIR;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Pair, [{\n    key: \"commentBefore\",\n    get: function get() {\n      return this.key instanceof Node ? this.key.commentBefore : undefined;\n    },\n    set: function set(cb) {\n      if (this.key == null) this.key = new Scalar(null);\n      if (this.key instanceof Node) this.key.commentBefore = cb;else {\n        var msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n        throw new Error(msg);\n      }\n    }\n  }, {\n    key: \"addToJSMap\",\n    value: function addToJSMap(ctx, map) {\n      var key = toJSON(this.key, '', ctx);\n\n      if (map instanceof Map) {\n        var value = toJSON(this.value, key, ctx);\n        map.set(key, value);\n      } else if (map instanceof Set) {\n        map.add(key);\n      } else {\n        var stringKey = stringifyKey(this.key, key, ctx);\n\n        var _value = toJSON(this.value, stringKey, ctx);\n\n        if (stringKey in map) Object.defineProperty(map, stringKey, {\n          value: _value,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });else map[stringKey] = _value;\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx) {\n      var pair = ctx && ctx.mapAsMap ? new Map() : {};\n      return this.addToJSMap(ctx, pair);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx || !ctx.doc) return JSON.stringify(this);\n      var _ctx$doc$options = ctx.doc.options,\n          indentSize = _ctx$doc$options.indent,\n          indentSeq = _ctx$doc$options.indentSeq,\n          simpleKeys = _ctx$doc$options.simpleKeys;\n      var key = this.key,\n          value = this.value;\n      var keyComment = key instanceof Node && key.comment;\n\n      if (simpleKeys) {\n        if (keyComment) {\n          throw new Error('With simple keys, key nodes cannot have comments');\n        }\n\n        if (key instanceof Collection) {\n          var msg = 'With simple keys, collection cannot be used as a key value';\n          throw new Error(msg);\n        }\n      }\n\n      var explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED || key.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL : (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(key) === 'object'));\n      var _ctx = ctx,\n          doc = _ctx.doc,\n          indent = _ctx.indent,\n          indentStep = _ctx.indentStep,\n          stringify = _ctx.stringify;\n      ctx = Object.assign({}, ctx, {\n        implicitKey: !explicitKey,\n        indent: indent + indentStep\n      });\n      var chompKeep = false;\n      var str = stringify(key, ctx, function () {\n        return keyComment = null;\n      }, function () {\n        return chompKeep = true;\n      });\n      str = addComment(str, ctx.indent, keyComment);\n\n      if (!explicitKey && str.length > 1024) {\n        if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n      }\n\n      if (ctx.allNullValues && !simpleKeys) {\n        if (this.comment) {\n          str = addComment(str, ctx.indent, this.comment);\n          if (onComment) onComment();\n        } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n        return ctx.inFlow && !explicitKey ? str : \"? \".concat(str);\n      }\n\n      str = explicitKey ? \"? \".concat(str, \"\\n\").concat(indent, \":\") : \"\".concat(str, \":\");\n\n      if (this.comment) {\n        // expected (but not strictly required) to be a single-line comment\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      }\n\n      var vcb = '';\n      var valueComment = null;\n\n      if (value instanceof Node) {\n        if (value.spaceBefore) vcb = '\\n';\n\n        if (value.commentBefore) {\n          var cs = value.commentBefore.replace(/^/gm, \"\".concat(ctx.indent, \"#\"));\n          vcb += \"\\n\".concat(cs);\n        }\n\n        valueComment = value.comment;\n      } else if (value && (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === 'object') {\n        value = doc.schema.createNode(value, true);\n      }\n\n      ctx.implicitKey = false;\n      if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n      chompKeep = false;\n\n      if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substr(2);\n      }\n\n      var valueStr = stringify(value, ctx, function () {\n        return valueComment = null;\n      }, function () {\n        return chompKeep = true;\n      });\n      var ws = ' ';\n\n      if (vcb || this.comment) {\n        ws = \"\".concat(vcb, \"\\n\").concat(ctx.indent);\n      } else if (!explicitKey && value instanceof Collection) {\n        var flow = valueStr[0] === '[' || valueStr[0] === '{';\n        if (!flow || valueStr.includes('\\n')) ws = \"\\n\".concat(ctx.indent);\n      } else if (valueStr[0] === '\\n') ws = '';\n\n      if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n      return addComment(str + ws + valueStr, ctx.indent, valueComment);\n    }\n  }]);\n\n  return Pair;\n}(Node);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nvar getAliasCount = function getAliasCount(node, anchors) {\n  if (node instanceof Alias) {\n    var anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    var count = 0;\n\n    var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(node.items),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        var c = getAliasCount(item, anchors);\n        if (c > count) count = c;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    var kc = getAliasCount(node.key, anchors);\n    var vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Alias, _Node);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Alias);\n\n  function Alias(source) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Alias);\n\n    _this = _super.call(this);\n    _this.source = source;\n    _this.type = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.ALIAS;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Alias, [{\n    key: \"tag\",\n    set: function set(t) {\n      throw new Error('Alias nodes cannot have tags');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, ctx) {\n      if (!ctx) return toJSON(this.source, arg, ctx);\n      var anchors = ctx.anchors,\n          maxAliasCount = ctx.maxAliasCount;\n      var anchor = anchors.get(this.source);\n      /* istanbul ignore if */\n\n      if (!anchor || anchor.res === undefined) {\n        var msg = 'This should not happen: Alias anchor was not resolved?';\n        if (this.cstNode) throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.o(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n\n      if (maxAliasCount >= 0) {\n        anchor.count += 1;\n        if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n        if (anchor.count * anchor.aliasCount > maxAliasCount) {\n          var _msg = 'Excessive alias count indicates a resource exhaustion attack';\n          if (this.cstNode) throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.o(this.cstNode, _msg);else throw new ReferenceError(_msg);\n        }\n      }\n\n      return anchor.res;\n    } // Only called when stringifying an alias mapping key while constructing\n    // Object output.\n\n  }, {\n    key: \"toString\",\n    value: function toString(ctx) {\n      return Alias.stringify(this, ctx);\n    }\n  }], [{\n    key: \"stringify\",\n    value: function stringify(_ref, _ref2) {\n      var range = _ref.range,\n          source = _ref.source;\n      var anchors = _ref2.anchors,\n          doc = _ref2.doc,\n          implicitKey = _ref2.implicitKey,\n          inStringifyKey = _ref2.inStringifyKey;\n      var anchor = Object.keys(anchors).find(function (a) {\n        return anchors[a] === source;\n      });\n      if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n      if (anchor) return \"*\".concat(anchor).concat(implicitKey ? ' ' : '');\n      var msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n      throw new Error(\"\".concat(msg, \" [\").concat(range, \"]\"));\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  var k = key instanceof Scalar ? key.value : key;\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(items),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var it = _step.value;\n\n      if (it instanceof Pair) {\n        if (it.key === key || it.key === k) return it;\n        if (it.key && it.key.value === k) return it;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return undefined;\n}\nvar YAMLMap = /*#__PURE__*/function (_Collection) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(YAMLMap, _Collection);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(YAMLMap);\n\n  function YAMLMap() {\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, YAMLMap);\n\n    return _super.apply(this, arguments);\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(YAMLMap, [{\n    key: \"add\",\n    value: function add(pair, overwrite) {\n      if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n      var prev = findPair(this.items, pair.key);\n      var sortEntries = this.schema && this.schema.sortMapEntries;\n\n      if (prev) {\n        if (overwrite) prev.value = pair.value;else throw new Error(\"Key \".concat(pair.key, \" already set\"));\n      } else if (sortEntries) {\n        var i = this.items.findIndex(function (item) {\n          return sortEntries(pair, item) < 0;\n        });\n        if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n      } else {\n        this.items.push(pair);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var it = findPair(this.items, key);\n      if (!it) return false;\n      var del = this.items.splice(this.items.indexOf(it), 1);\n      return del.length > 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      var it = findPair(this.items, key);\n      var node = it && it.value;\n      return !keepScalar && node instanceof Scalar ? node.value : node;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return !!findPair(this.items, key);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      this.add(new Pair(key, value), true);\n    }\n    /**\n     * @param {*} arg ignored\n     * @param {*} ctx Conversion context, originally set in Document#toJSON()\n     * @param {Class} Type If set, forces the returned collection type\n     * @returns {*} Instance of Type, Map, or Object\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx, Type) {\n      var map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n      if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n      var _iterator2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.items),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          item.addToJSMap(ctx, map);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n\n      var _iterator3 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.items),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          if (!(item instanceof Pair)) throw new Error(\"Map items must all be pairs; found \".concat(JSON.stringify(item), \" instead\"));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(YAMLMap.prototype), \"toString\", this).call(this, ctx, {\n        blockItem: function blockItem(n) {\n          return n.str;\n        },\n        flowChars: {\n          start: '{',\n          end: '}'\n        },\n        isMap: true,\n        itemIndent: ctx.indent || ''\n      }, onComment, onChompKeep);\n    }\n  }]);\n\n  return YAMLMap;\n}(Collection);\n\nvar MERGE_KEY = '<<';\nvar Merge = /*#__PURE__*/function (_Pair) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(Merge, _Pair);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(Merge);\n\n  function Merge(pair) {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, Merge);\n\n    if (pair instanceof Pair) {\n      var seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      _this = _super.call(this, pair.key, seq);\n      _this.range = pair.range;\n    } else {\n      _this = _super.call(this, new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    _this.type = Pair.Type.MERGE_PAIR;\n    return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.r)(_this);\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(Merge, [{\n    key: \"addToJSMap\",\n    value: function addToJSMap(ctx, map) {\n      var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.value.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var source = _step.value.source;\n          if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n          var srcMap = source.toJSON(null, ctx, Map);\n\n          var _iterator2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(srcMap),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.h)(_step2.value, 2),\n                  key = _step2$value[0],\n                  value = _step2$value[1];\n\n              if (map instanceof Map) {\n                if (!map.has(key)) map.set(key, value);\n              } else if (map instanceof Set) {\n                map.add(key);\n              } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n                Object.defineProperty(map, key, {\n                  value: value,\n                  writable: true,\n                  enumerable: true,\n                  configurable: true\n                });\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment) {\n      var seq = this.value;\n      if (seq.items.length > 1) return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(Merge.prototype), \"toString\", this).call(this, ctx, onComment);\n      this.value = seq.items[0];\n\n      var str = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(Merge.prototype), \"toString\", this).call(this, ctx, onComment);\n\n      this.value = seq;\n      return str;\n    }\n  }]);\n\n  return Merge;\n}(Pair);\n\nvar binaryOptions = {\n  defaultType: _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL,\n  lineWidth: 76\n};\nvar boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nvar intOptions = {\n  asBigInt: false\n};\nvar nullOptions = {\n  nullStr: 'null'\n};\nvar strOptions = {\n  defaultType: _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          format = _step$value.format,\n          test = _step$value.test,\n          resolve = _step$value.resolve;\n\n      if (test) {\n        var match = str.match(test);\n\n        if (match) {\n          var res = resolve.apply(null, match);\n          if (!(res instanceof Scalar)) res = new Scalar(res);\n          if (format) res.format = format;\n          return res;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nvar FOLD_FLOW = 'flow';\nvar FOLD_BLOCK = 'block';\nvar FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nvar consumeMoreIndentedLines = function consumeMoreIndentedLines(text, i) {\n  var ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width or indent content from the start\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, _ref) {\n  var indentAtStart = _ref.indentAtStart,\n      _ref$lineWidth = _ref.lineWidth,\n      lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth,\n      _ref$minContentWidth = _ref.minContentWidth,\n      minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth,\n      onFold = _ref.onFold,\n      onOverflow = _ref.onOverflow;\n  if (!lineWidth || lineWidth < 0) return text;\n  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  var folds = [];\n  var escapedFolds = {};\n  var end = lineWidth - indent.length;\n\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n\n  var split = undefined;\n  var prev = undefined;\n  var overflow = false;\n  var i = -1;\n  var escStart = -1;\n  var escEnd = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (var ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n\n      escEnd = i;\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        var next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // Account for newline escape, but don't break preceding escape\n\n\n          var j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string\n\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  var res = text.slice(0, folds[0]);\n\n  for (var _i = 0; _i < folds.length; ++_i) {\n    var fold = folds[_i];\n\n    var _end = folds[_i + 1] || text.length;\n\n    if (fold === 0) res = \"\\n\".concat(indent).concat(text.slice(0, _end));else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += \"\".concat(text[fold], \"\\\\\");\n      res += \"\\n\".concat(indent).concat(text.slice(fold + 1, _end));\n    }\n  }\n\n  return res;\n}\n\nvar getFoldOptions = function getFoldOptions(_ref) {\n  var indentAtStart = _ref.indentAtStart;\n  return indentAtStart ? Object.assign({\n    indentAtStart: indentAtStart\n  }, strOptions.fold) : strOptions.fold;\n}; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nvar containsDocumentMarker = function containsDocumentMarker(str) {\n  return /^(%|---|\\.\\.\\.)/m.test(str);\n};\n\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n  if (!lineWidth || lineWidth < 0) return false;\n  var limit = lineWidth - indentLength;\n  var strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (var i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  var implicitKey = ctx.implicitKey;\n  var _strOptions$doubleQuo = strOptions.doubleQuoted,\n      jsonEncoding = _strOptions$doubleQuo.jsonEncoding,\n      minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;\n  var json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  var str = '';\n  var start = 0;\n\n  for (var i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          var code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  var res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, \"$&\\n\".concat(indent)) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString(_ref2, ctx, onComment, onChompKeep) {\n  var comment = _ref2.comment,\n      type = _ref2.type,\n      value = _ref2.value;\n\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  var indentSize = indent ? '2' : '1'; // root is at -1\n\n  var literal = type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED ? false : type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);\n  var header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  var wsStart = '';\n  var wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, function (ws) {\n    var n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, function (ws) {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    var m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, \"$&\".concat(indent));\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, \"$&\".concat(indent));\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return \"\".concat(header).concat(indentSize, \"\\n\").concat(indent).concat(wsEnd);\n\n  if (literal) {\n    value = value.replace(/\\n+/g, \"$&\".concat(indent));\n    return \"\".concat(header, \"\\n\").concat(indent).concat(wsStart).concat(value).concat(wsEnd);\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, \"$&\".concat(indent));\n  var body = foldFlowLines(\"\".concat(wsStart).concat(value).concat(wsEnd), indent, FOLD_BLOCK, strOptions.fold);\n  return \"\".concat(header, \"\\n\").concat(indent).concat(body);\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  var comment = item.comment,\n      type = item.type,\n      value = item.value;\n  var actualString = ctx.actualString,\n      implicitKey = ctx.implicitKey,\n      indent = ctx.indent,\n      inFlow = ctx.inFlow;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  var str = value.replace(/\\n+/g, \"$&\\n\".concat(indent)); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    var tags = ctx.doc.schema.tags;\n    var resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  var body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  var defaultType = strOptions.defaultType;\n  var implicitKey = ctx.implicitKey,\n      inFlow = ctx.inFlow;\n  var _item = item,\n      type = _item.type,\n      value = _item.value;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value: value\n    });\n  }\n\n  var _stringify = function _stringify(_type) {\n    switch (_type) {\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED:\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED || type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE;\n  }\n\n  var res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(\"Unsupported default string type \".concat(defaultType));\n  }\n\n  return res;\n}\n\nfunction stringifyNumber(_ref) {\n  var format = _ref.format,\n      minFractionDigits = _ref.minFractionDigits,\n      tag = _ref.tag,\n      value = _ref.value;\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  var n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    var i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    var d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) {\n      n += '0';\n    }\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  var char, name;\n\n  switch (cst.type) {\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  var lastItem;\n\n  for (var i = cst.items.length - 1; i >= 0; --i) {\n    var item = cst.items[i];\n\n    if (!item || item.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    var msg = \"Expected \".concat(name, \" to end with \").concat(char);\n    var err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  var prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    var msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  var sk = String(key);\n  var k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(source, \"The \\\"\".concat(k, \"\\\" key is too long\"));\n}\nfunction resolveComments(collection, comments) {\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(comments),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          afterKey = _step$value.afterKey,\n          before = _step$value.before,\n          comment = _step$value.comment;\n      var item = collection.items[before];\n\n      if (!item) {\n        if (comment !== undefined) {\n          if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n        }\n      } else {\n        if (afterKey && item.value) item = item.value;\n\n        if (comment === undefined) {\n          if (afterKey || !item.commentBefore) item.spaceBefore = true;\n        } else {\n          if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  var res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(function (error) {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  var _node$tag = node.tag,\n      handle = _node$tag.handle,\n      suffix = _node$tag.suffix;\n  var prefix = doc.tagPrefixes.find(function (p) {\n    return p.handle === handle;\n  });\n\n  if (!prefix) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(function (p) {\n      return p.handle === handle;\n    });\n    if (!prefix) throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, \"The \".concat(handle, \" tag handle is non-default and was not declared.\"));\n  }\n\n  if (!suffix) throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, \"The \".concat(handle, \" tag has no suffix.\"));\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      var vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? \"tag:\".concat(vocab[1], \".yaml.org,2002:\").concat(vocab[2]) : \"tag:\".concat(suffix);\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  var tag = node.tag,\n      type = node.type;\n  var nonSpecific = false;\n\n  if (tag) {\n    var handle = tag.handle,\n        suffix = tag.suffix,\n        verbatim = tag.verbatim;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      var msg = \"Verbatim tags aren't resolved, so \".concat(verbatim, \" is invalid.\");\n      doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_FOLDED:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_SINGLE:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.STR;\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.MAP;\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.SEQ;\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN:\n      return nonSpecific ? _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  var tags = doc.schema.tags;\n  var matchWithTest = [];\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var tag = _step.value;\n\n      if (tag.tag === tagName) {\n        if (tag.test) matchWithTest.push(tag);else {\n          var res = tag.resolve(doc, node);\n          return res instanceof Collection ? res : new Scalar(res);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName(_ref) {\n  var type = _ref.type;\n\n  switch (type) {\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.MAP;\n\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ:\n    case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.SEQ;\n\n    default:\n      return _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.n.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    var res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    var fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(\"The tag \".concat(tagName, \" is unavailable\"));\n    var msg = \"The tag \".concat(tagName, \" is unavailable, falling back to \").concat(fallback);\n    doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(node, msg));\n\n    var _res = resolveByTagName(doc, node, fallback);\n\n    _res.tag = tagName;\n    return _res;\n  } catch (error) {\n    var refError = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.o(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nvar isCollectionItem = function isCollectionItem(node) {\n  if (!node) return false;\n  var type = node.type;\n  return type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_KEY || type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_VALUE || type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var hasAnchor = false;\n  var hasTag = false;\n  var props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(props),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          start = _step$value.start,\n          end = _step$value.end;\n\n      switch (node.context.src[start]) {\n        case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.COMMENT:\n          {\n            if (!node.commentHasRequiredWhitespace(start)) {\n              var msg = 'Comments must be separated from other tokens by white space characters';\n              errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, msg));\n            }\n\n            var header = node.header,\n                valueRange = node.valueRange;\n            var cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n            cc.push(node.context.src.slice(start + 1, end));\n            break;\n          }\n        // Actual anchor & tag resolution is handled by schema, here we just complain\n\n        case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.ANCHOR:\n          if (hasAnchor) {\n            var _msg = 'A node can have at most one anchor';\n            errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, _msg));\n          }\n\n          hasAnchor = true;\n          break;\n\n        case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.TAG:\n          if (hasTag) {\n            var _msg2 = 'A node can have at most one tag';\n            errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, _msg2));\n          }\n\n          hasTag = true;\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    comments: comments,\n    hasAnchor: hasAnchor,\n    hasTag: hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  var anchors = doc.anchors,\n      errors = doc.errors,\n      schema = doc.schema;\n\n  if (node.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.ALIAS) {\n    var name = node.rawValue;\n    var src = anchors.getNode(name);\n\n    if (!src) {\n      var msg = \"Aliased anchor not found: \".concat(name);\n      errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.o(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    var res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  var tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN) {\n    var _msg3 = \"Failed to resolve \".concat(node.type, \" node here\");\n\n    errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(node, _msg3));\n    return null;\n  }\n\n  try {\n    var str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n\n  var _resolveNodeProps = resolveNodeProps(doc.errors, node),\n      comments = _resolveNodeProps.comments,\n      hasAnchor = _resolveNodeProps.hasAnchor,\n      hasTag = _resolveNodeProps.hasTag;\n\n  if (hasAnchor) {\n    var anchors = doc.anchors;\n    var name = node.anchor;\n    var prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.ALIAS && (hasAnchor || hasTag)) {\n    var msg = 'An alias node must not specify any properties';\n    doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(node, msg));\n  }\n\n  var res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? \"\".concat(res.commentBefore, \"\\n\").concat(cb) : cb;\n    }\n\n    var ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? \"\".concat(res.comment, \"\\n\").concat(ca) : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP && cst.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP) {\n    var msg = \"A \".concat(cst.type, \" node cannot be resolved as a mapping\");\n    doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(cst, msg));\n    return null;\n  }\n\n  var _ref = cst.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst),\n      comments = _ref.comments,\n      items = _ref.items;\n\n  var map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  var hasCollectionKey = false;\n\n  for (var i = 0; i < items.length; ++i) {\n    var iKey = items[i].key;\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      var sources = items[i].value.items;\n      var error = null;\n      sources.some(function (node) {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          var type = node.source.type;\n          if (type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP || type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, error));\n    } else {\n      for (var j = i + 1; j < items.length; ++j) {\n        var jKey = items[j].key;\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          var _msg = \"Map keys must be unique; \\\"\".concat(iKey, \"\\\" is repeated\");\n\n          doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, _msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nvar valueHasPairComment = function valueHasPairComment(_ref2) {\n  var _ref2$context = _ref2.context,\n      lineStart = _ref2$context.lineStart,\n      node = _ref2$context.node,\n      src = _ref2$context.src,\n      props = _ref2.props;\n  if (props.length === 0) return false;\n  var start = props[0].start;\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.COMMENT) return false;\n\n  for (var i = lineStart; i < start; ++i) {\n    if (src[i] === '\\n') return false;\n  }\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  var comment = item.getPropValue(0, _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.C.COMMENT, true);\n  var found = false;\n  var cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    var cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var key = undefined;\n  var keyStart = null;\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    switch (item.type) {\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP && !item.node.context.atLineStart) {\n            var msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item.node, msg));\n          }\n\n          var valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.P(_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            var pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              var origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          var pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (var j = i + 1;; ++j) {\n          var nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE:\n            case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT:\n              continue next;\n\n            case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                var _msg2 = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, _msg2));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          var _msg3 = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, _msg3));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var key = undefined;\n  var explicitKey = false;\n  var next = '{';\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      var char = item.char,\n          offset = item.offset;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      var msg = \"Flow map contains an unexpected \".concat(char);\n      var err = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ && cst.type !== _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ) {\n    var msg = \"A \".concat(cst.type, \" node cannot be resolved as a sequence\");\n    doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(cst, msg));\n    return null;\n  }\n\n  var _ref = cst.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst),\n      comments = _ref.comments,\n      items = _ref.items;\n\n  var seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(function (it) {\n    return it instanceof Pair && it.key instanceof Collection;\n  })) {\n    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.f(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  var comments = [];\n  var items = [];\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    switch (item.type) {\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          var msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(item, \"Unexpected \".concat(item.type, \" node in sequence\")));\n    }\n  }\n\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var explicitKey = false;\n  var key = undefined;\n  var keyStart = null;\n  var next = '[';\n  var prevItem = null;\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      var char = item.char,\n          offset = item.offset;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            var msg = 'Chaining flow sequence pairs is invalid';\n            var err = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            var keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            var src = prevItem.context.src;\n\n            for (var _i = keyStart; _i < keyEnd; ++_i) {\n              if (src[_i] === '\\n') {\n                var _msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n                doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(prevItem, _msg));\n                break;\n              }\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        var _msg2 = \"Flow sequence contains an unexpected \".concat(char);\n\n        var _err = new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.Y(cst, _msg2);\n\n        _err.offset = offset;\n        doc.errors.push(_err);\n      }\n    } else if (item.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        var _msg3 = \"Expected a \".concat(next, \" in flow sequence\");\n\n        doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(item, _msg3));\n      }\n\n      var value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcmVzb2x2ZVNlcS00OTJhYjQ0MC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ2Q7O0FBRWhkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDBEQUFlO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSwwREFBUzs7QUFFWCxlQUFlLDBEQUFZOztBQUUzQjtBQUNBOztBQUVBLElBQUksMERBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsMERBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsZ0NBQWdDLFFBQVE7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0EseUJBQXlCLDBEQUFPO0FBQ2hDO0FBQ0E7QUFDQSxFQUFFLDBEQUFTOztBQUVYLGVBQWUsMERBQVk7O0FBRTNCO0FBQ0E7O0FBRUEsSUFBSSwwREFBZTs7QUFFbkI7O0FBRUEsSUFBSSwwREFBZSxDQUFDLDBEQUFzQjs7QUFFMUM7QUFDQTtBQUNBOztBQUVBLEVBQUUsMERBQVk7QUFDZDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLG9CQUFvQiwwREFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLHdHQUF3RztBQUN4SztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQkFBa0IsMERB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QUNBOztBQUVBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQSxvQ0FBb0Msc0RBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLHVCQUF1QixzREFBZTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1QkFBdUIsaUVBQWU7QUFDNUM7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNLHVCQUF1Qiw4REFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQSw0QkFBNEIsc0RBQWlCO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3Jlc29sdmVTZXEtNDkyYWI0NDAuanM/ZTA1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjIGFzIF9jbGFzc0NhbGxDaGVjaywgaiBhcyBfaW5oZXJpdHMsIGsgYXMgX2NyZWF0ZVN1cGVyLCBiIGFzIF9jcmVhdGVDbGFzcywgZSBhcyBfZGVmaW5lUHJvcGVydHksIHAgYXMgX2Fzc2VydFRoaXNJbml0aWFsaXplZCwgYSBhcyBfdHlwZW9mLCBxIGFzIF90b0FycmF5LCBUIGFzIFR5cGUsIF8gYXMgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIsIGwgYXMgX2dldCwgbSBhcyBfZ2V0UHJvdG90eXBlT2YsIG8gYXMgWUFNTFJlZmVyZW5jZUVycm9yLCByIGFzIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBoIGFzIF9zbGljZWRUb0FycmF5LCBnIGFzIFlBTUxTZW1hbnRpY0Vycm9yLCBuIGFzIGRlZmF1bHRUYWdzLCBmIGFzIFlBTUxXYXJuaW5nLCBDIGFzIENoYXIsIFkgYXMgWUFNTFN5bnRheEVycm9yLCBQIGFzIFBsYWluVmFsdWUgfSBmcm9tICcuL1BsYWluVmFsdWUtYjgwMzZiNzUuanMnO1xuXG5mdW5jdGlvbiBhZGRDb21tZW50QmVmb3JlKHN0ciwgaW5kZW50LCBjb21tZW50KSB7XG4gIGlmICghY29tbWVudCkgcmV0dXJuIHN0cjtcbiAgdmFyIGNjID0gY29tbWVudC5yZXBsYWNlKC9bXFxzXFxTXV4vZ20sIFwiJCZcIi5jb25jYXQoaW5kZW50LCBcIiNcIikpO1xuICByZXR1cm4gXCIjXCIuY29uY2F0KGNjLCBcIlxcblwiKS5jb25jYXQoaW5kZW50KS5jb25jYXQoc3RyKTtcbn1cbmZ1bmN0aW9uIGFkZENvbW1lbnQoc3RyLCBpbmRlbnQsIGNvbW1lbnQpIHtcbiAgcmV0dXJuICFjb21tZW50ID8gc3RyIDogY29tbWVudC5pbmRleE9mKCdcXG4nKSA9PT0gLTEgPyBcIlwiLmNvbmNhdChzdHIsIFwiICNcIikuY29uY2F0KGNvbW1lbnQpIDogXCJcIi5jb25jYXQoc3RyLCBcIlxcblwiKSArIGNvbW1lbnQucmVwbGFjZSgvXi9nbSwgXCJcIi5jb25jYXQoaW5kZW50IHx8ICcnLCBcIiNcIikpO1xufVxuXG52YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUoKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHRvSlNPTih2YWx1ZSwgYXJnLCBjdHgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgcmV0dXJuIHRvSlNPTih2LCBTdHJpbmcoaSksIGN0eCk7XG4gIH0pO1xuXG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGFuY2hvciA9IGN0eCAmJiBjdHguYW5jaG9ycyAmJiBjdHguYW5jaG9ycy5nZXQodmFsdWUpO1xuICAgIGlmIChhbmNob3IpIGN0eC5vbkNyZWF0ZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGFuY2hvci5yZXMgPSByZXM7XG4gICAgICBkZWxldGUgY3R4Lm9uQ3JlYXRlO1xuICAgIH07XG4gICAgdmFyIHJlcyA9IHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgaWYgKGFuY2hvciAmJiBjdHgub25DcmVhdGUpIGN0eC5vbkNyZWF0ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBpZiAoKCFjdHggfHwgIWN0eC5rZWVwKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgU2NhbGFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoU2NhbGFyLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTY2FsYXIpO1xuXG4gIGZ1bmN0aW9uIFNjYWxhcih2YWx1ZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2FsYXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY2FsYXIsIFt7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04kMShhcmcsIGN0eCkge1xuICAgICAgcmV0dXJuIGN0eCAmJiBjdHgua2VlcCA/IHRoaXMudmFsdWUgOiB0b0pTT04odGhpcy52YWx1ZSwgYXJnLCBjdHgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjYWxhcjtcbn0oTm9kZSk7XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25Gcm9tUGF0aChzY2hlbWEsIHBhdGgsIHZhbHVlKSB7XG4gIHZhciB2ID0gdmFsdWU7XG5cbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgayA9IHBhdGhbaV07XG5cbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihrKSAmJiBrID49IDApIHtcbiAgICAgIHZhciBhID0gW107XG4gICAgICBhW2tdID0gdjtcbiAgICAgIHYgPSBhO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGssIHtcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdiA9IG87XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNjaGVtYS5jcmVhdGVOb2RlKHYsIGZhbHNlKTtcbn0gLy8gbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBlbXB0eSBub24tc3RyaW5nIGl0ZXJhYmxlIChlLmcuIFtdKVxuXG5cbnZhciBpc0VtcHR5UGF0aCA9IGZ1bmN0aW9uIGlzRW1wdHlQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGggPT0gbnVsbCB8fCBfdHlwZW9mKHBhdGgpID09PSAnb2JqZWN0JyAmJiBwYXRoW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkuZG9uZTtcbn07XG52YXIgQ29sbGVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKENvbGxlY3Rpb24sIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENvbGxlY3Rpb24pO1xuXG4gIGZ1bmN0aW9uIENvbGxlY3Rpb24oc2NoZW1hKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbGxlY3Rpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpdGVtc1wiLCBbXSk7XG5cbiAgICBfdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbGxlY3Rpb24sIFt7XG4gICAga2V5OiBcImFkZEluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpIHRoaXMuYWRkKHZhbHVlKTtlbHNlIHtcbiAgICAgICAgdmFyIF9wYXRoID0gX3RvQXJyYXkocGF0aCksXG4gICAgICAgICAgICBrZXkgPSBfcGF0aFswXSxcbiAgICAgICAgICAgIHJlc3QgPSBfcGF0aC5zbGljZSgxKTtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbikgbm9kZS5hZGRJbihyZXN0LCB2YWx1ZSk7ZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKSB0aGlzLnNldChrZXksIGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgcmVzdCwgdmFsdWUpKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCBcIi5jb25jYXQoa2V5LCBcIi4gUmVtYWluaW5nIHBhdGg6IFwiKS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVJbihfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfdG9BcnJheShfcmVmKSxcbiAgICAgICAgICBrZXkgPSBfcmVmMlswXSxcbiAgICAgICAgICByZXN0ID0gX3JlZjIuc2xpY2UoMSk7XG5cbiAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHJldHVybiBub2RlLmRlbGV0ZUluKHJlc3QpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0IFwiLmNvbmNhdChrZXksIFwiLiBSZW1haW5pbmcgcGF0aDogXCIpLmNvbmNhdChyZXN0KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluKF9yZWYzLCBrZWVwU2NhbGFyKSB7XG4gICAgICB2YXIgX3JlZjQgPSBfdG9BcnJheShfcmVmMyksXG4gICAgICAgICAga2V5ID0gX3JlZjRbMF0sXG4gICAgICAgICAgcmVzdCA9IF9yZWY0LnNsaWNlKDEpO1xuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHJldHVybiAha2VlcFNjYWxhciAmJiBub2RlIGluc3RhbmNlb2YgU2NhbGFyID8gbm9kZS52YWx1ZSA6IG5vZGU7ZWxzZSByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24gPyBub2RlLmdldEluKHJlc3QsIGtlZXBTY2FsYXIpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNBbGxOdWxsVmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0FsbE51bGxWYWx1ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtcy5ldmVyeShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS50eXBlICE9PSAnUEFJUicpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIG4gPSBub2RlLnZhbHVlO1xuICAgICAgICByZXR1cm4gbiA9PSBudWxsIHx8IG4gaW5zdGFuY2VvZiBTY2FsYXIgJiYgbi52YWx1ZSA9PSBudWxsICYmICFuLmNvbW1lbnRCZWZvcmUgJiYgIW4uY29tbWVudCAmJiAhbi50YWc7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzSW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzSW4oX3JlZjUpIHtcbiAgICAgIHZhciBfcmVmNiA9IF90b0FycmF5KF9yZWY1KSxcbiAgICAgICAgICBrZXkgPSBfcmVmNlswXSxcbiAgICAgICAgICByZXN0ID0gX3JlZjYuc2xpY2UoMSk7XG5cbiAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuaGFzKGtleSk7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24gPyBub2RlLmhhc0luKHJlc3QpIDogZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluKF9yZWY3LCB2YWx1ZSkge1xuICAgICAgdmFyIF9yZWY4ID0gX3RvQXJyYXkoX3JlZjcpLFxuICAgICAgICAgIGtleSA9IF9yZWY4WzBdLFxuICAgICAgICAgIHJlc3QgPSBfcmVmOC5zbGljZSgxKTtcblxuICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIG5vZGUuc2V0SW4ocmVzdCwgdmFsdWUpO2Vsc2UgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNjaGVtYSkgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgXCIuY29uY2F0KGtleSwgXCIuIFJlbWFpbmluZyBwYXRoOiBcIikuY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICB9IC8vIG92ZXJyaWRkZW4gaW4gaW1wbGVtZW50YXRpb25zXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhjdHgsIF9yZWY5LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGJsb2NrSXRlbSA9IF9yZWY5LmJsb2NrSXRlbSxcbiAgICAgICAgICBmbG93Q2hhcnMgPSBfcmVmOS5mbG93Q2hhcnMsXG4gICAgICAgICAgaXNNYXAgPSBfcmVmOS5pc01hcCxcbiAgICAgICAgICBpdGVtSW5kZW50ID0gX3JlZjkuaXRlbUluZGVudDtcbiAgICAgIHZhciBfY3R4ID0gY3R4LFxuICAgICAgICAgIGluZGVudCA9IF9jdHguaW5kZW50LFxuICAgICAgICAgIGluZGVudFN0ZXAgPSBfY3R4LmluZGVudFN0ZXAsXG4gICAgICAgICAgc3RyaW5naWZ5ID0gX2N0eC5zdHJpbmdpZnk7XG4gICAgICB2YXIgaW5GbG93ID0gdGhpcy50eXBlID09PSBUeXBlLkZMT1dfTUFQIHx8IHRoaXMudHlwZSA9PT0gVHlwZS5GTE9XX1NFUSB8fCBjdHguaW5GbG93O1xuICAgICAgaWYgKGluRmxvdykgaXRlbUluZGVudCArPSBpbmRlbnRTdGVwO1xuICAgICAgdmFyIGFsbE51bGxWYWx1ZXMgPSBpc01hcCAmJiB0aGlzLmhhc0FsbE51bGxWYWx1ZXMoKTtcbiAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwge1xuICAgICAgICBhbGxOdWxsVmFsdWVzOiBhbGxOdWxsVmFsdWVzLFxuICAgICAgICBpbmRlbnQ6IGl0ZW1JbmRlbnQsXG4gICAgICAgIGluRmxvdzogaW5GbG93LFxuICAgICAgICB0eXBlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIHZhciBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICAgIHZhciBoYXNJdGVtV2l0aE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChub2RlcywgaXRlbSwgaSkge1xuICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIGlmICghY2hvbXBLZWVwICYmIGl0ZW0uc3BhY2VCZWZvcmUpIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1lbnQnLFxuICAgICAgICAgICAgc3RyOiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnRCZWZvcmUpIGl0ZW0uY29tbWVudEJlZm9yZS5tYXRjaCgvXi4qJC9nbSkuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdjb21tZW50JyxcbiAgICAgICAgICAgICAgc3RyOiBcIiNcIi5jb25jYXQobGluZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgICAgaWYgKGluRmxvdyAmJiAoIWNob21wS2VlcCAmJiBpdGVtLnNwYWNlQmVmb3JlIHx8IGl0ZW0uY29tbWVudEJlZm9yZSB8fCBpdGVtLmNvbW1lbnQgfHwgaXRlbS5rZXkgJiYgKGl0ZW0ua2V5LmNvbW1lbnRCZWZvcmUgfHwgaXRlbS5rZXkuY29tbWVudCkgfHwgaXRlbS52YWx1ZSAmJiAoaXRlbS52YWx1ZS5jb21tZW50QmVmb3JlIHx8IGl0ZW0udmFsdWUuY29tbWVudCkpKSBoYXNJdGVtV2l0aE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICAgIHZhciBzdHIgPSBzdHJpbmdpZnkoaXRlbSwgY3R4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNob21wS2VlcCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5GbG93ICYmICFoYXNJdGVtV2l0aE5ld0xpbmUgJiYgc3RyLmluY2x1ZGVzKCdcXG4nKSkgaGFzSXRlbVdpdGhOZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluRmxvdyAmJiBpIDwgX3RoaXMyLml0ZW1zLmxlbmd0aCAtIDEpIHN0ciArPSAnLCc7XG4gICAgICAgIHN0ciA9IGFkZENvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50KTtcbiAgICAgICAgaWYgKGNob21wS2VlcCAmJiAoY29tbWVudCB8fCBpbkZsb3cpKSBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2l0ZW0nLFxuICAgICAgICAgIHN0cjogc3RyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICB9LCBbXSk7XG4gICAgICB2YXIgc3RyO1xuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0ciA9IGZsb3dDaGFycy5zdGFydCArIGZsb3dDaGFycy5lbmQ7XG4gICAgICB9IGVsc2UgaWYgKGluRmxvdykge1xuICAgICAgICB2YXIgc3RhcnQgPSBmbG93Q2hhcnMuc3RhcnQsXG4gICAgICAgICAgICBlbmQgPSBmbG93Q2hhcnMuZW5kO1xuICAgICAgICB2YXIgc3RyaW5ncyA9IG5vZGVzLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBuLnN0cjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc0l0ZW1XaXRoTmV3TGluZSB8fCBzdHJpbmdzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBzdHIpIHtcbiAgICAgICAgICByZXR1cm4gc3VtICsgc3RyLmxlbmd0aCArIDI7XG4gICAgICAgIH0sIDIpID4gQ29sbGVjdGlvbi5tYXhGbG93U3RyaW5nU2luZ2xlTGluZUxlbmd0aCkge1xuICAgICAgICAgIHN0ciA9IHN0YXJ0O1xuXG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0cmluZ3MpLFxuICAgICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgcyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBzdHIgKz0gcyA/IFwiXFxuXCIuY29uY2F0KGluZGVudFN0ZXApLmNvbmNhdChpbmRlbnQpLmNvbmNhdChzKSA6ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHIgKz0gXCJcXG5cIi5jb25jYXQoaW5kZW50KS5jb25jYXQoZW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSBcIlwiLmNvbmNhdChzdGFydCwgXCIgXCIpLmNvbmNhdChzdHJpbmdzLmpvaW4oJyAnKSwgXCIgXCIpLmNvbmNhdChlbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3N0cmluZ3MgPSBub2Rlcy5tYXAoYmxvY2tJdGVtKTtcblxuICAgICAgICBzdHIgPSBfc3RyaW5ncy5zaGlmdCgpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX3N0cmluZ3MpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfcyA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIHN0ciArPSBfcyA/IFwiXFxuXCIuY29uY2F0KGluZGVudCkuY29uY2F0KF9zKSA6ICdcXG4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29tbWVudCkge1xuICAgICAgICBzdHIgKz0gJ1xcbicgKyB0aGlzLmNvbW1lbnQucmVwbGFjZSgvXi9nbSwgXCJcIi5jb25jYXQoaW5kZW50LCBcIiNcIikpO1xuICAgICAgICBpZiAob25Db21tZW50KSBvbkNvbW1lbnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKSBvbkNob21wS2VlcCgpO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xsZWN0aW9uO1xufShOb2RlKTtcblxuX2RlZmluZVByb3BlcnR5KENvbGxlY3Rpb24sIFwibWF4Rmxvd1N0cmluZ1NpbmdsZUxpbmVMZW5ndGhcIiwgNjApO1xuXG5mdW5jdGlvbiBhc0l0ZW1JbmRleChrZXkpIHtcbiAgdmFyIGlkeCA9IGtleSBpbnN0YW5jZW9mIFNjYWxhciA/IGtleS52YWx1ZSA6IGtleTtcbiAgaWYgKGlkeCAmJiB0eXBlb2YgaWR4ID09PSAnc3RyaW5nJykgaWR4ID0gTnVtYmVyKGlkeCk7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGlkeCkgJiYgaWR4ID49IDAgPyBpZHggOiBudWxsO1xufVxuXG52YXIgWUFNTFNlcSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbGxlY3Rpb24pIHtcbiAgX2luaGVyaXRzKFlBTUxTZXEsIF9Db2xsZWN0aW9uKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFlBTUxTZXEpO1xuXG4gIGZ1bmN0aW9uIFlBTUxTZXEoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBTUxTZXEpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFlBTUxTZXEsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgIHRoaXMuaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgdmFyIGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBkZWwgPSB0aGlzLml0ZW1zLnNwbGljZShpZHgsIDEpO1xuICAgICAgcmV0dXJuIGRlbC5sZW5ndGggPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgdmFyIGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgaXQgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXQgaW5zdGFuY2VvZiBTY2FsYXIgPyBpdC52YWx1ZSA6IGl0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgdmFyIGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICByZXR1cm4gdHlwZW9mIGlkeCA9PT0gJ251bWJlcicgJiYgaWR4IDwgdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGEgdmFsaWQgaW5kZXgsIG5vdCBcIi5jb25jYXQoa2V5LCBcIi5cIikpO1xuICAgICAgdGhpcy5pdGVtc1tpZHhdID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04kMShfLCBjdHgpIHtcbiAgICAgIHZhciBzZXEgPSBbXTtcbiAgICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKSBjdHgub25DcmVhdGUoc2VxKTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuaXRlbXMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgc2VxLnB1c2godG9KU09OKGl0ZW0sIFN0cmluZyhpKyspLCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgIGlmICghY3R4KSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoWUFNTFNlcS5wcm90b3R5cGUpLCBcInRvU3RyaW5nXCIsIHRoaXMpLmNhbGwodGhpcywgY3R4LCB7XG4gICAgICAgIGJsb2NrSXRlbTogZnVuY3Rpb24gYmxvY2tJdGVtKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi50eXBlID09PSAnY29tbWVudCcgPyBuLnN0ciA6IFwiLSBcIi5jb25jYXQobi5zdHIpO1xuICAgICAgICB9LFxuICAgICAgICBmbG93Q2hhcnM6IHtcbiAgICAgICAgICBzdGFydDogJ1snLFxuICAgICAgICAgIGVuZDogJ10nXG4gICAgICAgIH0sXG4gICAgICAgIGlzTWFwOiBmYWxzZSxcbiAgICAgICAgaXRlbUluZGVudDogKGN0eC5pbmRlbnQgfHwgJycpICsgJyAgJ1xuICAgICAgfSwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFlBTUxTZXE7XG59KENvbGxlY3Rpb24pO1xuXG52YXIgc3RyaW5naWZ5S2V5ID0gZnVuY3Rpb24gc3RyaW5naWZ5S2V5KGtleSwganNLZXksIGN0eCkge1xuICBpZiAoanNLZXkgPT09IG51bGwpIHJldHVybiAnJztcbiAgaWYgKF90eXBlb2YoanNLZXkpICE9PSAnb2JqZWN0JykgcmV0dXJuIFN0cmluZyhqc0tleSk7XG4gIGlmIChrZXkgaW5zdGFuY2VvZiBOb2RlICYmIGN0eCAmJiBjdHguZG9jKSByZXR1cm4ga2V5LnRvU3RyaW5nKHtcbiAgICBhbmNob3JzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIGRvYzogY3R4LmRvYyxcbiAgICBpbmRlbnQ6ICcnLFxuICAgIGluZGVudFN0ZXA6IGN0eC5pbmRlbnRTdGVwLFxuICAgIGluRmxvdzogdHJ1ZSxcbiAgICBpblN0cmluZ2lmeUtleTogdHJ1ZSxcbiAgICBzdHJpbmdpZnk6IGN0eC5zdHJpbmdpZnlcbiAgfSk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShqc0tleSk7XG59O1xuXG52YXIgUGFpciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKFBhaXIsIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFBhaXIpO1xuXG4gIGZ1bmN0aW9uIFBhaXIoa2V5KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhaXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5rZXkgPSBrZXk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICBfdGhpcy50eXBlID0gUGFpci5UeXBlLlBBSVI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhaXIsIFt7XG4gICAga2V5OiBcImNvbW1lbnRCZWZvcmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleSBpbnN0YW5jZW9mIE5vZGUgPyB0aGlzLmtleS5jb21tZW50QmVmb3JlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzLmtleSA9PSBudWxsKSB0aGlzLmtleSA9IG5ldyBTY2FsYXIobnVsbCk7XG4gICAgICBpZiAodGhpcy5rZXkgaW5zdGFuY2VvZiBOb2RlKSB0aGlzLmtleS5jb21tZW50QmVmb3JlID0gY2I7ZWxzZSB7XG4gICAgICAgIHZhciBtc2cgPSAnUGFpci5jb21tZW50QmVmb3JlIGlzIGFuIGFsaWFzIGZvciBQYWlyLmtleS5jb21tZW50QmVmb3JlLiBUbyBzZXQgaXQsIHRoZSBrZXkgbXVzdCBiZSBhIE5vZGUuJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFRvSlNNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVG9KU01hcChjdHgsIG1hcCkge1xuICAgICAgdmFyIGtleSA9IHRvSlNPTih0aGlzLmtleSwgJycsIGN0eCk7XG5cbiAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdG9KU09OKHRoaXMudmFsdWUsIGtleSwgY3R4KTtcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIG1hcC5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdHJpbmdLZXkgPSBzdHJpbmdpZnlLZXkodGhpcy5rZXksIGtleSwgY3R4KTtcblxuICAgICAgICB2YXIgX3ZhbHVlID0gdG9KU09OKHRoaXMudmFsdWUsIHN0cmluZ0tleSwgY3R4KTtcblxuICAgICAgICBpZiAoc3RyaW5nS2V5IGluIG1hcCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwgc3RyaW5nS2V5LCB7XG4gICAgICAgICAgdmFsdWU6IF92YWx1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtlbHNlIG1hcFtzdHJpbmdLZXldID0gX3ZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKF8sIGN0eCkge1xuICAgICAgdmFyIHBhaXIgPSBjdHggJiYgY3R4Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICByZXR1cm4gdGhpcy5hZGRUb0pTTWFwKGN0eCwgcGFpcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgaWYgKCFjdHggfHwgIWN0eC5kb2MpIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgIHZhciBfY3R4JGRvYyRvcHRpb25zID0gY3R4LmRvYy5vcHRpb25zLFxuICAgICAgICAgIGluZGVudFNpemUgPSBfY3R4JGRvYyRvcHRpb25zLmluZGVudCxcbiAgICAgICAgICBpbmRlbnRTZXEgPSBfY3R4JGRvYyRvcHRpb25zLmluZGVudFNlcSxcbiAgICAgICAgICBzaW1wbGVLZXlzID0gX2N0eCRkb2Mkb3B0aW9ucy5zaW1wbGVLZXlzO1xuICAgICAgdmFyIGtleSA9IHRoaXMua2V5LFxuICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHZhciBrZXlDb21tZW50ID0ga2V5IGluc3RhbmNlb2YgTm9kZSAmJiBrZXkuY29tbWVudDtcblxuICAgICAgaWYgKHNpbXBsZUtleXMpIHtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIGtleSBub2RlcyBjYW5ub3QgaGF2ZSBjb21tZW50cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgbXNnID0gJ1dpdGggc2ltcGxlIGtleXMsIGNvbGxlY3Rpb24gY2Fubm90IGJlIHVzZWQgYXMgYSBrZXkgdmFsdWUnO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBleHBsaWNpdEtleSA9ICFzaW1wbGVLZXlzICYmICgha2V5IHx8IGtleUNvbW1lbnQgfHwgKGtleSBpbnN0YW5jZW9mIE5vZGUgPyBrZXkgaW5zdGFuY2VvZiBDb2xsZWN0aW9uIHx8IGtleS50eXBlID09PSBUeXBlLkJMT0NLX0ZPTERFRCB8fCBrZXkudHlwZSA9PT0gVHlwZS5CTE9DS19MSVRFUkFMIDogX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JykpO1xuICAgICAgdmFyIF9jdHggPSBjdHgsXG4gICAgICAgICAgZG9jID0gX2N0eC5kb2MsXG4gICAgICAgICAgaW5kZW50ID0gX2N0eC5pbmRlbnQsXG4gICAgICAgICAgaW5kZW50U3RlcCA9IF9jdHguaW5kZW50U3RlcCxcbiAgICAgICAgICBzdHJpbmdpZnkgPSBfY3R4LnN0cmluZ2lmeTtcbiAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwge1xuICAgICAgICBpbXBsaWNpdEtleTogIWV4cGxpY2l0S2V5LFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIGluZGVudFN0ZXBcbiAgICAgIH0pO1xuICAgICAgdmFyIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgdmFyIHN0ciA9IHN0cmluZ2lmeShrZXksIGN0eCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ga2V5Q29tbWVudCA9IG51bGw7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjaG9tcEtlZXAgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBzdHIgPSBhZGRDb21tZW50KHN0ciwgY3R4LmluZGVudCwga2V5Q29tbWVudCk7XG5cbiAgICAgIGlmICghZXhwbGljaXRLZXkgJiYgc3RyLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgaWYgKHNpbXBsZUtleXMpIHRocm93IG5ldyBFcnJvcignV2l0aCBzaW1wbGUga2V5cywgc2luZ2xlIGxpbmUgc2NhbGFyIG11c3Qgbm90IHNwYW4gbW9yZSB0aGFuIDEwMjQgY2hhcmFjdGVycycpO1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdHguYWxsTnVsbFZhbHVlcyAmJiAhc2ltcGxlS2V5cykge1xuICAgICAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAgICAgc3RyID0gYWRkQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIHRoaXMuY29tbWVudCk7XG4gICAgICAgICAgaWYgKG9uQ29tbWVudCkgb25Db21tZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hvbXBLZWVwICYmICFrZXlDb21tZW50ICYmIG9uQ2hvbXBLZWVwKSBvbkNob21wS2VlcCgpO1xuXG4gICAgICAgIHJldHVybiBjdHguaW5GbG93ICYmICFleHBsaWNpdEtleSA/IHN0ciA6IFwiPyBcIi5jb25jYXQoc3RyKTtcbiAgICAgIH1cblxuICAgICAgc3RyID0gZXhwbGljaXRLZXkgPyBcIj8gXCIuY29uY2F0KHN0ciwgXCJcXG5cIikuY29uY2F0KGluZGVudCwgXCI6XCIpIDogXCJcIi5jb25jYXQoc3RyLCBcIjpcIik7XG5cbiAgICAgIGlmICh0aGlzLmNvbW1lbnQpIHtcbiAgICAgICAgLy8gZXhwZWN0ZWQgKGJ1dCBub3Qgc3RyaWN0bHkgcmVxdWlyZWQpIHRvIGJlIGEgc2luZ2xlLWxpbmUgY29tbWVudFxuICAgICAgICBzdHIgPSBhZGRDb21tZW50KHN0ciwgY3R4LmluZGVudCwgdGhpcy5jb21tZW50KTtcbiAgICAgICAgaWYgKG9uQ29tbWVudCkgb25Db21tZW50KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2Y2IgPSAnJztcbiAgICAgIHZhciB2YWx1ZUNvbW1lbnQgPSBudWxsO1xuXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zcGFjZUJlZm9yZSkgdmNiID0gJ1xcbic7XG5cbiAgICAgICAgaWYgKHZhbHVlLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgICB2YXIgY3MgPSB2YWx1ZS5jb21tZW50QmVmb3JlLnJlcGxhY2UoL14vZ20sIFwiXCIuY29uY2F0KGN0eC5pbmRlbnQsIFwiI1wiKSk7XG4gICAgICAgICAgdmNiICs9IFwiXFxuXCIuY29uY2F0KGNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlQ29tbWVudCA9IHZhbHVlLmNvbW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWx1ZSA9IGRvYy5zY2hlbWEuY3JlYXRlTm9kZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5pbXBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgaWYgKCFleHBsaWNpdEtleSAmJiAhdGhpcy5jb21tZW50ICYmIHZhbHVlIGluc3RhbmNlb2YgU2NhbGFyKSBjdHguaW5kZW50QXRTdGFydCA9IHN0ci5sZW5ndGggKyAxO1xuICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG5cbiAgICAgIGlmICghaW5kZW50U2VxICYmIGluZGVudFNpemUgPj0gMiAmJiAhY3R4LmluRmxvdyAmJiAhZXhwbGljaXRLZXkgJiYgdmFsdWUgaW5zdGFuY2VvZiBZQU1MU2VxICYmIHZhbHVlLnR5cGUgIT09IFR5cGUuRkxPV19TRVEgJiYgIXZhbHVlLnRhZyAmJiAhZG9jLmFuY2hvcnMuZ2V0TmFtZSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gSWYgaW5kZW50U2VxID09PSBmYWxzZSwgY29uc2lkZXIgJy0gJyBhcyBwYXJ0IG9mIGluZGVudGF0aW9uIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgIGN0eC5pbmRlbnQgPSBjdHguaW5kZW50LnN1YnN0cigyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlU3RyID0gc3RyaW5naWZ5KHZhbHVlLCBjdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlQ29tbWVudCA9IG51bGw7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjaG9tcEtlZXAgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB2YXIgd3MgPSAnICc7XG5cbiAgICAgIGlmICh2Y2IgfHwgdGhpcy5jb21tZW50KSB7XG4gICAgICAgIHdzID0gXCJcIi5jb25jYXQodmNiLCBcIlxcblwiKS5jb25jYXQoY3R4LmluZGVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFleHBsaWNpdEtleSAmJiB2YWx1ZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGZsb3cgPSB2YWx1ZVN0clswXSA9PT0gJ1snIHx8IHZhbHVlU3RyWzBdID09PSAneyc7XG4gICAgICAgIGlmICghZmxvdyB8fCB2YWx1ZVN0ci5pbmNsdWRlcygnXFxuJykpIHdzID0gXCJcXG5cIi5jb25jYXQoY3R4LmluZGVudCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlU3RyWzBdID09PSAnXFxuJykgd3MgPSAnJztcblxuICAgICAgaWYgKGNob21wS2VlcCAmJiAhdmFsdWVDb21tZW50ICYmIG9uQ2hvbXBLZWVwKSBvbkNob21wS2VlcCgpO1xuICAgICAgcmV0dXJuIGFkZENvbW1lbnQoc3RyICsgd3MgKyB2YWx1ZVN0ciwgY3R4LmluZGVudCwgdmFsdWVDb21tZW50KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFpcjtcbn0oTm9kZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShQYWlyLCBcIlR5cGVcIiwge1xuICBQQUlSOiAnUEFJUicsXG4gIE1FUkdFX1BBSVI6ICdNRVJHRV9QQUlSJ1xufSk7XG5cbnZhciBnZXRBbGlhc0NvdW50ID0gZnVuY3Rpb24gZ2V0QWxpYXNDb3VudChub2RlLCBhbmNob3JzKSB7XG4gIGlmIChub2RlIGluc3RhbmNlb2YgQWxpYXMpIHtcbiAgICB2YXIgYW5jaG9yID0gYW5jaG9ycy5nZXQobm9kZS5zb3VyY2UpO1xuICAgIHJldHVybiBhbmNob3IuY291bnQgKiBhbmNob3IuYWxpYXNDb3VudDtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobm9kZS5pdGVtcyksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHZhciBjID0gZ2V0QWxpYXNDb3VudChpdGVtLCBhbmNob3JzKTtcbiAgICAgICAgaWYgKGMgPiBjb3VudCkgY291bnQgPSBjO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFBhaXIpIHtcbiAgICB2YXIga2MgPSBnZXRBbGlhc0NvdW50KG5vZGUua2V5LCBhbmNob3JzKTtcbiAgICB2YXIgdmMgPSBnZXRBbGlhc0NvdW50KG5vZGUudmFsdWUsIGFuY2hvcnMpO1xuICAgIHJldHVybiBNYXRoLm1heChrYywgdmMpO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59O1xuXG52YXIgQWxpYXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhBbGlhcywgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWxpYXMpO1xuXG4gIGZ1bmN0aW9uIEFsaWFzKHNvdXJjZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbGlhcyk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICBfdGhpcy50eXBlID0gVHlwZS5BTElBUztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQWxpYXMsIFt7XG4gICAga2V5OiBcInRhZ1wiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWxpYXMgbm9kZXMgY2Fubm90IGhhdmUgdGFncycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OJDEoYXJnLCBjdHgpIHtcbiAgICAgIGlmICghY3R4KSByZXR1cm4gdG9KU09OKHRoaXMuc291cmNlLCBhcmcsIGN0eCk7XG4gICAgICB2YXIgYW5jaG9ycyA9IGN0eC5hbmNob3JzLFxuICAgICAgICAgIG1heEFsaWFzQ291bnQgPSBjdHgubWF4QWxpYXNDb3VudDtcbiAgICAgIHZhciBhbmNob3IgPSBhbmNob3JzLmdldCh0aGlzLnNvdXJjZSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgICAgaWYgKCFhbmNob3IgfHwgYW5jaG9yLnJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBtc2cgPSAnVGhpcyBzaG91bGQgbm90IGhhcHBlbjogQWxpYXMgYW5jaG9yIHdhcyBub3QgcmVzb2x2ZWQ/JztcbiAgICAgICAgaWYgKHRoaXMuY3N0Tm9kZSkgdGhyb3cgbmV3IFlBTUxSZWZlcmVuY2VFcnJvcih0aGlzLmNzdE5vZGUsIG1zZyk7ZWxzZSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heEFsaWFzQ291bnQgPj0gMCkge1xuICAgICAgICBhbmNob3IuY291bnQgKz0gMTtcbiAgICAgICAgaWYgKGFuY2hvci5hbGlhc0NvdW50ID09PSAwKSBhbmNob3IuYWxpYXNDb3VudCA9IGdldEFsaWFzQ291bnQodGhpcy5zb3VyY2UsIGFuY2hvcnMpO1xuXG4gICAgICAgIGlmIChhbmNob3IuY291bnQgKiBhbmNob3IuYWxpYXNDb3VudCA+IG1heEFsaWFzQ291bnQpIHtcbiAgICAgICAgICB2YXIgX21zZyA9ICdFeGNlc3NpdmUgYWxpYXMgY291bnQgaW5kaWNhdGVzIGEgcmVzb3VyY2UgZXhoYXVzdGlvbiBhdHRhY2snO1xuICAgICAgICAgIGlmICh0aGlzLmNzdE5vZGUpIHRocm93IG5ldyBZQU1MUmVmZXJlbmNlRXJyb3IodGhpcy5jc3ROb2RlLCBfbXNnKTtlbHNlIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihfbXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYW5jaG9yLnJlcztcbiAgICB9IC8vIE9ubHkgY2FsbGVkIHdoZW4gc3RyaW5naWZ5aW5nIGFuIGFsaWFzIG1hcHBpbmcga2V5IHdoaWxlIGNvbnN0cnVjdGluZ1xuICAgIC8vIE9iamVjdCBvdXRwdXQuXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhjdHgpIHtcbiAgICAgIHJldHVybiBBbGlhcy5zdHJpbmdpZnkodGhpcywgY3R4KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJzdHJpbmdpZnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyaW5naWZ5KF9yZWYsIF9yZWYyKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgICAgIHNvdXJjZSA9IF9yZWYuc291cmNlO1xuICAgICAgdmFyIGFuY2hvcnMgPSBfcmVmMi5hbmNob3JzLFxuICAgICAgICAgIGRvYyA9IF9yZWYyLmRvYyxcbiAgICAgICAgICBpbXBsaWNpdEtleSA9IF9yZWYyLmltcGxpY2l0S2V5LFxuICAgICAgICAgIGluU3RyaW5naWZ5S2V5ID0gX3JlZjIuaW5TdHJpbmdpZnlLZXk7XG4gICAgICB2YXIgYW5jaG9yID0gT2JqZWN0LmtleXMoYW5jaG9ycykuZmluZChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gYW5jaG9yc1thXSA9PT0gc291cmNlO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWFuY2hvciAmJiBpblN0cmluZ2lmeUtleSkgYW5jaG9yID0gZG9jLmFuY2hvcnMuZ2V0TmFtZShzb3VyY2UpIHx8IGRvYy5hbmNob3JzLm5ld05hbWUoKTtcbiAgICAgIGlmIChhbmNob3IpIHJldHVybiBcIipcIi5jb25jYXQoYW5jaG9yKS5jb25jYXQoaW1wbGljaXRLZXkgPyAnICcgOiAnJyk7XG4gICAgICB2YXIgbXNnID0gZG9jLmFuY2hvcnMuZ2V0TmFtZShzb3VyY2UpID8gJ0FsaWFzIG5vZGUgbXVzdCBiZSBhZnRlciBzb3VyY2Ugbm9kZScgOiAnU291cmNlIG5vZGUgbm90IGZvdW5kIGZvciBhbGlhcyBub2RlJztcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChtc2csIFwiIFtcIikuY29uY2F0KHJhbmdlLCBcIl1cIikpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbGlhcztcbn0oTm9kZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShBbGlhcywgXCJkZWZhdWx0XCIsIHRydWUpO1xuXG5mdW5jdGlvbiBmaW5kUGFpcihpdGVtcywga2V5KSB7XG4gIHZhciBrID0ga2V5IGluc3RhbmNlb2YgU2NhbGFyID8ga2V5LnZhbHVlIDoga2V5O1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpdGVtcyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgaXQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKGl0IGluc3RhbmNlb2YgUGFpcikge1xuICAgICAgICBpZiAoaXQua2V5ID09PSBrZXkgfHwgaXQua2V5ID09PSBrKSByZXR1cm4gaXQ7XG4gICAgICAgIGlmIChpdC5rZXkgJiYgaXQua2V5LnZhbHVlID09PSBrKSByZXR1cm4gaXQ7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxudmFyIFlBTUxNYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db2xsZWN0aW9uKSB7XG4gIF9pbmhlcml0cyhZQU1MTWFwLCBfQ29sbGVjdGlvbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihZQU1MTWFwKTtcblxuICBmdW5jdGlvbiBZQU1MTWFwKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBZQU1MTWFwKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhZQU1MTWFwLCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHBhaXIsIG92ZXJ3cml0ZSkge1xuICAgICAgaWYgKCFwYWlyKSBwYWlyID0gbmV3IFBhaXIocGFpcik7ZWxzZSBpZiAoIShwYWlyIGluc3RhbmNlb2YgUGFpcikpIHBhaXIgPSBuZXcgUGFpcihwYWlyLmtleSB8fCBwYWlyLCBwYWlyLnZhbHVlKTtcbiAgICAgIHZhciBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywgcGFpci5rZXkpO1xuICAgICAgdmFyIHNvcnRFbnRyaWVzID0gdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuc29ydE1hcEVudHJpZXM7XG5cbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIGlmIChvdmVyd3JpdGUpIHByZXYudmFsdWUgPSBwYWlyLnZhbHVlO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiS2V5IFwiLmNvbmNhdChwYWlyLmtleSwgXCIgYWxyZWFkeSBzZXRcIikpO1xuICAgICAgfSBlbHNlIGlmIChzb3J0RW50cmllcykge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaXRlbXMuZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIHNvcnRFbnRyaWVzKHBhaXIsIGl0ZW0pIDwgMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpID09PSAtMSkgdGhpcy5pdGVtcy5wdXNoKHBhaXIpO2Vsc2UgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMCwgcGFpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgdmFyIGl0ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgIGlmICghaXQpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBkZWwgPSB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YoaXQpLCAxKTtcbiAgICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgIHZhciBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICB2YXIgbm9kZSA9IGl0ICYmIGl0LnZhbHVlO1xuICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIG5vZGUgaW5zdGFuY2VvZiBTY2FsYXIgPyBub2RlLnZhbHVlIDogbm9kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiAhIWZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5hZGQobmV3IFBhaXIoa2V5LCB2YWx1ZSksIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGFyZyBpZ25vcmVkXG4gICAgICogQHBhcmFtIHsqfSBjdHggQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTT04oKVxuICAgICAqIEBwYXJhbSB7Q2xhc3N9IFR5cGUgSWYgc2V0LCBmb3JjZXMgdGhlIHJldHVybmVkIGNvbGxlY3Rpb24gdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfSBJbnN0YW5jZSBvZiBUeXBlLCBNYXAsIG9yIE9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihfLCBjdHgsIFR5cGUpIHtcbiAgICAgIHZhciBtYXAgPSBUeXBlID8gbmV3IFR5cGUoKSA6IGN0eCAmJiBjdHgubWFwQXNNYXAgPyBuZXcgTWFwKCkgOiB7fTtcbiAgICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKSBjdHgub25DcmVhdGUobWFwKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLml0ZW1zKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgaXRlbS5hZGRUb0pTTWFwKGN0eCwgbWFwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgaWYgKCFjdHgpIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLml0ZW1zKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFBhaXIpKSB0aHJvdyBuZXcgRXJyb3IoXCJNYXAgaXRlbXMgbXVzdCBhbGwgYmUgcGFpcnM7IGZvdW5kIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShpdGVtKSwgXCIgaW5zdGVhZFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoWUFNTE1hcC5wcm90b3R5cGUpLCBcInRvU3RyaW5nXCIsIHRoaXMpLmNhbGwodGhpcywgY3R4LCB7XG4gICAgICAgIGJsb2NrSXRlbTogZnVuY3Rpb24gYmxvY2tJdGVtKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5zdHI7XG4gICAgICAgIH0sXG4gICAgICAgIGZsb3dDaGFyczoge1xuICAgICAgICAgIHN0YXJ0OiAneycsXG4gICAgICAgICAgZW5kOiAnfSdcbiAgICAgICAgfSxcbiAgICAgICAgaXNNYXA6IHRydWUsXG4gICAgICAgIGl0ZW1JbmRlbnQ6IGN0eC5pbmRlbnQgfHwgJydcbiAgICAgIH0sIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBZQU1MTWFwO1xufShDb2xsZWN0aW9uKTtcblxudmFyIE1FUkdFX0tFWSA9ICc8PCc7XG52YXIgTWVyZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYWlyKSB7XG4gIF9pbmhlcml0cyhNZXJnZSwgX1BhaXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTWVyZ2UpO1xuXG4gIGZ1bmN0aW9uIE1lcmdlKHBhaXIpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVyZ2UpO1xuXG4gICAgaWYgKHBhaXIgaW5zdGFuY2VvZiBQYWlyKSB7XG4gICAgICB2YXIgc2VxID0gcGFpci52YWx1ZTtcblxuICAgICAgaWYgKCEoc2VxIGluc3RhbmNlb2YgWUFNTFNlcSkpIHtcbiAgICAgICAgc2VxID0gbmV3IFlBTUxTZXEoKTtcbiAgICAgICAgc2VxLml0ZW1zLnB1c2gocGFpci52YWx1ZSk7XG4gICAgICAgIHNlcS5yYW5nZSA9IHBhaXIudmFsdWUucmFuZ2U7XG4gICAgICB9XG5cbiAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFpci5rZXksIHNlcSk7XG4gICAgICBfdGhpcy5yYW5nZSA9IHBhaXIucmFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV3IFNjYWxhcihNRVJHRV9LRVkpLCBuZXcgWUFNTFNlcSgpKTtcbiAgICB9XG5cbiAgICBfdGhpcy50eXBlID0gUGFpci5UeXBlLk1FUkdFX1BBSVI7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfSAvLyBJZiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEgbWVyZ2Uga2V5IGlzIGEgc2luZ2xlIG1hcHBpbmcgbm9kZSwgZWFjaCBvZlxuICAvLyBpdHMga2V5L3ZhbHVlIHBhaXJzIGlzIGluc2VydGVkIGludG8gdGhlIGN1cnJlbnQgbWFwcGluZywgdW5sZXNzIHRoZSBrZXlcbiAgLy8gYWxyZWFkeSBleGlzdHMgaW4gaXQuIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1lcmdlIGtleSBpcyBhXG4gIC8vIHNlcXVlbmNlLCB0aGVuIHRoaXMgc2VxdWVuY2UgaXMgZXhwZWN0ZWQgdG8gY29udGFpbiBtYXBwaW5nIG5vZGVzIGFuZCBlYWNoXG4gIC8vIG9mIHRoZXNlIG5vZGVzIGlzIG1lcmdlZCBpbiB0dXJuIGFjY29yZGluZyB0byBpdHMgb3JkZXIgaW4gdGhlIHNlcXVlbmNlLlxuICAvLyBLZXlzIGluIG1hcHBpbmcgbm9kZXMgZWFybGllciBpbiB0aGUgc2VxdWVuY2Ugb3ZlcnJpZGUga2V5cyBzcGVjaWZpZWQgaW5cbiAgLy8gbGF0ZXIgbWFwcGluZyBub2Rlcy4gLS0gaHR0cDovL3lhbWwub3JnL3R5cGUvbWVyZ2UuaHRtbFxuXG5cbiAgX2NyZWF0ZUNsYXNzKE1lcmdlLCBbe1xuICAgIGtleTogXCJhZGRUb0pTTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRvSlNNYXAoY3R4LCBtYXApIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLnZhbHVlLml0ZW1zKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gX3N0ZXAudmFsdWUuc291cmNlO1xuICAgICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFlBTUxNYXApKSB0aHJvdyBuZXcgRXJyb3IoJ01lcmdlIHNvdXJjZXMgbXVzdCBiZSBtYXBzJyk7XG4gICAgICAgICAgdmFyIHNyY01hcCA9IHNvdXJjZS50b0pTT04obnVsbCwgY3R4LCBNYXApO1xuXG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzcmNNYXApLFxuICAgICAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBrZXkgPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9zdGVwMiR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXAuaGFzKGtleSkpIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgbWFwLmFkZChrZXkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCkge1xuICAgICAgdmFyIHNlcSA9IHRoaXMudmFsdWU7XG4gICAgICBpZiAoc2VxLml0ZW1zLmxlbmd0aCA+IDEpIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZXJnZS5wcm90b3R5cGUpLCBcInRvU3RyaW5nXCIsIHRoaXMpLmNhbGwodGhpcywgY3R4LCBvbkNvbW1lbnQpO1xuICAgICAgdGhpcy52YWx1ZSA9IHNlcS5pdGVtc1swXTtcblxuICAgICAgdmFyIHN0ciA9IF9nZXQoX2dldFByb3RvdHlwZU9mKE1lcmdlLnByb3RvdHlwZSksIFwidG9TdHJpbmdcIiwgdGhpcykuY2FsbCh0aGlzLCBjdHgsIG9uQ29tbWVudCk7XG5cbiAgICAgIHRoaXMudmFsdWUgPSBzZXE7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXJnZTtcbn0oUGFpcik7XG5cbnZhciBiaW5hcnlPcHRpb25zID0ge1xuICBkZWZhdWx0VHlwZTogVHlwZS5CTE9DS19MSVRFUkFMLFxuICBsaW5lV2lkdGg6IDc2XG59O1xudmFyIGJvb2xPcHRpb25zID0ge1xuICB0cnVlU3RyOiAndHJ1ZScsXG4gIGZhbHNlU3RyOiAnZmFsc2UnXG59O1xudmFyIGludE9wdGlvbnMgPSB7XG4gIGFzQmlnSW50OiBmYWxzZVxufTtcbnZhciBudWxsT3B0aW9ucyA9IHtcbiAgbnVsbFN0cjogJ251bGwnXG59O1xudmFyIHN0ck9wdGlvbnMgPSB7XG4gIGRlZmF1bHRUeXBlOiBUeXBlLlBMQUlOLFxuICBkb3VibGVRdW90ZWQ6IHtcbiAgICBqc29uRW5jb2Rpbmc6IGZhbHNlLFxuICAgIG1pbk11bHRpTGluZUxlbmd0aDogNDBcbiAgfSxcbiAgZm9sZDoge1xuICAgIGxpbmVXaWR0aDogODAsXG4gICAgbWluQ29udGVudFdpZHRoOiAyMFxuICB9XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlU2NhbGFyKHN0ciwgdGFncywgc2NhbGFyRmFsbGJhY2spIHtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRhZ3MpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3N0ZXAudmFsdWUsXG4gICAgICAgICAgZm9ybWF0ID0gX3N0ZXAkdmFsdWUuZm9ybWF0LFxuICAgICAgICAgIHRlc3QgPSBfc3RlcCR2YWx1ZS50ZXN0LFxuICAgICAgICAgIHJlc29sdmUgPSBfc3RlcCR2YWx1ZS5yZXNvbHZlO1xuXG4gICAgICBpZiAodGVzdCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2godGVzdCk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IHJlc29sdmUuYXBwbHkobnVsbCwgbWF0Y2gpO1xuICAgICAgICAgIGlmICghKHJlcyBpbnN0YW5jZW9mIFNjYWxhcikpIHJlcyA9IG5ldyBTY2FsYXIocmVzKTtcbiAgICAgICAgICBpZiAoZm9ybWF0KSByZXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIGlmIChzY2FsYXJGYWxsYmFjaykgc3RyID0gc2NhbGFyRmFsbGJhY2soc3RyKTtcbiAgcmV0dXJuIG5ldyBTY2FsYXIoc3RyKTtcbn1cblxudmFyIEZPTERfRkxPVyA9ICdmbG93JztcbnZhciBGT0xEX0JMT0NLID0gJ2Jsb2NrJztcbnZhciBGT0xEX1FVT1RFRCA9ICdxdW90ZWQnOyAvLyBwcmVzdW1lcyBpKzEgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZVxuLy8gcmV0dXJucyBpbmRleCBvZiBsYXN0IG5ld2xpbmUgaW4gbW9yZS1pbmRlbnRlZCBibG9ja1xuXG52YXIgY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzID0gZnVuY3Rpb24gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGkpIHtcbiAgdmFyIGNoID0gdGV4dFtpICsgMV07XG5cbiAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgZG8ge1xuICAgICAgY2ggPSB0ZXh0W2kgKz0gMV07XG4gICAgfSB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nKTtcblxuICAgIGNoID0gdGV4dFtpICsgMV07XG4gIH1cblxuICByZXR1cm4gaTtcbn07XG4vKipcbiAqIFRyaWVzIHRvIGtlZXAgaW5wdXQgYXQgdXAgdG8gYGxpbmVXaWR0aGAgY2hhcmFjdGVycywgc3BsaXR0aW5nIG9ubHkgb24gc3BhY2VzXG4gKiBub3QgZm9sbG93ZWQgYnkgbmV3bGluZXMgb3Igc3BhY2VzIHVubGVzcyBgbW9kZWAgaXMgYCdxdW90ZWQnYC4gTGluZXMgYXJlXG4gKiB0ZXJtaW5hdGVkIHdpdGggYFxcbmAgYW5kIHN0YXJ0ZWQgd2l0aCBgaW5kZW50YC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGluZGVudFxuICogQHBhcmFtIHtzdHJpbmd9IFttb2RlPSdmbG93J10gYCdibG9jaydgIHByZXZlbnRzIG1vcmUtaW5kZW50ZWQgbGluZXNcbiAqICAgZnJvbSBiZWluZyBmb2xkZWQ7IGAncXVvdGVkJ2AgYWxsb3dzIGZvciBgXFxgIGVzY2FwZXMsIGluY2x1ZGluZyBlc2NhcGVkXG4gKiAgIG5ld2xpbmVzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmluZGVudEF0U3RhcnRdIEFjY291bnRzIGZvciBsZWFkaW5nIGNvbnRlbnRzIG9uXG4gKiAgIHRoZSBmaXJzdCBsaW5lLCBkZWZhdWx0aW5nIHRvIGBpbmRlbnQubGVuZ3RoYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbmVXaWR0aD04MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5Db250ZW50V2lkdGg9MjBdIEFsbG93IGhpZ2hseSBpbmRlbnRlZCBsaW5lcyB0b1xuICogICBzdHJldGNoIHRoZSBsaW5lIHdpZHRoIG9yIGluZGVudCBjb250ZW50IGZyb20gdGhlIHN0YXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLm9uRm9sZCBDYWxsZWQgb25jZSBpZiB0aGUgdGV4dCBpcyBmb2xkZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMub25Gb2xkIENhbGxlZCBvbmNlIGlmIGFueSBsaW5lIG9mIHRleHQgZXhjZWVkc1xuICogICBsaW5lV2lkdGggY2hhcmFjdGVyc1xuICovXG5cblxuZnVuY3Rpb24gZm9sZEZsb3dMaW5lcyh0ZXh0LCBpbmRlbnQsIG1vZGUsIF9yZWYpIHtcbiAgdmFyIGluZGVudEF0U3RhcnQgPSBfcmVmLmluZGVudEF0U3RhcnQsXG4gICAgICBfcmVmJGxpbmVXaWR0aCA9IF9yZWYubGluZVdpZHRoLFxuICAgICAgbGluZVdpZHRoID0gX3JlZiRsaW5lV2lkdGggPT09IHZvaWQgMCA/IDgwIDogX3JlZiRsaW5lV2lkdGgsXG4gICAgICBfcmVmJG1pbkNvbnRlbnRXaWR0aCA9IF9yZWYubWluQ29udGVudFdpZHRoLFxuICAgICAgbWluQ29udGVudFdpZHRoID0gX3JlZiRtaW5Db250ZW50V2lkdGggPT09IHZvaWQgMCA/IDIwIDogX3JlZiRtaW5Db250ZW50V2lkdGgsXG4gICAgICBvbkZvbGQgPSBfcmVmLm9uRm9sZCxcbiAgICAgIG9uT3ZlcmZsb3cgPSBfcmVmLm9uT3ZlcmZsb3c7XG4gIGlmICghbGluZVdpZHRoIHx8IGxpbmVXaWR0aCA8IDApIHJldHVybiB0ZXh0O1xuICB2YXIgZW5kU3RlcCA9IE1hdGgubWF4KDEgKyBtaW5Db250ZW50V2lkdGgsIDEgKyBsaW5lV2lkdGggLSBpbmRlbnQubGVuZ3RoKTtcbiAgaWYgKHRleHQubGVuZ3RoIDw9IGVuZFN0ZXApIHJldHVybiB0ZXh0O1xuICB2YXIgZm9sZHMgPSBbXTtcbiAgdmFyIGVzY2FwZWRGb2xkcyA9IHt9O1xuICB2YXIgZW5kID0gbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aDtcblxuICBpZiAodHlwZW9mIGluZGVudEF0U3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGluZGVudEF0U3RhcnQgPiBsaW5lV2lkdGggLSBNYXRoLm1heCgyLCBtaW5Db250ZW50V2lkdGgpKSBmb2xkcy5wdXNoKDApO2Vsc2UgZW5kID0gbGluZVdpZHRoIC0gaW5kZW50QXRTdGFydDtcbiAgfVxuXG4gIHZhciBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXYgPSB1bmRlZmluZWQ7XG4gIHZhciBvdmVyZmxvdyA9IGZhbHNlO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgZXNjU3RhcnQgPSAtMTtcbiAgdmFyIGVzY0VuZCA9IC0xO1xuXG4gIGlmIChtb2RlID09PSBGT0xEX0JMT0NLKSB7XG4gICAgaSA9IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpKTtcbiAgICBpZiAoaSAhPT0gLTEpIGVuZCA9IGkgKyBlbmRTdGVwO1xuICB9XG5cbiAgZm9yICh2YXIgY2g7IGNoID0gdGV4dFtpICs9IDFdOykge1xuICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICBlc2NTdGFydCA9IGk7XG5cbiAgICAgIHN3aXRjaCAodGV4dFtpICsgMV0pIHtcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgaSArPSAzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGVzY0VuZCA9IGk7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgaWYgKG1vZGUgPT09IEZPTERfQkxPQ0spIGkgPSBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSk7XG4gICAgICBlbmQgPSBpICsgZW5kU3RlcDtcbiAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2ggPT09ICcgJyAmJiBwcmV2ICYmIHByZXYgIT09ICcgJyAmJiBwcmV2ICE9PSAnXFxuJyAmJiBwcmV2ICE9PSAnXFx0Jykge1xuICAgICAgICAvLyBzcGFjZSBzdXJyb3VuZGVkIGJ5IG5vbi1zcGFjZSBjYW4gYmUgcmVwbGFjZWQgd2l0aCBuZXdsaW5lICsgaW5kZW50XG4gICAgICAgIHZhciBuZXh0ID0gdGV4dFtpICsgMV07XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09ICcgJyAmJiBuZXh0ICE9PSAnXFxuJyAmJiBuZXh0ICE9PSAnXFx0Jykgc3BsaXQgPSBpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+PSBlbmQpIHtcbiAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgZm9sZHMucHVzaChzcGxpdCk7XG4gICAgICAgICAgZW5kID0gc3BsaXQgKyBlbmRTdGVwO1xuICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEKSB7XG4gICAgICAgICAgLy8gd2hpdGUtc3BhY2UgY29sbGVjdGVkIGF0IGVuZCBtYXkgc3RyZXRjaCBwYXN0IGxpbmVXaWR0aFxuICAgICAgICAgIHdoaWxlIChwcmV2ID09PSAnICcgfHwgcHJldiA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIHByZXYgPSBjaDtcbiAgICAgICAgICAgIGNoID0gdGV4dFtpICs9IDFdO1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgIH0gLy8gQWNjb3VudCBmb3IgbmV3bGluZSBlc2NhcGUsIGJ1dCBkb24ndCBicmVhayBwcmVjZWRpbmcgZXNjYXBlXG5cblxuICAgICAgICAgIHZhciBqID0gaSA+IGVzY0VuZCArIDEgPyBpIC0gMiA6IGVzY1N0YXJ0IC0gMTsgLy8gQmFpbCBvdXQgaWYgbGluZVdpZHRoICYgbWluQ29udGVudFdpZHRoIGFyZSBzaG9ydGVyIHRoYW4gYW4gZXNjYXBlIHN0cmluZ1xuXG4gICAgICAgICAgaWYgKGVzY2FwZWRGb2xkc1tqXSkgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgZm9sZHMucHVzaChqKTtcbiAgICAgICAgICBlc2NhcGVkRm9sZHNbal0gPSB0cnVlO1xuICAgICAgICAgIGVuZCA9IGogKyBlbmRTdGVwO1xuICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHByZXYgPSBjaDtcbiAgfVxuXG4gIGlmIChvdmVyZmxvdyAmJiBvbk92ZXJmbG93KSBvbk92ZXJmbG93KCk7XG4gIGlmIChmb2xkcy5sZW5ndGggPT09IDApIHJldHVybiB0ZXh0O1xuICBpZiAob25Gb2xkKSBvbkZvbGQoKTtcbiAgdmFyIHJlcyA9IHRleHQuc2xpY2UoMCwgZm9sZHNbMF0pO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBmb2xkcy5sZW5ndGg7ICsrX2kpIHtcbiAgICB2YXIgZm9sZCA9IGZvbGRzW19pXTtcblxuICAgIHZhciBfZW5kID0gZm9sZHNbX2kgKyAxXSB8fCB0ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChmb2xkID09PSAwKSByZXMgPSBcIlxcblwiLmNvbmNhdChpbmRlbnQpLmNvbmNhdCh0ZXh0LnNsaWNlKDAsIF9lbmQpKTtlbHNlIHtcbiAgICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBlc2NhcGVkRm9sZHNbZm9sZF0pIHJlcyArPSBcIlwiLmNvbmNhdCh0ZXh0W2ZvbGRdLCBcIlxcXFxcIik7XG4gICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoaW5kZW50KS5jb25jYXQodGV4dC5zbGljZShmb2xkICsgMSwgX2VuZCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbnZhciBnZXRGb2xkT3B0aW9ucyA9IGZ1bmN0aW9uIGdldEZvbGRPcHRpb25zKF9yZWYpIHtcbiAgdmFyIGluZGVudEF0U3RhcnQgPSBfcmVmLmluZGVudEF0U3RhcnQ7XG4gIHJldHVybiBpbmRlbnRBdFN0YXJ0ID8gT2JqZWN0LmFzc2lnbih7XG4gICAgaW5kZW50QXRTdGFydDogaW5kZW50QXRTdGFydFxuICB9LCBzdHJPcHRpb25zLmZvbGQpIDogc3RyT3B0aW9ucy5mb2xkO1xufTsgLy8gQWxzbyBjaGVja3MgZm9yIGxpbmVzIHN0YXJ0aW5nIHdpdGggJSwgYXMgcGFyc2luZyB0aGUgb3V0cHV0IGFzIFlBTUwgMS4xIHdpbGxcbi8vIHByZXN1bWUgdGhhdCdzIHN0YXJ0aW5nIGEgbmV3IGRvY3VtZW50LlxuXG5cbnZhciBjb250YWluc0RvY3VtZW50TWFya2VyID0gZnVuY3Rpb24gY29udGFpbnNEb2N1bWVudE1hcmtlcihzdHIpIHtcbiAgcmV0dXJuIC9eKCV8LS0tfFxcLlxcLlxcLikvbS50ZXN0KHN0cik7XG59O1xuXG5mdW5jdGlvbiBsaW5lTGVuZ3RoT3ZlckxpbWl0KHN0ciwgbGluZVdpZHRoLCBpbmRlbnRMZW5ndGgpIHtcbiAgaWYgKCFsaW5lV2lkdGggfHwgbGluZVdpZHRoIDwgMCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgbGltaXQgPSBsaW5lV2lkdGggLSBpbmRlbnRMZW5ndGg7XG4gIHZhciBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuICBpZiAoc3RyTGVuIDw9IGxpbWl0KSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDAsIHN0YXJ0ID0gMDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gJ1xcbicpIHtcbiAgICAgIGlmIChpIC0gc3RhcnQgPiBsaW1pdCkgcmV0dXJuIHRydWU7XG4gICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgaWYgKHN0ckxlbiAtIHN0YXJ0IDw9IGxpbWl0KSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gIHZhciBpbXBsaWNpdEtleSA9IGN0eC5pbXBsaWNpdEtleTtcbiAgdmFyIF9zdHJPcHRpb25zJGRvdWJsZVF1byA9IHN0ck9wdGlvbnMuZG91YmxlUXVvdGVkLFxuICAgICAganNvbkVuY29kaW5nID0gX3N0ck9wdGlvbnMkZG91YmxlUXVvLmpzb25FbmNvZGluZyxcbiAgICAgIG1pbk11bHRpTGluZUxlbmd0aCA9IF9zdHJPcHRpb25zJGRvdWJsZVF1by5taW5NdWx0aUxpbmVMZW5ndGg7XG4gIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICBpZiAoanNvbkVuY29kaW5nKSByZXR1cm4ganNvbjtcbiAgdmFyIGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgc3RhcnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBjaCA9IGpzb25baV07IGNoOyBjaCA9IGpzb25bKytpXSkge1xuICAgIGlmIChjaCA9PT0gJyAnICYmIGpzb25baSArIDFdID09PSAnXFxcXCcgJiYganNvbltpICsgMl0gPT09ICduJykge1xuICAgICAgLy8gc3BhY2UgYmVmb3JlIG5ld2xpbmUgbmVlZHMgdG8gYmUgZXNjYXBlZCB0byBub3QgYmUgZm9sZGVkXG4gICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxcXCAnO1xuICAgICAgaSArPSAxO1xuICAgICAgc3RhcnQgPSBpO1xuICAgICAgY2ggPSAnXFxcXCc7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnXFxcXCcpIHN3aXRjaCAoanNvbltpICsgMV0pIHtcbiAgICAgIGNhc2UgJ3UnOlxuICAgICAgICB7XG4gICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgIHZhciBjb2RlID0ganNvbi5zdWJzdHIoaSArIDIsIDQpO1xuXG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlICcwMDAwJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcMCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDA3JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcYSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDBiJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDFiJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcZSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDg1JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMGEwJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcXyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcyMDI4JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcyMDI5JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcUCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoY29kZS5zdWJzdHIoMCwgMikgPT09ICcwMCcpIHN0ciArPSAnXFxcXHgnICsgY29kZS5zdWJzdHIoMik7ZWxzZSBzdHIgKz0ganNvbi5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA1O1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ24nOlxuICAgICAgICBpZiAoaW1wbGljaXRLZXkgfHwganNvbltpICsgMl0gPT09ICdcIicgfHwganNvbi5sZW5ndGggPCBtaW5NdWx0aUxpbmVMZW5ndGgpIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZm9sZGluZyB3aWxsIGVhdCBmaXJzdCBuZXdsaW5lXG4gICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcblxcbic7XG5cbiAgICAgICAgICB3aGlsZSAoanNvbltpICsgMl0gPT09ICdcXFxcJyAmJiBqc29uW2kgKyAzXSA9PT0gJ24nICYmIGpzb25baSArIDRdICE9PSAnXCInKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyICs9IGluZGVudDsgLy8gc3BhY2UgYWZ0ZXIgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcblxuICAgICAgICAgIGlmIChqc29uW2kgKyAyXSA9PT0gJyAnKSBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGkgKz0gMTtcbiAgICB9XG4gIH1cblxuICBzdHIgPSBzdGFydCA/IHN0ciArIGpzb24uc2xpY2Uoc3RhcnQpIDoganNvbjtcbiAgcmV0dXJuIGltcGxpY2l0S2V5ID8gc3RyIDogZm9sZEZsb3dMaW5lcyhzdHIsIGluZGVudCwgRk9MRF9RVU9URUQsIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICBpZiAoY3R4LmltcGxpY2l0S2V5KSB7XG4gICAgaWYgKC9cXG4vLnRlc3QodmFsdWUpKSByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHNpbmdsZSBxdW90ZWQgc3RyaW5nIGNhbid0IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBuZXdsaW5lXG4gICAgaWYgKC9bIFxcdF1cXG58XFxuWyBcXHRdLy50ZXN0KHZhbHVlKSkgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgfVxuXG4gIHZhciBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gIHZhciByZXMgPSBcIidcIiArIHZhbHVlLnJlcGxhY2UoLycvZywgXCInJ1wiKS5yZXBsYWNlKC9cXG4rL2csIFwiJCZcXG5cIi5jb25jYXQoaW5kZW50KSkgKyBcIidcIjtcbiAgcmV0dXJuIGN0eC5pbXBsaWNpdEtleSA/IHJlcyA6IGZvbGRGbG93TGluZXMocmVzLCBpbmRlbnQsIEZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5cbmZ1bmN0aW9uIGJsb2NrU3RyaW5nKF9yZWYyLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgdmFyIGNvbW1lbnQgPSBfcmVmMi5jb21tZW50LFxuICAgICAgdHlwZSA9IF9yZWYyLnR5cGUsXG4gICAgICB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuXG4gIC8vIDEuIEJsb2NrIGNhbid0IGVuZCBpbiB3aGl0ZXNwYWNlIHVubGVzcyB0aGUgbGFzdCBsaW5lIGlzIG5vbi1lbXB0eS5cbiAgLy8gMi4gU3RyaW5ncyBjb25zaXN0aW5nIG9mIG9ubHkgd2hpdGVzcGFjZSBhcmUgYmVzdCByZW5kZXJlZCBleHBsaWNpdGx5LlxuICBpZiAoL1xcbltcXHQgXSskLy50ZXN0KHZhbHVlKSB8fCAvXlxccyokLy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gIH1cblxuICB2YXIgaW5kZW50ID0gY3R4LmluZGVudCB8fCAoY3R4LmZvcmNlQmxvY2tJbmRlbnQgfHwgY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkgPyAnICAnIDogJycpO1xuICB2YXIgaW5kZW50U2l6ZSA9IGluZGVudCA/ICcyJyA6ICcxJzsgLy8gcm9vdCBpcyBhdCAtMVxuXG4gIHZhciBsaXRlcmFsID0gdHlwZSA9PT0gVHlwZS5CTE9DS19GT0xERUQgPyBmYWxzZSA6IHR5cGUgPT09IFR5cGUuQkxPQ0tfTElURVJBTCA/IHRydWUgOiAhbGluZUxlbmd0aE92ZXJMaW1pdCh2YWx1ZSwgc3RyT3B0aW9ucy5mb2xkLmxpbmVXaWR0aCwgaW5kZW50Lmxlbmd0aCk7XG4gIHZhciBoZWFkZXIgPSBsaXRlcmFsID8gJ3wnIDogJz4nO1xuICBpZiAoIXZhbHVlKSByZXR1cm4gaGVhZGVyICsgJ1xcbic7XG4gIHZhciB3c1N0YXJ0ID0gJyc7XG4gIHZhciB3c0VuZCA9ICcnO1xuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1tcXG5cXHQgXSokLywgZnVuY3Rpb24gKHdzKSB7XG4gICAgdmFyIG4gPSB3cy5pbmRleE9mKCdcXG4nKTtcblxuICAgIGlmIChuID09PSAtMSkge1xuICAgICAgaGVhZGVyICs9ICctJzsgLy8gc3RyaXBcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB3cyB8fCBuICE9PSB3cy5sZW5ndGggLSAxKSB7XG4gICAgICBoZWFkZXIgKz0gJysnOyAvLyBrZWVwXG5cbiAgICAgIGlmIChvbkNob21wS2VlcCkgb25DaG9tcEtlZXAoKTtcbiAgICB9XG5cbiAgICB3c0VuZCA9IHdzLnJlcGxhY2UoL1xcbiQvLCAnJyk7XG4gICAgcmV0dXJuICcnO1xuICB9KS5yZXBsYWNlKC9eW1xcbiBdKi8sIGZ1bmN0aW9uICh3cykge1xuICAgIGlmICh3cy5pbmRleE9mKCcgJykgIT09IC0xKSBoZWFkZXIgKz0gaW5kZW50U2l6ZTtcbiAgICB2YXIgbSA9IHdzLm1hdGNoKC8gKyQvKTtcblxuICAgIGlmIChtKSB7XG4gICAgICB3c1N0YXJ0ID0gd3Muc2xpY2UoMCwgLW1bMF0ubGVuZ3RoKTtcbiAgICAgIHJldHVybiBtWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB3c1N0YXJ0ID0gd3M7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9KTtcbiAgaWYgKHdzRW5kKSB3c0VuZCA9IHdzRW5kLnJlcGxhY2UoL1xcbisoPyFcXG58JCkvZywgXCIkJlwiLmNvbmNhdChpbmRlbnQpKTtcbiAgaWYgKHdzU3RhcnQpIHdzU3RhcnQgPSB3c1N0YXJ0LnJlcGxhY2UoL1xcbisvZywgXCIkJlwiLmNvbmNhdChpbmRlbnQpKTtcblxuICBpZiAoY29tbWVudCkge1xuICAgIGhlYWRlciArPSAnICMnICsgY29tbWVudC5yZXBsYWNlKC8gP1tcXHJcXG5dKy9nLCAnICcpO1xuICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIFwiXCIuY29uY2F0KGhlYWRlcikuY29uY2F0KGluZGVudFNpemUsIFwiXFxuXCIpLmNvbmNhdChpbmRlbnQpLmNvbmNhdCh3c0VuZCk7XG5cbiAgaWYgKGxpdGVyYWwpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgXCIkJlwiLmNvbmNhdChpbmRlbnQpKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoaGVhZGVyLCBcIlxcblwiKS5jb25jYXQoaW5kZW50KS5jb25jYXQod3NTdGFydCkuY29uY2F0KHZhbHVlKS5jb25jYXQod3NFbmQpO1xuICB9XG5cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csICdcXG4kJicpLnJlcGxhY2UoLyg/Ol58XFxuKShbXFx0IF0uKikoPzooW1xcblxcdCBdKilcXG4oPyFbXFxuXFx0IF0pKT8vZywgJyQxJDInKSAvLyBtb3JlLWluZGVudGVkIGxpbmVzIGFyZW4ndCBmb2xkZWRcbiAgLy8gICAgICAgICBeIGluZC5saW5lICBeIGVtcHR5ICAgICBeIGNhcHR1cmUgbmV4dCBlbXB0eSBsaW5lcyBvbmx5IGF0IGVuZCBvZiBpbmRlbnRcbiAgLnJlcGxhY2UoL1xcbisvZywgXCIkJlwiLmNvbmNhdChpbmRlbnQpKTtcbiAgdmFyIGJvZHkgPSBmb2xkRmxvd0xpbmVzKFwiXCIuY29uY2F0KHdzU3RhcnQpLmNvbmNhdCh2YWx1ZSkuY29uY2F0KHdzRW5kKSwgaW5kZW50LCBGT0xEX0JMT0NLLCBzdHJPcHRpb25zLmZvbGQpO1xuICByZXR1cm4gXCJcIi5jb25jYXQoaGVhZGVyLCBcIlxcblwiKS5jb25jYXQoaW5kZW50KS5jb25jYXQoYm9keSk7XG59XG5cbmZ1bmN0aW9uIHBsYWluU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICB2YXIgY29tbWVudCA9IGl0ZW0uY29tbWVudCxcbiAgICAgIHR5cGUgPSBpdGVtLnR5cGUsXG4gICAgICB2YWx1ZSA9IGl0ZW0udmFsdWU7XG4gIHZhciBhY3R1YWxTdHJpbmcgPSBjdHguYWN0dWFsU3RyaW5nLFxuICAgICAgaW1wbGljaXRLZXkgPSBjdHguaW1wbGljaXRLZXksXG4gICAgICBpbmRlbnQgPSBjdHguaW5kZW50LFxuICAgICAgaW5GbG93ID0gY3R4LmluRmxvdztcblxuICBpZiAoaW1wbGljaXRLZXkgJiYgL1tcXG5bXFxde30sXS8udGVzdCh2YWx1ZSkgfHwgaW5GbG93ICYmIC9bW1xcXXt9LF0vLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgfVxuXG4gIGlmICghdmFsdWUgfHwgL15bXFxuXFx0ICxbXFxde30jJiohfD4nXCIlQGBdfF5bPy1dJHxeWz8tXVsgXFx0XXxbXFxuOl1bIFxcdF18WyBcXHRdXFxufFtcXG5cXHQgXSN8W1xcblxcdCA6XSQvLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gbm90IGFsbG93ZWQ6XG4gICAgLy8gLSBlbXB0eSBzdHJpbmcsICctJyBvciAnPydcbiAgICAvLyAtIHN0YXJ0IHdpdGggYW4gaW5kaWNhdG9yIGNoYXJhY3RlciAoZXhjZXB0IFs/Oi1dKSBvciAvWz8tXSAvXG4gICAgLy8gLSAnXFxuICcsICc6ICcgb3IgJyBcXG4nIGFueXdoZXJlXG4gICAgLy8gLSAnIycgbm90IHByZWNlZGVkIGJ5IGEgbm9uLXNwYWNlIGNoYXJcbiAgICAvLyAtIGVuZCB3aXRoICcgJyBvciAnOidcbiAgICByZXR1cm4gaW1wbGljaXRLZXkgfHwgaW5GbG93IHx8IHZhbHVlLmluZGV4T2YoJ1xcbicpID09PSAtMSA/IHZhbHVlLmluZGV4T2YoJ1wiJykgIT09IC0xICYmIHZhbHVlLmluZGV4T2YoXCInXCIpID09PSAtMSA/IHNpbmdsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSA6IGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSA6IGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIH1cblxuICBpZiAoIWltcGxpY2l0S2V5ICYmICFpbkZsb3cgJiYgdHlwZSAhPT0gVHlwZS5QTEFJTiAmJiB2YWx1ZS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAvLyBXaGVyZSBhbGxvd2VkICYgdHlwZSBub3Qgc2V0IGV4cGxpY2l0bHksIHByZWZlciBibG9jayBzdHlsZSBmb3IgbXVsdGlsaW5lIHN0cmluZ3NcbiAgICByZXR1cm4gYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfVxuXG4gIGlmIChpbmRlbnQgPT09ICcnICYmIGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpKSB7XG4gICAgY3R4LmZvcmNlQmxvY2tJbmRlbnQgPSB0cnVlO1xuICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICB9XG5cbiAgdmFyIHN0ciA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgXCIkJlxcblwiLmNvbmNhdChpbmRlbnQpKTsgLy8gVmVyaWZ5IHRoYXQgb3V0cHV0IHdpbGwgYmUgcGFyc2VkIGFzIGEgc3RyaW5nLCBhcyBlLmcuIHBsYWluIG51bWJlcnMgYW5kXG4gIC8vIGJvb2xlYW5zIGdldCBwYXJzZWQgd2l0aCB0aG9zZSB0eXBlcyBpbiB2MS4yIChlLmcuICc0MicsICd0cnVlJyAmICcwLjllLTMnKSxcbiAgLy8gYW5kIG90aGVycyBpbiB2MS4xLlxuXG4gIGlmIChhY3R1YWxTdHJpbmcpIHtcbiAgICB2YXIgdGFncyA9IGN0eC5kb2Muc2NoZW1hLnRhZ3M7XG4gICAgdmFyIHJlc29sdmVkID0gcmVzb2x2ZVNjYWxhcihzdHIsIHRhZ3MsIHRhZ3Muc2NhbGFyRmFsbGJhY2spLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgcmVzb2x2ZWQgIT09ICdzdHJpbmcnKSByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICB9XG5cbiAgdmFyIGJvZHkgPSBpbXBsaWNpdEtleSA/IHN0ciA6IGZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIEZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG5cbiAgaWYgKGNvbW1lbnQgJiYgIWluRmxvdyAmJiAoYm9keS5pbmRleE9mKCdcXG4nKSAhPT0gLTEgfHwgY29tbWVudC5pbmRleE9mKCdcXG4nKSAhPT0gLTEpKSB7XG4gICAgaWYgKG9uQ29tbWVudCkgb25Db21tZW50KCk7XG4gICAgcmV0dXJuIGFkZENvbW1lbnRCZWZvcmUoYm9keSwgaW5kZW50LCBjb21tZW50KTtcbiAgfVxuXG4gIHJldHVybiBib2R5O1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gIHZhciBkZWZhdWx0VHlwZSA9IHN0ck9wdGlvbnMuZGVmYXVsdFR5cGU7XG4gIHZhciBpbXBsaWNpdEtleSA9IGN0eC5pbXBsaWNpdEtleSxcbiAgICAgIGluRmxvdyA9IGN0eC5pbkZsb3c7XG4gIHZhciBfaXRlbSA9IGl0ZW0sXG4gICAgICB0eXBlID0gX2l0ZW0udHlwZSxcbiAgICAgIHZhbHVlID0gX2l0ZW0udmFsdWU7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0sIHtcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIF9zdHJpbmdpZnkgPSBmdW5jdGlvbiBfc3RyaW5naWZ5KF90eXBlKSB7XG4gICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgY2FzZSBUeXBlLkJMT0NLX0ZPTERFRDpcbiAgICAgIGNhc2UgVHlwZS5CTE9DS19MSVRFUkFMOlxuICAgICAgICByZXR1cm4gYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcblxuICAgICAgY2FzZSBUeXBlLlFVT1RFX0RPVUJMRTpcbiAgICAgICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcblxuICAgICAgY2FzZSBUeXBlLlFVT1RFX1NJTkdMRTpcbiAgICAgICAgcmV0dXJuIHNpbmdsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcblxuICAgICAgY2FzZSBUeXBlLlBMQUlOOlxuICAgICAgICByZXR1cm4gcGxhaW5TdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGlmICh0eXBlICE9PSBUeXBlLlFVT1RFX0RPVUJMRSAmJiAvW1xceDAwLVxceDA4XFx4MGItXFx4MWZcXHg3Zi1cXHg5Zl0vLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gZm9yY2UgZG91YmxlIHF1b3RlcyBvbiBjb250cm9sIGNoYXJhY3RlcnNcbiAgICB0eXBlID0gVHlwZS5RVU9URV9ET1VCTEU7XG4gIH0gZWxzZSBpZiAoKGltcGxpY2l0S2V5IHx8IGluRmxvdykgJiYgKHR5cGUgPT09IFR5cGUuQkxPQ0tfRk9MREVEIHx8IHR5cGUgPT09IFR5cGUuQkxPQ0tfTElURVJBTCkpIHtcbiAgICAvLyBzaG91bGQgbm90IGhhcHBlbjsgYmxvY2tzIGFyZSBub3QgdmFsaWQgaW5zaWRlIGZsb3cgY29udGFpbmVyc1xuICAgIHR5cGUgPSBUeXBlLlFVT1RFX0RPVUJMRTtcbiAgfVxuXG4gIHZhciByZXMgPSBfc3RyaW5naWZ5KHR5cGUpO1xuXG4gIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICByZXMgPSBfc3RyaW5naWZ5KGRlZmF1bHRUeXBlKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkZWZhdWx0IHN0cmluZyB0eXBlIFwiLmNvbmNhdChkZWZhdWx0VHlwZSkpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5TnVtYmVyKF9yZWYpIHtcbiAgdmFyIGZvcm1hdCA9IF9yZWYuZm9ybWF0LFxuICAgICAgbWluRnJhY3Rpb25EaWdpdHMgPSBfcmVmLm1pbkZyYWN0aW9uRGlnaXRzLFxuICAgICAgdGFnID0gX3JlZi50YWcsXG4gICAgICB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHJldHVybiBpc05hTih2YWx1ZSkgPyAnLm5hbicgOiB2YWx1ZSA8IDAgPyAnLS5pbmYnIDogJy5pbmYnO1xuICB2YXIgbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblxuICBpZiAoIWZvcm1hdCAmJiBtaW5GcmFjdGlvbkRpZ2l0cyAmJiAoIXRhZyB8fCB0YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcpICYmIC9eXFxkLy50ZXN0KG4pKSB7XG4gICAgdmFyIGkgPSBuLmluZGV4T2YoJy4nKTtcblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgaSA9IG4ubGVuZ3RoO1xuICAgICAgbiArPSAnLic7XG4gICAgfVxuXG4gICAgdmFyIGQgPSBtaW5GcmFjdGlvbkRpZ2l0cyAtIChuLmxlbmd0aCAtIGkgLSAxKTtcblxuICAgIHdoaWxlIChkLS0gPiAwKSB7XG4gICAgICBuICs9ICcwJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gY2hlY2tGbG93Q29sbGVjdGlvbkVuZChlcnJvcnMsIGNzdCkge1xuICB2YXIgY2hhciwgbmFtZTtcblxuICBzd2l0Y2ggKGNzdC50eXBlKSB7XG4gICAgY2FzZSBUeXBlLkZMT1dfTUFQOlxuICAgICAgY2hhciA9ICd9JztcbiAgICAgIG5hbWUgPSAnZmxvdyBtYXAnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFR5cGUuRkxPV19TRVE6XG4gICAgICBjaGFyID0gJ10nO1xuICAgICAgbmFtZSA9ICdmbG93IHNlcXVlbmNlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihjc3QsICdOb3QgYSBmbG93IGNvbGxlY3Rpb24hPycpKTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYXN0SXRlbTtcblxuICBmb3IgKHZhciBpID0gY3N0Lml0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIGl0ZW0gPSBjc3QuaXRlbXNbaV07XG5cbiAgICBpZiAoIWl0ZW0gfHwgaXRlbS50eXBlICE9PSBUeXBlLkNPTU1FTlQpIHtcbiAgICAgIGxhc3RJdGVtID0gaXRlbTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsYXN0SXRlbSAmJiBsYXN0SXRlbS5jaGFyICE9PSBjaGFyKSB7XG4gICAgdmFyIG1zZyA9IFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWUsIFwiIHRvIGVuZCB3aXRoIFwiKS5jb25jYXQoY2hhcik7XG4gICAgdmFyIGVycjtcblxuICAgIGlmICh0eXBlb2YgbGFzdEl0ZW0ub2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyID0gbmV3IFlBTUxTZW1hbnRpY0Vycm9yKGNzdCwgbXNnKTtcbiAgICAgIGVyci5vZmZzZXQgPSBsYXN0SXRlbS5vZmZzZXQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnIgPSBuZXcgWUFNTFNlbWFudGljRXJyb3IobGFzdEl0ZW0sIG1zZyk7XG4gICAgICBpZiAobGFzdEl0ZW0ucmFuZ2UgJiYgbGFzdEl0ZW0ucmFuZ2UuZW5kKSBlcnIub2Zmc2V0ID0gbGFzdEl0ZW0ucmFuZ2UuZW5kIC0gbGFzdEl0ZW0ucmFuZ2Uuc3RhcnQ7XG4gICAgfVxuXG4gICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tGbG93Q29tbWVudFNwYWNlKGVycm9ycywgY29tbWVudCkge1xuICB2YXIgcHJldiA9IGNvbW1lbnQuY29udGV4dC5zcmNbY29tbWVudC5yYW5nZS5zdGFydCAtIDFdO1xuXG4gIGlmIChwcmV2ICE9PSAnXFxuJyAmJiBwcmV2ICE9PSAnXFx0JyAmJiBwcmV2ICE9PSAnICcpIHtcbiAgICB2YXIgbXNnID0gJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnO1xuICAgIGVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihjb21tZW50LCBtc2cpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TG9uZ0tleUVycm9yKHNvdXJjZSwga2V5KSB7XG4gIHZhciBzayA9IFN0cmluZyhrZXkpO1xuICB2YXIgayA9IHNrLnN1YnN0cigwLCA4KSArICcuLi4nICsgc2suc3Vic3RyKC04KTtcbiAgcmV0dXJuIG5ldyBZQU1MU2VtYW50aWNFcnJvcihzb3VyY2UsIFwiVGhlIFxcXCJcIi5jb25jYXQoaywgXCJcXFwiIGtleSBpcyB0b28gbG9uZ1wiKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlQ29tbWVudHMoY29sbGVjdGlvbiwgY29tbWVudHMpIHtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNvbW1lbnRzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgIGFmdGVyS2V5ID0gX3N0ZXAkdmFsdWUuYWZ0ZXJLZXksXG4gICAgICAgICAgYmVmb3JlID0gX3N0ZXAkdmFsdWUuYmVmb3JlLFxuICAgICAgICAgIGNvbW1lbnQgPSBfc3RlcCR2YWx1ZS5jb21tZW50O1xuICAgICAgdmFyIGl0ZW0gPSBjb2xsZWN0aW9uLml0ZW1zW2JlZm9yZV07XG5cbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb24uY29tbWVudCkgY29sbGVjdGlvbi5jb21tZW50ICs9ICdcXG4nICsgY29tbWVudDtlbHNlIGNvbGxlY3Rpb24uY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhZnRlcktleSAmJiBpdGVtLnZhbHVlKSBpdGVtID0gaXRlbS52YWx1ZTtcblxuICAgICAgICBpZiAoY29tbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGFmdGVyS2V5IHx8ICFpdGVtLmNvbW1lbnRCZWZvcmUpIGl0ZW0uc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnRCZWZvcmUpIGl0ZW0uY29tbWVudEJlZm9yZSArPSAnXFxuJyArIGNvbW1lbnQ7ZWxzZSBpdGVtLmNvbW1lbnRCZWZvcmUgPSBjb21tZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbn1cblxuLy8gb24gZXJyb3IsIHdpbGwgcmV0dXJuIHsgc3RyOiBzdHJpbmcsIGVycm9yczogRXJyb3JbXSB9XG5mdW5jdGlvbiByZXNvbHZlU3RyaW5nKGRvYywgbm9kZSkge1xuICB2YXIgcmVzID0gbm9kZS5zdHJWYWx1ZTtcbiAgaWYgKCFyZXMpIHJldHVybiAnJztcbiAgaWYgKHR5cGVvZiByZXMgPT09ICdzdHJpbmcnKSByZXR1cm4gcmVzO1xuICByZXMuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgaWYgKCFlcnJvci5zb3VyY2UpIGVycm9yLnNvdXJjZSA9IG5vZGU7XG4gICAgZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgfSk7XG4gIHJldHVybiByZXMuc3RyO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFnSGFuZGxlKGRvYywgbm9kZSkge1xuICB2YXIgX25vZGUkdGFnID0gbm9kZS50YWcsXG4gICAgICBoYW5kbGUgPSBfbm9kZSR0YWcuaGFuZGxlLFxuICAgICAgc3VmZml4ID0gX25vZGUkdGFnLnN1ZmZpeDtcbiAgdmFyIHByZWZpeCA9IGRvYy50YWdQcmVmaXhlcy5maW5kKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAuaGFuZGxlID09PSBoYW5kbGU7XG4gIH0pO1xuXG4gIGlmICghcHJlZml4KSB7XG4gICAgdmFyIGR0cCA9IGRvYy5nZXREZWZhdWx0cygpLnRhZ1ByZWZpeGVzO1xuICAgIGlmIChkdHApIHByZWZpeCA9IGR0cC5maW5kKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcC5oYW5kbGUgPT09IGhhbmRsZTtcbiAgICB9KTtcbiAgICBpZiAoIXByZWZpeCkgdGhyb3cgbmV3IFlBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIFwiVGhlIFwiLmNvbmNhdChoYW5kbGUsIFwiIHRhZyBoYW5kbGUgaXMgbm9uLWRlZmF1bHQgYW5kIHdhcyBub3QgZGVjbGFyZWQuXCIpKTtcbiAgfVxuXG4gIGlmICghc3VmZml4KSB0aHJvdyBuZXcgWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgXCJUaGUgXCIuY29uY2F0KGhhbmRsZSwgXCIgdGFnIGhhcyBubyBzdWZmaXguXCIpKTtcblxuICBpZiAoaGFuZGxlID09PSAnIScgJiYgKGRvYy52ZXJzaW9uIHx8IGRvYy5vcHRpb25zLnZlcnNpb24pID09PSAnMS4wJykge1xuICAgIGlmIChzdWZmaXhbMF0gPT09ICdeJykge1xuICAgICAgZG9jLndhcm5pbmdzLnB1c2gobmV3IFlBTUxXYXJuaW5nKG5vZGUsICdZQU1MIDEuMCBeIHRhZyBleHBhbnNpb24gaXMgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgIHJldHVybiBzdWZmaXg7XG4gICAgfVxuXG4gICAgaWYgKC9bOi9dLy50ZXN0KHN1ZmZpeCkpIHtcbiAgICAgIC8vIHdvcmQvZm9vIC0+IHRhZzp3b3JkLnlhbWwub3JnLDIwMDI6Zm9vXG4gICAgICB2YXIgdm9jYWIgPSBzdWZmaXgubWF0Y2goL14oW2EtejAtOS1dKylcXC8oLiopL2kpO1xuICAgICAgcmV0dXJuIHZvY2FiID8gXCJ0YWc6XCIuY29uY2F0KHZvY2FiWzFdLCBcIi55YW1sLm9yZywyMDAyOlwiKS5jb25jYXQodm9jYWJbMl0pIDogXCJ0YWc6XCIuY29uY2F0KHN1ZmZpeCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZWZpeC5wcmVmaXggKyBkZWNvZGVVUklDb21wb25lbnQoc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhZ05hbWUoZG9jLCBub2RlKSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZyxcbiAgICAgIHR5cGUgPSBub2RlLnR5cGU7XG4gIHZhciBub25TcGVjaWZpYyA9IGZhbHNlO1xuXG4gIGlmICh0YWcpIHtcbiAgICB2YXIgaGFuZGxlID0gdGFnLmhhbmRsZSxcbiAgICAgICAgc3VmZml4ID0gdGFnLnN1ZmZpeCxcbiAgICAgICAgdmVyYmF0aW0gPSB0YWcudmVyYmF0aW07XG5cbiAgICBpZiAodmVyYmF0aW0pIHtcbiAgICAgIGlmICh2ZXJiYXRpbSAhPT0gJyEnICYmIHZlcmJhdGltICE9PSAnISEnKSByZXR1cm4gdmVyYmF0aW07XG4gICAgICB2YXIgbXNnID0gXCJWZXJiYXRpbSB0YWdzIGFyZW4ndCByZXNvbHZlZCwgc28gXCIuY29uY2F0KHZlcmJhdGltLCBcIiBpcyBpbnZhbGlkLlwiKTtcbiAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgbXNnKSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGUgPT09ICchJyAmJiAhc3VmZml4KSB7XG4gICAgICBub25TcGVjaWZpYyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlVGFnSGFuZGxlKGRvYywgbm9kZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkb2MuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgVHlwZS5CTE9DS19GT0xERUQ6XG4gICAgY2FzZSBUeXBlLkJMT0NLX0xJVEVSQUw6XG4gICAgY2FzZSBUeXBlLlFVT1RFX0RPVUJMRTpcbiAgICBjYXNlIFR5cGUuUVVPVEVfU0lOR0xFOlxuICAgICAgcmV0dXJuIGRlZmF1bHRUYWdzLlNUUjtcblxuICAgIGNhc2UgVHlwZS5GTE9XX01BUDpcbiAgICBjYXNlIFR5cGUuTUFQOlxuICAgICAgcmV0dXJuIGRlZmF1bHRUYWdzLk1BUDtcblxuICAgIGNhc2UgVHlwZS5GTE9XX1NFUTpcbiAgICBjYXNlIFR5cGUuU0VROlxuICAgICAgcmV0dXJuIGRlZmF1bHRUYWdzLlNFUTtcblxuICAgIGNhc2UgVHlwZS5QTEFJTjpcbiAgICAgIHJldHVybiBub25TcGVjaWZpYyA/IGRlZmF1bHRUYWdzLlNUUiA6IG51bGw7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUJ5VGFnTmFtZShkb2MsIG5vZGUsIHRhZ05hbWUpIHtcbiAgdmFyIHRhZ3MgPSBkb2Muc2NoZW1hLnRhZ3M7XG4gIHZhciBtYXRjaFdpdGhUZXN0ID0gW107XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRhZ3MpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIHRhZyA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAodGFnLnRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBpZiAodGFnLnRlc3QpIG1hdGNoV2l0aFRlc3QucHVzaCh0YWcpO2Vsc2Uge1xuICAgICAgICAgIHZhciByZXMgPSB0YWcucmVzb2x2ZShkb2MsIG5vZGUpO1xuICAgICAgICAgIHJldHVybiByZXMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uID8gcmVzIDogbmV3IFNjYWxhcihyZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICB2YXIgc3RyID0gcmVzb2x2ZVN0cmluZyhkb2MsIG5vZGUpO1xuICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgbWF0Y2hXaXRoVGVzdC5sZW5ndGggPiAwKSByZXR1cm4gcmVzb2x2ZVNjYWxhcihzdHIsIG1hdGNoV2l0aFRlc3QsIHRhZ3Muc2NhbGFyRmFsbGJhY2spO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RmFsbGJhY2tUYWdOYW1lKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGU7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBUeXBlLkZMT1dfTUFQOlxuICAgIGNhc2UgVHlwZS5NQVA6XG4gICAgICByZXR1cm4gZGVmYXVsdFRhZ3MuTUFQO1xuXG4gICAgY2FzZSBUeXBlLkZMT1dfU0VROlxuICAgIGNhc2UgVHlwZS5TRVE6XG4gICAgICByZXR1cm4gZGVmYXVsdFRhZ3MuU0VRO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkZWZhdWx0VGFncy5TVFI7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhZyhkb2MsIG5vZGUsIHRhZ05hbWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcmVzID0gcmVzb2x2ZUJ5VGFnTmFtZShkb2MsIG5vZGUsIHRhZ05hbWUpO1xuXG4gICAgaWYgKHJlcykge1xuICAgICAgaWYgKHRhZ05hbWUgJiYgbm9kZS50YWcpIHJlcy50YWcgPSB0YWdOYW1lO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFlcnJvci5zb3VyY2UpIGVycm9yLnNvdXJjZSA9IG5vZGU7XG4gICAgZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGZhbGxiYWNrID0gZ2V0RmFsbGJhY2tUYWdOYW1lKG5vZGUpO1xuICAgIGlmICghZmFsbGJhY2spIHRocm93IG5ldyBFcnJvcihcIlRoZSB0YWcgXCIuY29uY2F0KHRhZ05hbWUsIFwiIGlzIHVuYXZhaWxhYmxlXCIpKTtcbiAgICB2YXIgbXNnID0gXCJUaGUgdGFnIFwiLmNvbmNhdCh0YWdOYW1lLCBcIiBpcyB1bmF2YWlsYWJsZSwgZmFsbGluZyBiYWNrIHRvIFwiKS5jb25jYXQoZmFsbGJhY2spO1xuICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBZQU1MV2FybmluZyhub2RlLCBtc2cpKTtcblxuICAgIHZhciBfcmVzID0gcmVzb2x2ZUJ5VGFnTmFtZShkb2MsIG5vZGUsIGZhbGxiYWNrKTtcblxuICAgIF9yZXMudGFnID0gdGFnTmFtZTtcbiAgICByZXR1cm4gX3JlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB2YXIgcmVmRXJyb3IgPSBuZXcgWUFNTFJlZmVyZW5jZUVycm9yKG5vZGUsIGVycm9yLm1lc3NhZ2UpO1xuICAgIHJlZkVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgZG9jLmVycm9ycy5wdXNoKHJlZkVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgaXNDb2xsZWN0aW9uSXRlbSA9IGZ1bmN0aW9uIGlzQ29sbGVjdGlvbkl0ZW0obm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gIHJldHVybiB0eXBlID09PSBUeXBlLk1BUF9LRVkgfHwgdHlwZSA9PT0gVHlwZS5NQVBfVkFMVUUgfHwgdHlwZSA9PT0gVHlwZS5TRVFfSVRFTTtcbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVOb2RlUHJvcHMoZXJyb3JzLCBub2RlKSB7XG4gIHZhciBjb21tZW50cyA9IHtcbiAgICBiZWZvcmU6IFtdLFxuICAgIGFmdGVyOiBbXVxuICB9O1xuICB2YXIgaGFzQW5jaG9yID0gZmFsc2U7XG4gIHZhciBoYXNUYWcgPSBmYWxzZTtcbiAgdmFyIHByb3BzID0gaXNDb2xsZWN0aW9uSXRlbShub2RlLmNvbnRleHQucGFyZW50KSA/IG5vZGUuY29udGV4dC5wYXJlbnQucHJvcHMuY29uY2F0KG5vZGUucHJvcHMpIDogbm9kZS5wcm9wcztcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocHJvcHMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3N0ZXAudmFsdWUsXG4gICAgICAgICAgc3RhcnQgPSBfc3RlcCR2YWx1ZS5zdGFydCxcbiAgICAgICAgICBlbmQgPSBfc3RlcCR2YWx1ZS5lbmQ7XG5cbiAgICAgIHN3aXRjaCAobm9kZS5jb250ZXh0LnNyY1tzdGFydF0pIHtcbiAgICAgICAgY2FzZSBDaGFyLkNPTU1FTlQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFub2RlLmNvbW1lbnRIYXNSZXF1aXJlZFdoaXRlc3BhY2Uoc3RhcnQpKSB7XG4gICAgICAgICAgICAgIHZhciBtc2cgPSAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycyc7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhlYWRlciA9IG5vZGUuaGVhZGVyLFxuICAgICAgICAgICAgICAgIHZhbHVlUmFuZ2UgPSBub2RlLnZhbHVlUmFuZ2U7XG4gICAgICAgICAgICB2YXIgY2MgPSB2YWx1ZVJhbmdlICYmIChzdGFydCA+IHZhbHVlUmFuZ2Uuc3RhcnQgfHwgaGVhZGVyICYmIHN0YXJ0ID4gaGVhZGVyLnN0YXJ0KSA/IGNvbW1lbnRzLmFmdGVyIDogY29tbWVudHMuYmVmb3JlO1xuICAgICAgICAgICAgY2MucHVzaChub2RlLmNvbnRleHQuc3JjLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIC8vIEFjdHVhbCBhbmNob3IgJiB0YWcgcmVzb2x1dGlvbiBpcyBoYW5kbGVkIGJ5IHNjaGVtYSwgaGVyZSB3ZSBqdXN0IGNvbXBsYWluXG5cbiAgICAgICAgY2FzZSBDaGFyLkFOQ0hPUjpcbiAgICAgICAgICBpZiAoaGFzQW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgX21zZyA9ICdBIG5vZGUgY2FuIGhhdmUgYXQgbW9zdCBvbmUgYW5jaG9yJztcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihub2RlLCBfbXNnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFzQW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENoYXIuVEFHOlxuICAgICAgICAgIGlmIChoYXNUYWcpIHtcbiAgICAgICAgICAgIHZhciBfbXNnMiA9ICdBIG5vZGUgY2FuIGhhdmUgYXQgbW9zdCBvbmUgdGFnJztcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihub2RlLCBfbXNnMikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhc1RhZyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbW1lbnRzOiBjb21tZW50cyxcbiAgICBoYXNBbmNob3I6IGhhc0FuY2hvcixcbiAgICBoYXNUYWc6IGhhc1RhZ1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTm9kZVZhbHVlKGRvYywgbm9kZSkge1xuICB2YXIgYW5jaG9ycyA9IGRvYy5hbmNob3JzLFxuICAgICAgZXJyb3JzID0gZG9jLmVycm9ycyxcbiAgICAgIHNjaGVtYSA9IGRvYy5zY2hlbWE7XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gVHlwZS5BTElBUykge1xuICAgIHZhciBuYW1lID0gbm9kZS5yYXdWYWx1ZTtcbiAgICB2YXIgc3JjID0gYW5jaG9ycy5nZXROb2RlKG5hbWUpO1xuXG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHZhciBtc2cgPSBcIkFsaWFzZWQgYW5jaG9yIG5vdCBmb3VuZDogXCIuY29uY2F0KG5hbWUpO1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFlBTUxSZWZlcmVuY2VFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gTGF6eSByZXNvbHV0aW9uIGZvciBjaXJjdWxhciByZWZlcmVuY2VzXG5cblxuICAgIHZhciByZXMgPSBuZXcgQWxpYXMoc3JjKTtcblxuICAgIGFuY2hvcnMuX2NzdEFsaWFzZXMucHVzaChyZXMpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHZhciB0YWdOYW1lID0gcmVzb2x2ZVRhZ05hbWUoZG9jLCBub2RlKTtcbiAgaWYgKHRhZ05hbWUpIHJldHVybiByZXNvbHZlVGFnKGRvYywgbm9kZSwgdGFnTmFtZSk7XG5cbiAgaWYgKG5vZGUudHlwZSAhPT0gVHlwZS5QTEFJTikge1xuICAgIHZhciBfbXNnMyA9IFwiRmFpbGVkIHRvIHJlc29sdmUgXCIuY29uY2F0KG5vZGUudHlwZSwgXCIgbm9kZSBoZXJlXCIpO1xuXG4gICAgZXJyb3JzLnB1c2gobmV3IFlBTUxTeW50YXhFcnJvcihub2RlLCBfbXNnMykpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgc3RyID0gcmVzb2x2ZVN0cmluZyhkb2MsIG5vZGUpO1xuICAgIHJldHVybiByZXNvbHZlU2NhbGFyKHN0ciwgc2NoZW1hLnRhZ3MsIHNjaGVtYS50YWdzLnNjYWxhckZhbGxiYWNrKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoIWVycm9yLnNvdXJjZSkgZXJyb3Iuc291cmNlID0gbm9kZTtcbiAgICBlcnJvcnMucHVzaChlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0gLy8gc2V0cyBub2RlLnJlc29sdmVkIG9uIHN1Y2Nlc3NcblxuXG5mdW5jdGlvbiByZXNvbHZlTm9kZShkb2MsIG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgaWYgKG5vZGUuZXJyb3IpIGRvYy5lcnJvcnMucHVzaChub2RlLmVycm9yKTtcblxuICB2YXIgX3Jlc29sdmVOb2RlUHJvcHMgPSByZXNvbHZlTm9kZVByb3BzKGRvYy5lcnJvcnMsIG5vZGUpLFxuICAgICAgY29tbWVudHMgPSBfcmVzb2x2ZU5vZGVQcm9wcy5jb21tZW50cyxcbiAgICAgIGhhc0FuY2hvciA9IF9yZXNvbHZlTm9kZVByb3BzLmhhc0FuY2hvcixcbiAgICAgIGhhc1RhZyA9IF9yZXNvbHZlTm9kZVByb3BzLmhhc1RhZztcblxuICBpZiAoaGFzQW5jaG9yKSB7XG4gICAgdmFyIGFuY2hvcnMgPSBkb2MuYW5jaG9ycztcbiAgICB2YXIgbmFtZSA9IG5vZGUuYW5jaG9yO1xuICAgIHZhciBwcmV2ID0gYW5jaG9ycy5nZXROb2RlKG5hbWUpOyAvLyBBdCB0aGlzIHBvaW50LCBhbGlhc2VzIGZvciBhbnkgcHJlY2VkaW5nIG5vZGUgd2l0aCB0aGUgc2FtZSBhbmNob3JcbiAgICAvLyBuYW1lIGhhdmUgYWxyZWFkeSBiZWVuIHJlc29sdmVkLCBzbyBpdCBtYXkgc2FmZWx5IGJlIHJlbmFtZWQuXG5cbiAgICBpZiAocHJldikgYW5jaG9ycy5tYXBbYW5jaG9ycy5uZXdOYW1lKG5hbWUpXSA9IHByZXY7IC8vIER1cmluZyBwYXJzaW5nLCB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBDU1Qgbm9kZSBpbiBhbmNob3JzLm1hcCBhc1xuICAgIC8vIGFuY2hvcnMgbmVlZCB0byBiZSBhdmFpbGFibGUgZHVyaW5nIHJlc29sdXRpb24gdG8gYWxsb3cgZm9yXG4gICAgLy8gY2lyY3VsYXIgcmVmZXJlbmNlcy5cblxuICAgIGFuY2hvcnMubWFwW25hbWVdID0gbm9kZTtcbiAgfVxuXG4gIGlmIChub2RlLnR5cGUgPT09IFR5cGUuQUxJQVMgJiYgKGhhc0FuY2hvciB8fCBoYXNUYWcpKSB7XG4gICAgdmFyIG1zZyA9ICdBbiBhbGlhcyBub2RlIG11c3Qgbm90IHNwZWNpZnkgYW55IHByb3BlcnRpZXMnO1xuICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgbXNnKSk7XG4gIH1cblxuICB2YXIgcmVzID0gcmVzb2x2ZU5vZGVWYWx1ZShkb2MsIG5vZGUpO1xuXG4gIGlmIChyZXMpIHtcbiAgICByZXMucmFuZ2UgPSBbbm9kZS5yYW5nZS5zdGFydCwgbm9kZS5yYW5nZS5lbmRdO1xuICAgIGlmIChkb2Mub3B0aW9ucy5rZWVwQ3N0Tm9kZXMpIHJlcy5jc3ROb2RlID0gbm9kZTtcbiAgICBpZiAoZG9jLm9wdGlvbnMua2VlcE5vZGVUeXBlcykgcmVzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgdmFyIGNiID0gY29tbWVudHMuYmVmb3JlLmpvaW4oJ1xcbicpO1xuXG4gICAgaWYgKGNiKSB7XG4gICAgICByZXMuY29tbWVudEJlZm9yZSA9IHJlcy5jb21tZW50QmVmb3JlID8gXCJcIi5jb25jYXQocmVzLmNvbW1lbnRCZWZvcmUsIFwiXFxuXCIpLmNvbmNhdChjYikgOiBjYjtcbiAgICB9XG5cbiAgICB2YXIgY2EgPSBjb21tZW50cy5hZnRlci5qb2luKCdcXG4nKTtcbiAgICBpZiAoY2EpIHJlcy5jb21tZW50ID0gcmVzLmNvbW1lbnQgPyBcIlwiLmNvbmNhdChyZXMuY29tbWVudCwgXCJcXG5cIikuY29uY2F0KGNhKSA6IGNhO1xuICB9XG5cbiAgcmV0dXJuIG5vZGUucmVzb2x2ZWQgPSByZXM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNYXAoZG9jLCBjc3QpIHtcbiAgaWYgKGNzdC50eXBlICE9PSBUeXBlLk1BUCAmJiBjc3QudHlwZSAhPT0gVHlwZS5GTE9XX01BUCkge1xuICAgIHZhciBtc2cgPSBcIkEgXCIuY29uY2F0KGNzdC50eXBlLCBcIiBub2RlIGNhbm5vdCBiZSByZXNvbHZlZCBhcyBhIG1hcHBpbmdcIik7XG4gICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MU3ludGF4RXJyb3IoY3N0LCBtc2cpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBfcmVmID0gY3N0LnR5cGUgPT09IFR5cGUuRkxPV19NQVAgPyByZXNvbHZlRmxvd01hcEl0ZW1zKGRvYywgY3N0KSA6IHJlc29sdmVCbG9ja01hcEl0ZW1zKGRvYywgY3N0KSxcbiAgICAgIGNvbW1lbnRzID0gX3JlZi5jb21tZW50cyxcbiAgICAgIGl0ZW1zID0gX3JlZi5pdGVtcztcblxuICB2YXIgbWFwID0gbmV3IFlBTUxNYXAoKTtcbiAgbWFwLml0ZW1zID0gaXRlbXM7XG4gIHJlc29sdmVDb21tZW50cyhtYXAsIGNvbW1lbnRzKTtcbiAgdmFyIGhhc0NvbGxlY3Rpb25LZXkgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGlLZXkgPSBpdGVtc1tpXS5rZXk7XG4gICAgaWYgKGlLZXkgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSBoYXNDb2xsZWN0aW9uS2V5ID0gdHJ1ZTtcblxuICAgIGlmIChkb2Muc2NoZW1hLm1lcmdlICYmIGlLZXkgJiYgaUtleS52YWx1ZSA9PT0gTUVSR0VfS0VZKSB7XG4gICAgICBpdGVtc1tpXSA9IG5ldyBNZXJnZShpdGVtc1tpXSk7XG4gICAgICB2YXIgc291cmNlcyA9IGl0ZW1zW2ldLnZhbHVlLml0ZW1zO1xuICAgICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICAgIHNvdXJjZXMuc29tZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFsaWFzKSB7XG4gICAgICAgICAgLy8gRHVyaW5nIHBhcnNpbmcsIGFsaWFzIHNvdXJjZXMgYXJlIENTVCBub2RlczsgdG8gYWNjb3VudCBmb3JcbiAgICAgICAgICAvLyBjaXJjdWxhciByZWZlcmVuY2VzIHRoZWlyIHJlc29sdmVkIHZhbHVlcyBjYW4ndCBiZSB1c2VkIGhlcmUuXG4gICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnNvdXJjZS50eXBlO1xuICAgICAgICAgIGlmICh0eXBlID09PSBUeXBlLk1BUCB8fCB0eXBlID09PSBUeXBlLkZMT1dfTUFQKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGVycm9yID0gJ01lcmdlIG5vZGVzIGFsaWFzZXMgY2FuIG9ubHkgcG9pbnQgdG8gbWFwcyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3IgPSAnTWVyZ2Ugbm9kZXMgY2FuIG9ubHkgaGF2ZSBBbGlhcyBub2RlcyBhcyB2YWx1ZXMnO1xuICAgICAgfSk7XG4gICAgICBpZiAoZXJyb3IpIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IoY3N0LCBlcnJvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBpdGVtcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgaktleSA9IGl0ZW1zW2pdLmtleTtcblxuICAgICAgICBpZiAoaUtleSA9PT0gaktleSB8fCBpS2V5ICYmIGpLZXkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlLZXksICd2YWx1ZScpICYmIGlLZXkudmFsdWUgPT09IGpLZXkudmFsdWUpIHtcbiAgICAgICAgICB2YXIgX21zZyA9IFwiTWFwIGtleXMgbXVzdCBiZSB1bmlxdWU7IFxcXCJcIi5jb25jYXQoaUtleSwgXCJcXFwiIGlzIHJlcGVhdGVkXCIpO1xuXG4gICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihjc3QsIF9tc2cpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNDb2xsZWN0aW9uS2V5ICYmICFkb2Mub3B0aW9ucy5tYXBBc01hcCkge1xuICAgIHZhciB3YXJuID0gJ0tleXMgd2l0aCBjb2xsZWN0aW9uIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkIGFzIFlBTUwgZHVlIHRvIEpTIE9iamVjdCByZXN0cmljdGlvbnMuIFVzZSBtYXBBc01hcDogdHJ1ZSB0byBhdm9pZCB0aGlzLic7XG4gICAgZG9jLndhcm5pbmdzLnB1c2gobmV3IFlBTUxXYXJuaW5nKGNzdCwgd2FybikpO1xuICB9XG5cbiAgY3N0LnJlc29sdmVkID0gbWFwO1xuICByZXR1cm4gbWFwO1xufVxuXG52YXIgdmFsdWVIYXNQYWlyQ29tbWVudCA9IGZ1bmN0aW9uIHZhbHVlSGFzUGFpckNvbW1lbnQoX3JlZjIpIHtcbiAgdmFyIF9yZWYyJGNvbnRleHQgPSBfcmVmMi5jb250ZXh0LFxuICAgICAgbGluZVN0YXJ0ID0gX3JlZjIkY29udGV4dC5saW5lU3RhcnQsXG4gICAgICBub2RlID0gX3JlZjIkY29udGV4dC5ub2RlLFxuICAgICAgc3JjID0gX3JlZjIkY29udGV4dC5zcmMsXG4gICAgICBwcm9wcyA9IF9yZWYyLnByb3BzO1xuICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzdGFydCA9IHByb3BzWzBdLnN0YXJ0O1xuICBpZiAobm9kZSAmJiBzdGFydCA+IG5vZGUudmFsdWVSYW5nZS5zdGFydCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoc3JjW3N0YXJ0XSAhPT0gQ2hhci5DT01NRU5UKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGxpbmVTdGFydDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICBpZiAoc3JjW2ldID09PSAnXFxuJykgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlUGFpckNvbW1lbnQoaXRlbSwgcGFpcikge1xuICBpZiAoIXZhbHVlSGFzUGFpckNvbW1lbnQoaXRlbSkpIHJldHVybjtcbiAgdmFyIGNvbW1lbnQgPSBpdGVtLmdldFByb3BWYWx1ZSgwLCBDaGFyLkNPTU1FTlQsIHRydWUpO1xuICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgdmFyIGNiID0gcGFpci52YWx1ZS5jb21tZW50QmVmb3JlO1xuXG4gIGlmIChjYiAmJiBjYi5zdGFydHNXaXRoKGNvbW1lbnQpKSB7XG4gICAgcGFpci52YWx1ZS5jb21tZW50QmVmb3JlID0gY2Iuc3Vic3RyKGNvbW1lbnQubGVuZ3RoICsgMSk7XG4gICAgZm91bmQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBjYyA9IHBhaXIudmFsdWUuY29tbWVudDtcblxuICAgIGlmICghaXRlbS5ub2RlICYmIGNjICYmIGNjLnN0YXJ0c1dpdGgoY29tbWVudCkpIHtcbiAgICAgIHBhaXIudmFsdWUuY29tbWVudCA9IGNjLnN1YnN0cihjb21tZW50Lmxlbmd0aCArIDEpO1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZCkgcGFpci5jb21tZW50ID0gY29tbWVudDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrTWFwSXRlbXMoZG9jLCBjc3QpIHtcbiAgdmFyIGNvbW1lbnRzID0gW107XG4gIHZhciBpdGVtcyA9IFtdO1xuICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuICB2YXIga2V5U3RhcnQgPSBudWxsO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3N0Lml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGl0ZW0gPSBjc3QuaXRlbXNbaV07XG5cbiAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuICAgICAgY2FzZSBUeXBlLkJMQU5LX0xJTkU6XG4gICAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICAgIGFmdGVyS2V5OiAhIWtleSxcbiAgICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVHlwZS5DT01NRU5UOlxuICAgICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgICBhZnRlcktleTogISFrZXksXG4gICAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgY29tbWVudDogaXRlbS5jb21tZW50XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUeXBlLk1BUF9LRVk6XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkgaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgICAgICAgaWYgKGl0ZW0uZXJyb3IpIGRvYy5lcnJvcnMucHVzaChpdGVtLmVycm9yKTtcbiAgICAgICAga2V5ID0gcmVzb2x2ZU5vZGUoZG9jLCBpdGVtLm5vZGUpO1xuICAgICAgICBrZXlTdGFydCA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFR5cGUuTUFQX1ZBTFVFOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSBrZXkgPSBudWxsO1xuICAgICAgICAgIGlmIChpdGVtLmVycm9yKSBkb2MuZXJyb3JzLnB1c2goaXRlbS5lcnJvcik7XG5cbiAgICAgICAgICBpZiAoIWl0ZW0uY29udGV4dC5hdExpbmVTdGFydCAmJiBpdGVtLm5vZGUgJiYgaXRlbS5ub2RlLnR5cGUgPT09IFR5cGUuTUFQICYmICFpdGVtLm5vZGUuY29udGV4dC5hdExpbmVTdGFydCkge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdOZXN0ZWQgbWFwcGluZ3MgYXJlIG5vdCBhbGxvd2VkIGluIGNvbXBhY3QgbWFwcGluZ3MnO1xuICAgICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihpdGVtLm5vZGUsIG1zZykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB2YWx1ZU5vZGUgPSBpdGVtLm5vZGU7XG5cbiAgICAgICAgICBpZiAoIXZhbHVlTm9kZSAmJiBpdGVtLnByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIENvbW1lbnRzIG9uIGFuIGVtcHR5IG1hcHBpbmcgdmFsdWUgbmVlZCB0byBiZSBwcmVzZXJ2ZWQsIHNvIHdlXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNvbnN0cnVjdCBhIG1pbmltYWwgZW1wdHkgbm9kZSBoZXJlIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZVxuICAgICAgICAgICAgLy8gbWlzc2luZyBgaXRlbS5ub2RlYC4gLS0gZWVtZWxpL3lhbWwjMTlcbiAgICAgICAgICAgIHZhbHVlTm9kZSA9IG5ldyBQbGFpblZhbHVlKFR5cGUuUExBSU4sIFtdKTtcbiAgICAgICAgICAgIHZhbHVlTm9kZS5jb250ZXh0ID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IGl0ZW0sXG4gICAgICAgICAgICAgIHNyYzogaXRlbS5jb250ZXh0LnNyY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBpdGVtLnJhbmdlLnN0YXJ0ICsgMTtcbiAgICAgICAgICAgIHZhbHVlTm9kZS5yYW5nZSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgICAgICAgICAgZW5kOiBwb3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZU5vZGUudmFsdWVSYW5nZSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgICAgICAgICAgZW5kOiBwb3NcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS5yYW5nZS5vcmlnU3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHZhciBvcmlnUG9zID0gaXRlbS5yYW5nZS5vcmlnU3RhcnQgKyAxO1xuICAgICAgICAgICAgICB2YWx1ZU5vZGUucmFuZ2Uub3JpZ1N0YXJ0ID0gdmFsdWVOb2RlLnJhbmdlLm9yaWdFbmQgPSBvcmlnUG9zO1xuICAgICAgICAgICAgICB2YWx1ZU5vZGUudmFsdWVSYW5nZS5vcmlnU3RhcnQgPSB2YWx1ZU5vZGUudmFsdWVSYW5nZS5vcmlnRW5kID0gb3JpZ1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGFpciA9IG5ldyBQYWlyKGtleSwgcmVzb2x2ZU5vZGUoZG9jLCB2YWx1ZU5vZGUpKTtcbiAgICAgICAgICByZXNvbHZlUGFpckNvbW1lbnQoaXRlbSwgcGFpcik7XG4gICAgICAgICAgaXRlbXMucHVzaChwYWlyKTtcblxuICAgICAgICAgIGlmIChrZXkgJiYgdHlwZW9mIGtleVN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucmFuZ2Uuc3RhcnQgPiBrZXlTdGFydCArIDEwMjQpIGRvYy5lcnJvcnMucHVzaChnZXRMb25nS2V5RXJyb3IoY3N0LCBrZXkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAga2V5U3RhcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gICAgICAgIGtleSA9IHJlc29sdmVOb2RlKGRvYywgaXRlbSk7XG4gICAgICAgIGtleVN0YXJ0ID0gaXRlbS5yYW5nZS5zdGFydDtcbiAgICAgICAgaWYgKGl0ZW0uZXJyb3IpIGRvYy5lcnJvcnMucHVzaChpdGVtLmVycm9yKTtcblxuICAgICAgICBuZXh0OiBmb3IgKHZhciBqID0gaSArIDE7OyArK2opIHtcbiAgICAgICAgICB2YXIgbmV4dEl0ZW0gPSBjc3QuaXRlbXNbal07XG5cbiAgICAgICAgICBzd2l0Y2ggKG5leHRJdGVtICYmIG5leHRJdGVtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVHlwZS5CTEFOS19MSU5FOlxuICAgICAgICAgICAgY2FzZSBUeXBlLkNPTU1FTlQ6XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG5leHQ7XG5cbiAgICAgICAgICAgIGNhc2UgVHlwZS5NQVBfVkFMVUU6XG4gICAgICAgICAgICAgIGJyZWFrIG5leHQ7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX21zZzIgPSAnSW1wbGljaXQgbWFwIGtleXMgbmVlZCB0byBiZSBmb2xsb3dlZCBieSBtYXAgdmFsdWVzJztcbiAgICAgICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKGl0ZW0sIF9tc2cyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWsgbmV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtLnZhbHVlUmFuZ2VDb250YWluc05ld2xpbmUpIHtcbiAgICAgICAgICB2YXIgX21zZzMgPSAnSW1wbGljaXQgbWFwIGtleXMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJztcbiAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTZW1hbnRpY0Vycm9yKGl0ZW0sIF9tc2czKSk7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCkgaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgcmV0dXJuIHtcbiAgICBjb21tZW50czogY29tbWVudHMsXG4gICAgaXRlbXM6IGl0ZW1zXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGbG93TWFwSXRlbXMoZG9jLCBjc3QpIHtcbiAgdmFyIGNvbW1lbnRzID0gW107XG4gIHZhciBpdGVtcyA9IFtdO1xuICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuICB2YXIgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgdmFyIG5leHQgPSAneyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjc3QuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaXRlbSA9IGNzdC5pdGVtc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaXRlbS5jaGFyID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGNoYXIgPSBpdGVtLmNoYXIsXG4gICAgICAgICAgb2Zmc2V0ID0gaXRlbS5vZmZzZXQ7XG5cbiAgICAgIGlmIChjaGFyID09PSAnPycgJiYga2V5ID09PSB1bmRlZmluZWQgJiYgIWV4cGxpY2l0S2V5KSB7XG4gICAgICAgIGV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgbmV4dCA9ICc6JztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFyID09PSAnOicpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSBrZXkgPSBudWxsO1xuXG4gICAgICAgIGlmIChuZXh0ID09PSAnOicpIHtcbiAgICAgICAgICBuZXh0ID0gJywnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgJiYgY2hhciAhPT0gJywnKSBrZXkgPSBudWxsO1xuICAgICAgICAgIGV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICAgICAgICAgIGtleSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChjaGFyID09PSAnLCcpIHtcbiAgICAgICAgICAgIG5leHQgPSAnOic7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXIgPT09ICd9Jykge1xuICAgICAgICBpZiAoaSA9PT0gY3N0Lml0ZW1zLmxlbmd0aCAtIDEpIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBuZXh0KSB7XG4gICAgICAgIG5leHQgPSAnOic7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbXNnID0gXCJGbG93IG1hcCBjb250YWlucyBhbiB1bmV4cGVjdGVkIFwiLmNvbmNhdChjaGFyKTtcbiAgICAgIHZhciBlcnIgPSBuZXcgWUFNTFN5bnRheEVycm9yKGNzdCwgbXNnKTtcbiAgICAgIGVyci5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBkb2MuZXJyb3JzLnB1c2goZXJyKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gVHlwZS5CTEFOS19MSU5FKSB7XG4gICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgYWZ0ZXJLZXk6ICEha2V5LFxuICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFR5cGUuQ09NTUVOVCkge1xuICAgICAgY2hlY2tGbG93Q29tbWVudFNwYWNlKGRvYy5lcnJvcnMsIGl0ZW0pO1xuICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgIGFmdGVyS2V5OiAhIWtleSxcbiAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGgsXG4gICAgICAgIGNvbW1lbnQ6IGl0ZW0uY29tbWVudFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG5leHQgPT09ICcsJykgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihpdGVtLCAnU2VwYXJhdG9yICwgbWlzc2luZyBpbiBmbG93IG1hcCcpKTtcbiAgICAgIGtleSA9IHJlc29sdmVOb2RlKGRvYywgaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0ICE9PSAnLCcpIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgJ0luZGljYXRvciA6IG1pc3NpbmcgaW4gZmxvdyBtYXAgZW50cnknKSk7XG4gICAgICBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSwgcmVzb2x2ZU5vZGUoZG9jLCBpdGVtKSkpO1xuICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjaGVja0Zsb3dDb2xsZWN0aW9uRW5kKGRvYy5lcnJvcnMsIGNzdCk7XG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCkgaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgcmV0dXJuIHtcbiAgICBjb21tZW50czogY29tbWVudHMsXG4gICAgaXRlbXM6IGl0ZW1zXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTZXEoZG9jLCBjc3QpIHtcbiAgaWYgKGNzdC50eXBlICE9PSBUeXBlLlNFUSAmJiBjc3QudHlwZSAhPT0gVHlwZS5GTE9XX1NFUSkge1xuICAgIHZhciBtc2cgPSBcIkEgXCIuY29uY2F0KGNzdC50eXBlLCBcIiBub2RlIGNhbm5vdCBiZSByZXNvbHZlZCBhcyBhIHNlcXVlbmNlXCIpO1xuICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFN5bnRheEVycm9yKGNzdCwgbXNnKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgX3JlZiA9IGNzdC50eXBlID09PSBUeXBlLkZMT1dfU0VRID8gcmVzb2x2ZUZsb3dTZXFJdGVtcyhkb2MsIGNzdCkgOiByZXNvbHZlQmxvY2tTZXFJdGVtcyhkb2MsIGNzdCksXG4gICAgICBjb21tZW50cyA9IF9yZWYuY29tbWVudHMsXG4gICAgICBpdGVtcyA9IF9yZWYuaXRlbXM7XG5cbiAgdmFyIHNlcSA9IG5ldyBZQU1MU2VxKCk7XG4gIHNlcS5pdGVtcyA9IGl0ZW1zO1xuICByZXNvbHZlQ29tbWVudHMoc2VxLCBjb21tZW50cyk7XG5cbiAgaWYgKCFkb2Mub3B0aW9ucy5tYXBBc01hcCAmJiBpdGVtcy5zb21lKGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdCBpbnN0YW5jZW9mIFBhaXIgJiYgaXQua2V5IGluc3RhbmNlb2YgQ29sbGVjdGlvbjtcbiAgfSkpIHtcbiAgICB2YXIgd2FybiA9ICdLZXlzIHdpdGggY29sbGVjdGlvbiB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZCBhcyBZQU1MIGR1ZSB0byBKUyBPYmplY3QgcmVzdHJpY3Rpb25zLiBVc2UgbWFwQXNNYXA6IHRydWUgdG8gYXZvaWQgdGhpcy4nO1xuICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBZQU1MV2FybmluZyhjc3QsIHdhcm4pKTtcbiAgfVxuXG4gIGNzdC5yZXNvbHZlZCA9IHNlcTtcbiAgcmV0dXJuIHNlcTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrU2VxSXRlbXMoZG9jLCBjc3QpIHtcbiAgdmFyIGNvbW1lbnRzID0gW107XG4gIHZhciBpdGVtcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3N0Lml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGl0ZW0gPSBjc3QuaXRlbXNbaV07XG5cbiAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuICAgICAgY2FzZSBUeXBlLkJMQU5LX0xJTkU6XG4gICAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICAgIGJlZm9yZTogaXRlbXMubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUeXBlLkNPTU1FTlQ6XG4gICAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICAgIGNvbW1lbnQ6IGl0ZW0uY29tbWVudCxcbiAgICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVHlwZS5TRVFfSVRFTTpcbiAgICAgICAgaWYgKGl0ZW0uZXJyb3IpIGRvYy5lcnJvcnMucHVzaChpdGVtLmVycm9yKTtcbiAgICAgICAgaXRlbXMucHVzaChyZXNvbHZlTm9kZShkb2MsIGl0ZW0ubm9kZSkpO1xuXG4gICAgICAgIGlmIChpdGVtLmhhc1Byb3BzKSB7XG4gICAgICAgICAgdmFyIG1zZyA9ICdTZXF1ZW5jZSBpdGVtcyBjYW5ub3QgaGF2ZSB0YWdzIG9yIGFuY2hvcnMgYmVmb3JlIHRoZSAtIGluZGljYXRvcic7XG4gICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihpdGVtLCBtc2cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoaXRlbS5lcnJvcikgZG9jLmVycm9ycy5wdXNoKGl0ZW0uZXJyb3IpO1xuICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxTeW50YXhFcnJvcihpdGVtLCBcIlVuZXhwZWN0ZWQgXCIuY29uY2F0KGl0ZW0udHlwZSwgXCIgbm9kZSBpbiBzZXF1ZW5jZVwiKSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tbWVudHM6IGNvbW1lbnRzLFxuICAgIGl0ZW1zOiBpdGVtc1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRmxvd1NlcUl0ZW1zKGRvYywgY3N0KSB7XG4gIHZhciBjb21tZW50cyA9IFtdO1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgdmFyIGV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gIHZhciBrZXkgPSB1bmRlZmluZWQ7XG4gIHZhciBrZXlTdGFydCA9IG51bGw7XG4gIHZhciBuZXh0ID0gJ1snO1xuICB2YXIgcHJldkl0ZW0gPSBudWxsO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3N0Lml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGl0ZW0gPSBjc3QuaXRlbXNbaV07XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0uY2hhciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBjaGFyID0gaXRlbS5jaGFyLFxuICAgICAgICAgIG9mZnNldCA9IGl0ZW0ub2Zmc2V0O1xuXG4gICAgICBpZiAoY2hhciAhPT0gJzonICYmIChleHBsaWNpdEtleSB8fCBrZXkgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgaWYgKGV4cGxpY2l0S2V5ICYmIGtleSA9PT0gdW5kZWZpbmVkKSBrZXkgPSBuZXh0ID8gaXRlbXMucG9wKCkgOiBudWxsO1xuICAgICAgICBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICAgICAgICBleHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGtleVN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXIgPT09IG5leHQpIHtcbiAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCFuZXh0ICYmIGNoYXIgPT09ICc/Jykge1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5leHQgIT09ICdbJyAmJiBjaGFyID09PSAnOicgJiYga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG5leHQgPT09ICcsJykge1xuICAgICAgICAgIGtleSA9IGl0ZW1zLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIFBhaXIpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnQ2hhaW5pbmcgZmxvdyBzZXF1ZW5jZSBwYWlycyBpcyBpbnZhbGlkJztcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgWUFNTFNlbWFudGljRXJyb3IoY3N0LCBtc2cpO1xuICAgICAgICAgICAgZXJyLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZXhwbGljaXRLZXkgJiYgdHlwZW9mIGtleVN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFyIGtleUVuZCA9IGl0ZW0ucmFuZ2UgPyBpdGVtLnJhbmdlLnN0YXJ0IDogaXRlbS5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoa2V5RW5kID4ga2V5U3RhcnQgKyAxMDI0KSBkb2MuZXJyb3JzLnB1c2goZ2V0TG9uZ0tleUVycm9yKGNzdCwga2V5KSk7XG4gICAgICAgICAgICB2YXIgc3JjID0gcHJldkl0ZW0uY29udGV4dC5zcmM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pID0ga2V5U3RhcnQ7IF9pIDwga2V5RW5kOyArK19pKSB7XG4gICAgICAgICAgICAgIGlmIChzcmNbX2ldID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIHZhciBfbXNnID0gJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnO1xuICAgICAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFNlbWFudGljRXJyb3IocHJldkl0ZW0sIF9tc2cpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5U3RhcnQgPSBudWxsO1xuICAgICAgICBleHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBuZXh0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gJ1snIHx8IGNoYXIgIT09ICddJyB8fCBpIDwgY3N0Lml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdmFyIF9tc2cyID0gXCJGbG93IHNlcXVlbmNlIGNvbnRhaW5zIGFuIHVuZXhwZWN0ZWQgXCIuY29uY2F0KGNoYXIpO1xuXG4gICAgICAgIHZhciBfZXJyID0gbmV3IFlBTUxTeW50YXhFcnJvcihjc3QsIF9tc2cyKTtcblxuICAgICAgICBfZXJyLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgZG9jLmVycm9ycy5wdXNoKF9lcnIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBUeXBlLkJMQU5LX0xJTkUpIHtcbiAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFR5cGUuQ09NTUVOVCkge1xuICAgICAgY2hlY2tGbG93Q29tbWVudFNwYWNlKGRvYy5lcnJvcnMsIGl0ZW0pO1xuICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgIGNvbW1lbnQ6IGl0ZW0uY29tbWVudCxcbiAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICB2YXIgX21zZzMgPSBcIkV4cGVjdGVkIGEgXCIuY29uY2F0KG5leHQsIFwiIGluIGZsb3cgc2VxdWVuY2VcIik7XG5cbiAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MU2VtYW50aWNFcnJvcihpdGVtLCBfbXNnMykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSByZXNvbHZlTm9kZShkb2MsIGl0ZW0pO1xuXG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHByZXZJdGVtID0gaXRlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5LCB2YWx1ZSkpO1xuICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGtleVN0YXJ0ID0gaXRlbS5yYW5nZS5zdGFydDtcbiAgICAgIG5leHQgPSAnLCc7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tGbG93Q29sbGVjdGlvbkVuZChkb2MuZXJyb3JzLCBjc3QpO1xuICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gIHJldHVybiB7XG4gICAgY29tbWVudHM6IGNvbW1lbnRzLFxuICAgIGl0ZW1zOiBpdGVtc1xuICB9O1xufVxuXG5leHBvcnQgeyBBbGlhcyBhcyBBLCBDb2xsZWN0aW9uIGFzIEMsIE1lcmdlIGFzIE0sIE5vZGUgYXMgTiwgUGFpciBhcyBQLCBTY2FsYXIgYXMgUywgWUFNTFNlcSBhcyBZLCBib29sT3B0aW9ucyBhcyBhLCBiaW5hcnlPcHRpb25zIGFzIGIsIHN0cmluZ2lmeVN0cmluZyBhcyBjLCBZQU1MTWFwIGFzIGQsIGlzRW1wdHlQYXRoIGFzIGUsIGFkZENvbW1lbnQgYXMgZiwgcmVzb2x2ZU1hcCBhcyBnLCByZXNvbHZlU2VxIGFzIGgsIGludE9wdGlvbnMgYXMgaSwgcmVzb2x2ZVN0cmluZyBhcyBqLCBzdHJpbmdpZnlOdW1iZXIgYXMgaywgZmluZFBhaXIgYXMgbCwgbnVsbE9wdGlvbnMgYXMgbiwgcmVzb2x2ZU5vZGUgYXMgciwgc3RyT3B0aW9ucyBhcyBzLCB0b0pTT04gYXMgdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/resolveSeq-492ab440.js\n")},"./node_modules/yaml/browser/dist/warnings-df54cb69.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"a\": () => (/* binding */ warnOptionDeprecation),\n/* harmony export */   \"b\": () => (/* binding */ binary),\n/* harmony export */   \"c\": () => (/* binding */ warnFileDeprecation),\n/* harmony export */   \"f\": () => (/* binding */ floatTime),\n/* harmony export */   \"i\": () => (/* binding */ intTime),\n/* harmony export */   \"o\": () => (/* binding */ omap),\n/* harmony export */   \"p\": () => (/* binding */ pairs),\n/* harmony export */   \"s\": () => (/* binding */ set),\n/* harmony export */   \"t\": () => (/* binding */ timestamp),\n/* harmony export */   \"w\": () => (/* binding */ warn)\n/* harmony export */ });\n/* harmony import */ var _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlainValue-b8036b75.js */ \"./node_modules/yaml/browser/dist/PlainValue-b8036b75.js\");\n/* harmony import */ var _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolveSeq-492ab440.js */ \"./node_modules/yaml/browser/dist/resolveSeq-492ab440.js\");\n\n\n\n/* global atob, btoa, Buffer */\nvar binary = {\n  identify: function identify(value) {\n    return value instanceof Uint8Array;\n  },\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: function resolve(doc, node) {\n    var src = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.j)(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      var str = atob(src.replace(/[\\n\\r]/g, ''));\n      var buffer = new Uint8Array(str.length);\n\n      for (var i = 0; i < str.length; ++i) {\n        buffer[i] = str.charCodeAt(i);\n      }\n\n      return buffer;\n    } else {\n      var msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.o(node, msg));\n      return null;\n    }\n  },\n  options: _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.b,\n  stringify: function stringify(_ref, ctx, onComment, onChompKeep) {\n    var comment = _ref.comment,\n        type = _ref.type,\n        value = _ref.value;\n    var src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      var s = '';\n\n      for (var i = 0; i < value.length; ++i) {\n        s += String.fromCharCode(value[i]);\n      }\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.b.defaultType;\n\n    if (type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      var lineWidth = _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.b.lineWidth;\n      var n = Math.ceil(src.length / lineWidth);\n      var lines = new Array(n);\n\n      for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) {\n        lines[_i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.T.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.c)({\n      comment: comment,\n      type: type,\n      value: value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  var seq = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.h)(doc, cst);\n\n  for (var i = 0; i < seq.items.length; ++i) {\n    var item = seq.items[i];\n    if (item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P) continue;else if (item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d) {\n      if (item.items.length > 1) {\n        var msg = 'Each pair must have its own sequence indicator';\n        throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, msg);\n      }\n\n      var pair = item.items[0] || new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? \"\".concat(item.commentBefore, \"\\n\").concat(pair.commentBefore) : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? \"\".concat(item.comment, \"\\n\").concat(pair.comment) : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P ? item : new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P(item);\n  }\n\n  return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n  var pairs = new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.Y(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(iterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var it = _step.value;\n      var key = void 0,\n          value = void 0;\n\n      if (Array.isArray(it)) {\n        if (it.length === 2) {\n          key = it[0];\n          value = it[1];\n        } else throw new TypeError(\"Expected [key, value] tuple: \".concat(it));\n      } else if (it && it instanceof Object) {\n        var keys = Object.keys(it);\n\n        if (keys.length === 1) {\n          key = keys[0];\n          value = it[key];\n        } else throw new TypeError(\"Expected { key: value } tuple: \".concat(it));\n      } else {\n        key = it;\n      }\n\n      var pair = schema.createPair(key, value, ctx);\n      pairs.items.push(pair);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return pairs;\n}\nvar pairs = {\n  default: false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nvar YAMLOMap = /*#__PURE__*/function (_YAMLSeq) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(YAMLOMap, _YAMLSeq);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(YAMLOMap);\n\n  function YAMLOMap() {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, YAMLOMap);\n\n    _this = _super.call(this);\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"add\", _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d.prototype.add.bind((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this)));\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"delete\", _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d.prototype[\"delete\"].bind((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this)));\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"get\", _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d.prototype.get.bind((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this)));\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"has\", _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d.prototype.has.bind((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this)));\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this), \"set\", _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d.prototype.set.bind((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.p)(_this)));\n\n    _this.tag = YAMLOMap.tag;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(YAMLOMap, [{\n    key: \"toJSON\",\n    value: function toJSON$1(_, ctx) {\n      var map = new Map();\n      if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n      var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(this.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pair = _step.value;\n          var key = void 0,\n              value = void 0;\n\n          if (pair instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P) {\n            key = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.t)(pair.key, '', ctx);\n            value = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.t)(pair.value, key, ctx);\n          } else {\n            key = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.t)(pair, '', ctx);\n          }\n\n          if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n          map.set(key, value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return map;\n    }\n  }]);\n\n  return YAMLOMap;\n}(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.Y);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  var pairs = parsePairs(doc, cst);\n  var seenKeys = [];\n\n  var _iterator2 = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(pairs.items),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value.key;\n\n      if (key instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S) {\n        if (seenKeys.includes(key.value)) {\n          var msg = 'Ordered maps must not include duplicate keys';\n          throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, msg);\n        } else {\n          seenKeys.push(key.value);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  var pairs = createPairs(schema, iterable, ctx);\n  var omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nvar omap = {\n  identify: function identify(value) {\n    return value instanceof Map;\n  },\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nvar YAMLSet = /*#__PURE__*/function (_YAMLMap) {\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.j)(YAMLSet, _YAMLMap);\n\n  var _super = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.k)(YAMLSet);\n\n  function YAMLSet() {\n    var _this;\n\n    (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, YAMLSet);\n\n    _this = _super.call(this);\n    _this.tag = YAMLSet.tag;\n    return _this;\n  }\n\n  (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.b)(YAMLSet, [{\n    key: \"add\",\n    value: function add(key) {\n      var pair = key instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P ? key : new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P(key);\n      var prev = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.l)(this.items, pair.key);\n      if (!prev) this.items.push(pair);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepPair) {\n      var pair = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.l)(this.items, key);\n      return !keepPair && pair instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P ? pair.key instanceof _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.S ? pair.key.value : pair.key : pair;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      if (typeof value !== 'boolean') throw new Error(\"Expected boolean value for set(key, value) in a YAML set, not \".concat((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.a)(value)));\n      var prev = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.l)(this.items, key);\n\n      if (prev && !value) {\n        this.items.splice(this.items.indexOf(prev), 1);\n      } else if (!prev && value) {\n        this.items.push(new _resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.P(key));\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx) {\n      return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(YAMLSet.prototype), \"toJSON\", this).call(this, _, ctx, Set);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n      if (this.hasAllNullValues()) return (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.l)((0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.m)(YAMLSet.prototype), \"toString\", this).call(this, ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n    }\n  }]);\n\n  return YAMLSet;\n}(_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.d);\n\n(0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.e)(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  var map = (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.g)(doc, cst);\n  if (!map.hasAllNullValues()) throw new _PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__.g(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  var set = new YAMLSet();\n\n  var _iterator = (0,_PlainValue_b8036b75_js__WEBPACK_IMPORTED_MODULE_0__._)(iterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var value = _step.value;\n      set.items.push(schema.createPair(value, null, ctx));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return set;\n}\n\nvar set = {\n  identify: function identify(value) {\n    return value instanceof Set;\n  },\n  nodeClass: YAMLSet,\n  default: false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nvar parseSexagesimal = function parseSexagesimal(sign, parts) {\n  var n = parts.split(':').reduce(function (n, p) {\n    return n * 60 + Number(p);\n  }, 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nvar stringifySexagesimal = function stringifySexagesimal(_ref) {\n  var value = _ref.value;\n  if (isNaN(value) || !isFinite(value)) return (0,_resolveSeq_492ab440_js__WEBPACK_IMPORTED_MODULE_1__.k)(value);\n  var sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  var parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(function (n) {\n    return n < 10 ? '0' + String(n) : String(n);\n  }).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nvar intTime = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: function resolve(str, sign, parts) {\n    return parseSexagesimal(sign, parts.replace(/_/g, ''));\n  },\n  stringify: stringifySexagesimal\n};\nvar floatTime = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: function resolve(str, sign, parts) {\n    return parseSexagesimal(sign, parts.replace(/_/g, ''));\n  },\n  stringify: stringifySexagesimal\n};\nvar timestamp = {\n  identify: function identify(value) {\n    return value instanceof Date;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: function resolve(str, year, month, day, hour, minute, second, millisec, tz) {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      var d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '');\n  }\n};\n\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\nfunction shouldWarn(deprecation) {\n  var env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    var emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? \"\".concat(type, \": \").concat(warning) : warning);\n    }\n  }\n}\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    var path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(\"The endpoint 'yaml/\".concat(path, \"' will be removed in a future release.\"), 'DeprecationWarning');\n  }\n}\nvar warned = {};\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    var msg = \"The option '\".concat(name, \"' will be removed in a future release\");\n    msg += alternative ? \", use '\".concat(alternative, \"' instead.\") : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvd2FybmluZ3MtZGY1NGNiNjkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXFUO0FBQ3JFOztBQUVoUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsY0FBYywwREFBYTs7QUFFM0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLHdFQUF3RTtBQUN4RSwwQkFBMEIsc0RBQWtCO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVyxzREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLDhFQUE4RTtBQUM5RTs7QUFFQSxzQkFBc0Isa0VBQXlCOztBQUUvQyxpQkFBaUIsbUVBQWlCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixnRUFBdUI7QUFDN0M7QUFDQTs7QUFFQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBOztBQUVBLGtDQUFrQyxvRUFBa0I7QUFDcEQ7O0FBRUEsV0FBVywwREFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFlBQVksMERBQVU7O0FBRXRCLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQSx3QkFBd0Isc0RBQUksV0FBVyx5QkFBeUIsc0RBQU87QUFDdkU7QUFDQTtBQUNBLGtCQUFrQixzREFBaUI7QUFDbkM7O0FBRUEsc0NBQXNDLHNEQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFJLGNBQWMsc0RBQUk7QUFD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O0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVsZW9weHl6Ly4vbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3dhcm5pbmdzLWRmNTRjYjY5LmpzPzY0N2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbyBhcyBZQU1MUmVmZXJlbmNlRXJyb3IsIFQgYXMgVHlwZSwgZyBhcyBZQU1MU2VtYW50aWNFcnJvciwgXyBhcyBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciwgZSBhcyBfZGVmaW5lUHJvcGVydHksIGogYXMgX2luaGVyaXRzLCBrIGFzIF9jcmVhdGVTdXBlciwgYyBhcyBfY2xhc3NDYWxsQ2hlY2ssIHAgYXMgX2Fzc2VydFRoaXNJbml0aWFsaXplZCwgYiBhcyBfY3JlYXRlQ2xhc3MsIGEgYXMgX3R5cGVvZiwgbCBhcyBfZ2V0LCBtIGFzIF9nZXRQcm90b3R5cGVPZiB9IGZyb20gJy4vUGxhaW5WYWx1ZS1iODAzNmI3NS5qcyc7XG5pbXBvcnQgeyBqIGFzIHJlc29sdmVTdHJpbmcsIGIgYXMgYmluYXJ5T3B0aW9ucywgYyBhcyBzdHJpbmdpZnlTdHJpbmcsIGggYXMgcmVzb2x2ZVNlcSwgUCBhcyBQYWlyLCBkIGFzIFlBTUxNYXAsIFkgYXMgWUFNTFNlcSwgdCBhcyB0b0pTT04sIFMgYXMgU2NhbGFyLCBsIGFzIGZpbmRQYWlyLCBnIGFzIHJlc29sdmVNYXAsIGsgYXMgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi9yZXNvbHZlU2VxLTQ5MmFiNDQwLmpzJztcblxuLyogZ2xvYmFsIGF0b2IsIGJ0b2EsIEJ1ZmZlciAqL1xudmFyIGJpbmFyeSA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgfSxcbiAgLy8gQnVmZmVyIGluaGVyaXRzIGZyb20gVWludDhBcnJheVxuICBkZWZhdWx0OiBmYWxzZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5JyxcblxuICAvKipcbiAgICogUmV0dXJucyBhIEJ1ZmZlciBpbiBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAqXG4gICAqIFRvIHVzZSB0aGUgcmVzdWx0aW5nIGJ1ZmZlciBhcyBhbiBpbWFnZSwgeW91J2xsIHdhbnQgdG8gZG8gc29tZXRoaW5nIGxpa2U6XG4gICAqXG4gICAqICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwaG90bycpLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICovXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoZG9jLCBub2RlKSB7XG4gICAgdmFyIHNyYyA9IHJlc29sdmVTdHJpbmcoZG9jLCBub2RlKTtcblxuICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3JjLCAnYmFzZTY0Jyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gT24gSUUgMTEsIGF0b2IoKSBjYW4ndCBoYW5kbGUgbmV3bGluZXNcbiAgICAgIHZhciBzdHIgPSBhdG9iKHNyYy5yZXBsYWNlKC9bXFxuXFxyXS9nLCAnJykpO1xuICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBidWZmZXJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1zZyA9ICdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgcmVhZGluZyBiaW5hcnkgdGFnczsgZWl0aGVyIEJ1ZmZlciBvciBhdG9iIGlzIHJlcXVpcmVkJztcbiAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgWUFNTFJlZmVyZW5jZUVycm9yKG5vZGUsIG1zZykpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxuICBvcHRpb25zOiBiaW5hcnlPcHRpb25zLFxuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShfcmVmLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICB2YXIgY29tbWVudCA9IF9yZWYuY29tbWVudCxcbiAgICAgICAgdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgICAgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgIHZhciBzcmM7XG5cbiAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3JjID0gdmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIgPyB2YWx1ZS50b1N0cmluZygnYmFzZTY0JykgOiBCdWZmZXIuZnJvbSh2YWx1ZS5idWZmZXIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcyA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZVtpXSk7XG4gICAgICB9XG5cbiAgICAgIHNyYyA9IGJ0b2Eocyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IHdyaXRpbmcgYmluYXJ5IHRhZ3M7IGVpdGhlciBCdWZmZXIgb3IgYnRvYSBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGlmICghdHlwZSkgdHlwZSA9IGJpbmFyeU9wdGlvbnMuZGVmYXVsdFR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gVHlwZS5RVU9URV9ET1VCTEUpIHtcbiAgICAgIHZhbHVlID0gc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gYmluYXJ5T3B0aW9ucy5saW5lV2lkdGg7XG4gICAgICB2YXIgbiA9IE1hdGguY2VpbChzcmMubGVuZ3RoIC8gbGluZVdpZHRoKTtcbiAgICAgIHZhciBsaW5lcyA9IG5ldyBBcnJheShuKTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBvID0gMDsgX2kgPCBuOyArK19pLCBvICs9IGxpbmVXaWR0aCkge1xuICAgICAgICBsaW5lc1tfaV0gPSBzcmMuc3Vic3RyKG8sIGxpbmVXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gbGluZXMuam9pbih0eXBlID09PSBUeXBlLkJMT0NLX0xJVEVSQUwgPyAnXFxuJyA6ICcgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyh7XG4gICAgICBjb21tZW50OiBjb21tZW50LFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhcnNlUGFpcnMoZG9jLCBjc3QpIHtcbiAgdmFyIHNlcSA9IHJlc29sdmVTZXEoZG9jLCBjc3QpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGl0ZW0gPSBzZXEuaXRlbXNbaV07XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQYWlyKSBjb250aW51ZTtlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgWUFNTE1hcCkge1xuICAgICAgaWYgKGl0ZW0uaXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbXNnID0gJ0VhY2ggcGFpciBtdXN0IGhhdmUgaXRzIG93biBzZXF1ZW5jZSBpbmRpY2F0b3InO1xuICAgICAgICB0aHJvdyBuZXcgWUFNTFNlbWFudGljRXJyb3IoY3N0LCBtc2cpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFpciA9IGl0ZW0uaXRlbXNbMF0gfHwgbmV3IFBhaXIoKTtcbiAgICAgIGlmIChpdGVtLmNvbW1lbnRCZWZvcmUpIHBhaXIuY29tbWVudEJlZm9yZSA9IHBhaXIuY29tbWVudEJlZm9yZSA/IFwiXCIuY29uY2F0KGl0ZW0uY29tbWVudEJlZm9yZSwgXCJcXG5cIikuY29uY2F0KHBhaXIuY29tbWVudEJlZm9yZSkgOiBpdGVtLmNvbW1lbnRCZWZvcmU7XG4gICAgICBpZiAoaXRlbS5jb21tZW50KSBwYWlyLmNvbW1lbnQgPSBwYWlyLmNvbW1lbnQgPyBcIlwiLmNvbmNhdChpdGVtLmNvbW1lbnQsIFwiXFxuXCIpLmNvbmNhdChwYWlyLmNvbW1lbnQpIDogaXRlbS5jb21tZW50O1xuICAgICAgaXRlbSA9IHBhaXI7XG4gICAgfVxuICAgIHNlcS5pdGVtc1tpXSA9IGl0ZW0gaW5zdGFuY2VvZiBQYWlyID8gaXRlbSA6IG5ldyBQYWlyKGl0ZW0pO1xuICB9XG5cbiAgcmV0dXJuIHNlcTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICB2YXIgcGFpcnMgPSBuZXcgWUFNTFNlcShzY2hlbWEpO1xuICBwYWlycy50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpdGVyYWJsZSksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgaXQgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHZhciBrZXkgPSB2b2lkIDAsXG4gICAgICAgICAgdmFsdWUgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0KSkge1xuICAgICAgICBpZiAoaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAga2V5ID0gaXRbMF07XG4gICAgICAgICAgdmFsdWUgPSBpdFsxXTtcbiAgICAgICAgfSBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBba2V5LCB2YWx1ZV0gdHVwbGU6IFwiLmNvbmNhdChpdCkpO1xuICAgICAgfSBlbHNlIGlmIChpdCAmJiBpdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGl0KTtcblxuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzWzBdO1xuICAgICAgICAgIHZhbHVlID0gaXRba2V5XTtcbiAgICAgICAgfSBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB7IGtleTogdmFsdWUgfSB0dXBsZTogXCIuY29uY2F0KGl0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBpdDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhaXIgPSBzY2hlbWEuY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpO1xuICAgICAgcGFpcnMuaXRlbXMucHVzaChwYWlyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHJldHVybiBwYWlycztcbn1cbnZhciBwYWlycyA9IHtcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJyxcbiAgcmVzb2x2ZTogcGFyc2VQYWlycyxcbiAgY3JlYXRlTm9kZTogY3JlYXRlUGFpcnNcbn07XG5cbnZhciBZQU1MT01hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1lBTUxTZXEpIHtcbiAgX2luaGVyaXRzKFlBTUxPTWFwLCBfWUFNTFNlcSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihZQU1MT01hcCk7XG5cbiAgZnVuY3Rpb24gWUFNTE9NYXAoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBTUxPTWFwKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiYWRkXCIsIFlBTUxNYXAucHJvdG90eXBlLmFkZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZGVsZXRlXCIsIFlBTUxNYXAucHJvdG90eXBlLmRlbGV0ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZ2V0XCIsIFlBTUxNYXAucHJvdG90eXBlLmdldC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFzXCIsIFlBTUxNYXAucHJvdG90eXBlLmhhcy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2V0XCIsIFlBTUxNYXAucHJvdG90eXBlLnNldC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG5cbiAgICBfdGhpcy50YWcgPSBZQU1MT01hcC50YWc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFlBTUxPTWFwLCBbe1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OJDEoXywgY3R4KSB7XG4gICAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgaWYgKGN0eCAmJiBjdHgub25DcmVhdGUpIGN0eC5vbkNyZWF0ZShtYXApO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5pdGVtcyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIga2V5ID0gdm9pZCAwLFxuICAgICAgICAgICAgICB2YWx1ZSA9IHZvaWQgMDtcblxuICAgICAgICAgIGlmIChwYWlyIGluc3RhbmNlb2YgUGFpcikge1xuICAgICAgICAgICAga2V5ID0gdG9KU09OKHBhaXIua2V5LCAnJywgY3R4KTtcbiAgICAgICAgICAgIHZhbHVlID0gdG9KU09OKHBhaXIudmFsdWUsIGtleSwgY3R4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gdG9KU09OKHBhaXIsICcnLCBjdHgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXAuaGFzKGtleSkpIHRocm93IG5ldyBFcnJvcignT3JkZXJlZCBtYXBzIG11c3Qgbm90IGluY2x1ZGUgZHVwbGljYXRlIGtleXMnKTtcbiAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFlBTUxPTWFwO1xufShZQU1MU2VxKTtcblxuX2RlZmluZVByb3BlcnR5KFlBTUxPTWFwLCBcInRhZ1wiLCAndGFnOnlhbWwub3JnLDIwMDI6b21hcCcpO1xuXG5mdW5jdGlvbiBwYXJzZU9NYXAoZG9jLCBjc3QpIHtcbiAgdmFyIHBhaXJzID0gcGFyc2VQYWlycyhkb2MsIGNzdCk7XG4gIHZhciBzZWVuS2V5cyA9IFtdO1xuXG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGFpcnMuaXRlbXMpLFxuICAgICAgX3N0ZXAyO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWUua2V5O1xuXG4gICAgICBpZiAoa2V5IGluc3RhbmNlb2YgU2NhbGFyKSB7XG4gICAgICAgIGlmIChzZWVuS2V5cy5pbmNsdWRlcyhrZXkudmFsdWUpKSB7XG4gICAgICAgICAgdmFyIG1zZyA9ICdPcmRlcmVkIG1hcHMgbXVzdCBub3QgaW5jbHVkZSBkdXBsaWNhdGUga2V5cyc7XG4gICAgICAgICAgdGhyb3cgbmV3IFlBTUxTZW1hbnRpY0Vycm9yKGNzdCwgbXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5cy5wdXNoKGtleS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIuZigpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxPTWFwKCksIHBhaXJzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT01hcChzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgdmFyIHBhaXJzID0gY3JlYXRlUGFpcnMoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KTtcbiAgdmFyIG9tYXAgPSBuZXcgWUFNTE9NYXAoKTtcbiAgb21hcC5pdGVtcyA9IHBhaXJzLml0ZW1zO1xuICByZXR1cm4gb21hcDtcbn1cblxudmFyIG9tYXAgPSB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbiAgfSxcbiAgbm9kZUNsYXNzOiBZQU1MT01hcCxcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLFxuICByZXNvbHZlOiBwYXJzZU9NYXAsXG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZU9NYXBcbn07XG5cbnZhciBZQU1MU2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfWUFNTE1hcCkge1xuICBfaW5oZXJpdHMoWUFNTFNldCwgX1lBTUxNYXApO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoWUFNTFNldCk7XG5cbiAgZnVuY3Rpb24gWUFNTFNldCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWUFNTFNldCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLnRhZyA9IFlBTUxTZXQudGFnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhZQU1MU2V0LCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGtleSkge1xuICAgICAgdmFyIHBhaXIgPSBrZXkgaW5zdGFuY2VvZiBQYWlyID8ga2V5IDogbmV3IFBhaXIoa2V5KTtcbiAgICAgIHZhciBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywgcGFpci5rZXkpO1xuICAgICAgaWYgKCFwcmV2KSB0aGlzLml0ZW1zLnB1c2gocGFpcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5LCBrZWVwUGFpcikge1xuICAgICAgdmFyIHBhaXIgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgcmV0dXJuICFrZWVwUGFpciAmJiBwYWlyIGluc3RhbmNlb2YgUGFpciA/IHBhaXIua2V5IGluc3RhbmNlb2YgU2NhbGFyID8gcGFpci5rZXkudmFsdWUgOiBwYWlyLmtleSA6IHBhaXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBib29sZWFuIHZhbHVlIGZvciBzZXQoa2V5LCB2YWx1ZSkgaW4gYSBZQU1MIHNldCwgbm90IFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSkpO1xuICAgICAgdmFyIHByZXYgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuXG4gICAgICBpZiAocHJldiAmJiAhdmFsdWUpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKHByZXYpLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByZXYgJiYgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKF8sIGN0eCkge1xuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFlBTUxTZXQucHJvdG90eXBlKSwgXCJ0b0pTT05cIiwgdGhpcykuY2FsbCh0aGlzLCBfLCBjdHgsIFNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgaWYgKCFjdHgpIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgIGlmICh0aGlzLmhhc0FsbE51bGxWYWx1ZXMoKSkgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFlBTUxTZXQucHJvdG90eXBlKSwgXCJ0b1N0cmluZ1wiLCB0aGlzKS5jYWxsKHRoaXMsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1NldCBpdGVtcyBtdXN0IGFsbCBoYXZlIG51bGwgdmFsdWVzJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFlBTUxTZXQ7XG59KFlBTUxNYXApO1xuXG5fZGVmaW5lUHJvcGVydHkoWUFNTFNldCwgXCJ0YWdcIiwgJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcpO1xuXG5mdW5jdGlvbiBwYXJzZVNldChkb2MsIGNzdCkge1xuICB2YXIgbWFwID0gcmVzb2x2ZU1hcChkb2MsIGNzdCk7XG4gIGlmICghbWFwLmhhc0FsbE51bGxWYWx1ZXMoKSkgdGhyb3cgbmV3IFlBTUxTZW1hbnRpY0Vycm9yKGNzdCwgJ1NldCBpdGVtcyBtdXN0IGFsbCBoYXZlIG51bGwgdmFsdWVzJyk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBZQU1MU2V0KCksIG1hcCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNldChzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgdmFyIHNldCA9IG5ldyBZQU1MU2V0KCk7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGl0ZXJhYmxlKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgc2V0Lml0ZW1zLnB1c2goc2NoZW1hLmNyZWF0ZVBhaXIodmFsdWUsIG51bGwsIGN0eCkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIHNldDtcbn1cblxudmFyIHNldCA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0O1xuICB9LFxuICBub2RlQ2xhc3M6IFlBTUxTZXQsXG4gIGRlZmF1bHQ6IGZhbHNlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLFxuICByZXNvbHZlOiBwYXJzZVNldCxcbiAgY3JlYXRlTm9kZTogY3JlYXRlU2V0XG59O1xuXG52YXIgcGFyc2VTZXhhZ2VzaW1hbCA9IGZ1bmN0aW9uIHBhcnNlU2V4YWdlc2ltYWwoc2lnbiwgcGFydHMpIHtcbiAgdmFyIG4gPSBwYXJ0cy5zcGxpdCgnOicpLnJlZHVjZShmdW5jdGlvbiAobiwgcCkge1xuICAgIHJldHVybiBuICogNjAgKyBOdW1iZXIocCk7XG4gIH0sIDApO1xuICByZXR1cm4gc2lnbiA9PT0gJy0nID8gLW4gOiBuO1xufTsgLy8gaGhoaDptbTpzcy5zc3NcblxuXG52YXIgc3RyaW5naWZ5U2V4YWdlc2ltYWwgPSBmdW5jdGlvbiBzdHJpbmdpZnlTZXhhZ2VzaW1hbChfcmVmKSB7XG4gIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gIGlmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkgcmV0dXJuIHN0cmluZ2lmeU51bWJlcih2YWx1ZSk7XG4gIHZhciBzaWduID0gJyc7XG5cbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIHNpZ24gPSAnLSc7XG4gICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG4gIH1cblxuICB2YXIgcGFydHMgPSBbdmFsdWUgJSA2MF07IC8vIHNlY29uZHMsIGluY2x1ZGluZyBtc1xuXG4gIGlmICh2YWx1ZSA8IDYwKSB7XG4gICAgcGFydHMudW5zaGlmdCgwKTsgLy8gYXQgbGVhc3Qgb25lIDogaXMgcmVxdWlyZWRcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IE1hdGgucm91bmQoKHZhbHVlIC0gcGFydHNbMF0pIC8gNjApO1xuICAgIHBhcnRzLnVuc2hpZnQodmFsdWUgJSA2MCk7IC8vIG1pbnV0ZXNcblxuICAgIGlmICh2YWx1ZSA+PSA2MCkge1xuICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKCh2YWx1ZSAtIHBhcnRzWzBdKSAvIDYwKTtcbiAgICAgIHBhcnRzLnVuc2hpZnQodmFsdWUpOyAvLyBob3Vyc1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzaWduICsgcGFydHMubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIFN0cmluZyhuKSA6IFN0cmluZyhuKTtcbiAgfSkuam9pbignOicpLnJlcGxhY2UoLzAwMDAwMFxcZCokLywgJycpIC8vICUgNjAgbWF5IGludHJvZHVjZSBlcnJvclxuICA7XG59O1xuXG52YXIgaW50VGltZSA9IHtcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uIGlkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gIH0sXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ1RJTUUnLFxuICB0ZXN0OiAvXihbLStdPykoWzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKSspJC8sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyLCBzaWduLCBwYXJ0cykge1xuICAgIHJldHVybiBwYXJzZVNleGFnZXNpbWFsKHNpZ24sIHBhcnRzLnJlcGxhY2UoL18vZywgJycpKTtcbiAgfSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlTZXhhZ2VzaW1hbFxufTtcbnZhciBmbG9hdFRpbWUgPSB7XG4gIGlkZW50aWZ5OiBmdW5jdGlvbiBpZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIGZvcm1hdDogJ1RJTUUnLFxuICB0ZXN0OiAvXihbLStdPykoWzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKStcXC5bMC05X10qKSQvLFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHN0ciwgc2lnbiwgcGFydHMpIHtcbiAgICByZXR1cm4gcGFyc2VTZXhhZ2VzaW1hbChzaWduLCBwYXJ0cy5yZXBsYWNlKC9fL2csICcnKSk7XG4gIH0sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG52YXIgdGltZXN0YW1wID0ge1xuICBpZGVudGlmeTogZnVuY3Rpb24gaWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xuICB9LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLFxuICAvLyBJZiB0aGUgdGltZSB6b25lIGlzIG9taXR0ZWQsIHRoZSB0aW1lc3RhbXAgaXMgYXNzdW1lZCB0byBiZSBzcGVjaWZpZWQgaW4gVVRDLiBUaGUgdGltZSBwYXJ0XG4gIC8vIG1heSBiZSBvbWl0dGVkIGFsdG9nZXRoZXIsIHJlc3VsdGluZyBpbiBhIGRhdGUgZm9ybWF0LiBJbiBzdWNoIGEgY2FzZSwgdGhlIHRpbWUgcGFydCBpc1xuICAvLyBhc3N1bWVkIHRvIGJlIDAwOjAwOjAwWiAoc3RhcnQgb2YgZGF5LCBVVEMpLlxuICB0ZXN0OiBSZWdFeHAoJ14oPzonICsgJyhbMC05XXs0fSktKFswLTldezEsMn0pLShbMC05XXsxLDJ9KScgKyAvLyBZWVlZLU1tLURkXG4gICcoPzooPzp0fFR8WyBcXFxcdF0rKScgKyAvLyB0IHwgVCB8IHdoaXRlc3BhY2VcbiAgJyhbMC05XXsxLDJ9KTooWzAtOV17MSwyfSk6KFswLTldezEsMn0oXFxcXC5bMC05XSspPyknICsgLy8gSGg6TW06U3MoLnNzKT9cbiAgJyg/OlsgXFxcXHRdKihafFstK11bMDEyXT9bMC05XSg/OjpbMC05XXsyfSk/KSk/JyArIC8vIFogfCArNSB8IC0wMzozMFxuICAnKT8nICsgJykkJyksXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoc3RyLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWMsIHR6KSB7XG4gICAgaWYgKG1pbGxpc2VjKSBtaWxsaXNlYyA9IChtaWxsaXNlYyArICcwMCcpLnN1YnN0cigxLCAzKTtcbiAgICB2YXIgZGF0ZSA9IERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyIHx8IDAsIG1pbnV0ZSB8fCAwLCBzZWNvbmQgfHwgMCwgbWlsbGlzZWMgfHwgMCk7XG5cbiAgICBpZiAodHogJiYgdHogIT09ICdaJykge1xuICAgICAgdmFyIGQgPSBwYXJzZVNleGFnZXNpbWFsKHR6WzBdLCB0ei5zbGljZSgxKSk7XG4gICAgICBpZiAoTWF0aC5hYnMoZCkgPCAzMCkgZCAqPSA2MDtcbiAgICAgIGRhdGUgLT0gNjAwMDAgKiBkO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgfSxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoX3JlZjIpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKS5yZXBsYWNlKC8oKFQwMDowMCk/OjAwKT9cXC4wMDBaJC8sICcnKTtcbiAgfVxufTtcblxuLyogZ2xvYmFsIGNvbnNvbGUsIHByb2Nlc3MsIFlBTUxfU0lMRU5DRV9ERVBSRUNBVElPTl9XQVJOSU5HUywgWUFNTF9TSUxFTkNFX1dBUk5JTkdTICovXG5mdW5jdGlvbiBzaG91bGRXYXJuKGRlcHJlY2F0aW9uKSB7XG4gIHZhciBlbnYgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgfHwge307XG5cbiAgaWYgKGRlcHJlY2F0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBZQU1MX1NJTEVOQ0VfREVQUkVDQVRJT05fV0FSTklOR1MgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gIVlBTUxfU0lMRU5DRV9ERVBSRUNBVElPTl9XQVJOSU5HUztcbiAgICByZXR1cm4gIWVudi5ZQU1MX1NJTEVOQ0VfREVQUkVDQVRJT05fV0FSTklOR1M7XG4gIH1cblxuICBpZiAodHlwZW9mIFlBTUxfU0lMRU5DRV9XQVJOSU5HUyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiAhWUFNTF9TSUxFTkNFX1dBUk5JTkdTO1xuICByZXR1cm4gIWVudi5ZQU1MX1NJTEVOQ0VfV0FSTklOR1M7XG59XG5cbmZ1bmN0aW9uIHdhcm4od2FybmluZywgdHlwZSkge1xuICBpZiAoc2hvdWxkV2FybihmYWxzZSkpIHtcbiAgICB2YXIgZW1pdCA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVtaXRXYXJuaW5nOyAvLyBUaGlzIHdpbGwgdGhyb3cgaW4gSmVzdCBpZiBgd2FybmluZ2AgaXMgYW4gRXJyb3IgaW5zdGFuY2UgZHVlIHRvXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2plc3QvaXNzdWVzLzI1NDlcblxuICAgIGlmIChlbWl0KSBlbWl0KHdhcm5pbmcsIHR5cGUpO2Vsc2Uge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2Fybih0eXBlID8gXCJcIi5jb25jYXQodHlwZSwgXCI6IFwiKS5jb25jYXQod2FybmluZykgOiB3YXJuaW5nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5GaWxlRGVwcmVjYXRpb24oZmlsZW5hbWUpIHtcbiAgaWYgKHNob3VsZFdhcm4odHJ1ZSkpIHtcbiAgICB2YXIgcGF0aCA9IGZpbGVuYW1lLnJlcGxhY2UoLy4qeWFtbFsvXFxcXF0vaSwgJycpLnJlcGxhY2UoL1xcLmpzJC8sICcnKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgd2FybihcIlRoZSBlbmRwb2ludCAneWFtbC9cIi5jb25jYXQocGF0aCwgXCInIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiKSwgJ0RlcHJlY2F0aW9uV2FybmluZycpO1xuICB9XG59XG52YXIgd2FybmVkID0ge307XG5mdW5jdGlvbiB3YXJuT3B0aW9uRGVwcmVjYXRpb24obmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgaWYgKCF3YXJuZWRbbmFtZV0gJiYgc2hvdWxkV2Fybih0cnVlKSkge1xuICAgIHdhcm5lZFtuYW1lXSA9IHRydWU7XG4gICAgdmFyIG1zZyA9IFwiVGhlIG9wdGlvbiAnXCIuY29uY2F0KG5hbWUsIFwiJyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZVwiKTtcbiAgICBtc2cgKz0gYWx0ZXJuYXRpdmUgPyBcIiwgdXNlICdcIi5jb25jYXQoYWx0ZXJuYXRpdmUsIFwiJyBpbnN0ZWFkLlwiKSA6ICcuJztcbiAgICB3YXJuKG1zZywgJ0RlcHJlY2F0aW9uV2FybmluZycpO1xuICB9XG59XG5cbmV4cG9ydCB7IHdhcm5PcHRpb25EZXByZWNhdGlvbiBhcyBhLCBiaW5hcnkgYXMgYiwgd2FybkZpbGVEZXByZWNhdGlvbiBhcyBjLCBmbG9hdFRpbWUgYXMgZiwgaW50VGltZSBhcyBpLCBvbWFwIGFzIG8sIHBhaXJzIGFzIHAsIHNldCBhcyBzLCB0aW1lc3RhbXAgYXMgdCwgd2FybiBhcyB3IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/yaml/browser/dist/warnings-df54cb69.js\n")},"./package.json":n=>{"use strict";n.exports=JSON.parse('{"name":"teleop-xyz","version":"0.3.2","description":"","main":"src/index.js","files":["dist","src/*"],"scripts":{"build":"webpack","watch":"webpack --watch"},"author":"","license":"Apache-2.0","dependencies":{"debug":"^3.1.0","gamepad.js":"^1.0.4","yaml":"^1.10.2"},"devDependencies":{"@babel/cli":"^7.13.14","@babel/core":"^7.13.14","@babel/preset-env":"^7.13.12","babel-eslint":"^10.1.0","babel-preset-es2015":"^6.24.1","babelify":"^10.0.0","browserify":"^17.0.0","compression-webpack-plugin":"^7.1.2","constants-browserify":"^1.0.0","es2015":"^0.0.0","eslint":"^7.23.0","http-browserify":"^1.7.0","https-browserify":"^1.0.0","nodemon":"^2.0.7","path-browserify":"^1.0.1","webpack":"^5.25.0","webpack-bundle-analyzer":"^4.4.0","webpack-cli":"^4.5.0","webpack-node-externals":"^2.5.2","zlib-browserify":"0.0.3"},"babel":{"presets":["@babel/preset-env"],"sourceType":"module"},"eslintConfig":{"parser":"babel-eslint","env":{"browser":true,"node":true},"parserOptions":{"sourceType":"module","allowImportExportEverywhere":true}}}')}},__webpack_module_cache__={};function __webpack_require__(n){var I=__webpack_module_cache__[n];if(void 0!==I)return I.exports;var g=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n].call(g.exports,g,g.exports,__webpack_require__),g.exports}__webpack_require__.d=(n,I)=>{for(var g in I)__webpack_require__.o(I,g)&&!__webpack_require__.o(n,g)&&Object.defineProperty(n,g,{enumerable:!0,get:I[g]})},__webpack_require__.o=(n,I)=>Object.prototype.hasOwnProperty.call(n,I),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.js");teleopxyz=__webpack_exports__})();